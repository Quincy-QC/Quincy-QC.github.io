{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/img/icon_wechat.png","path":"img/icon_wechat.png","modified":0,"renderable":0},{"_id":"source/img/header_img/about.jpg","path":"img/header_img/about.jpg","modified":0,"renderable":0},{"_id":"themes/huweihuang/source/css/archive.styl","path":"css/archive.styl","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/css/beantech.css","path":"css/beantech.css","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/css/beantech.min.css","path":"css/beantech.min.css","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/css/donate.css","path":"css/donate.css","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/css/highlight.styl","path":"css/highlight.styl","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/css/hux-blog.min.css","path":"css/hux-blog.min.css","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/css/rocket.styl","path":"css/rocket.styl","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/css/signature.styl","path":"css/signature.styl","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/css/toc.styl","path":"css/toc.styl","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/css/widget.styl","path":"css/widget.styl","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/fonts/glyphicons-halflings-regular.eot","path":"fonts/glyphicons-halflings-regular.eot","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/fonts/glyphicons-halflings-regular.ttf","path":"fonts/glyphicons-halflings-regular.ttf","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/fonts/glyphicons-halflings-regular.woff","path":"fonts/glyphicons-halflings-regular.woff","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/fonts/glyphicons-halflings-regular.woff2","path":"fonts/glyphicons-halflings-regular.woff2","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/js/bootstrap.min.js","path":"js/bootstrap.min.js","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/js/hux-blog.js","path":"js/hux-blog.js","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/js/hux-blog.min.js","path":"js/hux-blog.min.js","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/js/jquery.nav.js","path":"js/jquery.nav.js","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/js/jquery.tagcloud.js","path":"js/jquery.tagcloud.js","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/js/toc.js","path":"js/toc.js","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/js/totop.js","path":"js/totop.js","modified":0,"renderable":1},{"_id":"source/img/header_img/archives-widget.jpg","path":"img/header_img/archives-widget.jpg","modified":0,"renderable":0},{"_id":"themes/huweihuang/source/css/bootstrap.min.css","path":"css/bootstrap.min.css","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/fonts/glyphicons-halflings-regular.svg","path":"fonts/glyphicons-halflings-regular.svg","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/js/bootstrap.js","path":"js/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/js/jquery.min.js","path":"js/jquery.min.js","modified":0,"renderable":1},{"_id":"source/img/article/20190418/1.png","path":"img/article/20190418/1.png","modified":0,"renderable":0},{"_id":"source/img/article/20190418/2.png","path":"img/article/20190418/2.png","modified":0,"renderable":0},{"_id":"source/img/article/20190503/1.png","path":"img/article/20190503/1.png","modified":0,"renderable":0},{"_id":"source/img/article/20190503/5.png","path":"img/article/20190503/5.png","modified":0,"renderable":0},{"_id":"source/img/article/20190503/9.png","path":"img/article/20190503/9.png","modified":0,"renderable":0},{"_id":"source/img/article/20190519/1.png","path":"img/article/20190519/1.png","modified":0,"renderable":0},{"_id":"source/img/article/20190519/10.png","path":"img/article/20190519/10.png","modified":0,"renderable":0},{"_id":"source/img/article/20190519/14.png","path":"img/article/20190519/14.png","modified":0,"renderable":0},{"_id":"source/img/article/20190519/2.png","path":"img/article/20190519/2.png","modified":0,"renderable":0},{"_id":"source/img/article/20190519/4.png","path":"img/article/20190519/4.png","modified":0,"renderable":0},{"_id":"source/img/article/20190519/5.png","path":"img/article/20190519/5.png","modified":0,"renderable":0},{"_id":"source/img/article/20190519/6.png","path":"img/article/20190519/6.png","modified":0,"renderable":0},{"_id":"source/img/article/20190519/7.png","path":"img/article/20190519/7.png","modified":0,"renderable":0},{"_id":"source/img/article/20190519/8.png","path":"img/article/20190519/8.png","modified":0,"renderable":0},{"_id":"source/img/article/20190519/9.png","path":"img/article/20190519/9.png","modified":0,"renderable":0},{"_id":"source/img/article/20190606/1.png","path":"img/article/20190606/1.png","modified":0,"renderable":0},{"_id":"source/img/article/20190801/2.png","path":"img/article/20190801/2.png","modified":0,"renderable":0},{"_id":"source/img/article/20190801/3.png","path":"img/article/20190801/3.png","modified":0,"renderable":0},{"_id":"source/img/article/20190801/4.png","path":"img/article/20190801/4.png","modified":0,"renderable":0},{"_id":"source/img/article/20190801/5.png","path":"img/article/20190801/5.png","modified":0,"renderable":0},{"_id":"source/img/article/20190801/6.png","path":"img/article/20190801/6.png","modified":0,"renderable":0},{"_id":"source/img/article/20190801/7.png","path":"img/article/20190801/7.png","modified":0,"renderable":0},{"_id":"source/img/article/20190801/8.png","path":"img/article/20190801/8.png","modified":0,"renderable":0},{"_id":"source/img/article/20190810/1.png","path":"img/article/20190810/1.png","modified":0,"renderable":0},{"_id":"source/img/article/20190810/2.png","path":"img/article/20190810/2.png","modified":0,"renderable":0},{"_id":"source/img/article/20190810/3.png","path":"img/article/20190810/3.png","modified":0,"renderable":0},{"_id":"source/img/article/20190816/1.png","path":"img/article/20190816/1.png","modified":0,"renderable":0},{"_id":"source/img/article/20190816/3.png","path":"img/article/20190816/3.png","modified":0,"renderable":0},{"_id":"source/img/article/20190816/4.png","path":"img/article/20190816/4.png","modified":0,"renderable":0},{"_id":"source/img/article/20190816/5.png","path":"img/article/20190816/5.png","modified":0,"renderable":0},{"_id":"source/img/article/20190816/6.png","path":"img/article/20190816/6.png","modified":0,"renderable":0},{"_id":"source/img/article/20190816/7.png","path":"img/article/20190816/7.png","modified":0,"renderable":0},{"_id":"source/img/article/20190825/1.png","path":"img/article/20190825/1.png","modified":0,"renderable":0},{"_id":"source/img/article/20190825/2.png","path":"img/article/20190825/2.png","modified":0,"renderable":0},{"_id":"source/img/article/20190825/3.png","path":"img/article/20190825/3.png","modified":0,"renderable":0},{"_id":"source/img/article/20190825/4.png","path":"img/article/20190825/4.png","modified":0,"renderable":0},{"_id":"source/img/article/20190825/5.png","path":"img/article/20190825/5.png","modified":0,"renderable":0},{"_id":"source/img/article/20190825/6.png","path":"img/article/20190825/6.png","modified":0,"renderable":0},{"_id":"source/img/article/20190825/7.png","path":"img/article/20190825/7.png","modified":0,"renderable":0},{"_id":"source/img/article/20190902/1.png","path":"img/article/20190902/1.png","modified":0,"renderable":0},{"_id":"source/img/article/20190902/2.png","path":"img/article/20190902/2.png","modified":0,"renderable":0},{"_id":"source/img/article/20190902/3.png","path":"img/article/20190902/3.png","modified":0,"renderable":0},{"_id":"source/img/article/20190902/4.png","path":"img/article/20190902/4.png","modified":0,"renderable":0},{"_id":"source/img/article/20190902/5.png","path":"img/article/20190902/5.png","modified":0,"renderable":0},{"_id":"source/img/article/20190902/6.png","path":"img/article/20190902/6.png","modified":0,"renderable":0},{"_id":"source/img/article/20190902/7.png","path":"img/article/20190902/7.png","modified":0,"renderable":0},{"_id":"source/img/article/20190902/9.png","path":"img/article/20190902/9.png","modified":0,"renderable":0},{"_id":"source/img/article/20191216/1.png","path":"img/article/20191216/1.png","modified":0,"renderable":0},{"_id":"source/img/article/20200226/1.png","path":"img/article/20200226/1.png","modified":0,"renderable":0},{"_id":"source/img/article/20200330/1.png","path":"img/article/20200330/1.png","modified":0,"renderable":0},{"_id":"source/img/article/20200330/2.png","path":"img/article/20200330/2.png","modified":0,"renderable":0},{"_id":"source/img/article/20210621/1.png","path":"img/article/20210621/1.png","modified":0,"renderable":0},{"_id":"source/img/article/20210621/2.png","path":"img/article/20210621/2.png","modified":0,"renderable":0},{"_id":"source/img/header_img/archive.jpg","path":"img/header_img/archive.jpg","modified":0,"renderable":0},{"_id":"source/img/signature/BeanTechSign-white.png","path":"img/signature/BeanTechSign-white.png","modified":0,"renderable":0},{"_id":"themes/huweihuang/source/css/bootstrap.css","path":"css/bootstrap.css","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/css/images/ironman.png","path":"css/images/ironman.png","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/css/images/rocket.png","path":"css/images/rocket.png","modified":0,"renderable":1},{"_id":"source/img/article/20190212/2.png","path":"img/article/20190212/2.png","modified":0,"renderable":0},{"_id":"source/img/article/20190418/3.png","path":"img/article/20190418/3.png","modified":0,"renderable":0},{"_id":"source/img/article/20190425/1.png","path":"img/article/20190425/1.png","modified":0,"renderable":0},{"_id":"source/img/article/20190503/11.png","path":"img/article/20190503/11.png","modified":0,"renderable":0},{"_id":"source/img/article/20190503/2.png","path":"img/article/20190503/2.png","modified":0,"renderable":0},{"_id":"source/img/article/20190503/4.png","path":"img/article/20190503/4.png","modified":0,"renderable":0},{"_id":"source/img/article/20190503/8.png","path":"img/article/20190503/8.png","modified":0,"renderable":0},{"_id":"source/img/article/20190519/12.png","path":"img/article/20190519/12.png","modified":0,"renderable":0},{"_id":"source/img/article/20190519/11.png","path":"img/article/20190519/11.png","modified":0,"renderable":0},{"_id":"source/img/article/20190519/13.png","path":"img/article/20190519/13.png","modified":0,"renderable":0},{"_id":"source/img/article/20190519/3.png","path":"img/article/20190519/3.png","modified":0,"renderable":0},{"_id":"source/img/article/20190801/1.png","path":"img/article/20190801/1.png","modified":0,"renderable":0},{"_id":"source/img/article/20190803/1.png","path":"img/article/20190803/1.png","modified":0,"renderable":0},{"_id":"source/img/article/20190810/6.png","path":"img/article/20190810/6.png","modified":0,"renderable":0},{"_id":"source/img/article/20190819/1.png","path":"img/article/20190819/1.png","modified":0,"renderable":0},{"_id":"source/img/article/20190902/8.png","path":"img/article/20190902/8.png","modified":0,"renderable":0},{"_id":"source/img/article/20191122/3.png","path":"img/article/20191122/3.png","modified":0,"renderable":0},{"_id":"source/img/article/20200226/5.png","path":"img/article/20200226/5.png","modified":0,"renderable":0},{"_id":"source/img/article/20210830/1.png","path":"img/article/20210830/1.png","modified":0,"renderable":0},{"_id":"source/img/header_img/tag.png","path":"img/header_img/tag.png","modified":0,"renderable":0},{"_id":"themes/huweihuang/source/js/jquery.js","path":"js/jquery.js","modified":0,"renderable":1},{"_id":"source/img/article/20190212/1.png","path":"img/article/20190212/1.png","modified":0,"renderable":0},{"_id":"source/img/article/20190212/4.png","path":"img/article/20190212/4.png","modified":0,"renderable":0},{"_id":"source/img/article/20190425/3.png","path":"img/article/20190425/3.png","modified":0,"renderable":0},{"_id":"source/img/article/20190503/3.png","path":"img/article/20190503/3.png","modified":0,"renderable":0},{"_id":"source/img/article/20190503/7.png","path":"img/article/20190503/7.png","modified":0,"renderable":0},{"_id":"source/img/signature/BeanTechSign-black.png","path":"img/signature/BeanTechSign-black.png","modified":0,"renderable":0},{"_id":"source/img/article/20190503/10.png","path":"img/article/20190503/10.png","modified":0,"renderable":0},{"_id":"source/img/article/20190503/6.png","path":"img/article/20190503/6.png","modified":0,"renderable":0},{"_id":"source/img/article/20190706/1.png","path":"img/article/20190706/1.png","modified":0,"renderable":0},{"_id":"source/img/article/20190815/1.png","path":"img/article/20190815/1.png","modified":0,"renderable":0},{"_id":"source/img/header_img/home.jpg","path":"img/header_img/home.jpg","modified":0,"renderable":0},{"_id":"source/img/article/20190212/3.png","path":"img/article/20190212/3.png","modified":0,"renderable":0},{"_id":"source/img/article/20190810/5.png","path":"img/article/20190810/5.png","modified":0,"renderable":0},{"_id":"source/img/article/20190816/2.png","path":"img/article/20190816/2.png","modified":0,"renderable":0},{"_id":"source/img/header_img/404.png","path":"img/header_img/404.png","modified":0,"renderable":0},{"_id":"source/img/article/20190810/4.png","path":"img/article/20190810/4.png","modified":0,"renderable":0},{"_id":"source/img/avatar/icon.png","path":"img/avatar/icon.png","modified":0,"renderable":0},{"_id":"source/img/article/20190425/2.png","path":"img/article/20190425/2.png","modified":0,"renderable":0},{"_id":"source/img/article/20210830/2.mp4","path":"img/article/20210830/2.mp4","modified":0,"renderable":0},{"_id":"source/img/header_img/home-bg-o.png","path":"img/header_img/home-bg-o.png","modified":0,"renderable":0},{"_id":"source/img/header_img/home2.png","path":"img/header_img/home2.png","modified":0,"renderable":0},{"_id":"source/img/article/20190810/8.png","path":"img/article/20190810/8.png","modified":0,"renderable":0},{"_id":"source/img/article/20200226/3.png","path":"img/article/20200226/3.png","modified":0,"renderable":0},{"_id":"source/img/article/20200226/4.png","path":"img/article/20200226/4.png","modified":0,"renderable":0},{"_id":"source/img/article/20210621/3.png","path":"img/article/20210621/3.png","modified":0,"renderable":0},{"_id":"source/img/article/20190810/7.png","path":"img/article/20190810/7.png","modified":0,"renderable":0},{"_id":"source/img/article/20191121/1.png","path":"img/article/20191121/1.png","modified":0,"renderable":0},{"_id":"source/img/article/20191122/2.png","path":"img/article/20191122/2.png","modified":0,"renderable":0},{"_id":"source/img/article/20200226/2.png","path":"img/article/20200226/2.png","modified":0,"renderable":0},{"_id":"source/img/article/20191122/1.png","path":"img/article/20191122/1.png","modified":0,"renderable":0},{"_id":"source/img/article_header/article_header.png","path":"img/article_header/article_header.png","modified":0,"renderable":0}],"Cache":[{"_id":"source/404.md","hash":"8aa56af7bcd7cd23667cbf3eb5b5c9fa4533eb60","modified":1641805492801},{"_id":"themes/huweihuang/LICENSE","hash":"2b209f06bebeb2a8c2b7e187e436f3e1e1fbc8a7","modified":1641805492898},{"_id":"themes/huweihuang/_config.yml","hash":"e800e32847df32dacddb5202823a004557023bcd","modified":1641805492898},{"_id":"source/_posts/.DS_Store","hash":"026cdd156a5b6bd3e1a402eae75a353ffdb9b392","modified":1641805492802},{"_id":"source/archive/index.md","hash":"40c6d6d8a40f8133e48eaf8111df4a361d6ac30d","modified":1641805492812},{"_id":"source/about/index.md","hash":"dd8408f951bc3c52eb61b475404fdd48849f7e4a","modified":1641805492811},{"_id":"source/img/.DS_Store","hash":"1a5a7b1e9248ee851e5acbbd4f85b11cf939e6eb","modified":1641805492812},{"_id":"source/img/icon_wechat.png","hash":"4188058026609de06c6cac88b349a2da831a1783","modified":1641805492896},{"_id":"source/tags/index.md","hash":"f6ad1039c242795de5cd7d81781148f8c5298c28","modified":1641805492898},{"_id":"themes/huweihuang/layout/404.ejs","hash":"40de38bd399f6f4aef0d6c63c7b13b02d74f1c56","modified":1641805492900},{"_id":"themes/huweihuang/layout/about.ejs","hash":"406ee87558145a1c321a4867c3bcb716dc8796ce","modified":1641805492902},{"_id":"themes/huweihuang/layout/archive.ejs","hash":"72a150c8dff0031a9107d12eaa7c2e6c6ce950d2","modified":1641805492902},{"_id":"themes/huweihuang/layout/index.ejs","hash":"dc8a6eaa00d1e7c33a40979afe0953ed5d7b512e","modified":1641805492902},{"_id":"themes/huweihuang/layout/keynote.ejs","hash":"b956cc63454c5158b0dd1b9f730eb36246ad77e7","modified":1641805492903},{"_id":"themes/huweihuang/layout/layout.ejs","hash":"a5af5b99ac3456ab5da1a319455904b979b91601","modified":1641805492903},{"_id":"themes/huweihuang/layout/page.ejs","hash":"ece58c2de372f2f10d245f880fea4d008bc16811","modified":1641805492903},{"_id":"themes/huweihuang/layout/post.ejs","hash":"2477fd011180cf367f21b9107f5fdf17b2f5a737","modified":1641805492903},{"_id":"themes/huweihuang/layout/tags.ejs","hash":"2c72eb2e89130658aa068d80d27b561b509c5dcd","modified":1641805492903},{"_id":"themes/huweihuang/languages_to_be_added/de.yml","hash":"424a9c1e6ab69334d7873f6574da02ca960aa572","modified":1641805492898},{"_id":"themes/huweihuang/languages_to_be_added/default.yml","hash":"97326c9e6518d9f379778178b3b8f9a58434725d","modified":1641805492899},{"_id":"themes/huweihuang/languages_to_be_added/en.yml","hash":"97326c9e6518d9f379778178b3b8f9a58434725d","modified":1641805492899},{"_id":"themes/huweihuang/languages_to_be_added/es.yml","hash":"cb4eeca0ed3768a77e0cd216300f2b2549628b1b","modified":1641805492899},{"_id":"themes/huweihuang/languages_to_be_added/no.yml","hash":"8ca475a3b4f8efe6603030f0013aae39668230e1","modified":1641805492899},{"_id":"themes/huweihuang/languages_to_be_added/pl.yml","hash":"de7eb5850ae65ba7638e907c805fea90617a988c","modified":1641805492899},{"_id":"themes/huweihuang/languages_to_be_added/ru.yml","hash":"42df7afeb7a35dc46d272b7f4fb880a9d9ebcaa5","modified":1641805492899},{"_id":"themes/huweihuang/languages_to_be_added/zh-CN.yml","hash":"7bfcb0b8e97d7e5edcfca8ab26d55d9da2573c1c","modified":1641805492899},{"_id":"themes/huweihuang/languages_to_be_added/zh-TW.yml","hash":"9acac6cc4f8002c3fa53ff69fb8cf66c915bd016","modified":1641805492899},{"_id":"source/_posts/2020/load-pdf-with-signature-0226.md","hash":"fb79157d4a2cf033ffa6d93659c5326e75227444","modified":1641805492810},{"_id":"source/_posts/2020/nstimer-circular-reference-issue-0330.md","hash":"e610d65447b8d1b631ebe10c50440f95834c9595","modified":1641805492810},{"_id":"source/_posts/2020/talk-about-map-flatmap-compactmap-0119.md","hash":"0c5340f676ce3b8d595160b31050e4e93edd30cb","modified":1641805492811},{"_id":"source/_posts/2019/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1641805492802},{"_id":"source/_posts/2019/cocoapods-create-pods-1121.md","hash":"e6d21b4e295b52a18782c9c944b17f1d584ba2ba","modified":1641805492803},{"_id":"source/_posts/2019/core-animation-study-0503.md","hash":"5576a953c796d75e65038e1b650a254fe64860a0","modified":1641805492803},{"_id":"source/_posts/2019/core-graphics-study-0418.md","hash":"2eb2b19072f6f5e16c11358f9100e9f7dcca6a81","modified":1641805492803},{"_id":"source/_posts/2019/create-github-pages-0212.md","hash":"b8d414bef33805796e174899a47ccd18b4494ef7","modified":1641805492804},{"_id":"source/_posts/2019/core-image-study-0425.md","hash":"d5511cbefad6a3ab4b286e89f55d2fcb4b93e1bd","modified":1641805492804},{"_id":"source/_posts/2019/leetcode-kth-problems-1216.md","hash":"a34df662e89b62db7d84b73b681d8e7731a78519","modified":1641805492804},{"_id":"source/_posts/2019/leetcode-substring-search-problems-1007.md","hash":"36bcdc89bc3bc329d2138a0bb209c513dc100804","modified":1641805492804},{"_id":"source/_posts/2019/opengl-es-coordinated-system-0825.md","hash":"9e47d8991e31d19368cc3f2a1987ceeb7094acc6","modified":1641805492804},{"_id":"source/_posts/2019/opengl-es-draw-triangles-0606.md","hash":"72c7469e1d875472048272b49b0cb6c171b8ab68","modified":1641805492805},{"_id":"source/_posts/2019/opengl-es-fragment-operation-0816.md","hash":"df352e3ca9c6caab5c45e5e7a420994897b717f4","modified":1641805492805},{"_id":"source/_posts/2019/opengl-es-fragment-shader-0815.md","hash":"e283ec0d3f322bfa7fdb164c03caf7a2aa8ec24d","modified":1641805492805},{"_id":"source/_posts/2019/opengl-es-framebuffer-0819.md","hash":"d7d146fbce6d17491c29900048cce64346345fa5","modified":1641805492806},{"_id":"source/_posts/2019/opengl-es-glsl-0715.md","hash":"0850c3810724dae34ba679c2472a1385bcb0d26d","modified":1641805492806},{"_id":"source/_posts/2019/opengl-es-illuminate-0902.md","hash":"2cf9e1a2a53aef7418ee6f5268a24bb5a76a2309","modified":1641805492806},{"_id":"source/_posts/2019/opengl-es-primitive-0801.md","hash":"8ba18da3073289bb4d39e12aa30501398030a3f1","modified":1641805492807},{"_id":"source/_posts/2019/opengl-es-shader-and-program-0706.md","hash":"ee1182bffcae32759ddd3a8c0913ee588734c98d","modified":1641805492807},{"_id":"source/_posts/2019/opengl-es-sync-and-fence-0821.md","hash":"cbdbe765f737e0195aca9fabf558a9431f025380","modified":1641805492808},{"_id":"source/_posts/2019/opengl-es-vertex-0720.md","hash":"2ee6752a8f69187f2332ef622a372711afe13a3e","modified":1641805492809},{"_id":"source/_posts/2019/opengl-es-vertex-shader-0803.md","hash":"52cd4c33e1c47f20b1fb2ab883c4b0c5a802350f","modified":1641805492809},{"_id":"source/_posts/2019/refactoring-massive-app-delegate-0215.md","hash":"1fa8171aaa7f7b9caca0699454a14d95e82d02a9","modified":1641805492809},{"_id":"source/_posts/2019/swift-package-manager-1122.md","hash":"3c4a3aa81352f4096e63f19c5a12fcadfcb6dee3","modified":1641805492810},{"_id":"source/_posts/2019/talk-about-design-pattern-0326.md","hash":"51fa67de2894934552c754e23edee362e7e13fca","modified":1641805492810},{"_id":"source/_posts/2019/ubuntu-core-update-and-bbr-accelerate-1101.md","hash":"bf6001e044ad6dd7f1b96131bf5d0c361d3cf4fb","modified":1641805492810},{"_id":"source/_posts/2021/realitykit-0621.md","hash":"051674445727ecc44ec5750eb15368ead362aa09","modified":1641805492811},{"_id":"source/_posts/2021/realitykit-live-ar-0830.md","hash":"baf3c1a6d8d2e3a30e7e866013686978705e43c0","modified":1641805492811},{"_id":"source/img/article/.DS_Store","hash":"16437191288e8bd726c36f27a3629508309de40b","modified":1641805492812},{"_id":"source/img/article_header/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1641805492885},{"_id":"source/img/avatar/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1641805492888},{"_id":"source/img/header_img/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1641805492889},{"_id":"source/img/header_img/about.jpg","hash":"9623612fa0c03f8065b9ff2052e78bf4bdb1e6fa","modified":1641805492890},{"_id":"themes/huweihuang/layout/_partial/footer.ejs","hash":"616204beba8f3a64723bd9061a1c62faaeb16722","modified":1641805492900},{"_id":"themes/huweihuang/layout/_partial/head.ejs","hash":"720349195a5ea7b610a82ce3ce74298fb2bc7347","modified":1641805492900},{"_id":"themes/huweihuang/layout/_partial/nav.ejs","hash":"4c905166c960852e9b9a3c9d5c680091e37b481f","modified":1641805492900},{"_id":"themes/huweihuang/layout/_partial/header.ejs","hash":"3bd09df76e0622d76d186b020393fcab361e6c97","modified":1641805492900},{"_id":"themes/huweihuang/layout/_partial/pagination.ejs","hash":"557d6bb069a1d48af49ae912994653f44b32a570","modified":1641805492900},{"_id":"themes/huweihuang/layout/_partial/sidebar.ejs","hash":"2e4e528a555917b2a267da4db2440bcc4a7a65ab","modified":1641805492901},{"_id":"themes/huweihuang/layout/_partial/toc.ejs","hash":"40e11b303df113c64a5ca35b79dd53c824010c09","modified":1641805492901},{"_id":"themes/huweihuang/layout/_widget/archive.ejs","hash":"7594929d472806ca4c64d9906d9903a96de111a0","modified":1641805492901},{"_id":"themes/huweihuang/layout/_widget/category.ejs","hash":"1cf485def07dc06e870dc9613767c6c614bcf428","modified":1641805492901},{"_id":"themes/huweihuang/layout/_widget/featured-tags.ejs","hash":"0c9ce1942f1943dc8891a9302a922ef1ffe300c5","modified":1641805492901},{"_id":"themes/huweihuang/layout/_widget/friends-blog.ejs","hash":"734d3775017aedac185028924baf890a71a74548","modified":1641805492902},{"_id":"themes/huweihuang/layout/_widget/recent-posts.ejs","hash":"e08ab8ba60e31638006acf27f066b989a0a3c433","modified":1641805492902},{"_id":"themes/huweihuang/layout/_widget/short-about.ejs","hash":"315de02246f07c747c32495e107ad7b19cb3ff54","modified":1641805492902},{"_id":"themes/huweihuang/source/css/archive.styl","hash":"715bcbd085eb95ec26c9805c11c374919cde971c","modified":1641805492904},{"_id":"themes/huweihuang/source/css/beantech.css","hash":"4c361354fd8e9851923fb21a620bc079380ebcd8","modified":1641805492904},{"_id":"themes/huweihuang/source/css/beantech.min.css","hash":"05a06230b1a9eca0b30cece54a397008cb77dc50","modified":1641805492904},{"_id":"themes/huweihuang/source/css/donate.css","hash":"f65ac8363d8d215adb896158e7b45165db259a47","modified":1641805492906},{"_id":"themes/huweihuang/source/css/highlight.styl","hash":"e842080e6d580f0f70a7df71fbde3c4e49463c19","modified":1641805492906},{"_id":"themes/huweihuang/source/css/hux-blog.min.css","hash":"1baef04de262aeb7023d835429b49a805ac4ab40","modified":1641805492906},{"_id":"themes/huweihuang/source/css/rocket.styl","hash":"e15c51c8566ecd943112e57592888dd318b6fa6a","modified":1641805492907},{"_id":"themes/huweihuang/source/css/signature.styl","hash":"88159b31c59d59c01a0b534af57242662a2a3969","modified":1641805492907},{"_id":"themes/huweihuang/source/css/toc.styl","hash":"631e97f634d30f53314e2fec8bdde267c1c49f4c","modified":1641805492907},{"_id":"themes/huweihuang/source/css/widget.styl","hash":"7a9f735f5ef323dc2950fbd9d76daa16c9a0f1a9","modified":1641805492908},{"_id":"themes/huweihuang/source/fonts/glyphicons-halflings-regular.eot","hash":"86b6f62b7853e67d3e635f6512a5a5efc58ea3c3","modified":1641805492908},{"_id":"themes/huweihuang/source/fonts/glyphicons-halflings-regular.ttf","hash":"44bc1850f570972267b169ae18f1cb06b611ffa2","modified":1641805492909},{"_id":"themes/huweihuang/source/fonts/glyphicons-halflings-regular.woff","hash":"278e49a86e634da6f2a02f3b47dd9d2a8f26210f","modified":1641805492909},{"_id":"themes/huweihuang/source/fonts/glyphicons-halflings-regular.woff2","hash":"ca35b697d99cae4d1b60f2d60fcd37771987eb07","modified":1641805492910},{"_id":"themes/huweihuang/source/js/bootstrap.min.js","hash":"b3f2ef9f985e7906c9360756b73cd64bf7733647","modified":1641805492911},{"_id":"themes/huweihuang/source/js/hux-blog.js","hash":"4b4d3c557405d04c3087d36c13e2834fe05c0f73","modified":1641805492911},{"_id":"themes/huweihuang/source/js/hux-blog.min.js","hash":"1563e7f70550ac6b30803d6f449719b853200e35","modified":1641805492911},{"_id":"themes/huweihuang/source/js/jquery.nav.js","hash":"ef2160a456176a4d09cc0b95d52b27dfbbadf2d8","modified":1641805492913},{"_id":"themes/huweihuang/source/js/jquery.tagcloud.js","hash":"4e5fd0b07f3bd935f2e603710447e039e3677211","modified":1641805492913},{"_id":"themes/huweihuang/source/js/toc.js","hash":"41e52551731854224c249d53010c1bae5aa92ffa","modified":1641805492913},{"_id":"themes/huweihuang/source/js/totop.js","hash":"c05360f6fc699ac12e794b1764b4a952713a3017","modified":1641805492913},{"_id":"source/_posts/2019/opengl-es-study-0519.md","hash":"ffff115507bbe0d4ccc794619b082794066797e4","modified":1641805492808},{"_id":"source/_posts/2019/opengl-es-texture-0810.md","hash":"8a47fce748fb56f7c8a7f3e34a0e8f5360032545","modified":1641805492808},{"_id":"source/img/header_img/archives-widget.jpg","hash":"d0877c46663ef0626d7c69821b0a711af3192c87","modified":1641805492892},{"_id":"themes/huweihuang/source/css/bootstrap.min.css","hash":"fec7b176a4b9a67c0eb5d184f57b84297efc23aa","modified":1641805492906},{"_id":"themes/huweihuang/source/fonts/glyphicons-halflings-regular.svg","hash":"de51a8494180a6db074af2dee2383f0a363c5b08","modified":1641805492909},{"_id":"themes/huweihuang/source/js/bootstrap.js","hash":"f8752e9ae24daec0a0baffd7819122f8c6fd9103","modified":1641805492910},{"_id":"themes/huweihuang/source/js/jquery.min.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1641805492913},{"_id":"source/img/article/20190418/1.png","hash":"0299377ec17fb68fdb9b3798046d87ffd774eb7a","modified":1641805492816},{"_id":"source/img/article/20190418/2.png","hash":"f9ba932744e87143ce181fbfd3e0db605a3c5288","modified":1641805492816},{"_id":"source/img/article/20190503/1.png","hash":"6f240153476c4d24fc80a677363e6f26aed69bcf","modified":1641805492818},{"_id":"source/img/article/20190503/5.png","hash":"e1e65e49f2e8138c96b0022758884e5f5cb5e59b","modified":1641805492820},{"_id":"source/img/article/20190503/9.png","hash":"630fe7f8c7413a9e96a457d592340041e9cd3511","modified":1641805492823},{"_id":"source/img/article/20190519/1.png","hash":"4f56d9b4392028cf952bf3b26977409a22cb101e","modified":1641805492823},{"_id":"source/img/article/20190519/10.png","hash":"08fca75419543d5f04c19a8604c6934a77f096bf","modified":1641805492823},{"_id":"source/img/article/20190519/14.png","hash":"4c29af5bda7d07eae47f8ae8af2af83f5319ed22","modified":1641805492825},{"_id":"source/img/article/20190519/2.png","hash":"44a12f97d35898ebdfe9f2a52dc350e9efab5e86","modified":1641805492825},{"_id":"source/img/article/20190519/4.png","hash":"38d0d5edbbbeb4fd2d020c052c8f625ef85583ea","modified":1641805492826},{"_id":"source/img/article/20190519/5.png","hash":"cb7320b63dfce559ff7780b33656985d77543128","modified":1641805492827},{"_id":"source/img/article/20190519/6.png","hash":"51633cf88c4cbb921a3bc94b3b0375a5c2cd2297","modified":1641805492827},{"_id":"source/img/article/20190519/7.png","hash":"565c7d3a251051b983777a130589e649a2be83b3","modified":1641805492827},{"_id":"source/img/article/20190519/8.png","hash":"0b3e0dc786e709d96100192acc9ac686d8202b47","modified":1641805492827},{"_id":"source/img/article/20190519/9.png","hash":"7b2b12f67f62e17f13f32b5cfefe4a7c18591542","modified":1641805492828},{"_id":"source/img/article/20190606/1.png","hash":"45ea9c91ddbd66d8cb0735e55a066fb6d779728c","modified":1641805492828},{"_id":"source/img/article/20190801/2.png","hash":"22efb5534b4e5a57422a89887cd6a866767ef1a7","modified":1641805492830},{"_id":"source/img/article/20190801/3.png","hash":"33505616b521b93e9dab4c7bc07fa0f03f80d2a2","modified":1641805492830},{"_id":"source/img/article/20190801/4.png","hash":"54921ec9b919ce2071528f3198c51e1461fb9a5f","modified":1641805492830},{"_id":"source/img/article/20190801/5.png","hash":"7c5137d66c0998581e5832dcaf771d77da2a72fc","modified":1641805492831},{"_id":"source/img/article/20190801/6.png","hash":"10ae506b1780fd5ab3c526f23975a57fad40538d","modified":1641805492831},{"_id":"source/img/article/20190801/7.png","hash":"c12a993069d9fc02ea39d57bb2485496e4442ce7","modified":1641805492831},{"_id":"source/img/article/20190801/8.png","hash":"2a855490ecf07738172e286c329774d7c1865086","modified":1641805492832},{"_id":"source/img/article/20190810/1.png","hash":"528f24a7103f74831b49695c0dd7f6dd5aea77f9","modified":1641805492832},{"_id":"source/img/article/20190810/2.png","hash":"48c3f5a2f9892b7f507775695a5a0fa4a89b93a6","modified":1641805492833},{"_id":"source/img/article/20190810/3.png","hash":"0b41f0fe71e16c4b4ee1ed713fcc77e778876e31","modified":1641805492833},{"_id":"source/img/article/20190816/1.png","hash":"5daf59c316be2f25fea863ec1239679225f6bdfd","modified":1641805492840},{"_id":"source/img/article/20190816/3.png","hash":"50d43f764006415bd47630b56ce2db49f57372c8","modified":1641805492842},{"_id":"source/img/article/20190816/4.png","hash":"67642ea36e06b8c0c95317e38a8b57ece049bf8a","modified":1641805492842},{"_id":"source/img/article/20190816/5.png","hash":"83222a6a978d48ec66bb6440f1dff5b91fda2b11","modified":1641805492842},{"_id":"source/img/article/20190816/6.png","hash":"bad8407e53c80c91e86700a258da5c8c25fc425f","modified":1641805492843},{"_id":"source/img/article/20190816/7.png","hash":"6fe7da47e2cec2bc97b339c40459b0e8923597e6","modified":1641805492843},{"_id":"source/img/article/20190825/1.png","hash":"da4408a55494257720ccc75e59c1aeed84145210","modified":1641805492844},{"_id":"source/img/article/20190825/2.png","hash":"454dd47ee77ddf467a4fe9eb6e47a06d872a52c2","modified":1641805492845},{"_id":"source/img/article/20190825/3.png","hash":"b4463590e06bbabc63f55ed2b103aec0c315b249","modified":1641805492845},{"_id":"source/img/article/20190825/4.png","hash":"68d3c65af31a379925038df4dc1c5a7af71a6df6","modified":1641805492845},{"_id":"source/img/article/20190825/5.png","hash":"8a4e1e22e18f4e3ef3696dd024c2c353f6ce4f6b","modified":1641805492845},{"_id":"source/img/article/20190825/6.png","hash":"7cc0f3cbbc80ad14598bbd844f49df3b45e55a46","modified":1641805492846},{"_id":"source/img/article/20190825/7.png","hash":"0e95a0d583e28e3503f97f9337e9363c0f618e8c","modified":1641805492846},{"_id":"source/img/article/20190902/1.png","hash":"32c8c70ec762944cd8ce116eb9877625c311a481","modified":1641805492846},{"_id":"source/img/article/20190902/2.png","hash":"1503429560ec6973b6a8ca89aa8ced7983c57731","modified":1641805492847},{"_id":"source/img/article/20190902/3.png","hash":"fda5d1ddbc74229a3b6c6a97d46d60ae851b349a","modified":1641805492847},{"_id":"source/img/article/20190902/4.png","hash":"2649634a7a1552770a5947f4000480840af38203","modified":1641805492847},{"_id":"source/img/article/20190902/5.png","hash":"2cea088af4f9cd9326cb9ebec959bd77cb970668","modified":1641805492847},{"_id":"source/img/article/20190902/6.png","hash":"eacb5ec59175ed496ec7c5a3e521f19d200f2bd8","modified":1641805492848},{"_id":"source/img/article/20190902/7.png","hash":"cea671bee72c7caaad347f73b58f8ce2f96e9c59","modified":1641805492848},{"_id":"source/img/article/20190902/9.png","hash":"8a3d2bdbc8af8d56c34802c07034680f2cbacb79","modified":1641805492849},{"_id":"source/img/article/20191216/1.png","hash":"0ce6818316b968e5b4278f4bd6edf0174251ebb9","modified":1641805492870},{"_id":"source/img/article/20200226/1.png","hash":"b61f5e9f0c096fc07fd296f67ead0bfa7c030fd9","modified":1641805492870},{"_id":"source/img/article/20200330/1.png","hash":"c49780142d9a0fb566331891e27943c5b4c2b4be","modified":1641805492880},{"_id":"source/img/article/20200330/2.png","hash":"3c852a8fd87610d23575dd7ddacd2c6f64014774","modified":1641805492880},{"_id":"source/img/article/20210621/1.png","hash":"5a175761b1e4ffd36d0367300ed41ce207c104c4","modified":1641805492881},{"_id":"source/img/article/20210621/2.png","hash":"81450394d91e92fc4a6d46399f1703daa0b88514","modified":1641805492881},{"_id":"source/img/header_img/archive.jpg","hash":"e2d32262ba6cf34af93ee21ffb63fa2a17505988","modified":1641805492891},{"_id":"source/img/signature/BeanTechSign-white.png","hash":"34289ed41cf9ddac2d56be46fbb1515b7d5913cd","modified":1641805492898},{"_id":"themes/huweihuang/source/css/bootstrap.css","hash":"41c54bf695145ae0b4d9020a1da308ceb05dcaf3","modified":1641805492905},{"_id":"themes/huweihuang/source/css/images/ironman.png","hash":"2f0db0ab15d466c4065d9f6102fdf829726d9e3f","modified":1641805492907},{"_id":"themes/huweihuang/source/css/images/rocket.png","hash":"6dee0406955aa9b7a261161d30f2538a671e806b","modified":1641805492907},{"_id":"source/img/article/20190212/2.png","hash":"a2e320aba940339a36f25924d6d649af928e2beb","modified":1641805492813},{"_id":"source/img/article/20190418/3.png","hash":"be3f40208e2b8aa7cfc78ed1927948e09cae18bc","modified":1641805492816},{"_id":"source/img/article/20190425/1.png","hash":"7f5b7b45f09c7c16b48ea7910b4549aa7d5cabaa","modified":1641805492817},{"_id":"source/img/article/20190503/11.png","hash":"02036c4390c93a7d885e9be85f3979fa3086c244","modified":1641805492819},{"_id":"source/img/article/20190503/2.png","hash":"e1dacc10efd084aed772294d128b8b40b03a807c","modified":1641805492819},{"_id":"source/img/article/20190503/4.png","hash":"d67473d97b4fd8d0ded1c27487ebd45989c7f04e","modified":1641805492820},{"_id":"source/img/article/20190503/8.png","hash":"b7c962936ff663442e141b1755beb60bbf15b2b7","modified":1641805492822},{"_id":"source/img/article/20190519/12.png","hash":"36020292a72d28e69ab6af29ff7e96579b1da2fc","modified":1641805492824},{"_id":"source/img/article/20190519/11.png","hash":"aa42b46311fc91f83bd6a42a78b89dff75f0c003","modified":1641805492824},{"_id":"source/img/article/20190519/13.png","hash":"ff74b655acca2f0fdc3bd8149cc63321fab5b8fb","modified":1641805492825},{"_id":"source/img/article/20190519/3.png","hash":"6afa47435e8a47fbe68a3f7e0003e7650b2532e1","modified":1641805492826},{"_id":"source/img/article/20190801/1.png","hash":"a70d4a300eab5fafca25fbab2f87be8dfe7b2fee","modified":1641805492829},{"_id":"source/img/article/20190803/1.png","hash":"fe08cce605be6102ac59d97614f7b0e8be9bd63a","modified":1641805492832},{"_id":"source/img/article/20190810/6.png","hash":"962cc9b03bd42f70f3e31820fd2761ec93febd94","modified":1641805492836},{"_id":"source/img/article/20190819/1.png","hash":"11da9b99cb19c57edbd27bb5aded54e02bcd42a2","modified":1641805492844},{"_id":"source/img/article/20190902/8.png","hash":"e555c91472cc977c5531125bed0f023b79f94b5c","modified":1641805492848},{"_id":"source/img/article/20191122/3.png","hash":"0b4290dcd3a69161dfe84f0159687898b4addbbc","modified":1641805492870},{"_id":"source/img/article/20200226/5.png","hash":"5077dbd03fc9886f01963d83fd903d9a80742f47","modified":1641805492880},{"_id":"source/img/article/20210830/1.png","hash":"81e59707a9e4635d65b9f5c2cf6f71c8aeceb888","modified":1641805492883},{"_id":"source/img/header_img/tag.png","hash":"fe9af631de776eaec7dcc8a90ad4a388e19a6dd0","modified":1641805492895},{"_id":"themes/huweihuang/source/js/jquery.js","hash":"1852661bd11a09ca9b9cb63d1aa6ff390fffaf4e","modified":1641805492912},{"_id":"source/img/article/20190212/1.png","hash":"a34dc632eae4b0f4fcf1667782f91f174f042bf5","modified":1641805492813},{"_id":"source/img/article/20190212/4.png","hash":"0332a0d27cb323a46f06c85290ab5e0381712478","modified":1641805492815},{"_id":"source/img/article/20190425/3.png","hash":"4c95725be63a4d0c2b6e91e7f0f04d1b0eb820fd","modified":1641805492818},{"_id":"source/img/article/20190503/3.png","hash":"4b96360a64964ed5922a7d7a75ba4e093b940d52","modified":1641805492820},{"_id":"source/img/article/20190503/7.png","hash":"4369866580a35ca3fec026adb9f4b24f10c17aa8","modified":1641805492822},{"_id":"source/img/signature/BeanTechSign-black.png","hash":"94b7102e819fd6ee082d3fb0166f4de7458c22ff","modified":1641805492897},{"_id":"source/img/article/20190503/10.png","hash":"f7440ae13cf915c04019406764d71801b023547e","modified":1641805492819},{"_id":"source/img/article/20190503/6.png","hash":"ffc821ab8c5517fd7de654bf2414fd79798bbb49","modified":1641805492821},{"_id":"source/img/article/20190706/1.png","hash":"08a4c59a43c4b7f624b528e1966b845811153f31","modified":1641805492829},{"_id":"source/img/article/20190815/1.png","hash":"13db577bbc8b5f6a1286b82e93ebb69998e240b6","modified":1641805492840},{"_id":"source/img/header_img/home.jpg","hash":"8761377c2a6b7a0d06575e11576169bf7b400f32","modified":1641805492894},{"_id":"source/img/article/20190212/3.png","hash":"6eb5545f10dd97761986fa431eccf7cbbb719d5a","modified":1641805492814},{"_id":"source/img/article/20190810/5.png","hash":"f2eddb4b848c2c8b098ad3f09873ee48e275d446","modified":1641805492835},{"_id":"source/img/article/20190816/2.png","hash":"91d85b5e9f2c66e985c62167e676dc422326afc2","modified":1641805492842},{"_id":"source/img/header_img/404.png","hash":"ea6155e5bea83f7c2a12195583999b0d8c741e99","modified":1641805492890},{"_id":"source/img/article/20190810/4.png","hash":"84f2e331782eda2aa9ebdf612a34abc2e05219b8","modified":1641805492834},{"_id":"source/img/avatar/icon.png","hash":"6b1084810816f6465fd095349d6a87d09a97f9a2","modified":1641805492889},{"_id":"source/img/article/20190425/2.png","hash":"845cac70dc0b859b371a22942d4f1dd012191c63","modified":1641805492818},{"_id":"source/img/article/20210830/2.mp4","hash":"b7aee484b1ef57e8e6d756b3922abf8805e4d108","modified":1641805492885},{"_id":"source/img/header_img/home-bg-o.png","hash":"a2a9c8e1e68fd40363661f136337c7722e1b72e0","modified":1641805492892},{"_id":"source/img/header_img/home2.png","hash":"a9dd324e77f502a367eaf1091e6529cfa57d80e5","modified":1641805492894},{"_id":"source/img/article/20190810/8.png","hash":"c5a7414b18a147aceae3aa739b411b05a3f179a9","modified":1641805492839},{"_id":"source/img/article/20200226/3.png","hash":"fe99d79c0f0790b21fba571806f0f1a8b38a41e7","modified":1641805492877},{"_id":"source/img/article/20200226/4.png","hash":"ec765873f7e88a2753f3d28078e4c61b99297850","modified":1641805492879},{"_id":"source/img/article/20210621/3.png","hash":"d0eb2e3e72af8f4cb63d34e44637a2294e00aff3","modified":1641805492882},{"_id":"source/img/article/20190810/7.png","hash":"86c98c0c0160e635a05ff3d53dd0f57f36db3fca","modified":1641805492838},{"_id":"source/img/article/20191121/1.png","hash":"612ac8295677696bfca9c8b1a2bee9c00371aa76","modified":1641805492853},{"_id":"source/img/article/20191122/2.png","hash":"9f5048ebbb4fc01dba87634fd537aad8c3c79291","modified":1641805492869},{"_id":"source/img/article/20200226/2.png","hash":"c74b63eaaef2c8470d8983d363e3d0b0d22d0958","modified":1641805492875},{"_id":"source/img/article/20191122/1.png","hash":"030a7d5b85f3bcada7db70e0e56c2291333b3b94","modified":1641805492864},{"_id":"source/img/article_header/article_header.png","hash":"d9fa12f1e40924a0db57761d09d52dce450b4f7b","modified":1641805492888},{"_id":"source/_posts/2022/bitmap-0110.md","hash":"da0baa6afb8aa5be0f6711626964796ee271b94f","modified":1642156968943}],"Category":[],"Data":[],"Page":[{"layout":"404","description":"你来到了没有知识的荒原","header-img":"/img/header_img/404.png","_content":"","source":"404.md","raw":"---\nlayout: 404\ndescription: \"你来到了没有知识的荒原\"\nheader-img: \"/img/header_img/404.png\"\n---\n","date":"2022-01-10T09:04:52.801Z","updated":"2022-01-10T09:04:52.801Z","path":"404.html","title":"","comments":1,"_id":"cky8gmc0s0000d1qhv3jjx4rt","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"archive","title":"Archives","header-img":"/img/header_img/archive.jpg","comments":0,"date":"2017-09-20T12:49:56.000Z","description":"Hey, this is archives","_content":"","source":"archive/index.md","raw":"---\nlayout: \"archive\"\ntitle: \"Archives\"\nheader-img: \"/img/header_img/archive.jpg\"\ncomments: false\ndate: 2017-09-20 20:49:56\ndescription: \"Hey, this is archives\"\n---\n","updated":"2022-01-10T09:04:52.812Z","path":"archive/index.html","_id":"cky8gmc260001d1qhw9rehfyy","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"about","title":"About","date":"2017-10-03T02:48:33.000Z","description":"Just do IT","header-img":"/img/header_img/about.jpg","aplayer":false,"comments":1,"fixed":false,"_content":"\n### 关于我\n\n>一个低调、稳重，喜欢敲代码，喜欢新鲜技术，表面上高冷、不苟言笑的，\n>\n>偶尔神经兮兮、莫名其妙，喜欢游戏，偶尔又特立独行的，双重性格的技术爱好者！\n\n### 兴趣方向\n\n> iOS 起家，在大前端的路上越走越远。\n\n### 参与社区\n\n > Github:https://github.com/Quincy-QC\n >\n > 码云:https://gitee.com/qiuchong\n >\n > leetCode:https://leetcode.com/quincy-qc\n\n### 联系我\n\n>Email: quincy.qiuchong@gmail.com\n\n","source":"about/index.md","raw":"---\nlayout: \"about\"\ntitle: \"About\"\ndate: 2017-10-03 10:48:33\ndescription: \"Just do IT\"\nheader-img: \"/img/header_img/about.jpg\"\naplayer: false\ncomments: true\nfixed: false\n---\n\n### 关于我\n\n>一个低调、稳重，喜欢敲代码，喜欢新鲜技术，表面上高冷、不苟言笑的，\n>\n>偶尔神经兮兮、莫名其妙，喜欢游戏，偶尔又特立独行的，双重性格的技术爱好者！\n\n### 兴趣方向\n\n> iOS 起家，在大前端的路上越走越远。\n\n### 参与社区\n\n > Github:https://github.com/Quincy-QC\n >\n > 码云:https://gitee.com/qiuchong\n >\n > leetCode:https://leetcode.com/quincy-qc\n\n### 联系我\n\n>Email: quincy.qiuchong@gmail.com\n\n","updated":"2022-01-10T09:04:52.811Z","path":"about/index.html","_id":"cky8gmc270002d1qhrgf7k4v8","content":"<h3 id=\"关于我\">关于我</h3>\n<blockquote>\n<p>一个低调、稳重，喜欢敲代码，喜欢新鲜技术，表面上高冷、不苟言笑的，</p>\n<p>偶尔神经兮兮、莫名其妙，喜欢游戏，偶尔又特立独行的，双重性格的技术爱好者！</p>\n</blockquote>\n<h3 id=\"兴趣方向\">兴趣方向</h3>\n<blockquote>\n<p>iOS 起家，在大前端的路上越走越远。</p>\n</blockquote>\n<h3 id=\"参与社区\">参与社区</h3>\n<blockquote>\n<p>Github:<a href=\"https://github.com/Quincy-QC\" target=\"_blank\" rel=\"noopener\">https://github.com/Quincy-QC</a></p>\n<p>码云:<a href=\"https://gitee.com/qiuchong\" target=\"_blank\" rel=\"noopener\">https://gitee.com/qiuchong</a></p>\n<p>leetCode:<a href=\"https://leetcode.com/quincy-qc\" target=\"_blank\" rel=\"noopener\">https://leetcode.com/quincy-qc</a></p>\n</blockquote>\n<h3 id=\"联系我\">联系我</h3>\n<blockquote>\n<p>Email: <a href=\"mailto:quincy.qiuchong@gmail.com\" target=\"_blank\" rel=\"noopener\">quincy.qiuchong@gmail.com</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h3>关于我</h3>\n<blockquote>\n<p>一个低调、稳重，喜欢敲代码，喜欢新鲜技术，表面上高冷、不苟言笑的，</p>\n<p>偶尔神经兮兮、莫名其妙，喜欢游戏，偶尔又特立独行的，双重性格的技术爱好者！</p>\n</blockquote>\n<h3>兴趣方向</h3>\n<blockquote>\n<p>iOS 起家，在大前端的路上越走越远。</p>\n</blockquote>\n<h3>参与社区</h3>\n<blockquote>\n<p>Github:<a href=\"https://github.com/Quincy-QC\" target=\"_blank\" rel=\"noopener\">https://github.com/Quincy-QC</a></p>\n<p>码云:<a href=\"https://gitee.com/qiuchong\" target=\"_blank\" rel=\"noopener\">https://gitee.com/qiuchong</a></p>\n<p>leetCode:<a href=\"https://leetcode.com/quincy-qc\" target=\"_blank\" rel=\"noopener\">https://leetcode.com/quincy-qc</a></p>\n</blockquote>\n<h3>联系我</h3>\n<blockquote>\n<p>Email: <a href=\"mailto:quincy.qiuchong@gmail.com\" target=\"_blank\" rel=\"noopener\">quincy.qiuchong@gmail.com</a></p>\n</blockquote>\n"},{"layout":"tags","title":"Tags","description":"Hey, this is Tags.","header-img":"/img/header_img/tag.png","_content":"","source":"tags/index.md","raw":"---\nlayout: \"tags\"\ntitle: \"Tags\"\ndescription: \"Hey, this is Tags.\"\nheader-img: \"/img/header_img/tag.png\"\n---\n","date":"2022-01-10T09:04:52.898Z","updated":"2022-01-10T09:04:52.898Z","path":"tags/index.html","comments":1,"_id":"cky8gmc3c0003d1qh1bieksop","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"加载带有签章的PDF文件","catalog":true,"toc_nav_num":true,"date":"2020-02-26T11:54:20.000Z","subtitle":"Load PDF File with Signature","header-img":"/img/article_header/article_header.png","busuanzi":true,"_content":"\n# 前言\n\n常规的PDF文件可以直接通过`UIWebView`或`WKWebView`直接进行本地文件或远程链接加载，但是带有签章的PDF文件，需要一些处理。\n\n<!-- more -->\n\n# 对于iOS 12以上的系统\n\n可以直接使用`WKWebView`进行加载本地PDF文件或URL，就会直接显示电子签章。（`UIWebView`并不会直接显示电子签章）。\n\n# 对于iOS 12以下的系统\n\n即使是使用`WKWebView`也无法加载显示电子签章，这时候就需要[pdf.js](https://github.com/mozilla/pdf.js)。`pfd.js`可以实现在`html`下直接浏览PDF文档，是一款开源的PDF文档读取解析插件。\n\n`pdf.js`主要包含两个库文件：\n- `pdf.js`负责API解析；\n- `pdf.worker.js`负责核心解析；\n\n## 下载\n\n`pdf.js`是火狐浏览器的开源项目，[下载地址](http://mozilla.github.io/pdf.js/getting_started/)。\n\n1. 我们可以直接下载`Stable`包，包含需要的`PDF.js`和`viewer`文件：\n\n![pdf.js](/img/article/20200226/1.png)\n\n2. 也可以从[github](https://github.com/mozilla/pdf.js)下载代码，\n- 并进行`gulp generic`编译，最终需要的代码文件`pdf.js`和`pdf.worker.js`会在`build/generic/`路径下；\n![编译后](/img/article/20200226/3.png)\n- 或使用`gulp minified`编译，可以一定程度对文件进行压缩，最终需要的代码文件`pdf.js`和`pdf.worker.js`会在`build/minified/`路径下；\n![编译后](/img/article/20200226/4.png)\n\n如果还觉得文件够大，我们还可以对之进行一些删减，最终文件如下：\n![文件](/img/article/20200226/5.png)\n\n## 使用\n\n直接拖入到项目中，文件夹添加方式选择`Create folder references`，选择`Create groups`会丢失样式。\n\nPDF文件只能使用本地文件，所以对于网络资源需要先进行下载再展示。\n\n代码：\n\n``` objectivec\n - (void)loadPDFFile:(NSString*)filePath {  \n    NSString *viwerPath = [[NSBundle mainBundle] pathForResource:@\"viewer\" ofType:@\"html\" inDirectory:@\"minified/web\"];\n    NSString *urlStr = [NSString stringWithFormat:@\"%@?file=%@#page=1\", viwerPath, filePath];\n    urlStr = [urlStr stringByAddingPercentEncodingWithAllowedCharacters:[NSCharacterSet URLQueryAllowedCharacterSet]];\n    NSURLRequest *request = [NSURLRequest requestWithURL:[NSURL URLWithString:urlStr]];\n    [self loadRequest:request];\n}\n```\n\n至此，`pdf.js`加载的功能也只是和使用原生的方式一样加载无电子签章的文件，需要显示电子签章，需要将一下代码注释，可以全局搜索代码`data.fieldType === 'Sig'`查找：\n\n``` objectivec\n//    if (data.fieldType === 'Sig') {\n//      data.fieldValue = null;\n//\n//      _this3.setFlags(_util.AnnotationFlag.HIDDEN);\n//    }\n```\n\n## 在线使用\n\n我们可以使用`mozilla`部署在`github pages`上的`Viewer`就行PDF加载，和本地`viewer.html`加载PDF文件类型，使用如下路径加载：\n\n``` objectivec\nNSString *urlStr = [NSString stringWithFormat:@\"http://mozilla.github.io/pdf.js/web/viewer.html?file=%@#page=1\", filePath];\n```\n\n但是源码的本身是默认不显示签章，所以如果想使用在线预览方式，需要我们自定义`HTML`修改部分代码并部署到网页，就可以实现在线预览。\n\n## 最终效果\n\n![效果图](/img/article/20200226/2.png)\n","source":"_posts/2020/load-pdf-with-signature-0226.md","raw":"---\ntitle: \"加载带有签章的PDF文件\"\ncatalog: true\ntoc_nav_num: true\ndate: 2020-02-26 19:54:20\nsubtitle: \"Load PDF File with Signature\"\nheader-img: \"/img/article_header/article_header.png\"\nbusuanzi: true\ntags:\n- iOS - Objective-C\n\n---\n\n# 前言\n\n常规的PDF文件可以直接通过`UIWebView`或`WKWebView`直接进行本地文件或远程链接加载，但是带有签章的PDF文件，需要一些处理。\n\n<!-- more -->\n\n# 对于iOS 12以上的系统\n\n可以直接使用`WKWebView`进行加载本地PDF文件或URL，就会直接显示电子签章。（`UIWebView`并不会直接显示电子签章）。\n\n# 对于iOS 12以下的系统\n\n即使是使用`WKWebView`也无法加载显示电子签章，这时候就需要[pdf.js](https://github.com/mozilla/pdf.js)。`pfd.js`可以实现在`html`下直接浏览PDF文档，是一款开源的PDF文档读取解析插件。\n\n`pdf.js`主要包含两个库文件：\n- `pdf.js`负责API解析；\n- `pdf.worker.js`负责核心解析；\n\n## 下载\n\n`pdf.js`是火狐浏览器的开源项目，[下载地址](http://mozilla.github.io/pdf.js/getting_started/)。\n\n1. 我们可以直接下载`Stable`包，包含需要的`PDF.js`和`viewer`文件：\n\n![pdf.js](/img/article/20200226/1.png)\n\n2. 也可以从[github](https://github.com/mozilla/pdf.js)下载代码，\n- 并进行`gulp generic`编译，最终需要的代码文件`pdf.js`和`pdf.worker.js`会在`build/generic/`路径下；\n![编译后](/img/article/20200226/3.png)\n- 或使用`gulp minified`编译，可以一定程度对文件进行压缩，最终需要的代码文件`pdf.js`和`pdf.worker.js`会在`build/minified/`路径下；\n![编译后](/img/article/20200226/4.png)\n\n如果还觉得文件够大，我们还可以对之进行一些删减，最终文件如下：\n![文件](/img/article/20200226/5.png)\n\n## 使用\n\n直接拖入到项目中，文件夹添加方式选择`Create folder references`，选择`Create groups`会丢失样式。\n\nPDF文件只能使用本地文件，所以对于网络资源需要先进行下载再展示。\n\n代码：\n\n``` objectivec\n - (void)loadPDFFile:(NSString*)filePath {  \n    NSString *viwerPath = [[NSBundle mainBundle] pathForResource:@\"viewer\" ofType:@\"html\" inDirectory:@\"minified/web\"];\n    NSString *urlStr = [NSString stringWithFormat:@\"%@?file=%@#page=1\", viwerPath, filePath];\n    urlStr = [urlStr stringByAddingPercentEncodingWithAllowedCharacters:[NSCharacterSet URLQueryAllowedCharacterSet]];\n    NSURLRequest *request = [NSURLRequest requestWithURL:[NSURL URLWithString:urlStr]];\n    [self loadRequest:request];\n}\n```\n\n至此，`pdf.js`加载的功能也只是和使用原生的方式一样加载无电子签章的文件，需要显示电子签章，需要将一下代码注释，可以全局搜索代码`data.fieldType === 'Sig'`查找：\n\n``` objectivec\n//    if (data.fieldType === 'Sig') {\n//      data.fieldValue = null;\n//\n//      _this3.setFlags(_util.AnnotationFlag.HIDDEN);\n//    }\n```\n\n## 在线使用\n\n我们可以使用`mozilla`部署在`github pages`上的`Viewer`就行PDF加载，和本地`viewer.html`加载PDF文件类型，使用如下路径加载：\n\n``` objectivec\nNSString *urlStr = [NSString stringWithFormat:@\"http://mozilla.github.io/pdf.js/web/viewer.html?file=%@#page=1\", filePath];\n```\n\n但是源码的本身是默认不显示签章，所以如果想使用在线预览方式，需要我们自定义`HTML`修改部分代码并部署到网页，就可以实现在线预览。\n\n## 最终效果\n\n![效果图](/img/article/20200226/2.png)\n","slug":"2020/load-pdf-with-signature-0226","published":1,"updated":"2022-01-10T09:04:52.810Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cky8gmc3s0004d1qhr74i6fsf","content":"<h1 id=\"前言\">前言</h1>\n<p>常规的PDF文件可以直接通过<code>UIWebView</code>或<code>WKWebView</code>直接进行本地文件或远程链接加载，但是带有签章的PDF文件，需要一些处理。</p>\n<a id=\"more\"></a>\n<h1 id=\"对于ios-12以上的系统\">对于iOS 12以上的系统</h1>\n<p>可以直接使用<code>WKWebView</code>进行加载本地PDF文件或URL，就会直接显示电子签章。（<code>UIWebView</code>并不会直接显示电子签章）。</p>\n<h1 id=\"对于ios-12以下的系统\">对于iOS 12以下的系统</h1>\n<p>即使是使用<code>WKWebView</code>也无法加载显示电子签章，这时候就需要<a href=\"https://github.com/mozilla/pdf.js\" target=\"_blank\" rel=\"noopener\">pdf.js</a>。<code>pfd.js</code>可以实现在<code>html</code>下直接浏览PDF文档，是一款开源的PDF文档读取解析插件。</p>\n<p><code>pdf.js</code>主要包含两个库文件：</p>\n<ul>\n<li><code>pdf.js</code>负责API解析；</li>\n<li><code>pdf.worker.js</code>负责核心解析；</li>\n</ul>\n<h2 id=\"下载\">下载</h2>\n<p><code>pdf.js</code>是火狐浏览器的开源项目，<a href=\"http://mozilla.github.io/pdf.js/getting_started/\" target=\"_blank\" rel=\"noopener\">下载地址</a>。</p>\n<ol>\n<li>我们可以直接下载<code>Stable</code>包，包含需要的<code>PDF.js</code>和<code>viewer</code>文件：</li>\n</ol>\n<p><img src=\"/img/article/20200226/1.png\" alt=\"pdf.js\"></p>\n<ol start=\"2\">\n<li>也可以从<a href=\"https://github.com/mozilla/pdf.js\" target=\"_blank\" rel=\"noopener\">github</a>下载代码，</li>\n</ol>\n<ul>\n<li>并进行<code>gulp generic</code>编译，最终需要的代码文件<code>pdf.js</code>和<code>pdf.worker.js</code>会在<code>build/generic/</code>路径下；<br>\n<img src=\"/img/article/20200226/3.png\" alt=\"编译后\"></li>\n<li>或使用<code>gulp minified</code>编译，可以一定程度对文件进行压缩，最终需要的代码文件<code>pdf.js</code>和<code>pdf.worker.js</code>会在<code>build/minified/</code>路径下；<br>\n<img src=\"/img/article/20200226/4.png\" alt=\"编译后\"></li>\n</ul>\n<p>如果还觉得文件够大，我们还可以对之进行一些删减，最终文件如下：<br>\n<img src=\"/img/article/20200226/5.png\" alt=\"文件\"></p>\n<h2 id=\"使用\">使用</h2>\n<p>直接拖入到项目中，文件夹添加方式选择<code>Create folder references</code>，选择<code>Create groups</code>会丢失样式。</p>\n<p>PDF文件只能使用本地文件，所以对于网络资源需要先进行下载再展示。</p>\n<p>代码：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> - (<span class=\"keyword\">void</span>)loadPDFFile:(<span class=\"built_in\">NSString</span>*)filePath &#123;  </span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> *viwerPath = [[<span class=\"built_in\">NSBundle</span> mainBundle] pathForResource:<span class=\"string\">@\"viewer\"</span> ofType:<span class=\"string\">@\"html\"</span> inDirectory:<span class=\"string\">@\"minified/web\"</span>];</span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> *urlStr = [<span class=\"built_in\">NSString</span> stringWithFormat:<span class=\"string\">@\"%@?file=%@#page=1\"</span>, viwerPath, filePath];</span><br><span class=\"line\">    urlStr = [urlStr stringByAddingPercentEncodingWithAllowedCharacters:[<span class=\"built_in\">NSCharacterSet</span> URLQueryAllowedCharacterSet]];</span><br><span class=\"line\">    <span class=\"built_in\">NSURLRequest</span> *request = [<span class=\"built_in\">NSURLRequest</span> requestWithURL:[<span class=\"built_in\">NSURL</span> URLWithString:urlStr]];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> loadRequest:request];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>至此，<code>pdf.js</code>加载的功能也只是和使用原生的方式一样加载无电子签章的文件，需要显示电子签章，需要将一下代码注释，可以全局搜索代码<code>data.fieldType === 'Sig'</code>查找：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//    if (data.fieldType === 'Sig') &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//      data.fieldValue = null;</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">//      _this3.setFlags(_util.AnnotationFlag.HIDDEN);</span></span><br><span class=\"line\"><span class=\"comment\">//    &#125;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"在线使用\">在线使用</h2>\n<p>我们可以使用<code>mozilla</code>部署在<code>github pages</code>上的<code>Viewer</code>就行PDF加载，和本地<code>viewer.html</code>加载PDF文件类型，使用如下路径加载：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSString</span> *urlStr = [<span class=\"built_in\">NSString</span> stringWithFormat:<span class=\"string\">@\"http://mozilla.github.io/pdf.js/web/viewer.html?file=%@#page=1\"</span>, filePath];</span><br></pre></td></tr></table></figure>\n<p>但是源码的本身是默认不显示签章，所以如果想使用在线预览方式，需要我们自定义<code>HTML</code>修改部分代码并部署到网页，就可以实现在线预览。</p>\n<h2 id=\"最终效果\">最终效果</h2>\n<p><img src=\"/img/article/20200226/2.png\" alt=\"效果图\"></p>\n","site":{"data":{}},"excerpt":"<h1>前言</h1>\n<p>常规的PDF文件可以直接通过<code>UIWebView</code>或<code>WKWebView</code>直接进行本地文件或远程链接加载，但是带有签章的PDF文件，需要一些处理。</p>","more":"<h1>对于iOS 12以上的系统</h1>\n<p>可以直接使用<code>WKWebView</code>进行加载本地PDF文件或URL，就会直接显示电子签章。（<code>UIWebView</code>并不会直接显示电子签章）。</p>\n<h1>对于iOS 12以下的系统</h1>\n<p>即使是使用<code>WKWebView</code>也无法加载显示电子签章，这时候就需要<a href=\"https://github.com/mozilla/pdf.js\" target=\"_blank\" rel=\"noopener\">pdf.js</a>。<code>pfd.js</code>可以实现在<code>html</code>下直接浏览PDF文档，是一款开源的PDF文档读取解析插件。</p>\n<p><code>pdf.js</code>主要包含两个库文件：</p>\n<ul>\n<li><code>pdf.js</code>负责API解析；</li>\n<li><code>pdf.worker.js</code>负责核心解析；</li>\n</ul>\n<h2>下载</h2>\n<p><code>pdf.js</code>是火狐浏览器的开源项目，<a href=\"http://mozilla.github.io/pdf.js/getting_started/\" target=\"_blank\" rel=\"noopener\">下载地址</a>。</p>\n<ol>\n<li>我们可以直接下载<code>Stable</code>包，包含需要的<code>PDF.js</code>和<code>viewer</code>文件：</li>\n</ol>\n<p><img src=\"/img/article/20200226/1.png\" alt=\"pdf.js\"></p>\n<ol start=\"2\">\n<li>也可以从<a href=\"https://github.com/mozilla/pdf.js\" target=\"_blank\" rel=\"noopener\">github</a>下载代码，</li>\n</ol>\n<ul>\n<li>并进行<code>gulp generic</code>编译，最终需要的代码文件<code>pdf.js</code>和<code>pdf.worker.js</code>会在<code>build/generic/</code>路径下；<br>\n<img src=\"/img/article/20200226/3.png\" alt=\"编译后\"></li>\n<li>或使用<code>gulp minified</code>编译，可以一定程度对文件进行压缩，最终需要的代码文件<code>pdf.js</code>和<code>pdf.worker.js</code>会在<code>build/minified/</code>路径下；<br>\n<img src=\"/img/article/20200226/4.png\" alt=\"编译后\"></li>\n</ul>\n<p>如果还觉得文件够大，我们还可以对之进行一些删减，最终文件如下：<br>\n<img src=\"/img/article/20200226/5.png\" alt=\"文件\"></p>\n<h2>使用</h2>\n<p>直接拖入到项目中，文件夹添加方式选择<code>Create folder references</code>，选择<code>Create groups</code>会丢失样式。</p>\n<p>PDF文件只能使用本地文件，所以对于网络资源需要先进行下载再展示。</p>\n<p>代码：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> - (<span class=\"keyword\">void</span>)loadPDFFile:(<span class=\"built_in\">NSString</span>*)filePath &#123;  </span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> *viwerPath = [[<span class=\"built_in\">NSBundle</span> mainBundle] pathForResource:<span class=\"string\">@\"viewer\"</span> ofType:<span class=\"string\">@\"html\"</span> inDirectory:<span class=\"string\">@\"minified/web\"</span>];</span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> *urlStr = [<span class=\"built_in\">NSString</span> stringWithFormat:<span class=\"string\">@\"%@?file=%@#page=1\"</span>, viwerPath, filePath];</span><br><span class=\"line\">    urlStr = [urlStr stringByAddingPercentEncodingWithAllowedCharacters:[<span class=\"built_in\">NSCharacterSet</span> URLQueryAllowedCharacterSet]];</span><br><span class=\"line\">    <span class=\"built_in\">NSURLRequest</span> *request = [<span class=\"built_in\">NSURLRequest</span> requestWithURL:[<span class=\"built_in\">NSURL</span> URLWithString:urlStr]];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> loadRequest:request];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>至此，<code>pdf.js</code>加载的功能也只是和使用原生的方式一样加载无电子签章的文件，需要显示电子签章，需要将一下代码注释，可以全局搜索代码<code>data.fieldType === 'Sig'</code>查找：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//    if (data.fieldType === 'Sig') &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//      data.fieldValue = null;</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">//      _this3.setFlags(_util.AnnotationFlag.HIDDEN);</span></span><br><span class=\"line\"><span class=\"comment\">//    &#125;</span></span><br></pre></td></tr></table></figure>\n<h2>在线使用</h2>\n<p>我们可以使用<code>mozilla</code>部署在<code>github pages</code>上的<code>Viewer</code>就行PDF加载，和本地<code>viewer.html</code>加载PDF文件类型，使用如下路径加载：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSString</span> *urlStr = [<span class=\"built_in\">NSString</span> stringWithFormat:<span class=\"string\">@\"http://mozilla.github.io/pdf.js/web/viewer.html?file=%@#page=1\"</span>, filePath];</span><br></pre></td></tr></table></figure>\n<p>但是源码的本身是默认不显示签章，所以如果想使用在线预览方式，需要我们自定义<code>HTML</code>修改部分代码并部署到网页，就可以实现在线预览。</p>\n<h2>最终效果</h2>\n<p><img src=\"/img/article/20200226/2.png\" alt=\"效果图\"></p>"},{"title":"NSTimer循环引用解决方案","catalog":true,"toc_nav_num":true,"date":"2020-03-30T12:04:21.000Z","subtitle":"The Circular Reference Issue with NSTimer","header-img":"/img/article_header/article_header.png","busuanzi":true,"_content":"\n# 问题\n\n当我们从控制器`View Controller`跳转到一个启用重复调用定时器的控制器`Anohter View Controller`后，进行`pop`操作后，无法销毁该控制器`Another View Controller`。\n\n``` objectivec\nself.timer = [NSTimer timerWithTimeInterval:1.0 target:self selector:@selector(timerAction) userInfo:nil repeats:YES];\n```\n\n`timer`作为`VC`的属性，被`VC`强引用，创建`timer`对象时`VC`作为`target`被`timer`强引用，即循环引用。\n\n![循环引用](/img/article/20200330/1.png)\n\n<!-- more -->\n\n# weak指针\n\n既然有循环引用，那我们可以用解决`Block`循环引用的方案--`weak`指针来解决吗？答案是不可以的，因为无论是用`weak`还是`strong`修饰，在`NSTimer`的创建过程中都会重新生成一个强引用指针指向`VC`，导致循环引用。\n\n# 解决方案\n\n## invalidate：\n\n> This method is the only way to remove a timer from an NSRunLoop object. The NSRunLoop object removes its strong reference to the timer, either just before the invalidate method returns or at some later point.\nIf it was configured with target and user info objects, the receiver removes its strong references to those objects as well.\n\n我们可以调用`NSTimer`的`invalidate`方法来手动释放`timer`，当然我们不能在`dealloc`中调用这个方法，因为本身因为循环引用已经导致当前控制器无法释放，自然也不会走`dealloc`方法。\n所以我们可以考虑在`viewWillDisappear`这个方法中进行释放，缺点就是可以会忘记，而且并不是很严谨。\n\n## 类方法：\n\n创建一个继承自`NSObject`的子类`TimerWeakTarget`，并创建开启定时器的方法。\n\n`TimerWeakTarget`文件：\n``` objectivec\n// TimerWeakTarget.h\n@interface TimerWeakTarget : NSObject\n\n+ (NSTimer *) scheduledTimerWithTimeInterval:(NSTimeInterval)interval\n                                      target:(id)aTarget\n                                    selector:(SEL)aSelector\n                                    userInfo:(id)userInfo\n                                     repeats:(BOOL)repeats;\n\n@end\n```\n\n``` objectivec\n// TimerWeakTarget.m\n@interface TimerWeakTarget ()\n\n@property (weak, nonatomic) id target;\n@property (assign, nonatomic) SEL selector;\n@property (weak, nonatomic) NSTimer *tempTimer;\n\n@end\n\n@implementation TimerWeakTarget\n\n+ (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)interval target:(id)aTarget selector:(SEL)aSelector userInfo:(id)userInfo repeats:(BOOL)repeats {\n    TimerWeakTarget *timerWeakTarget = [[TimerWeakTarget alloc] init];\n    timerWeakTarget.target = aTarget;\n    timerWeakTarget.selector = aSelector;\n    timerWeakTarget.tempTimer = [NSTimer scheduledTimerWithTimeInterval:interval target:timerWeakTarget selector:@selector(fire:) userInfo:userInfo repeats:repeats];\n    return timerWeakTarget.tempTimer;\n}\n\n\n- (void)fire:(NSTimer *)timer {\n    if (self.target && [self.target respondsToSelector:self.selector]) {\n        [self.target performSelector:self.selector withObject:timer.userInfo];\n    } else {\n        [self.tempTimer invalidate];\n    }\n}\n\n@end\n```\n\n控制器内调用：\n``` objectivec\nself.timer = [TimerWeakTarget scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(timerAction) userInfo:nil repeats:YES];\n```\n\n`VC`强引用`timer`，`timer`强引用的`target`是`timerWeakTarget`，而`timerWeakTarget`弱引用`VC`，解除循环引用。\n\n![解除循环引用](/img/article/20200330/2.png)\n\n## WeakProxy：\n\n创建一个继承`NSObject`的子类`WeakProxy`，并实现消息转发的相关方法。\n\n`WeakProxy`文件：\n``` objectivec\n// WeakProxy.h\n@interface WeakProxy : NSObject\n\n+ (instancetype)proxyWithTarget:(id)target;\n\n@end\n```\n\n``` objectivec\n// WeakProxy.m\n@interface WeakProxy ()\n\n@property (weak, nonatomic) id weakTarget;\n\n@end\n\n@implementation WeakProxy\n\n+ (instancetype)proxyWithTarget:(id)target {\n    return [[WeakProxy alloc] initWithTarget:target];\n}\n\n\n- (instancetype)initWithTarget:(id)target {\n    _weakTarget = target;\n    return self;\n}\n\n\n- (id)forwardingTargetForSelector:(SEL)aSelector {\n    return self.weakTarget;\n}\n\n\n/* OR\n- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector {\n    return [self.weakTarget methodSignatureForSelector:aSelector];\n}\n\n\n- (void)forwardInvocation:(NSInvocation *)anInvocation {\n    SEL sel = [anInvocation selector];\n    if ([self.weakTarget respondsToSelector:sel]) {\n        [anInvocation invokeWithTarget:self.weakTarget];\n    }\n}\n*/\n\n@end\n```\n\n控制器内的调用：\n``` objectivec\nself.timer = [NSTimer scheduledTimerWithTimeInterval:1.0 target:[WeakProxy proxyWithTarget:self] selector:@selector(timerAction) userInfo:nil repeats:YES];\n```\n\n这个方法的原理和类方法相似，将`timer`的`target`设置为`WeakProxy`的实例，利用消息转发机制实现执行`VC`中的计时方法，解决循环引用。\n\n## GCD：\n\n控制器内：\n``` objectivec\n@interface AnotherViewController ()\n\n@property (strong, nonatomic) dispatch_source_t timer;\n\n@end\n\n@implementation AnotherViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n   \n    self.timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0));\n    dispatch_source_set_timer(self.timer, DISPATCH_TIME_NOW, 1*NSEC_PER_SEC, 0);\n    dispatch_source_set_event_handler(self.timer, ^{\n        dispatch_async(dispatch_get_main_queue(), ^{\n            NSLog(@\"fire\");\n        });\n    });\n    dispatch_resume(self.timer);\n}\n\n@end\n```\n\n结束计时：\n``` objectivec\ndispatch_source_cancel(self.timer);\n```\n\n## Block:\n\n`iOS 10`之后新出的`API`：\n\n``` objectivec\nself.timer = [NSTimer scheduledTimerWithTimeInterval:1.0 repeats:YES block:^(NSTimer * _Nonnull timer) {\n    NSLog(@\"fire\");\n}];\n```\n\n\n","source":"_posts/2020/nstimer-circular-reference-issue-0330.md","raw":"---\ntitle: \"NSTimer循环引用解决方案\"\ncatalog: true\ntoc_nav_num: true\ndate: 2020-03-30 20:04:21\nsubtitle: \"The Circular Reference Issue with NSTimer\"\nheader-img: \"/img/article_header/article_header.png\"\nbusuanzi: true\ntags:\n- iOS - Objective-C\n\n---\n\n# 问题\n\n当我们从控制器`View Controller`跳转到一个启用重复调用定时器的控制器`Anohter View Controller`后，进行`pop`操作后，无法销毁该控制器`Another View Controller`。\n\n``` objectivec\nself.timer = [NSTimer timerWithTimeInterval:1.0 target:self selector:@selector(timerAction) userInfo:nil repeats:YES];\n```\n\n`timer`作为`VC`的属性，被`VC`强引用，创建`timer`对象时`VC`作为`target`被`timer`强引用，即循环引用。\n\n![循环引用](/img/article/20200330/1.png)\n\n<!-- more -->\n\n# weak指针\n\n既然有循环引用，那我们可以用解决`Block`循环引用的方案--`weak`指针来解决吗？答案是不可以的，因为无论是用`weak`还是`strong`修饰，在`NSTimer`的创建过程中都会重新生成一个强引用指针指向`VC`，导致循环引用。\n\n# 解决方案\n\n## invalidate：\n\n> This method is the only way to remove a timer from an NSRunLoop object. The NSRunLoop object removes its strong reference to the timer, either just before the invalidate method returns or at some later point.\nIf it was configured with target and user info objects, the receiver removes its strong references to those objects as well.\n\n我们可以调用`NSTimer`的`invalidate`方法来手动释放`timer`，当然我们不能在`dealloc`中调用这个方法，因为本身因为循环引用已经导致当前控制器无法释放，自然也不会走`dealloc`方法。\n所以我们可以考虑在`viewWillDisappear`这个方法中进行释放，缺点就是可以会忘记，而且并不是很严谨。\n\n## 类方法：\n\n创建一个继承自`NSObject`的子类`TimerWeakTarget`，并创建开启定时器的方法。\n\n`TimerWeakTarget`文件：\n``` objectivec\n// TimerWeakTarget.h\n@interface TimerWeakTarget : NSObject\n\n+ (NSTimer *) scheduledTimerWithTimeInterval:(NSTimeInterval)interval\n                                      target:(id)aTarget\n                                    selector:(SEL)aSelector\n                                    userInfo:(id)userInfo\n                                     repeats:(BOOL)repeats;\n\n@end\n```\n\n``` objectivec\n// TimerWeakTarget.m\n@interface TimerWeakTarget ()\n\n@property (weak, nonatomic) id target;\n@property (assign, nonatomic) SEL selector;\n@property (weak, nonatomic) NSTimer *tempTimer;\n\n@end\n\n@implementation TimerWeakTarget\n\n+ (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)interval target:(id)aTarget selector:(SEL)aSelector userInfo:(id)userInfo repeats:(BOOL)repeats {\n    TimerWeakTarget *timerWeakTarget = [[TimerWeakTarget alloc] init];\n    timerWeakTarget.target = aTarget;\n    timerWeakTarget.selector = aSelector;\n    timerWeakTarget.tempTimer = [NSTimer scheduledTimerWithTimeInterval:interval target:timerWeakTarget selector:@selector(fire:) userInfo:userInfo repeats:repeats];\n    return timerWeakTarget.tempTimer;\n}\n\n\n- (void)fire:(NSTimer *)timer {\n    if (self.target && [self.target respondsToSelector:self.selector]) {\n        [self.target performSelector:self.selector withObject:timer.userInfo];\n    } else {\n        [self.tempTimer invalidate];\n    }\n}\n\n@end\n```\n\n控制器内调用：\n``` objectivec\nself.timer = [TimerWeakTarget scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(timerAction) userInfo:nil repeats:YES];\n```\n\n`VC`强引用`timer`，`timer`强引用的`target`是`timerWeakTarget`，而`timerWeakTarget`弱引用`VC`，解除循环引用。\n\n![解除循环引用](/img/article/20200330/2.png)\n\n## WeakProxy：\n\n创建一个继承`NSObject`的子类`WeakProxy`，并实现消息转发的相关方法。\n\n`WeakProxy`文件：\n``` objectivec\n// WeakProxy.h\n@interface WeakProxy : NSObject\n\n+ (instancetype)proxyWithTarget:(id)target;\n\n@end\n```\n\n``` objectivec\n// WeakProxy.m\n@interface WeakProxy ()\n\n@property (weak, nonatomic) id weakTarget;\n\n@end\n\n@implementation WeakProxy\n\n+ (instancetype)proxyWithTarget:(id)target {\n    return [[WeakProxy alloc] initWithTarget:target];\n}\n\n\n- (instancetype)initWithTarget:(id)target {\n    _weakTarget = target;\n    return self;\n}\n\n\n- (id)forwardingTargetForSelector:(SEL)aSelector {\n    return self.weakTarget;\n}\n\n\n/* OR\n- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector {\n    return [self.weakTarget methodSignatureForSelector:aSelector];\n}\n\n\n- (void)forwardInvocation:(NSInvocation *)anInvocation {\n    SEL sel = [anInvocation selector];\n    if ([self.weakTarget respondsToSelector:sel]) {\n        [anInvocation invokeWithTarget:self.weakTarget];\n    }\n}\n*/\n\n@end\n```\n\n控制器内的调用：\n``` objectivec\nself.timer = [NSTimer scheduledTimerWithTimeInterval:1.0 target:[WeakProxy proxyWithTarget:self] selector:@selector(timerAction) userInfo:nil repeats:YES];\n```\n\n这个方法的原理和类方法相似，将`timer`的`target`设置为`WeakProxy`的实例，利用消息转发机制实现执行`VC`中的计时方法，解决循环引用。\n\n## GCD：\n\n控制器内：\n``` objectivec\n@interface AnotherViewController ()\n\n@property (strong, nonatomic) dispatch_source_t timer;\n\n@end\n\n@implementation AnotherViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n   \n    self.timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0));\n    dispatch_source_set_timer(self.timer, DISPATCH_TIME_NOW, 1*NSEC_PER_SEC, 0);\n    dispatch_source_set_event_handler(self.timer, ^{\n        dispatch_async(dispatch_get_main_queue(), ^{\n            NSLog(@\"fire\");\n        });\n    });\n    dispatch_resume(self.timer);\n}\n\n@end\n```\n\n结束计时：\n``` objectivec\ndispatch_source_cancel(self.timer);\n```\n\n## Block:\n\n`iOS 10`之后新出的`API`：\n\n``` objectivec\nself.timer = [NSTimer scheduledTimerWithTimeInterval:1.0 repeats:YES block:^(NSTimer * _Nonnull timer) {\n    NSLog(@\"fire\");\n}];\n```\n\n\n","slug":"2020/nstimer-circular-reference-issue-0330","published":1,"updated":"2022-01-10T09:04:52.810Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cky8gmc3v0005d1qhofwez3yc","content":"<h1 id=\"问题\">问题</h1>\n<p>当我们从控制器<code>View Controller</code>跳转到一个启用重复调用定时器的控制器<code>Anohter View Controller</code>后，进行<code>pop</code>操作后，无法销毁该控制器<code>Another View Controller</code>。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">self</span>.timer = [<span class=\"built_in\">NSTimer</span> timerWithTimeInterval:<span class=\"number\">1.0</span> target:<span class=\"keyword\">self</span> selector:<span class=\"keyword\">@selector</span>(timerAction) userInfo:<span class=\"literal\">nil</span> repeats:<span class=\"literal\">YES</span>];</span><br></pre></td></tr></table></figure>\n<p><code>timer</code>作为<code>VC</code>的属性，被<code>VC</code>强引用，创建<code>timer</code>对象时<code>VC</code>作为<code>target</code>被<code>timer</code>强引用，即循环引用。</p>\n<p><img src=\"/img/article/20200330/1.png\" alt=\"循环引用\"></p>\n<a id=\"more\"></a>\n<h1 id=\"weak指针\">weak指针</h1>\n<p>既然有循环引用，那我们可以用解决<code>Block</code>循环引用的方案–<code>weak</code>指针来解决吗？答案是不可以的，因为无论是用<code>weak</code>还是<code>strong</code>修饰，在<code>NSTimer</code>的创建过程中都会重新生成一个强引用指针指向<code>VC</code>，导致循环引用。</p>\n<h1 id=\"解决方案\">解决方案</h1>\n<h2 id=\"invalidate\">invalidate：</h2>\n<blockquote>\n<p>This method is the only way to remove a timer from an NSRunLoop object. The NSRunLoop object removes its strong reference to the timer, either just before the invalidate method returns or at some later point.<br>\nIf it was configured with target and user info objects, the receiver removes its strong references to those objects as well.</p>\n</blockquote>\n<p>我们可以调用<code>NSTimer</code>的<code>invalidate</code>方法来手动释放<code>timer</code>，当然我们不能在<code>dealloc</code>中调用这个方法，因为本身因为循环引用已经导致当前控制器无法释放，自然也不会走<code>dealloc</code>方法。<br>\n所以我们可以考虑在<code>viewWillDisappear</code>这个方法中进行释放，缺点就是可以会忘记，而且并不是很严谨。</p>\n<h2 id=\"类方法\">类方法：</h2>\n<p>创建一个继承自<code>NSObject</code>的子类<code>TimerWeakTarget</code>，并创建开启定时器的方法。</p>\n<p><code>TimerWeakTarget</code>文件：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// TimerWeakTarget.h</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">TimerWeakTarget</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">+ (<span class=\"built_in\">NSTimer</span> *) scheduledTimerWithTimeInterval:(<span class=\"built_in\">NSTimeInterval</span>)interval</span><br><span class=\"line\">                                      target:(<span class=\"keyword\">id</span>)aTarget</span><br><span class=\"line\">                                    selector:(SEL)aSelector</span><br><span class=\"line\">                                    userInfo:(<span class=\"keyword\">id</span>)userInfo</span><br><span class=\"line\">                                     repeats:(<span class=\"built_in\">BOOL</span>)repeats;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// TimerWeakTarget.m</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">TimerWeakTarget</span> ()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">weak</span>, <span class=\"keyword\">nonatomic</span>) <span class=\"keyword\">id</span> target;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">assign</span>, <span class=\"keyword\">nonatomic</span>) SEL selector;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">weak</span>, <span class=\"keyword\">nonatomic</span>) <span class=\"built_in\">NSTimer</span> *tempTimer;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">TimerWeakTarget</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">+ (<span class=\"built_in\">NSTimer</span> *)scheduledTimerWithTimeInterval:(<span class=\"built_in\">NSTimeInterval</span>)interval target:(<span class=\"keyword\">id</span>)aTarget selector:(SEL)aSelector userInfo:(<span class=\"keyword\">id</span>)userInfo repeats:(<span class=\"built_in\">BOOL</span>)repeats &#123;</span><br><span class=\"line\">    TimerWeakTarget *timerWeakTarget = [[TimerWeakTarget alloc] init];</span><br><span class=\"line\">    timerWeakTarget.target = aTarget;</span><br><span class=\"line\">    timerWeakTarget.selector = aSelector;</span><br><span class=\"line\">    timerWeakTarget.tempTimer = [<span class=\"built_in\">NSTimer</span> scheduledTimerWithTimeInterval:interval target:timerWeakTarget selector:<span class=\"keyword\">@selector</span>(fire:) userInfo:userInfo repeats:repeats];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> timerWeakTarget.tempTimer;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)fire:(<span class=\"built_in\">NSTimer</span> *)timer &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.target &amp;&amp; [<span class=\"keyword\">self</span>.target respondsToSelector:<span class=\"keyword\">self</span>.selector]) &#123;</span><br><span class=\"line\">        [<span class=\"keyword\">self</span>.target performSelector:<span class=\"keyword\">self</span>.selector withObject:timer.userInfo];</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        [<span class=\"keyword\">self</span>.tempTimer invalidate];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>控制器内调用：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">self</span>.timer = [TimerWeakTarget scheduledTimerWithTimeInterval:<span class=\"number\">1.0</span> target:<span class=\"keyword\">self</span> selector:<span class=\"keyword\">@selector</span>(timerAction) userInfo:<span class=\"literal\">nil</span> repeats:<span class=\"literal\">YES</span>];</span><br></pre></td></tr></table></figure>\n<p><code>VC</code>强引用<code>timer</code>，<code>timer</code>强引用的<code>target</code>是<code>timerWeakTarget</code>，而<code>timerWeakTarget</code>弱引用<code>VC</code>，解除循环引用。</p>\n<p><img src=\"/img/article/20200330/2.png\" alt=\"解除循环引用\"></p>\n<h2 id=\"weakproxy\">WeakProxy：</h2>\n<p>创建一个继承<code>NSObject</code>的子类<code>WeakProxy</code>，并实现消息转发的相关方法。</p>\n<p><code>WeakProxy</code>文件：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// WeakProxy.h</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">WeakProxy</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">+ (<span class=\"keyword\">instancetype</span>)proxyWithTarget:(<span class=\"keyword\">id</span>)target;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// WeakProxy.m</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">WeakProxy</span> ()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">weak</span>, <span class=\"keyword\">nonatomic</span>) <span class=\"keyword\">id</span> weakTarget;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">WeakProxy</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">+ (<span class=\"keyword\">instancetype</span>)proxyWithTarget:(<span class=\"keyword\">id</span>)target &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [[WeakProxy alloc] initWithTarget:target];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">instancetype</span>)initWithTarget:(<span class=\"keyword\">id</span>)target &#123;</span><br><span class=\"line\">    _weakTarget = target;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">id</span>)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>.weakTarget;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* OR</span></span><br><span class=\"line\"><span class=\"comment\">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123;</span></span><br><span class=\"line\"><span class=\"comment\">    return [self.weakTarget methodSignatureForSelector:aSelector];</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">- (void)forwardInvocation:(NSInvocation *)anInvocation &#123;</span></span><br><span class=\"line\"><span class=\"comment\">    SEL sel = [anInvocation selector];</span></span><br><span class=\"line\"><span class=\"comment\">    if ([self.weakTarget respondsToSelector:sel]) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">        [anInvocation invokeWithTarget:self.weakTarget];</span></span><br><span class=\"line\"><span class=\"comment\">    &#125;</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>控制器内的调用：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">self</span>.timer = [<span class=\"built_in\">NSTimer</span> scheduledTimerWithTimeInterval:<span class=\"number\">1.0</span> target:[WeakProxy proxyWithTarget:<span class=\"keyword\">self</span>] selector:<span class=\"keyword\">@selector</span>(timerAction) userInfo:<span class=\"literal\">nil</span> repeats:<span class=\"literal\">YES</span>];</span><br></pre></td></tr></table></figure>\n<p>这个方法的原理和类方法相似，将<code>timer</code>的<code>target</code>设置为<code>WeakProxy</code>的实例，利用消息转发机制实现执行<code>VC</code>中的计时方法，解决循环引用。</p>\n<h2 id=\"gcd\">GCD：</h2>\n<p>控制器内：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">AnotherViewController</span> ()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">strong</span>, <span class=\"keyword\">nonatomic</span>) dispatch_source_t timer;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">AnotherViewController</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"keyword\">self</span>.timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, <span class=\"number\">0</span>, <span class=\"number\">0</span>, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class=\"number\">0</span>));</span><br><span class=\"line\">    dispatch_source_set_timer(<span class=\"keyword\">self</span>.timer, DISPATCH_TIME_NOW, <span class=\"number\">1</span>*<span class=\"built_in\">NSEC_PER_SEC</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    dispatch_source_set_event_handler(<span class=\"keyword\">self</span>.timer, ^&#123;</span><br><span class=\"line\">        <span class=\"built_in\">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"fire\"</span>);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    dispatch_resume(<span class=\"keyword\">self</span>.timer);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>结束计时：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_source_cancel(<span class=\"keyword\">self</span>.timer);</span><br></pre></td></tr></table></figure>\n<h2 id=\"block\">Block:</h2>\n<p><code>iOS 10</code>之后新出的<code>API</code>：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">self</span>.timer = [<span class=\"built_in\">NSTimer</span> scheduledTimerWithTimeInterval:<span class=\"number\">1.0</span> repeats:<span class=\"literal\">YES</span> block:^(<span class=\"built_in\">NSTimer</span> * _Nonnull timer) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"fire\"</span>);</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h1>问题</h1>\n<p>当我们从控制器<code>View Controller</code>跳转到一个启用重复调用定时器的控制器<code>Anohter View Controller</code>后，进行<code>pop</code>操作后，无法销毁该控制器<code>Another View Controller</code>。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">self</span>.timer = [<span class=\"built_in\">NSTimer</span> timerWithTimeInterval:<span class=\"number\">1.0</span> target:<span class=\"keyword\">self</span> selector:<span class=\"keyword\">@selector</span>(timerAction) userInfo:<span class=\"literal\">nil</span> repeats:<span class=\"literal\">YES</span>];</span><br></pre></td></tr></table></figure>\n<p><code>timer</code>作为<code>VC</code>的属性，被<code>VC</code>强引用，创建<code>timer</code>对象时<code>VC</code>作为<code>target</code>被<code>timer</code>强引用，即循环引用。</p>\n<p><img src=\"/img/article/20200330/1.png\" alt=\"循环引用\"></p>","more":"<h1>weak指针</h1>\n<p>既然有循环引用，那我们可以用解决<code>Block</code>循环引用的方案–<code>weak</code>指针来解决吗？答案是不可以的，因为无论是用<code>weak</code>还是<code>strong</code>修饰，在<code>NSTimer</code>的创建过程中都会重新生成一个强引用指针指向<code>VC</code>，导致循环引用。</p>\n<h1>解决方案</h1>\n<h2>invalidate：</h2>\n<blockquote>\n<p>This method is the only way to remove a timer from an NSRunLoop object. The NSRunLoop object removes its strong reference to the timer, either just before the invalidate method returns or at some later point.<br>\nIf it was configured with target and user info objects, the receiver removes its strong references to those objects as well.</p>\n</blockquote>\n<p>我们可以调用<code>NSTimer</code>的<code>invalidate</code>方法来手动释放<code>timer</code>，当然我们不能在<code>dealloc</code>中调用这个方法，因为本身因为循环引用已经导致当前控制器无法释放，自然也不会走<code>dealloc</code>方法。<br>\n所以我们可以考虑在<code>viewWillDisappear</code>这个方法中进行释放，缺点就是可以会忘记，而且并不是很严谨。</p>\n<h2>类方法：</h2>\n<p>创建一个继承自<code>NSObject</code>的子类<code>TimerWeakTarget</code>，并创建开启定时器的方法。</p>\n<p><code>TimerWeakTarget</code>文件：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// TimerWeakTarget.h</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">TimerWeakTarget</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">+ (<span class=\"built_in\">NSTimer</span> *) scheduledTimerWithTimeInterval:(<span class=\"built_in\">NSTimeInterval</span>)interval</span><br><span class=\"line\">                                      target:(<span class=\"keyword\">id</span>)aTarget</span><br><span class=\"line\">                                    selector:(SEL)aSelector</span><br><span class=\"line\">                                    userInfo:(<span class=\"keyword\">id</span>)userInfo</span><br><span class=\"line\">                                     repeats:(<span class=\"built_in\">BOOL</span>)repeats;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// TimerWeakTarget.m</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">TimerWeakTarget</span> ()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">weak</span>, <span class=\"keyword\">nonatomic</span>) <span class=\"keyword\">id</span> target;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">assign</span>, <span class=\"keyword\">nonatomic</span>) SEL selector;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">weak</span>, <span class=\"keyword\">nonatomic</span>) <span class=\"built_in\">NSTimer</span> *tempTimer;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">TimerWeakTarget</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">+ (<span class=\"built_in\">NSTimer</span> *)scheduledTimerWithTimeInterval:(<span class=\"built_in\">NSTimeInterval</span>)interval target:(<span class=\"keyword\">id</span>)aTarget selector:(SEL)aSelector userInfo:(<span class=\"keyword\">id</span>)userInfo repeats:(<span class=\"built_in\">BOOL</span>)repeats &#123;</span><br><span class=\"line\">    TimerWeakTarget *timerWeakTarget = [[TimerWeakTarget alloc] init];</span><br><span class=\"line\">    timerWeakTarget.target = aTarget;</span><br><span class=\"line\">    timerWeakTarget.selector = aSelector;</span><br><span class=\"line\">    timerWeakTarget.tempTimer = [<span class=\"built_in\">NSTimer</span> scheduledTimerWithTimeInterval:interval target:timerWeakTarget selector:<span class=\"keyword\">@selector</span>(fire:) userInfo:userInfo repeats:repeats];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> timerWeakTarget.tempTimer;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)fire:(<span class=\"built_in\">NSTimer</span> *)timer &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.target &amp;&amp; [<span class=\"keyword\">self</span>.target respondsToSelector:<span class=\"keyword\">self</span>.selector]) &#123;</span><br><span class=\"line\">        [<span class=\"keyword\">self</span>.target performSelector:<span class=\"keyword\">self</span>.selector withObject:timer.userInfo];</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        [<span class=\"keyword\">self</span>.tempTimer invalidate];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>控制器内调用：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">self</span>.timer = [TimerWeakTarget scheduledTimerWithTimeInterval:<span class=\"number\">1.0</span> target:<span class=\"keyword\">self</span> selector:<span class=\"keyword\">@selector</span>(timerAction) userInfo:<span class=\"literal\">nil</span> repeats:<span class=\"literal\">YES</span>];</span><br></pre></td></tr></table></figure>\n<p><code>VC</code>强引用<code>timer</code>，<code>timer</code>强引用的<code>target</code>是<code>timerWeakTarget</code>，而<code>timerWeakTarget</code>弱引用<code>VC</code>，解除循环引用。</p>\n<p><img src=\"/img/article/20200330/2.png\" alt=\"解除循环引用\"></p>\n<h2>WeakProxy：</h2>\n<p>创建一个继承<code>NSObject</code>的子类<code>WeakProxy</code>，并实现消息转发的相关方法。</p>\n<p><code>WeakProxy</code>文件：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// WeakProxy.h</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">WeakProxy</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">+ (<span class=\"keyword\">instancetype</span>)proxyWithTarget:(<span class=\"keyword\">id</span>)target;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// WeakProxy.m</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">WeakProxy</span> ()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">weak</span>, <span class=\"keyword\">nonatomic</span>) <span class=\"keyword\">id</span> weakTarget;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">WeakProxy</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">+ (<span class=\"keyword\">instancetype</span>)proxyWithTarget:(<span class=\"keyword\">id</span>)target &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [[WeakProxy alloc] initWithTarget:target];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">instancetype</span>)initWithTarget:(<span class=\"keyword\">id</span>)target &#123;</span><br><span class=\"line\">    _weakTarget = target;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">id</span>)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>.weakTarget;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* OR</span></span><br><span class=\"line\"><span class=\"comment\">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123;</span></span><br><span class=\"line\"><span class=\"comment\">    return [self.weakTarget methodSignatureForSelector:aSelector];</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">- (void)forwardInvocation:(NSInvocation *)anInvocation &#123;</span></span><br><span class=\"line\"><span class=\"comment\">    SEL sel = [anInvocation selector];</span></span><br><span class=\"line\"><span class=\"comment\">    if ([self.weakTarget respondsToSelector:sel]) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">        [anInvocation invokeWithTarget:self.weakTarget];</span></span><br><span class=\"line\"><span class=\"comment\">    &#125;</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>控制器内的调用：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">self</span>.timer = [<span class=\"built_in\">NSTimer</span> scheduledTimerWithTimeInterval:<span class=\"number\">1.0</span> target:[WeakProxy proxyWithTarget:<span class=\"keyword\">self</span>] selector:<span class=\"keyword\">@selector</span>(timerAction) userInfo:<span class=\"literal\">nil</span> repeats:<span class=\"literal\">YES</span>];</span><br></pre></td></tr></table></figure>\n<p>这个方法的原理和类方法相似，将<code>timer</code>的<code>target</code>设置为<code>WeakProxy</code>的实例，利用消息转发机制实现执行<code>VC</code>中的计时方法，解决循环引用。</p>\n<h2>GCD：</h2>\n<p>控制器内：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">AnotherViewController</span> ()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">strong</span>, <span class=\"keyword\">nonatomic</span>) dispatch_source_t timer;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">AnotherViewController</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"keyword\">self</span>.timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, <span class=\"number\">0</span>, <span class=\"number\">0</span>, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class=\"number\">0</span>));</span><br><span class=\"line\">    dispatch_source_set_timer(<span class=\"keyword\">self</span>.timer, DISPATCH_TIME_NOW, <span class=\"number\">1</span>*<span class=\"built_in\">NSEC_PER_SEC</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    dispatch_source_set_event_handler(<span class=\"keyword\">self</span>.timer, ^&#123;</span><br><span class=\"line\">        <span class=\"built_in\">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"fire\"</span>);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    dispatch_resume(<span class=\"keyword\">self</span>.timer);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>结束计时：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_source_cancel(<span class=\"keyword\">self</span>.timer);</span><br></pre></td></tr></table></figure>\n<h2>Block:</h2>\n<p><code>iOS 10</code>之后新出的<code>API</code>：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">self</span>.timer = [<span class=\"built_in\">NSTimer</span> scheduledTimerWithTimeInterval:<span class=\"number\">1.0</span> repeats:<span class=\"literal\">YES</span> block:^(<span class=\"built_in\">NSTimer</span> * _Nonnull timer) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"fire\"</span>);</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>"},{"title":"基于Cocoapods创建私有公有库","catalog":true,"toc_nav_num":true,"date":"2019-11-21T10:30:24.000Z","subtitle":"Making a Cocoapod","header-img":"/img/article_header/article_header.png","busuanzi":true,"_content":"\n# 前言\n\n之前一直在用大神们的三方库，工作这么久也积累了一些自己的常用类库，考虑想要上传到自己的Cocoapods私有库，方便后期新项目的调用，下面来介绍上传方法。\n\n# 方法\n\n## 首先创建pod模板\n\n可以使用`pod lib create projectName`，如果有自己的模板，可以添加`--template-url=URL`来调用。\n\n创建过程会让你进行一些选项：\n``` zsh\nWhat platform do you want to use?? [ iOS / macOS ]\n > iOS\n\nWhat language do you want to use?? [ Swift / ObjC ]\n > Swift\n\nWould you like to include a demo application with your library? [ Yes / No ]\n > NO\n\nWhich testing frameworks will you use? [ Quick / None ]\n > None\n\nWould you like to do view based testing? [ Yes / No ]\n > No\n```\n\n## 配置文件\n\n创建完成后会自动打开一个Xcode文件，这边我们打开`Podspec Metadata`文件下的`Project.podspec`配置文件：\n\n![配置文件](/img/article/20191121/1.png)\n\n中间注意几个点：\n\n1. `s.name`的名字必须和项目名相同，不可更改；\n2. `s.version`是作为pod的版本号，后面项目上传Github时需对应打上相同的`tag`值；\n3. `s.homepage`与`s.source`是项目的地址，按照对应的格式修改即可；\n4. `s.framework`对应单数的系统库，`s.frameworks`对应复数的系统库；\n5. `s.dependency`对应其他三方库，如果多个三方库只需要多行添加即可，无需逗号；\n6. `s.subspec 'Core' do |ss|`可以将项目库文件划分子模块，注意每个模块后对应的`end`。\n\n配置文件结束后，将我们需要上传的类库复制到指定位置即可。\n\n## 验证本地库\n\n在上传之前我们需要验证下本地库是否正确，使用`pod lib lint Project.podsepc --verbose --allow-warnings`进行验证。（`pod spec lint Project.podspec`是用于验证远程库）\n\n如果出现如下问题：\n``` objc\nThe 'Pods-App' target has transitive dependencies that include static binaries: during validation.\n```\n这个错误是因为依赖库（s.dependency）包含了.a静态库造成的，虽然这不影响pod的使用，但是会使验证无法通过。可以用`--use-libraries`来让验证通过。\n\n如果库依赖私有库，则需要添加`--resources=xxx.git`\n\n\n## 上传远程仓库并Tag\n\n验证成功后需要将代码上传到远程仓库，代码上传远程仓库之后需要打对应的版本号Tag。\n\n## 私有库\n\n如果不想对外开放，可以使用`pod repo push 仓库地址 --allow-warnings`将podspec放到自己的项目网络地址上，比如公司的gitlab上，创建一个项目专门管理podspec。私有库是`pod search`搜索不到的。\n\n## 公有库\n\n如果需要对外开放，需要创建cocoapods账号：`pod trunk register xxx@email.com userName --verbose`\n\n这边它会发送一封邮件，点击验证即可。使用`pod trunk me`查看账号信息。\n\n然后就可以通过命令进行发布：`pod trunk push Project.podspec --verbose --use-libraries --allow-warnings`\n\n发布成功之后进行`pod repo update`更新，同时还需要进行`rm ~/Library/Caches/CocoaPods/search_index.json`索引缓存删除，然后我们就可以通过`pod search`进行查找对应的库啦。\n\n# 删pod库特定版本\n\n可以删除一个pod的特定版本来纠正意外推送。\n\n`pod trunk delete podName version`\n\n你也可以放弃整个pod和所有版本。\n\n`pod trunk deprecate podName`\n\n# 总结\n\n通过上面步骤就可以简单的创建我们自己的远程类库，更加愉快的开发啦！","source":"_posts/2019/cocoapods-create-pods-1121.md","raw":"---\ntitle: \"基于Cocoapods创建私有公有库\"\ncatalog: true\ntoc_nav_num: true\ndate: 2019-11-21 18:30:24\nsubtitle: \"Making a Cocoapod\"\nheader-img: \"/img/article_header/article_header.png\"\nbusuanzi: true\ntags:\n- iOS\n\n---\n\n# 前言\n\n之前一直在用大神们的三方库，工作这么久也积累了一些自己的常用类库，考虑想要上传到自己的Cocoapods私有库，方便后期新项目的调用，下面来介绍上传方法。\n\n# 方法\n\n## 首先创建pod模板\n\n可以使用`pod lib create projectName`，如果有自己的模板，可以添加`--template-url=URL`来调用。\n\n创建过程会让你进行一些选项：\n``` zsh\nWhat platform do you want to use?? [ iOS / macOS ]\n > iOS\n\nWhat language do you want to use?? [ Swift / ObjC ]\n > Swift\n\nWould you like to include a demo application with your library? [ Yes / No ]\n > NO\n\nWhich testing frameworks will you use? [ Quick / None ]\n > None\n\nWould you like to do view based testing? [ Yes / No ]\n > No\n```\n\n## 配置文件\n\n创建完成后会自动打开一个Xcode文件，这边我们打开`Podspec Metadata`文件下的`Project.podspec`配置文件：\n\n![配置文件](/img/article/20191121/1.png)\n\n中间注意几个点：\n\n1. `s.name`的名字必须和项目名相同，不可更改；\n2. `s.version`是作为pod的版本号，后面项目上传Github时需对应打上相同的`tag`值；\n3. `s.homepage`与`s.source`是项目的地址，按照对应的格式修改即可；\n4. `s.framework`对应单数的系统库，`s.frameworks`对应复数的系统库；\n5. `s.dependency`对应其他三方库，如果多个三方库只需要多行添加即可，无需逗号；\n6. `s.subspec 'Core' do |ss|`可以将项目库文件划分子模块，注意每个模块后对应的`end`。\n\n配置文件结束后，将我们需要上传的类库复制到指定位置即可。\n\n## 验证本地库\n\n在上传之前我们需要验证下本地库是否正确，使用`pod lib lint Project.podsepc --verbose --allow-warnings`进行验证。（`pod spec lint Project.podspec`是用于验证远程库）\n\n如果出现如下问题：\n``` objc\nThe 'Pods-App' target has transitive dependencies that include static binaries: during validation.\n```\n这个错误是因为依赖库（s.dependency）包含了.a静态库造成的，虽然这不影响pod的使用，但是会使验证无法通过。可以用`--use-libraries`来让验证通过。\n\n如果库依赖私有库，则需要添加`--resources=xxx.git`\n\n\n## 上传远程仓库并Tag\n\n验证成功后需要将代码上传到远程仓库，代码上传远程仓库之后需要打对应的版本号Tag。\n\n## 私有库\n\n如果不想对外开放，可以使用`pod repo push 仓库地址 --allow-warnings`将podspec放到自己的项目网络地址上，比如公司的gitlab上，创建一个项目专门管理podspec。私有库是`pod search`搜索不到的。\n\n## 公有库\n\n如果需要对外开放，需要创建cocoapods账号：`pod trunk register xxx@email.com userName --verbose`\n\n这边它会发送一封邮件，点击验证即可。使用`pod trunk me`查看账号信息。\n\n然后就可以通过命令进行发布：`pod trunk push Project.podspec --verbose --use-libraries --allow-warnings`\n\n发布成功之后进行`pod repo update`更新，同时还需要进行`rm ~/Library/Caches/CocoaPods/search_index.json`索引缓存删除，然后我们就可以通过`pod search`进行查找对应的库啦。\n\n# 删pod库特定版本\n\n可以删除一个pod的特定版本来纠正意外推送。\n\n`pod trunk delete podName version`\n\n你也可以放弃整个pod和所有版本。\n\n`pod trunk deprecate podName`\n\n# 总结\n\n通过上面步骤就可以简单的创建我们自己的远程类库，更加愉快的开发啦！","slug":"2019/cocoapods-create-pods-1121","published":1,"updated":"2022-01-10T09:04:52.803Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cky8gmc3x0007d1qh7aoi1m03","content":"<h1 id=\"前言\">前言</h1>\n<p>之前一直在用大神们的三方库，工作这么久也积累了一些自己的常用类库，考虑想要上传到自己的Cocoapods私有库，方便后期新项目的调用，下面来介绍上传方法。</p>\n<h1 id=\"方法\">方法</h1>\n<h2 id=\"首先创建pod模板\">首先创建pod模板</h2>\n<p>可以使用<code>pod lib create projectName</code>，如果有自己的模板，可以添加<code>--template-url=URL</code>来调用。</p>\n<p>创建过程会让你进行一些选项：</p>\n<figure class=\"highlight zsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">What platform <span class=\"keyword\">do</span> you want to use?? [ iOS / macOS ]</span><br><span class=\"line\"> &gt; iOS</span><br><span class=\"line\"></span><br><span class=\"line\">What language <span class=\"keyword\">do</span> you want to use?? [ Swift / ObjC ]</span><br><span class=\"line\"> &gt; Swift</span><br><span class=\"line\"></span><br><span class=\"line\">Would you like to include a demo application with your library? [ Yes / No ]</span><br><span class=\"line\"> &gt; NO</span><br><span class=\"line\"></span><br><span class=\"line\">Which testing frameworks will you use? [ Quick / None ]</span><br><span class=\"line\"> &gt; None</span><br><span class=\"line\"></span><br><span class=\"line\">Would you like to <span class=\"keyword\">do</span> view based testing? [ Yes / No ]</span><br><span class=\"line\"> &gt; No</span><br></pre></td></tr></table></figure>\n<h2 id=\"配置文件\">配置文件</h2>\n<p>创建完成后会自动打开一个Xcode文件，这边我们打开<code>Podspec Metadata</code>文件下的<code>Project.podspec</code>配置文件：</p>\n<p><img src=\"/img/article/20191121/1.png\" alt=\"配置文件\"></p>\n<p>中间注意几个点：</p>\n<ol>\n<li><code>s.name</code>的名字必须和项目名相同，不可更改；</li>\n<li><code>s.version</code>是作为pod的版本号，后面项目上传Github时需对应打上相同的<code>tag</code>值；</li>\n<li><code>s.homepage</code>与<code>s.source</code>是项目的地址，按照对应的格式修改即可；</li>\n<li><code>s.framework</code>对应单数的系统库，<code>s.frameworks</code>对应复数的系统库；</li>\n<li><code>s.dependency</code>对应其他三方库，如果多个三方库只需要多行添加即可，无需逗号；</li>\n<li><code>s.subspec 'Core' do |ss|</code>可以将项目库文件划分子模块，注意每个模块后对应的<code>end</code>。</li>\n</ol>\n<p>配置文件结束后，将我们需要上传的类库复制到指定位置即可。</p>\n<h2 id=\"验证本地库\">验证本地库</h2>\n<p>在上传之前我们需要验证下本地库是否正确，使用<code>pod lib lint Project.podsepc --verbose --allow-warnings</code>进行验证。（<code>pod spec lint Project.podspec</code>是用于验证远程库）</p>\n<p>如果出现如下问题：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">The 'Pods-App' target has transitive dependencies that include static binaries: during validation.</span><br></pre></td></tr></table></figure>\n<p>这个错误是因为依赖库（s.dependency）包含了.a静态库造成的，虽然这不影响pod的使用，但是会使验证无法通过。可以用<code>--use-libraries</code>来让验证通过。</p>\n<p>如果库依赖私有库，则需要添加<code>--resources=xxx.git</code></p>\n<h2 id=\"上传远程仓库并tag\">上传远程仓库并Tag</h2>\n<p>验证成功后需要将代码上传到远程仓库，代码上传远程仓库之后需要打对应的版本号Tag。</p>\n<h2 id=\"私有库\">私有库</h2>\n<p>如果不想对外开放，可以使用<code>pod repo push 仓库地址 --allow-warnings</code>将podspec放到自己的项目网络地址上，比如公司的gitlab上，创建一个项目专门管理podspec。私有库是<code>pod search</code>搜索不到的。</p>\n<h2 id=\"公有库\">公有库</h2>\n<p>如果需要对外开放，需要创建cocoapods账号：<code>pod trunk register xxx@email.com userName --verbose</code></p>\n<p>这边它会发送一封邮件，点击验证即可。使用<code>pod trunk me</code>查看账号信息。</p>\n<p>然后就可以通过命令进行发布：<code>pod trunk push Project.podspec --verbose --use-libraries --allow-warnings</code></p>\n<p>发布成功之后进行<code>pod repo update</code>更新，同时还需要进行<code>rm ~/Library/Caches/CocoaPods/search_index.json</code>索引缓存删除，然后我们就可以通过<code>pod search</code>进行查找对应的库啦。</p>\n<h1 id=\"删pod库特定版本\">删pod库特定版本</h1>\n<p>可以删除一个pod的特定版本来纠正意外推送。</p>\n<p><code>pod trunk delete podName version</code></p>\n<p>你也可以放弃整个pod和所有版本。</p>\n<p><code>pod trunk deprecate podName</code></p>\n<h1 id=\"总结\">总结</h1>\n<p>通过上面步骤就可以简单的创建我们自己的远程类库，更加愉快的开发啦！</p>\n","site":{"data":{}},"excerpt":"","more":"<h1>前言</h1>\n<p>之前一直在用大神们的三方库，工作这么久也积累了一些自己的常用类库，考虑想要上传到自己的Cocoapods私有库，方便后期新项目的调用，下面来介绍上传方法。</p>\n<h1>方法</h1>\n<h2>首先创建pod模板</h2>\n<p>可以使用<code>pod lib create projectName</code>，如果有自己的模板，可以添加<code>--template-url=URL</code>来调用。</p>\n<p>创建过程会让你进行一些选项：</p>\n<figure class=\"highlight zsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">What platform <span class=\"keyword\">do</span> you want to use?? [ iOS / macOS ]</span><br><span class=\"line\"> &gt; iOS</span><br><span class=\"line\"></span><br><span class=\"line\">What language <span class=\"keyword\">do</span> you want to use?? [ Swift / ObjC ]</span><br><span class=\"line\"> &gt; Swift</span><br><span class=\"line\"></span><br><span class=\"line\">Would you like to include a demo application with your library? [ Yes / No ]</span><br><span class=\"line\"> &gt; NO</span><br><span class=\"line\"></span><br><span class=\"line\">Which testing frameworks will you use? [ Quick / None ]</span><br><span class=\"line\"> &gt; None</span><br><span class=\"line\"></span><br><span class=\"line\">Would you like to <span class=\"keyword\">do</span> view based testing? [ Yes / No ]</span><br><span class=\"line\"> &gt; No</span><br></pre></td></tr></table></figure>\n<h2>配置文件</h2>\n<p>创建完成后会自动打开一个Xcode文件，这边我们打开<code>Podspec Metadata</code>文件下的<code>Project.podspec</code>配置文件：</p>\n<p><img src=\"/img/article/20191121/1.png\" alt=\"配置文件\"></p>\n<p>中间注意几个点：</p>\n<ol>\n<li><code>s.name</code>的名字必须和项目名相同，不可更改；</li>\n<li><code>s.version</code>是作为pod的版本号，后面项目上传Github时需对应打上相同的<code>tag</code>值；</li>\n<li><code>s.homepage</code>与<code>s.source</code>是项目的地址，按照对应的格式修改即可；</li>\n<li><code>s.framework</code>对应单数的系统库，<code>s.frameworks</code>对应复数的系统库；</li>\n<li><code>s.dependency</code>对应其他三方库，如果多个三方库只需要多行添加即可，无需逗号；</li>\n<li><code>s.subspec 'Core' do |ss|</code>可以将项目库文件划分子模块，注意每个模块后对应的<code>end</code>。</li>\n</ol>\n<p>配置文件结束后，将我们需要上传的类库复制到指定位置即可。</p>\n<h2>验证本地库</h2>\n<p>在上传之前我们需要验证下本地库是否正确，使用<code>pod lib lint Project.podsepc --verbose --allow-warnings</code>进行验证。（<code>pod spec lint Project.podspec</code>是用于验证远程库）</p>\n<p>如果出现如下问题：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">The 'Pods-App' target has transitive dependencies that include static binaries: during validation.</span><br></pre></td></tr></table></figure>\n<p>这个错误是因为依赖库（s.dependency）包含了.a静态库造成的，虽然这不影响pod的使用，但是会使验证无法通过。可以用<code>--use-libraries</code>来让验证通过。</p>\n<p>如果库依赖私有库，则需要添加<code>--resources=xxx.git</code></p>\n<h2>上传远程仓库并Tag</h2>\n<p>验证成功后需要将代码上传到远程仓库，代码上传远程仓库之后需要打对应的版本号Tag。</p>\n<h2>私有库</h2>\n<p>如果不想对外开放，可以使用<code>pod repo push 仓库地址 --allow-warnings</code>将podspec放到自己的项目网络地址上，比如公司的gitlab上，创建一个项目专门管理podspec。私有库是<code>pod search</code>搜索不到的。</p>\n<h2>公有库</h2>\n<p>如果需要对外开放，需要创建cocoapods账号：<code>pod trunk register xxx@email.com userName --verbose</code></p>\n<p>这边它会发送一封邮件，点击验证即可。使用<code>pod trunk me</code>查看账号信息。</p>\n<p>然后就可以通过命令进行发布：<code>pod trunk push Project.podspec --verbose --use-libraries --allow-warnings</code></p>\n<p>发布成功之后进行<code>pod repo update</code>更新，同时还需要进行<code>rm ~/Library/Caches/CocoaPods/search_index.json</code>索引缓存删除，然后我们就可以通过<code>pod search</code>进行查找对应的库啦。</p>\n<h1>删pod库特定版本</h1>\n<p>可以删除一个pod的特定版本来纠正意外推送。</p>\n<p><code>pod trunk delete podName version</code></p>\n<p>你也可以放弃整个pod和所有版本。</p>\n<p><code>pod trunk deprecate podName</code></p>\n<h1>总结</h1>\n<p>通过上面步骤就可以简单的创建我们自己的远程类库，更加愉快的开发啦！</p>\n"},{"title":"绘图引擎 -- Quartz 2D","catalog":true,"toc_nav_num":true,"date":"2019-04-18T09:40:24.000Z","subtitle":"Quartz 2D Programming Guide","header-img":"/img/article_header/article_header.png","busuanzi":true,"_content":"\n> 最近在网上看文章的时候，看到了一篇[在 iOS 中使用 GLSL 实现抖音特效](http://www.lymanli.com/2019/04/05/ios-opengles-filter/)的文章，忽然兴趣就来了，然后就看到了一系列图片处理专用名词，这反而更加勾起了我的兴趣，主要是之前也看到一些关于 OpenGL 的字眼的文章，但是都没有花很多精力去研究，刚好眼下又看到了这篇文章，刚好这个博主也有对 OpenGL 的基础介绍，所以本是打算边看边学，把这个 OpenGL 搞懂。\n这个博主对于 OpenGL 的研究文章有3篇，本想着应该问题不大，在完成第一篇的简单使用并绘制图片，到第二篇的对图片进行伸缩，我才发现这里面涵盖的东西非常之广，并不是我想象中那么简单的一个框架，这里面已经涉及到了一个大的领域技术，但是这并没有把我劝退，反而我的内心浮现了一个想法。说实话，作为 iOS 开发者这么多年，我还没有一个可以作为自己专业技术领域的特长，在未来的互联网斗争中如何扩大自己的优势呢，我感觉这个图形处理领域可能会是我进军的领域了。\n所以，我打算从最简单的绘图开始 -- iOS 绘图框架 Core Graphics。\n\n# Introduction\n\nQuartz 2D是一个二维绘图引擎，可以在 iOS 环境和内核之外的所有 Mac OS X 应用程序环境下使用。我们可以使用 Quartz 2D API 来使用功能，比如基于路径的绘图，具有透明度的绘制，阴影，绘制阴影，透明层，颜色管理，抗锯齿渲染，PDF 文档生成，PDF 元数据访问等。在 iOS 中，Quartz 2D 可以使用所有可用的图形和动画技术，比如 Core Animation, OpenGL ES, UIKit 类等。（只讨论 iOS 范畴）\n\n# Concepts\n\n## 绘图点：The Graphics Context\n\n图形上下文是一种不透明的数据类型（CGContextRef），他封装了 Quartz 用于将图像绘制到输出设备（如 PDF 文件，位图，显示窗口）的信息。图像上下文中的信息包括图像绘制参数和页面上绘制的特定于设备的表示。Quartz 中所有的对象被绘制到或者包含在图像上下文中。\n图像上下文包含以下几种：\n\n1. A bitmap graphics context：位图图形上下文，允许在位图中绘制 RGB 颜色，CMYK 颜色，灰度模式。位图是像素的矩阵阵列（或光栅），每个像素表示图像中的一个点。位图图形也称为采样图像。\n\n2. A PDF graphics context：PDF 图形上下文，允许创建 PDF 文件。在 PDF 文件中，绘图被保存为一系列命令。PDF 文件与位图之前有以下区别：\n- PDF 文件不同于位图，可以包含超过一页内容\n- 当在不同的设备从 PDF 文件中绘制页面时，生成的图像将根据该设备的显示特性进行优化\n- PDF 文件本质上是独立于分辨率--在不牺牲图像细节的情况下，他们被绘制的大小可以无限增加或减小；位图图像的用户感知质量与位图的显示分辨率有关\n\n3. A window graphics context：可以在窗口绘图。（适用于 Mac OS X）\n\n4. A layer context：图层上下文，与另一个图形上下文关联的离屏绘图位置。当将层绘制到创建它的图形上下文时，它的设计是为了获得最佳性能。对于屏幕外绘制，图层上下文比位图图形上下文是更好的选择。\n\n## 图形状态：Graphics States\n\nQuartz 根据当前图形状态下的参数修改绘图结果。图形上下文包含一组图形状态，当 Quartz 创建上下文，状态是空的，只有当保存图形状态时，才会将图形状态保存到堆栈。当恢复图形状态时，会将当前图形状态从堆栈顶部弹出，弹出状态变为上次保存的状态。\n``` objectivec\nCGContextSaveGState();  // 存储状态\nCGContextRestoreGState();   // 恢复状态\n```\n\n## 坐标系：Quartz 2D Coordinate Systems\n\nQuartz 2D坐标系：\n![Quartz 2D坐标系](/img/article/20190418/1.png \"Quartz 2D坐标系\")\n\n由于不同设备具有不同的底层成像功能，所以必须以与设备无关的方式定义设备的位置和大小。Quartz 通过单独的坐标系统--用户空间--将其映射到输出设备--设备空间--使用当前变换矩阵（CTM）来实现设备的独立性。当前的变换矩阵是一种特殊类型的矩阵，成为仿射变换，他通过应用平移、旋转、缩放（移动、旋转、调整坐标系大小）等操作将点从一个坐标系空间映射到另一个坐标系空间。\n\n有些技术使用不同于 Quartz 使用的默认坐标系来设置他们的图形上下文，相对于 Quartz，这样的坐标系是经过修改的坐标系，在执行一些 Quartz 绘图操作时必须对其进行补偿。最常见的修改坐标系就是讲原点放在上下文的左上角，并将y轴指向页面底部。比如：\n- Mac OS X，继承 NSView 并重写 *isFlipped* 返回 YES\n- iOS，UIView 返回的绘图上下文\n- iOS，*UIGraphicsBeginImageContextWithOptions* 调用返回的绘图上下文\n\n因为 UIKit 本身使用了不同于 Quartz 的默认坐标系约定，所以修改了绘图上下文坐标系；它将转换应用于它创建的 Quartz 上下文以匹配他们的约定。这些变换会导致一系列问题，比如路径绘制过程中，圆弧在默认坐标系中是顺时针绘制，但如果修改了坐标系，则会变成逆时针绘制，就像镜像反射。\n\n# Paths\n\n路径定义了一个或多个形状或子路径。\n\n## 一些基本绘图操作\n``` objectivec\n/// 点 Points\nCGContextMoveToPoint(context, x, y);\n\n/// 线 Lines\nCGContextAddLineToPoint(context, x, y);\nCGContextAddLines(context, [points], count)\n\n/// 圆弧\nCGContextAddArc(context, x, y, radius, startAngle, endAngle, clockwise);\nCGContextAddArcToPoint(context, x1, y1, x2, y2, radius);    // 前两个点表示切点\n\n/// 曲线 Curves\nCGContextAddCurveToPoint(context, x1, y1, x2, y2, x, y);    // 前两个点控制切线方向，最后一个点是结点\nCGContextAddQuadCurveToPoint(context, x1, y1, x, y)         // 第一个点是切点，最后一个点是结点\n\n/// 结束一段子路径\nCGContextClosePath(context);\n\n/// 椭圆 Ellipses\nCGContextAddEllipseInRect(context, rect);\n\n/// 矩形 Rectangles\nCGContextAddRect(context, rect);\nCGContextAddRects(context, [rects], count);\n\n/// 开始绘制路径\nCGContextBeginPath(context);\n\n```\n\n## 创建路径\n```objectivec\n/// 获取路径对象\nCGMutablePathRef mutablePath = CGPathCreateMutable();\nCGPathRef path = CGContextCopyPath(context);\n\n/// 移动绘图起始点\nCGPathMoveToPoint(path, NULL, x, y);    // 第二个参数，可以修改坐标系（CGContextTranslateCTM, CGContextScaleCTM, or CGContextRotateCTM）\n\n/// 其余与上述类似 ...\n```\n\n## 闭合路径\n\n- 影响闭合路径的参数：\n``` objectivec\n/// 线条粗细\nCGContextSetLineWidth(context, width);\n\n/// 线条转折处样式\nCGContextSetLineJoin(context, join);        // kCGLineJoinMiter (the default), kCGLineJoinRound 圆角, or kCGLineJoinBevel 折角\n\n/// 线条转折样式为 Miter 时，\nCGContextSetMiterLimit(context, limit);     // 斜接的长度除以线的宽度，如果结果大于斜接极限，则样式转换为Bevel。\n\n/// 线条终起点样式\nCGContextSetLineCap(context, cap);          // kCGLineCapButt (the default), kCGLineCapRound 圆角, or kCGLineCapSquare 折角\n\n/// 线条 虚线样式\nCGContextSetLineDash(context, phase, [lengths], count);     // phase: 起点处，指定从虚线的哪个位置开始绘制\n\n/// 线条颜色\nCGContextSetStrokeColorWithColor(context, color);\n```\n\n- 闭合路径的几种方式：\n``` objectivec\n/// 闭合\nCGContextStrokePath(context);\n\n/// 矩形闭合\nCGContextStrokeRect(context, rect);\n\n/// 特定线粗细矩形闭合\nCGContextStrokeRectWithWidth(context, rect, width);      // width: 线粗细\n\n/// 椭圆闭合\nCGContextStrokeEllipseInRect(context, rect);\n\n/// 多条线闭合\nCGContextStrokeLineSegments(context, [points], count);      // points: 每两个点定义点一条线\n\n/// 闭合\nCGContextDrawPath(context, kCGPathFillStroke || kCGPathEOFillStroke);\n```\n\n## 填充路径\n\n填充路径的几种方式：\n```objectivec\n/// 填充 奇偶规则 even-odd rule\nCGContextEOFillPath(context);   // 射线穿过图形，穿过路径+1，奇数为路径内部，偶数为路径外部\n\n/// 填充 非零圈数规则 nonzero winding number rule\nCGContextFillPath(context);     // 射线穿过图形，路径从左到右穿过射线+1，从右到左-1，0位路径外部，非0为路径内部\n\n/// 矩形填充\nCGContextFillRect(context, rect);\n\n/// 椭圆填充\nCGContextFillEllipseInRect(context, rect);\n\n/// 填充\nCGContextDrawPath(context, kCGPathFill || kCGPathEOFill);\n```\n\n## 修剪路径\n\n``` objectivec\n/// 修剪 非零圈数规则 nonzero winding number rule\nCGContextClip(context);\n\n/// 修剪 奇偶规则 even-odd rule\nCGContextEOClip(context);\n\n/// 矩形修剪\nCGContextClipToRect(context, rect);\n\n/// 矩形修剪图形\nCGContextClipToMask(context, rect, mask);\n```\n\n# Transforms\n\n## 修改用户坐标系\n\n``` objectivec\n/// 平移\nCGContextTranslateCTM(context, x, y);\n    \n/// 旋转\nCGContextRotateCTM(context, angle);\n    \n/// 缩放\nCGContextScaleCTM(context, x, y);\n\n/// 根据特定矩阵转换用户坐标系\nCGContextConcatCTM(context, transform);\n```\n\n## 创建仿射变换\n\n``` objectivec\n/// 平移\nCGAffineTransformMakeTranslation(x, y);\n\n/// 以transform基础进行平移\nCGAffineTransformTranslate(transform, x, y);\n\n/// 旋转\nCGAffineTransformMakeRotation(angle);\n\n/// 以transform基础进行旋转\nCGAffineTransformRotate(transform, angle);\n\n/// 缩放\nCGAffineTransformMakeScale(x, y);\n\n/// 以transform基础进行缩放\nCGAffineTransformScale(transform, x, y);\n\n/// 对point进行矩阵变换\nCGPointApplyAffineTransform(point, transform);\n\n/// 对size进行矩阵变换\nCGSizeApplyAffineTransform(size, transform);\n\n/// 对rect进行矩阵变换\nCGRectApplyAffineTransform(rect, transform);\n```\n\n## 评估仿射变换\n\n``` objectivec\n/// 仿射变换是否相同\nCGAffineTransformEqualToTransform(transform1, transform2);\n\n/// 仿射变换是否为初始状态\nCGAffineTransformIsIdentity(transform);\n\n/// 初始状态\nCGAffineTransformIdentity;\n```\n\n## 用户空间与设备空间转换\n\n``` objectivec\n/// point转换\nCGContextConvertPointToDeviceSpace(context, point);\nCGContextConvertPointToUserSpace(context, point);\n\n/// size转换\nCGContextConvertSizeToDeviceSpace(context, size);\nCGContextConvertRectToUserSpace(context, size);\n\n/// rect转换\nCGContextConvertRectToDeviceSpace(context, rect);\nCGContextConvertRectToUserSpace(context, rect);\n```\n\n# Patterns\n\nPattern 是一组绘图操作序列，这些操作被反复操作到图形上下文中。可以像使用颜色一样使用 Pattern，Quartz 会把页面划分为一组 Pattern 单元格，每个单元格大小与 Pattern 图形相似，并使用提供的回调函数绘制每个单元格。\n![A Pattern drawn to a window](/img/article/20190418/2.png)\n\n## 编写一个回调函数来绘制一个着色图案单元格\n\n``` objectivec\n/**\n 绘制着色图案单元格的绘图回调\n\n @param info 指向与图案关联的私有数据的泛型指针\n @param myContext 绘图上下文\n */\nvoid MyDrawColoredPattern(void *info, CGContextRef myContext) {\n    CGFloat subunit = 5;\n    \n    CGRect myRect1 = {{0, 0}, {subunit, subunit}},\n    myRect2 = {{subunit, subunit}, {subunit, subunit}},\n    myRect3 = {{0, subunit}, {subunit, subunit}},\n    myRect4 = {{subunit, 0}, {subunit, subunit}};\n    \n    CGContextSetRGBFillColor(myContext, 0, 0, 1, .5);\n    CGContextFillRect(myContext, myRect1);\n    CGContextSetRGBFillColor(myContext, 1, 0, 0, .5);\n    CGContextFillRect(myContext, myRect2);\n    CGContextSetRGBFillColor(myContext, 0, 1, 0, .5);\n    CGContextFillRect(myContext, myRect3);\n    CGContextSetRGBFillColor(myContext, .5, 0, .5, .5);\n    CGContextFillRect(myContext, myRect4);\n}\n```\n\n## 设置着色图案颜色空间\n\n允许*MyDrawColoredPattern*代码中使用颜色绘制图案单元格的前提是，将基本图案颜色空间设置为NULL。\n\n``` objectivec\nCGColorSpaceRef patternSpace;\npatternSpace = CGColorSpaceCreatePattern(NULL);\nCGContextSetFillColorSpace(context, patternSpace);\nCGColorSpaceRelease(patternSpace);\n```\n\n## 建立着色图案剖析\n\n``` objectivec\n/**\n 创建图案\n\n @param NULL 传递到*MyDrawColoredPattern*绘图回调中的info\n @param patternRect 图案rect\n @param CGAffineTransformIdentity 图形变换\n @param 16 单元格之间的水平位移（可以理解为单元格宽）\n @param 18 单元格之间的竖直位移（可以理解为单元格高）\n @param kCGPatternTilingConstantSpacing 拼接方式\n @param YES 是否为着色模式（否则为模板模式，应该是印刷模式）\n @param callbacks 绘图回调函数\n @return 图案\n */\nCGPatternRef myPattern = CGPatternCreate(NULL, patternRect, CGAffineTransformIdentity, 16, 18, kCGPatternTilingConstantSpacing, YES, &callbacks);\n```\n\n## 将着色图案填充、描边\n\n``` objectivec\nCGFloat alpha = 1;\nCGContextSetFillPattern(context, myPattern, &alpha);\n```\n\n## 完整的彩绘封装\n\n``` objectivec\nvoid MyColorPatternPainting(CGContextRef myContext, CGRect rect) {\n    CGPatternRef pattern;\n    CGColorSpaceRef patternSpace;\n    CGFloat alpha = 1;\n    static const CGPatternCallbacks callbacks = {0, &MyDrawColoredPattern, NULL};\n    CGContextSaveGState(myContext);\n    patternSpace = CGColorSpaceCreatePattern(NULL);\n    CGContextSetFillColorSpace(myContext, patternSpace);\n    CGColorSpaceRelease(patternSpace);\n    \n    pattern = CGPatternCreate(NULL, CGRectMake(0, 0, 16, 18), CGAffineTransformMake(1, 0, 0, 1, 0, 0), 16, 18, kCGPatternTilingConstantSpacing, true, &callbacks);\n    \n    CGContextSetFillPattern(myContext, pattern, &alpha);\n    CGPatternRelease(pattern);\n    CGContextFillRect(myContext, rect);\n    CGContextRestoreGState(myContext);\n}\n\nvoid MyDrawColoredPattern(void *info, CGContextRef myContext) {\n    CGFloat subunit = 5;\n    \n    CGRect myRect1 = {{0, 0}, {subunit, subunit}},\n    myRect2 = {{subunit, subunit}, {subunit, subunit}},\n    myRect3 = {{0, subunit}, {subunit, subunit}},\n    myRect4 = {{subunit, 0}, {subunit, subunit}};\n    \n    CGContextSetRGBFillColor(myContext, 0, 0, 1, .5);\n    CGContextFillRect(myContext, myRect1);\n    CGContextSetRGBFillColor(myContext, 1, 0, 0, .5);\n    CGContextFillRect(myContext, myRect2);\n    CGContextSetRGBFillColor(myContext, 0, 1, 0, .5);\n    CGContextFillRect(myContext, myRect3);\n    CGContextSetRGBFillColor(myContext, .5, 0, .5, .5);\n    CGContextFillRect(myContext, myRect4);\n}\n```\n\n# Shadows\n\n## 阴影的使用\n\n``` objectivec\nCGContextSaveGState(context);\nCGContextSetShadow(context, offsetsize, blur);  // offset：偏移量（UIKit下：x向右为正，y向下为正），blur：阴影量，颜色默认为（0, 0, 0, 1.0/3.0）\nCGContextSetShadowWithColor(context, offsetsize, blur, color);\n/* 其他绘图操作 */\nCGContextRestoreGState(context);\n```\n\n# Gradients\n\nQuartz 提供两种数据类型创建渐变色 -- *CGShadingRef* 和 *CGGradientRef*。同时，这两种数据类型又可以分别创建轴向(axial)或者径向(radial)的渐变线。\n\nAn axial gradient(a linear gradient) -- 在定义的两个端点之间沿轴向变化，所有垂直于该轴向的直线上的点具有相同的色值。\nA radial gradient -- 在定义的两个端点（通常都是圆）之间沿轴向径向变化的填充，所有圆心落在轴线上圆的圆周上的点具有相同的色值，梯度的圆截面半径由两端半径确定，半径从一端到另一端呈线性变化。\n\n## CGShading 与 CGGradient 比较\n\nCGShadingRef -- 可以自己控制渐变中每个点颜色值的计算，非常细节。在创建CGShading对象之前，必须先创建CGFunction对象来定义梯度颜色计算的函数，自定义的函数可以更自由的创建更流畅的颜色梯度。\n\nCGRadientRef -- 是CGShadingRef的子类，使用更加方便。Quartz为我们计算渐变中每个点的颜色，不需要我们提供计算函数，只需要提供作用域和颜色值，Quartz会自动计算每个连续位置的颜色梯度。\n\n## CGGradient\n\n### 轴向渐变线\n\n``` objectivec\nCGGradientRef myGradient;\nCGColorSpaceRef myColorspace;\nsize_t num_locations = 2;\nCGFloat locations[2] = { 0.0, 1.0 };\nCGFloat components[8] = {\n    1.0, 0.5, 0.4, 1.0,  // Start color\n    0.8, 0.8, 0.3, 1.0   // End color\n};\nCGPoint myStartPoint, myEndPoint;\nmyColorspace = CGColorSpaceCreateWithName(kCGColorSpaceGenericRGB);\nmyGradient = CGGradientCreateWithColorComponents(myColorspace, components, locations, num_locations);\nCGContextDrawLinearGradient(context, myGradient, myStartPoint, myEndPoint, kCGGradientDrawsBeforeStartLocation | kCGGradientDrawsAfterEndLocation);\n```\n\n### 径向渐变线\n\n``` objectivec\nCGGradientRef myGradient;\nCGColorSpaceRef myColorspace;\nsize_t num_locations = 2;\nCGFloat locations[2] = { 0.0, 1.0 };\nCGFloat components[8] = {\n    1.0, 0.5, 0.4, 1.0,  // Start color\n    0.8, 0.8, 0.3, 1.0   // End color\n};\nCGFloat myStartRadius, myEndRadius;\nCGPoint myStartPoint, myEndPoint;\nmyColorspace = CGColorSpaceCreateWithName(kCGColorSpaceGenericRGB);\nmyGradient = CGGradientCreateWithColorComponents(myColorspace, components, locations, num_locations);\nCGContextDrawRadialGradient(context, myGradient, myStartPoint, myStartRadius, myEndPoint, myEndRadius, 0);\n```\n\n## CGShading\n\n暂不予考虑\n\n# Transparency Layers\n\n当多个对象组合成复合图形，如何将复合图形视为单一对象，形成如同单一对象般的应用效果，这就要用到透明层这个概念。\n\n![Transparency Layers](/img/article/20190418/3.png)\n\n``` objectivec\nCGContextSetShadow(context, CGSizeMake(10, 20), 10);\nCGContextBeginTransparencyLayer(context, NULL);\n// your drawing code\nCGContextEndTransparencyLayer(context);\n```\n\n# Ending\n\n当然，Quartz 2D的内容不止这么多，我现在整理的也只是一些简单易用的皮毛，针对于 iOS 应用的一些简易图形绘制应该是没有问题了，总的说来，学无止境，后面可能要继续对Core Image的学习。\n\n# Reference\n\n> [Quartz 2D Programming Guide](https://developer.apple.com/library/archive/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/dq_overview/dq_overview.html#//apple_ref/doc/uid/TP30001066-CH202-TPXREF101)","source":"_posts/2019/core-graphics-study-0418.md","raw":"---\ntitle: \"绘图引擎 -- Quartz 2D\"\ncatalog: true\ntoc_nav_num: true\ndate: 2019-04-18 17:40:24\nsubtitle: \"Quartz 2D Programming Guide\"\nheader-img: \"/img/article_header/article_header.png\"\nbusuanzi: true\ntags:\n- iOS\n\n---\n\n> 最近在网上看文章的时候，看到了一篇[在 iOS 中使用 GLSL 实现抖音特效](http://www.lymanli.com/2019/04/05/ios-opengles-filter/)的文章，忽然兴趣就来了，然后就看到了一系列图片处理专用名词，这反而更加勾起了我的兴趣，主要是之前也看到一些关于 OpenGL 的字眼的文章，但是都没有花很多精力去研究，刚好眼下又看到了这篇文章，刚好这个博主也有对 OpenGL 的基础介绍，所以本是打算边看边学，把这个 OpenGL 搞懂。\n这个博主对于 OpenGL 的研究文章有3篇，本想着应该问题不大，在完成第一篇的简单使用并绘制图片，到第二篇的对图片进行伸缩，我才发现这里面涵盖的东西非常之广，并不是我想象中那么简单的一个框架，这里面已经涉及到了一个大的领域技术，但是这并没有把我劝退，反而我的内心浮现了一个想法。说实话，作为 iOS 开发者这么多年，我还没有一个可以作为自己专业技术领域的特长，在未来的互联网斗争中如何扩大自己的优势呢，我感觉这个图形处理领域可能会是我进军的领域了。\n所以，我打算从最简单的绘图开始 -- iOS 绘图框架 Core Graphics。\n\n# Introduction\n\nQuartz 2D是一个二维绘图引擎，可以在 iOS 环境和内核之外的所有 Mac OS X 应用程序环境下使用。我们可以使用 Quartz 2D API 来使用功能，比如基于路径的绘图，具有透明度的绘制，阴影，绘制阴影，透明层，颜色管理，抗锯齿渲染，PDF 文档生成，PDF 元数据访问等。在 iOS 中，Quartz 2D 可以使用所有可用的图形和动画技术，比如 Core Animation, OpenGL ES, UIKit 类等。（只讨论 iOS 范畴）\n\n# Concepts\n\n## 绘图点：The Graphics Context\n\n图形上下文是一种不透明的数据类型（CGContextRef），他封装了 Quartz 用于将图像绘制到输出设备（如 PDF 文件，位图，显示窗口）的信息。图像上下文中的信息包括图像绘制参数和页面上绘制的特定于设备的表示。Quartz 中所有的对象被绘制到或者包含在图像上下文中。\n图像上下文包含以下几种：\n\n1. A bitmap graphics context：位图图形上下文，允许在位图中绘制 RGB 颜色，CMYK 颜色，灰度模式。位图是像素的矩阵阵列（或光栅），每个像素表示图像中的一个点。位图图形也称为采样图像。\n\n2. A PDF graphics context：PDF 图形上下文，允许创建 PDF 文件。在 PDF 文件中，绘图被保存为一系列命令。PDF 文件与位图之前有以下区别：\n- PDF 文件不同于位图，可以包含超过一页内容\n- 当在不同的设备从 PDF 文件中绘制页面时，生成的图像将根据该设备的显示特性进行优化\n- PDF 文件本质上是独立于分辨率--在不牺牲图像细节的情况下，他们被绘制的大小可以无限增加或减小；位图图像的用户感知质量与位图的显示分辨率有关\n\n3. A window graphics context：可以在窗口绘图。（适用于 Mac OS X）\n\n4. A layer context：图层上下文，与另一个图形上下文关联的离屏绘图位置。当将层绘制到创建它的图形上下文时，它的设计是为了获得最佳性能。对于屏幕外绘制，图层上下文比位图图形上下文是更好的选择。\n\n## 图形状态：Graphics States\n\nQuartz 根据当前图形状态下的参数修改绘图结果。图形上下文包含一组图形状态，当 Quartz 创建上下文，状态是空的，只有当保存图形状态时，才会将图形状态保存到堆栈。当恢复图形状态时，会将当前图形状态从堆栈顶部弹出，弹出状态变为上次保存的状态。\n``` objectivec\nCGContextSaveGState();  // 存储状态\nCGContextRestoreGState();   // 恢复状态\n```\n\n## 坐标系：Quartz 2D Coordinate Systems\n\nQuartz 2D坐标系：\n![Quartz 2D坐标系](/img/article/20190418/1.png \"Quartz 2D坐标系\")\n\n由于不同设备具有不同的底层成像功能，所以必须以与设备无关的方式定义设备的位置和大小。Quartz 通过单独的坐标系统--用户空间--将其映射到输出设备--设备空间--使用当前变换矩阵（CTM）来实现设备的独立性。当前的变换矩阵是一种特殊类型的矩阵，成为仿射变换，他通过应用平移、旋转、缩放（移动、旋转、调整坐标系大小）等操作将点从一个坐标系空间映射到另一个坐标系空间。\n\n有些技术使用不同于 Quartz 使用的默认坐标系来设置他们的图形上下文，相对于 Quartz，这样的坐标系是经过修改的坐标系，在执行一些 Quartz 绘图操作时必须对其进行补偿。最常见的修改坐标系就是讲原点放在上下文的左上角，并将y轴指向页面底部。比如：\n- Mac OS X，继承 NSView 并重写 *isFlipped* 返回 YES\n- iOS，UIView 返回的绘图上下文\n- iOS，*UIGraphicsBeginImageContextWithOptions* 调用返回的绘图上下文\n\n因为 UIKit 本身使用了不同于 Quartz 的默认坐标系约定，所以修改了绘图上下文坐标系；它将转换应用于它创建的 Quartz 上下文以匹配他们的约定。这些变换会导致一系列问题，比如路径绘制过程中，圆弧在默认坐标系中是顺时针绘制，但如果修改了坐标系，则会变成逆时针绘制，就像镜像反射。\n\n# Paths\n\n路径定义了一个或多个形状或子路径。\n\n## 一些基本绘图操作\n``` objectivec\n/// 点 Points\nCGContextMoveToPoint(context, x, y);\n\n/// 线 Lines\nCGContextAddLineToPoint(context, x, y);\nCGContextAddLines(context, [points], count)\n\n/// 圆弧\nCGContextAddArc(context, x, y, radius, startAngle, endAngle, clockwise);\nCGContextAddArcToPoint(context, x1, y1, x2, y2, radius);    // 前两个点表示切点\n\n/// 曲线 Curves\nCGContextAddCurveToPoint(context, x1, y1, x2, y2, x, y);    // 前两个点控制切线方向，最后一个点是结点\nCGContextAddQuadCurveToPoint(context, x1, y1, x, y)         // 第一个点是切点，最后一个点是结点\n\n/// 结束一段子路径\nCGContextClosePath(context);\n\n/// 椭圆 Ellipses\nCGContextAddEllipseInRect(context, rect);\n\n/// 矩形 Rectangles\nCGContextAddRect(context, rect);\nCGContextAddRects(context, [rects], count);\n\n/// 开始绘制路径\nCGContextBeginPath(context);\n\n```\n\n## 创建路径\n```objectivec\n/// 获取路径对象\nCGMutablePathRef mutablePath = CGPathCreateMutable();\nCGPathRef path = CGContextCopyPath(context);\n\n/// 移动绘图起始点\nCGPathMoveToPoint(path, NULL, x, y);    // 第二个参数，可以修改坐标系（CGContextTranslateCTM, CGContextScaleCTM, or CGContextRotateCTM）\n\n/// 其余与上述类似 ...\n```\n\n## 闭合路径\n\n- 影响闭合路径的参数：\n``` objectivec\n/// 线条粗细\nCGContextSetLineWidth(context, width);\n\n/// 线条转折处样式\nCGContextSetLineJoin(context, join);        // kCGLineJoinMiter (the default), kCGLineJoinRound 圆角, or kCGLineJoinBevel 折角\n\n/// 线条转折样式为 Miter 时，\nCGContextSetMiterLimit(context, limit);     // 斜接的长度除以线的宽度，如果结果大于斜接极限，则样式转换为Bevel。\n\n/// 线条终起点样式\nCGContextSetLineCap(context, cap);          // kCGLineCapButt (the default), kCGLineCapRound 圆角, or kCGLineCapSquare 折角\n\n/// 线条 虚线样式\nCGContextSetLineDash(context, phase, [lengths], count);     // phase: 起点处，指定从虚线的哪个位置开始绘制\n\n/// 线条颜色\nCGContextSetStrokeColorWithColor(context, color);\n```\n\n- 闭合路径的几种方式：\n``` objectivec\n/// 闭合\nCGContextStrokePath(context);\n\n/// 矩形闭合\nCGContextStrokeRect(context, rect);\n\n/// 特定线粗细矩形闭合\nCGContextStrokeRectWithWidth(context, rect, width);      // width: 线粗细\n\n/// 椭圆闭合\nCGContextStrokeEllipseInRect(context, rect);\n\n/// 多条线闭合\nCGContextStrokeLineSegments(context, [points], count);      // points: 每两个点定义点一条线\n\n/// 闭合\nCGContextDrawPath(context, kCGPathFillStroke || kCGPathEOFillStroke);\n```\n\n## 填充路径\n\n填充路径的几种方式：\n```objectivec\n/// 填充 奇偶规则 even-odd rule\nCGContextEOFillPath(context);   // 射线穿过图形，穿过路径+1，奇数为路径内部，偶数为路径外部\n\n/// 填充 非零圈数规则 nonzero winding number rule\nCGContextFillPath(context);     // 射线穿过图形，路径从左到右穿过射线+1，从右到左-1，0位路径外部，非0为路径内部\n\n/// 矩形填充\nCGContextFillRect(context, rect);\n\n/// 椭圆填充\nCGContextFillEllipseInRect(context, rect);\n\n/// 填充\nCGContextDrawPath(context, kCGPathFill || kCGPathEOFill);\n```\n\n## 修剪路径\n\n``` objectivec\n/// 修剪 非零圈数规则 nonzero winding number rule\nCGContextClip(context);\n\n/// 修剪 奇偶规则 even-odd rule\nCGContextEOClip(context);\n\n/// 矩形修剪\nCGContextClipToRect(context, rect);\n\n/// 矩形修剪图形\nCGContextClipToMask(context, rect, mask);\n```\n\n# Transforms\n\n## 修改用户坐标系\n\n``` objectivec\n/// 平移\nCGContextTranslateCTM(context, x, y);\n    \n/// 旋转\nCGContextRotateCTM(context, angle);\n    \n/// 缩放\nCGContextScaleCTM(context, x, y);\n\n/// 根据特定矩阵转换用户坐标系\nCGContextConcatCTM(context, transform);\n```\n\n## 创建仿射变换\n\n``` objectivec\n/// 平移\nCGAffineTransformMakeTranslation(x, y);\n\n/// 以transform基础进行平移\nCGAffineTransformTranslate(transform, x, y);\n\n/// 旋转\nCGAffineTransformMakeRotation(angle);\n\n/// 以transform基础进行旋转\nCGAffineTransformRotate(transform, angle);\n\n/// 缩放\nCGAffineTransformMakeScale(x, y);\n\n/// 以transform基础进行缩放\nCGAffineTransformScale(transform, x, y);\n\n/// 对point进行矩阵变换\nCGPointApplyAffineTransform(point, transform);\n\n/// 对size进行矩阵变换\nCGSizeApplyAffineTransform(size, transform);\n\n/// 对rect进行矩阵变换\nCGRectApplyAffineTransform(rect, transform);\n```\n\n## 评估仿射变换\n\n``` objectivec\n/// 仿射变换是否相同\nCGAffineTransformEqualToTransform(transform1, transform2);\n\n/// 仿射变换是否为初始状态\nCGAffineTransformIsIdentity(transform);\n\n/// 初始状态\nCGAffineTransformIdentity;\n```\n\n## 用户空间与设备空间转换\n\n``` objectivec\n/// point转换\nCGContextConvertPointToDeviceSpace(context, point);\nCGContextConvertPointToUserSpace(context, point);\n\n/// size转换\nCGContextConvertSizeToDeviceSpace(context, size);\nCGContextConvertRectToUserSpace(context, size);\n\n/// rect转换\nCGContextConvertRectToDeviceSpace(context, rect);\nCGContextConvertRectToUserSpace(context, rect);\n```\n\n# Patterns\n\nPattern 是一组绘图操作序列，这些操作被反复操作到图形上下文中。可以像使用颜色一样使用 Pattern，Quartz 会把页面划分为一组 Pattern 单元格，每个单元格大小与 Pattern 图形相似，并使用提供的回调函数绘制每个单元格。\n![A Pattern drawn to a window](/img/article/20190418/2.png)\n\n## 编写一个回调函数来绘制一个着色图案单元格\n\n``` objectivec\n/**\n 绘制着色图案单元格的绘图回调\n\n @param info 指向与图案关联的私有数据的泛型指针\n @param myContext 绘图上下文\n */\nvoid MyDrawColoredPattern(void *info, CGContextRef myContext) {\n    CGFloat subunit = 5;\n    \n    CGRect myRect1 = {{0, 0}, {subunit, subunit}},\n    myRect2 = {{subunit, subunit}, {subunit, subunit}},\n    myRect3 = {{0, subunit}, {subunit, subunit}},\n    myRect4 = {{subunit, 0}, {subunit, subunit}};\n    \n    CGContextSetRGBFillColor(myContext, 0, 0, 1, .5);\n    CGContextFillRect(myContext, myRect1);\n    CGContextSetRGBFillColor(myContext, 1, 0, 0, .5);\n    CGContextFillRect(myContext, myRect2);\n    CGContextSetRGBFillColor(myContext, 0, 1, 0, .5);\n    CGContextFillRect(myContext, myRect3);\n    CGContextSetRGBFillColor(myContext, .5, 0, .5, .5);\n    CGContextFillRect(myContext, myRect4);\n}\n```\n\n## 设置着色图案颜色空间\n\n允许*MyDrawColoredPattern*代码中使用颜色绘制图案单元格的前提是，将基本图案颜色空间设置为NULL。\n\n``` objectivec\nCGColorSpaceRef patternSpace;\npatternSpace = CGColorSpaceCreatePattern(NULL);\nCGContextSetFillColorSpace(context, patternSpace);\nCGColorSpaceRelease(patternSpace);\n```\n\n## 建立着色图案剖析\n\n``` objectivec\n/**\n 创建图案\n\n @param NULL 传递到*MyDrawColoredPattern*绘图回调中的info\n @param patternRect 图案rect\n @param CGAffineTransformIdentity 图形变换\n @param 16 单元格之间的水平位移（可以理解为单元格宽）\n @param 18 单元格之间的竖直位移（可以理解为单元格高）\n @param kCGPatternTilingConstantSpacing 拼接方式\n @param YES 是否为着色模式（否则为模板模式，应该是印刷模式）\n @param callbacks 绘图回调函数\n @return 图案\n */\nCGPatternRef myPattern = CGPatternCreate(NULL, patternRect, CGAffineTransformIdentity, 16, 18, kCGPatternTilingConstantSpacing, YES, &callbacks);\n```\n\n## 将着色图案填充、描边\n\n``` objectivec\nCGFloat alpha = 1;\nCGContextSetFillPattern(context, myPattern, &alpha);\n```\n\n## 完整的彩绘封装\n\n``` objectivec\nvoid MyColorPatternPainting(CGContextRef myContext, CGRect rect) {\n    CGPatternRef pattern;\n    CGColorSpaceRef patternSpace;\n    CGFloat alpha = 1;\n    static const CGPatternCallbacks callbacks = {0, &MyDrawColoredPattern, NULL};\n    CGContextSaveGState(myContext);\n    patternSpace = CGColorSpaceCreatePattern(NULL);\n    CGContextSetFillColorSpace(myContext, patternSpace);\n    CGColorSpaceRelease(patternSpace);\n    \n    pattern = CGPatternCreate(NULL, CGRectMake(0, 0, 16, 18), CGAffineTransformMake(1, 0, 0, 1, 0, 0), 16, 18, kCGPatternTilingConstantSpacing, true, &callbacks);\n    \n    CGContextSetFillPattern(myContext, pattern, &alpha);\n    CGPatternRelease(pattern);\n    CGContextFillRect(myContext, rect);\n    CGContextRestoreGState(myContext);\n}\n\nvoid MyDrawColoredPattern(void *info, CGContextRef myContext) {\n    CGFloat subunit = 5;\n    \n    CGRect myRect1 = {{0, 0}, {subunit, subunit}},\n    myRect2 = {{subunit, subunit}, {subunit, subunit}},\n    myRect3 = {{0, subunit}, {subunit, subunit}},\n    myRect4 = {{subunit, 0}, {subunit, subunit}};\n    \n    CGContextSetRGBFillColor(myContext, 0, 0, 1, .5);\n    CGContextFillRect(myContext, myRect1);\n    CGContextSetRGBFillColor(myContext, 1, 0, 0, .5);\n    CGContextFillRect(myContext, myRect2);\n    CGContextSetRGBFillColor(myContext, 0, 1, 0, .5);\n    CGContextFillRect(myContext, myRect3);\n    CGContextSetRGBFillColor(myContext, .5, 0, .5, .5);\n    CGContextFillRect(myContext, myRect4);\n}\n```\n\n# Shadows\n\n## 阴影的使用\n\n``` objectivec\nCGContextSaveGState(context);\nCGContextSetShadow(context, offsetsize, blur);  // offset：偏移量（UIKit下：x向右为正，y向下为正），blur：阴影量，颜色默认为（0, 0, 0, 1.0/3.0）\nCGContextSetShadowWithColor(context, offsetsize, blur, color);\n/* 其他绘图操作 */\nCGContextRestoreGState(context);\n```\n\n# Gradients\n\nQuartz 提供两种数据类型创建渐变色 -- *CGShadingRef* 和 *CGGradientRef*。同时，这两种数据类型又可以分别创建轴向(axial)或者径向(radial)的渐变线。\n\nAn axial gradient(a linear gradient) -- 在定义的两个端点之间沿轴向变化，所有垂直于该轴向的直线上的点具有相同的色值。\nA radial gradient -- 在定义的两个端点（通常都是圆）之间沿轴向径向变化的填充，所有圆心落在轴线上圆的圆周上的点具有相同的色值，梯度的圆截面半径由两端半径确定，半径从一端到另一端呈线性变化。\n\n## CGShading 与 CGGradient 比较\n\nCGShadingRef -- 可以自己控制渐变中每个点颜色值的计算，非常细节。在创建CGShading对象之前，必须先创建CGFunction对象来定义梯度颜色计算的函数，自定义的函数可以更自由的创建更流畅的颜色梯度。\n\nCGRadientRef -- 是CGShadingRef的子类，使用更加方便。Quartz为我们计算渐变中每个点的颜色，不需要我们提供计算函数，只需要提供作用域和颜色值，Quartz会自动计算每个连续位置的颜色梯度。\n\n## CGGradient\n\n### 轴向渐变线\n\n``` objectivec\nCGGradientRef myGradient;\nCGColorSpaceRef myColorspace;\nsize_t num_locations = 2;\nCGFloat locations[2] = { 0.0, 1.0 };\nCGFloat components[8] = {\n    1.0, 0.5, 0.4, 1.0,  // Start color\n    0.8, 0.8, 0.3, 1.0   // End color\n};\nCGPoint myStartPoint, myEndPoint;\nmyColorspace = CGColorSpaceCreateWithName(kCGColorSpaceGenericRGB);\nmyGradient = CGGradientCreateWithColorComponents(myColorspace, components, locations, num_locations);\nCGContextDrawLinearGradient(context, myGradient, myStartPoint, myEndPoint, kCGGradientDrawsBeforeStartLocation | kCGGradientDrawsAfterEndLocation);\n```\n\n### 径向渐变线\n\n``` objectivec\nCGGradientRef myGradient;\nCGColorSpaceRef myColorspace;\nsize_t num_locations = 2;\nCGFloat locations[2] = { 0.0, 1.0 };\nCGFloat components[8] = {\n    1.0, 0.5, 0.4, 1.0,  // Start color\n    0.8, 0.8, 0.3, 1.0   // End color\n};\nCGFloat myStartRadius, myEndRadius;\nCGPoint myStartPoint, myEndPoint;\nmyColorspace = CGColorSpaceCreateWithName(kCGColorSpaceGenericRGB);\nmyGradient = CGGradientCreateWithColorComponents(myColorspace, components, locations, num_locations);\nCGContextDrawRadialGradient(context, myGradient, myStartPoint, myStartRadius, myEndPoint, myEndRadius, 0);\n```\n\n## CGShading\n\n暂不予考虑\n\n# Transparency Layers\n\n当多个对象组合成复合图形，如何将复合图形视为单一对象，形成如同单一对象般的应用效果，这就要用到透明层这个概念。\n\n![Transparency Layers](/img/article/20190418/3.png)\n\n``` objectivec\nCGContextSetShadow(context, CGSizeMake(10, 20), 10);\nCGContextBeginTransparencyLayer(context, NULL);\n// your drawing code\nCGContextEndTransparencyLayer(context);\n```\n\n# Ending\n\n当然，Quartz 2D的内容不止这么多，我现在整理的也只是一些简单易用的皮毛，针对于 iOS 应用的一些简易图形绘制应该是没有问题了，总的说来，学无止境，后面可能要继续对Core Image的学习。\n\n# Reference\n\n> [Quartz 2D Programming Guide](https://developer.apple.com/library/archive/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/dq_overview/dq_overview.html#//apple_ref/doc/uid/TP30001066-CH202-TPXREF101)","slug":"2019/core-graphics-study-0418","published":1,"updated":"2022-01-10T09:04:52.803Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cky8gmc3y0008d1qh9a9bgfjr","content":"<blockquote>\n<p>最近在网上看文章的时候，看到了一篇<a href=\"http://www.lymanli.com/2019/04/05/ios-opengles-filter/\" target=\"_blank\" rel=\"noopener\">在 iOS 中使用 GLSL 实现抖音特效</a>的文章，忽然兴趣就来了，然后就看到了一系列图片处理专用名词，这反而更加勾起了我的兴趣，主要是之前也看到一些关于 OpenGL 的字眼的文章，但是都没有花很多精力去研究，刚好眼下又看到了这篇文章，刚好这个博主也有对 OpenGL 的基础介绍，所以本是打算边看边学，把这个 OpenGL 搞懂。<br>\n这个博主对于 OpenGL 的研究文章有3篇，本想着应该问题不大，在完成第一篇的简单使用并绘制图片，到第二篇的对图片进行伸缩，我才发现这里面涵盖的东西非常之广，并不是我想象中那么简单的一个框架，这里面已经涉及到了一个大的领域技术，但是这并没有把我劝退，反而我的内心浮现了一个想法。说实话，作为 iOS 开发者这么多年，我还没有一个可以作为自己专业技术领域的特长，在未来的互联网斗争中如何扩大自己的优势呢，我感觉这个图形处理领域可能会是我进军的领域了。<br>\n所以，我打算从最简单的绘图开始 – iOS 绘图框架 Core Graphics。</p>\n</blockquote>\n<h1 id=\"introduction\">Introduction</h1>\n<p>Quartz 2D是一个二维绘图引擎，可以在 iOS 环境和内核之外的所有 Mac OS X 应用程序环境下使用。我们可以使用 Quartz 2D API 来使用功能，比如基于路径的绘图，具有透明度的绘制，阴影，绘制阴影，透明层，颜色管理，抗锯齿渲染，PDF 文档生成，PDF 元数据访问等。在 iOS 中，Quartz 2D 可以使用所有可用的图形和动画技术，比如 Core Animation, OpenGL ES, UIKit 类等。（只讨论 iOS 范畴）</p>\n<h1 id=\"concepts\">Concepts</h1>\n<h2 id=\"绘图点the-graphics-context\">绘图点：The Graphics Context</h2>\n<p>图形上下文是一种不透明的数据类型（CGContextRef），他封装了 Quartz 用于将图像绘制到输出设备（如 PDF 文件，位图，显示窗口）的信息。图像上下文中的信息包括图像绘制参数和页面上绘制的特定于设备的表示。Quartz 中所有的对象被绘制到或者包含在图像上下文中。<br>\n图像上下文包含以下几种：</p>\n<ol>\n<li>\n<p>A bitmap graphics context：位图图形上下文，允许在位图中绘制 RGB 颜色，CMYK 颜色，灰度模式。位图是像素的矩阵阵列（或光栅），每个像素表示图像中的一个点。位图图形也称为采样图像。</p>\n</li>\n<li>\n<p>A PDF graphics context：PDF 图形上下文，允许创建 PDF 文件。在 PDF 文件中，绘图被保存为一系列命令。PDF 文件与位图之前有以下区别：</p>\n</li>\n</ol>\n<ul>\n<li>PDF 文件不同于位图，可以包含超过一页内容</li>\n<li>当在不同的设备从 PDF 文件中绘制页面时，生成的图像将根据该设备的显示特性进行优化</li>\n<li>PDF 文件本质上是独立于分辨率–在不牺牲图像细节的情况下，他们被绘制的大小可以无限增加或减小；位图图像的用户感知质量与位图的显示分辨率有关</li>\n</ul>\n<ol start=\"3\">\n<li>\n<p>A window graphics context：可以在窗口绘图。（适用于 Mac OS X）</p>\n</li>\n<li>\n<p>A layer context：图层上下文，与另一个图形上下文关联的离屏绘图位置。当将层绘制到创建它的图形上下文时，它的设计是为了获得最佳性能。对于屏幕外绘制，图层上下文比位图图形上下文是更好的选择。</p>\n</li>\n</ol>\n<h2 id=\"图形状态graphics-states\">图形状态：Graphics States</h2>\n<p>Quartz 根据当前图形状态下的参数修改绘图结果。图形上下文包含一组图形状态，当 Quartz 创建上下文，状态是空的，只有当保存图形状态时，才会将图形状态保存到堆栈。当恢复图形状态时，会将当前图形状态从堆栈顶部弹出，弹出状态变为上次保存的状态。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">CGContextSaveGState</span>();  <span class=\"comment\">// 存储状态</span></span><br><span class=\"line\"><span class=\"built_in\">CGContextRestoreGState</span>();   <span class=\"comment\">// 恢复状态</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"坐标系quartz-2d-coordinate-systems\">坐标系：Quartz 2D Coordinate Systems</h2>\n<p>Quartz 2D坐标系：<br>\n<img src=\"/img/article/20190418/1.png\" alt=\"Quartz 2D坐标系\" title=\"Quartz 2D坐标系\"></p>\n<p>由于不同设备具有不同的底层成像功能，所以必须以与设备无关的方式定义设备的位置和大小。Quartz 通过单独的坐标系统–用户空间–将其映射到输出设备–设备空间–使用当前变换矩阵（CTM）来实现设备的独立性。当前的变换矩阵是一种特殊类型的矩阵，成为仿射变换，他通过应用平移、旋转、缩放（移动、旋转、调整坐标系大小）等操作将点从一个坐标系空间映射到另一个坐标系空间。</p>\n<p>有些技术使用不同于 Quartz 使用的默认坐标系来设置他们的图形上下文，相对于 Quartz，这样的坐标系是经过修改的坐标系，在执行一些 Quartz 绘图操作时必须对其进行补偿。最常见的修改坐标系就是讲原点放在上下文的左上角，并将y轴指向页面底部。比如：</p>\n<ul>\n<li>Mac OS X，继承 NSView 并重写 <em>isFlipped</em> 返回 YES</li>\n<li>iOS，UIView 返回的绘图上下文</li>\n<li>iOS，<em>UIGraphicsBeginImageContextWithOptions</em> 调用返回的绘图上下文</li>\n</ul>\n<p>因为 UIKit 本身使用了不同于 Quartz 的默认坐标系约定，所以修改了绘图上下文坐标系；它将转换应用于它创建的 Quartz 上下文以匹配他们的约定。这些变换会导致一系列问题，比如路径绘制过程中，圆弧在默认坐标系中是顺时针绘制，但如果修改了坐标系，则会变成逆时针绘制，就像镜像反射。</p>\n<h1 id=\"paths\">Paths</h1>\n<p>路径定义了一个或多个形状或子路径。</p>\n<h2 id=\"一些基本绘图操作\">一些基本绘图操作</h2>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// 点 Points</span></span><br><span class=\"line\"><span class=\"built_in\">CGContextMoveToPoint</span>(context, x, y);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 线 Lines</span></span><br><span class=\"line\"><span class=\"built_in\">CGContextAddLineToPoint</span>(context, x, y);</span><br><span class=\"line\"><span class=\"built_in\">CGContextAddLines</span>(context, [points], count)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 圆弧</span></span><br><span class=\"line\"><span class=\"built_in\">CGContextAddArc</span>(context, x, y, radius, startAngle, endAngle, clockwise);</span><br><span class=\"line\"><span class=\"built_in\">CGContextAddArcToPoint</span>(context, x1, y1, x2, y2, radius);    <span class=\"comment\">// 前两个点表示切点</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 曲线 Curves</span></span><br><span class=\"line\"><span class=\"built_in\">CGContextAddCurveToPoint</span>(context, x1, y1, x2, y2, x, y);    <span class=\"comment\">// 前两个点控制切线方向，最后一个点是结点</span></span><br><span class=\"line\"><span class=\"built_in\">CGContextAddQuadCurveToPoint</span>(context, x1, y1, x, y)         <span class=\"comment\">// 第一个点是切点，最后一个点是结点</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 结束一段子路径</span></span><br><span class=\"line\"><span class=\"built_in\">CGContextClosePath</span>(context);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 椭圆 Ellipses</span></span><br><span class=\"line\"><span class=\"built_in\">CGContextAddEllipseInRect</span>(context, rect);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 矩形 Rectangles</span></span><br><span class=\"line\"><span class=\"built_in\">CGContextAddRect</span>(context, rect);</span><br><span class=\"line\"><span class=\"built_in\">CGContextAddRects</span>(context, [rects], count);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 开始绘制路径</span></span><br><span class=\"line\"><span class=\"built_in\">CGContextBeginPath</span>(context);</span><br></pre></td></tr></table></figure>\n<h2 id=\"创建路径\">创建路径</h2>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// 获取路径对象</span></span><br><span class=\"line\"><span class=\"built_in\">CGMutablePathRef</span> mutablePath = <span class=\"built_in\">CGPathCreateMutable</span>();</span><br><span class=\"line\"><span class=\"built_in\">CGPathRef</span> path = <span class=\"built_in\">CGContextCopyPath</span>(context);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 移动绘图起始点</span></span><br><span class=\"line\"><span class=\"built_in\">CGPathMoveToPoint</span>(path, <span class=\"literal\">NULL</span>, x, y);    <span class=\"comment\">// 第二个参数，可以修改坐标系（CGContextTranslateCTM, CGContextScaleCTM, or CGContextRotateCTM）</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 其余与上述类似 ...</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"闭合路径\">闭合路径</h2>\n<ul>\n<li>影响闭合路径的参数：</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// 线条粗细</span></span><br><span class=\"line\"><span class=\"built_in\">CGContextSetLineWidth</span>(context, width);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 线条转折处样式</span></span><br><span class=\"line\"><span class=\"built_in\">CGContextSetLineJoin</span>(context, join);        <span class=\"comment\">// kCGLineJoinMiter (the default), kCGLineJoinRound 圆角, or kCGLineJoinBevel 折角</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 线条转折样式为 Miter 时，</span></span><br><span class=\"line\"><span class=\"built_in\">CGContextSetMiterLimit</span>(context, limit);     <span class=\"comment\">// 斜接的长度除以线的宽度，如果结果大于斜接极限，则样式转换为Bevel。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 线条终起点样式</span></span><br><span class=\"line\"><span class=\"built_in\">CGContextSetLineCap</span>(context, cap);          <span class=\"comment\">// kCGLineCapButt (the default), kCGLineCapRound 圆角, or kCGLineCapSquare 折角</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 线条 虚线样式</span></span><br><span class=\"line\"><span class=\"built_in\">CGContextSetLineDash</span>(context, phase, [lengths], count);     <span class=\"comment\">// phase: 起点处，指定从虚线的哪个位置开始绘制</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 线条颜色</span></span><br><span class=\"line\"><span class=\"built_in\">CGContextSetStrokeColorWithColor</span>(context, color);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>闭合路径的几种方式：</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// 闭合</span></span><br><span class=\"line\"><span class=\"built_in\">CGContextStrokePath</span>(context);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 矩形闭合</span></span><br><span class=\"line\"><span class=\"built_in\">CGContextStrokeRect</span>(context, rect);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 特定线粗细矩形闭合</span></span><br><span class=\"line\"><span class=\"built_in\">CGContextStrokeRectWithWidth</span>(context, rect, width);      <span class=\"comment\">// width: 线粗细</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 椭圆闭合</span></span><br><span class=\"line\"><span class=\"built_in\">CGContextStrokeEllipseInRect</span>(context, rect);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 多条线闭合</span></span><br><span class=\"line\"><span class=\"built_in\">CGContextStrokeLineSegments</span>(context, [points], count);      <span class=\"comment\">// points: 每两个点定义点一条线</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 闭合</span></span><br><span class=\"line\"><span class=\"built_in\">CGContextDrawPath</span>(context, kCGPathFillStroke || kCGPathEOFillStroke);</span><br></pre></td></tr></table></figure>\n<h2 id=\"填充路径\">填充路径</h2>\n<p>填充路径的几种方式：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// 填充 奇偶规则 even-odd rule</span></span><br><span class=\"line\"><span class=\"built_in\">CGContextEOFillPath</span>(context);   <span class=\"comment\">// 射线穿过图形，穿过路径+1，奇数为路径内部，偶数为路径外部</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 填充 非零圈数规则 nonzero winding number rule</span></span><br><span class=\"line\"><span class=\"built_in\">CGContextFillPath</span>(context);     <span class=\"comment\">// 射线穿过图形，路径从左到右穿过射线+1，从右到左-1，0位路径外部，非0为路径内部</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 矩形填充</span></span><br><span class=\"line\"><span class=\"built_in\">CGContextFillRect</span>(context, rect);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 椭圆填充</span></span><br><span class=\"line\"><span class=\"built_in\">CGContextFillEllipseInRect</span>(context, rect);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 填充</span></span><br><span class=\"line\"><span class=\"built_in\">CGContextDrawPath</span>(context, kCGPathFill || kCGPathEOFill);</span><br></pre></td></tr></table></figure>\n<h2 id=\"修剪路径\">修剪路径</h2>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// 修剪 非零圈数规则 nonzero winding number rule</span></span><br><span class=\"line\"><span class=\"built_in\">CGContextClip</span>(context);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 修剪 奇偶规则 even-odd rule</span></span><br><span class=\"line\"><span class=\"built_in\">CGContextEOClip</span>(context);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 矩形修剪</span></span><br><span class=\"line\"><span class=\"built_in\">CGContextClipToRect</span>(context, rect);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 矩形修剪图形</span></span><br><span class=\"line\"><span class=\"built_in\">CGContextClipToMask</span>(context, rect, mask);</span><br></pre></td></tr></table></figure>\n<h1 id=\"transforms\">Transforms</h1>\n<h2 id=\"修改用户坐标系\">修改用户坐标系</h2>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// 平移</span></span><br><span class=\"line\"><span class=\"built_in\">CGContextTranslateCTM</span>(context, x, y);</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">/// 旋转</span></span><br><span class=\"line\"><span class=\"built_in\">CGContextRotateCTM</span>(context, angle);</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">/// 缩放</span></span><br><span class=\"line\"><span class=\"built_in\">CGContextScaleCTM</span>(context, x, y);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 根据特定矩阵转换用户坐标系</span></span><br><span class=\"line\"><span class=\"built_in\">CGContextConcatCTM</span>(context, transform);</span><br></pre></td></tr></table></figure>\n<h2 id=\"创建仿射变换\">创建仿射变换</h2>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// 平移</span></span><br><span class=\"line\"><span class=\"built_in\">CGAffineTransformMakeTranslation</span>(x, y);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 以transform基础进行平移</span></span><br><span class=\"line\"><span class=\"built_in\">CGAffineTransformTranslate</span>(transform, x, y);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 旋转</span></span><br><span class=\"line\"><span class=\"built_in\">CGAffineTransformMakeRotation</span>(angle);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 以transform基础进行旋转</span></span><br><span class=\"line\"><span class=\"built_in\">CGAffineTransformRotate</span>(transform, angle);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 缩放</span></span><br><span class=\"line\"><span class=\"built_in\">CGAffineTransformMakeScale</span>(x, y);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 以transform基础进行缩放</span></span><br><span class=\"line\"><span class=\"built_in\">CGAffineTransformScale</span>(transform, x, y);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 对point进行矩阵变换</span></span><br><span class=\"line\"><span class=\"built_in\">CGPointApplyAffineTransform</span>(point, transform);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 对size进行矩阵变换</span></span><br><span class=\"line\"><span class=\"built_in\">CGSizeApplyAffineTransform</span>(size, transform);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 对rect进行矩阵变换</span></span><br><span class=\"line\"><span class=\"built_in\">CGRectApplyAffineTransform</span>(rect, transform);</span><br></pre></td></tr></table></figure>\n<h2 id=\"评估仿射变换\">评估仿射变换</h2>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// 仿射变换是否相同</span></span><br><span class=\"line\"><span class=\"built_in\">CGAffineTransformEqualToTransform</span>(transform1, transform2);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 仿射变换是否为初始状态</span></span><br><span class=\"line\"><span class=\"built_in\">CGAffineTransformIsIdentity</span>(transform);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 初始状态</span></span><br><span class=\"line\"><span class=\"built_in\">CGAffineTransformIdentity</span>;</span><br></pre></td></tr></table></figure>\n<h2 id=\"用户空间与设备空间转换\">用户空间与设备空间转换</h2>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// point转换</span></span><br><span class=\"line\"><span class=\"built_in\">CGContextConvertPointToDeviceSpace</span>(context, point);</span><br><span class=\"line\"><span class=\"built_in\">CGContextConvertPointToUserSpace</span>(context, point);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// size转换</span></span><br><span class=\"line\"><span class=\"built_in\">CGContextConvertSizeToDeviceSpace</span>(context, size);</span><br><span class=\"line\"><span class=\"built_in\">CGContextConvertRectToUserSpace</span>(context, size);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// rect转换</span></span><br><span class=\"line\"><span class=\"built_in\">CGContextConvertRectToDeviceSpace</span>(context, rect);</span><br><span class=\"line\"><span class=\"built_in\">CGContextConvertRectToUserSpace</span>(context, rect);</span><br></pre></td></tr></table></figure>\n<h1 id=\"patterns\">Patterns</h1>\n<p>Pattern 是一组绘图操作序列，这些操作被反复操作到图形上下文中。可以像使用颜色一样使用 Pattern，Quartz 会把页面划分为一组 Pattern 单元格，每个单元格大小与 Pattern 图形相似，并使用提供的回调函数绘制每个单元格。<br>\n<img src=\"/img/article/20190418/2.png\" alt=\"A Pattern drawn to a window\"></p>\n<h2 id=\"编写一个回调函数来绘制一个着色图案单元格\">编写一个回调函数来绘制一个着色图案单元格</h2>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 绘制着色图案单元格的绘图回调</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param info 指向与图案关联的私有数据的泛型指针</span></span><br><span class=\"line\"><span class=\"comment\"> @param myContext 绘图上下文</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> MyDrawColoredPattern(<span class=\"keyword\">void</span> *info, <span class=\"built_in\">CGContextRef</span> myContext) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">CGFloat</span> subunit = <span class=\"number\">5</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">CGRect</span> myRect1 = &#123;&#123;<span class=\"number\">0</span>, <span class=\"number\">0</span>&#125;, &#123;subunit, subunit&#125;&#125;,</span><br><span class=\"line\">    myRect2 = &#123;&#123;subunit, subunit&#125;, &#123;subunit, subunit&#125;&#125;,</span><br><span class=\"line\">    myRect3 = &#123;&#123;<span class=\"number\">0</span>, subunit&#125;, &#123;subunit, subunit&#125;&#125;,</span><br><span class=\"line\">    myRect4 = &#123;&#123;subunit, <span class=\"number\">0</span>&#125;, &#123;subunit, subunit&#125;&#125;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">CGContextSetRGBFillColor</span>(myContext, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">.5</span>);</span><br><span class=\"line\">    <span class=\"built_in\">CGContextFillRect</span>(myContext, myRect1);</span><br><span class=\"line\">    <span class=\"built_in\">CGContextSetRGBFillColor</span>(myContext, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">.5</span>);</span><br><span class=\"line\">    <span class=\"built_in\">CGContextFillRect</span>(myContext, myRect2);</span><br><span class=\"line\">    <span class=\"built_in\">CGContextSetRGBFillColor</span>(myContext, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">.5</span>);</span><br><span class=\"line\">    <span class=\"built_in\">CGContextFillRect</span>(myContext, myRect3);</span><br><span class=\"line\">    <span class=\"built_in\">CGContextSetRGBFillColor</span>(myContext, <span class=\"number\">.5</span>, <span class=\"number\">0</span>, <span class=\"number\">.5</span>, <span class=\"number\">.5</span>);</span><br><span class=\"line\">    <span class=\"built_in\">CGContextFillRect</span>(myContext, myRect4);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"设置着色图案颜色空间\">设置着色图案颜色空间</h2>\n<p>允许<em>MyDrawColoredPattern</em>代码中使用颜色绘制图案单元格的前提是，将基本图案颜色空间设置为NULL。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">CGColorSpaceRef</span> patternSpace;</span><br><span class=\"line\">patternSpace = <span class=\"built_in\">CGColorSpaceCreatePattern</span>(<span class=\"literal\">NULL</span>);</span><br><span class=\"line\"><span class=\"built_in\">CGContextSetFillColorSpace</span>(context, patternSpace);</span><br><span class=\"line\"><span class=\"built_in\">CGColorSpaceRelease</span>(patternSpace);</span><br></pre></td></tr></table></figure>\n<h2 id=\"建立着色图案剖析\">建立着色图案剖析</h2>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 创建图案</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param NULL 传递到*MyDrawColoredPattern*绘图回调中的info</span></span><br><span class=\"line\"><span class=\"comment\"> @param patternRect 图案rect</span></span><br><span class=\"line\"><span class=\"comment\"> @param CGAffineTransformIdentity 图形变换</span></span><br><span class=\"line\"><span class=\"comment\"> @param 16 单元格之间的水平位移（可以理解为单元格宽）</span></span><br><span class=\"line\"><span class=\"comment\"> @param 18 单元格之间的竖直位移（可以理解为单元格高）</span></span><br><span class=\"line\"><span class=\"comment\"> @param kCGPatternTilingConstantSpacing 拼接方式</span></span><br><span class=\"line\"><span class=\"comment\"> @param YES 是否为着色模式（否则为模板模式，应该是印刷模式）</span></span><br><span class=\"line\"><span class=\"comment\"> @param callbacks 绘图回调函数</span></span><br><span class=\"line\"><span class=\"comment\"> @return 图案</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"built_in\">CGPatternRef</span> myPattern = <span class=\"built_in\">CGPatternCreate</span>(<span class=\"literal\">NULL</span>, patternRect, <span class=\"built_in\">CGAffineTransformIdentity</span>, <span class=\"number\">16</span>, <span class=\"number\">18</span>, kCGPatternTilingConstantSpacing, <span class=\"literal\">YES</span>, &amp;callbacks);</span><br></pre></td></tr></table></figure>\n<h2 id=\"将着色图案填充-描边\">将着色图案填充、描边</h2>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">CGFloat</span> alpha = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"built_in\">CGContextSetFillPattern</span>(context, myPattern, &amp;alpha);</span><br></pre></td></tr></table></figure>\n<h2 id=\"完整的彩绘封装\">完整的彩绘封装</h2>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> MyColorPatternPainting(<span class=\"built_in\">CGContextRef</span> myContext, <span class=\"built_in\">CGRect</span> rect) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">CGPatternRef</span> pattern;</span><br><span class=\"line\">    <span class=\"built_in\">CGColorSpaceRef</span> patternSpace;</span><br><span class=\"line\">    <span class=\"built_in\">CGFloat</span> alpha = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"built_in\">CGPatternCallbacks</span> callbacks = &#123;<span class=\"number\">0</span>, &amp;MyDrawColoredPattern, <span class=\"literal\">NULL</span>&#125;;</span><br><span class=\"line\">    <span class=\"built_in\">CGContextSaveGState</span>(myContext);</span><br><span class=\"line\">    patternSpace = <span class=\"built_in\">CGColorSpaceCreatePattern</span>(<span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    <span class=\"built_in\">CGContextSetFillColorSpace</span>(myContext, patternSpace);</span><br><span class=\"line\">    <span class=\"built_in\">CGColorSpaceRelease</span>(patternSpace);</span><br><span class=\"line\">    </span><br><span class=\"line\">    pattern = <span class=\"built_in\">CGPatternCreate</span>(<span class=\"literal\">NULL</span>, <span class=\"built_in\">CGRectMake</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">16</span>, <span class=\"number\">18</span>), <span class=\"built_in\">CGAffineTransformMake</span>(<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>), <span class=\"number\">16</span>, <span class=\"number\">18</span>, kCGPatternTilingConstantSpacing, <span class=\"literal\">true</span>, &amp;callbacks);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">CGContextSetFillPattern</span>(myContext, pattern, &amp;alpha);</span><br><span class=\"line\">    <span class=\"built_in\">CGPatternRelease</span>(pattern);</span><br><span class=\"line\">    <span class=\"built_in\">CGContextFillRect</span>(myContext, rect);</span><br><span class=\"line\">    <span class=\"built_in\">CGContextRestoreGState</span>(myContext);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> MyDrawColoredPattern(<span class=\"keyword\">void</span> *info, <span class=\"built_in\">CGContextRef</span> myContext) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">CGFloat</span> subunit = <span class=\"number\">5</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">CGRect</span> myRect1 = &#123;&#123;<span class=\"number\">0</span>, <span class=\"number\">0</span>&#125;, &#123;subunit, subunit&#125;&#125;,</span><br><span class=\"line\">    myRect2 = &#123;&#123;subunit, subunit&#125;, &#123;subunit, subunit&#125;&#125;,</span><br><span class=\"line\">    myRect3 = &#123;&#123;<span class=\"number\">0</span>, subunit&#125;, &#123;subunit, subunit&#125;&#125;,</span><br><span class=\"line\">    myRect4 = &#123;&#123;subunit, <span class=\"number\">0</span>&#125;, &#123;subunit, subunit&#125;&#125;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">CGContextSetRGBFillColor</span>(myContext, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">.5</span>);</span><br><span class=\"line\">    <span class=\"built_in\">CGContextFillRect</span>(myContext, myRect1);</span><br><span class=\"line\">    <span class=\"built_in\">CGContextSetRGBFillColor</span>(myContext, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">.5</span>);</span><br><span class=\"line\">    <span class=\"built_in\">CGContextFillRect</span>(myContext, myRect2);</span><br><span class=\"line\">    <span class=\"built_in\">CGContextSetRGBFillColor</span>(myContext, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">.5</span>);</span><br><span class=\"line\">    <span class=\"built_in\">CGContextFillRect</span>(myContext, myRect3);</span><br><span class=\"line\">    <span class=\"built_in\">CGContextSetRGBFillColor</span>(myContext, <span class=\"number\">.5</span>, <span class=\"number\">0</span>, <span class=\"number\">.5</span>, <span class=\"number\">.5</span>);</span><br><span class=\"line\">    <span class=\"built_in\">CGContextFillRect</span>(myContext, myRect4);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"shadows\">Shadows</h1>\n<h2 id=\"阴影的使用\">阴影的使用</h2>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">CGContextSaveGState</span>(context);</span><br><span class=\"line\"><span class=\"built_in\">CGContextSetShadow</span>(context, offsetsize, blur);  <span class=\"comment\">// offset：偏移量（UIKit下：x向右为正，y向下为正），blur：阴影量，颜色默认为（0, 0, 0, 1.0/3.0）</span></span><br><span class=\"line\"><span class=\"built_in\">CGContextSetShadowWithColor</span>(context, offsetsize, blur, color);</span><br><span class=\"line\"><span class=\"comment\">/* 其他绘图操作 */</span></span><br><span class=\"line\"><span class=\"built_in\">CGContextRestoreGState</span>(context);</span><br></pre></td></tr></table></figure>\n<h1 id=\"gradients\">Gradients</h1>\n<p>Quartz 提供两种数据类型创建渐变色 – <em>CGShadingRef</em> 和 <em>CGGradientRef</em>。同时，这两种数据类型又可以分别创建轴向(axial)或者径向(radial)的渐变线。</p>\n<p>An axial gradient(a linear gradient) – 在定义的两个端点之间沿轴向变化，所有垂直于该轴向的直线上的点具有相同的色值。<br>\nA radial gradient – 在定义的两个端点（通常都是圆）之间沿轴向径向变化的填充，所有圆心落在轴线上圆的圆周上的点具有相同的色值，梯度的圆截面半径由两端半径确定，半径从一端到另一端呈线性变化。</p>\n<h2 id=\"cgshading-与-cggradient-比较\">CGShading 与 CGGradient 比较</h2>\n<p>CGShadingRef – 可以自己控制渐变中每个点颜色值的计算，非常细节。在创建CGShading对象之前，必须先创建CGFunction对象来定义梯度颜色计算的函数，自定义的函数可以更自由的创建更流畅的颜色梯度。</p>\n<p>CGRadientRef – 是CGShadingRef的子类，使用更加方便。Quartz为我们计算渐变中每个点的颜色，不需要我们提供计算函数，只需要提供作用域和颜色值，Quartz会自动计算每个连续位置的颜色梯度。</p>\n<h2 id=\"cggradient\">CGGradient</h2>\n<h3 id=\"轴向渐变线\">轴向渐变线</h3>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">CGGradientRef</span> myGradient;</span><br><span class=\"line\"><span class=\"built_in\">CGColorSpaceRef</span> myColorspace;</span><br><span class=\"line\">size_t num_locations = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"built_in\">CGFloat</span> locations[<span class=\"number\">2</span>] = &#123; <span class=\"number\">0.0</span>, <span class=\"number\">1.0</span> &#125;;</span><br><span class=\"line\"><span class=\"built_in\">CGFloat</span> components[<span class=\"number\">8</span>] = &#123;</span><br><span class=\"line\">    <span class=\"number\">1.0</span>, <span class=\"number\">0.5</span>, <span class=\"number\">0.4</span>, <span class=\"number\">1.0</span>,  <span class=\"comment\">// Start color</span></span><br><span class=\"line\">    <span class=\"number\">0.8</span>, <span class=\"number\">0.8</span>, <span class=\"number\">0.3</span>, <span class=\"number\">1.0</span>   <span class=\"comment\">// End color</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">CGPoint</span> myStartPoint, myEndPoint;</span><br><span class=\"line\">myColorspace = <span class=\"built_in\">CGColorSpaceCreateWithName</span>(kCGColorSpaceGenericRGB);</span><br><span class=\"line\">myGradient = <span class=\"built_in\">CGGradientCreateWithColorComponents</span>(myColorspace, components, locations, num_locations);</span><br><span class=\"line\"><span class=\"built_in\">CGContextDrawLinearGradient</span>(context, myGradient, myStartPoint, myEndPoint, kCGGradientDrawsBeforeStartLocation | kCGGradientDrawsAfterEndLocation);</span><br></pre></td></tr></table></figure>\n<h3 id=\"径向渐变线\">径向渐变线</h3>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">CGGradientRef</span> myGradient;</span><br><span class=\"line\"><span class=\"built_in\">CGColorSpaceRef</span> myColorspace;</span><br><span class=\"line\">size_t num_locations = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"built_in\">CGFloat</span> locations[<span class=\"number\">2</span>] = &#123; <span class=\"number\">0.0</span>, <span class=\"number\">1.0</span> &#125;;</span><br><span class=\"line\"><span class=\"built_in\">CGFloat</span> components[<span class=\"number\">8</span>] = &#123;</span><br><span class=\"line\">    <span class=\"number\">1.0</span>, <span class=\"number\">0.5</span>, <span class=\"number\">0.4</span>, <span class=\"number\">1.0</span>,  <span class=\"comment\">// Start color</span></span><br><span class=\"line\">    <span class=\"number\">0.8</span>, <span class=\"number\">0.8</span>, <span class=\"number\">0.3</span>, <span class=\"number\">1.0</span>   <span class=\"comment\">// End color</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">CGFloat</span> myStartRadius, myEndRadius;</span><br><span class=\"line\"><span class=\"built_in\">CGPoint</span> myStartPoint, myEndPoint;</span><br><span class=\"line\">myColorspace = <span class=\"built_in\">CGColorSpaceCreateWithName</span>(kCGColorSpaceGenericRGB);</span><br><span class=\"line\">myGradient = <span class=\"built_in\">CGGradientCreateWithColorComponents</span>(myColorspace, components, locations, num_locations);</span><br><span class=\"line\"><span class=\"built_in\">CGContextDrawRadialGradient</span>(context, myGradient, myStartPoint, myStartRadius, myEndPoint, myEndRadius, <span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure>\n<h2 id=\"cgshading\">CGShading</h2>\n<p>暂不予考虑</p>\n<h1 id=\"transparency-layers\">Transparency Layers</h1>\n<p>当多个对象组合成复合图形，如何将复合图形视为单一对象，形成如同单一对象般的应用效果，这就要用到透明层这个概念。</p>\n<p><img src=\"/img/article/20190418/3.png\" alt=\"Transparency Layers\"></p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">CGContextSetShadow</span>(context, <span class=\"built_in\">CGSizeMake</span>(<span class=\"number\">10</span>, <span class=\"number\">20</span>), <span class=\"number\">10</span>);</span><br><span class=\"line\"><span class=\"built_in\">CGContextBeginTransparencyLayer</span>(context, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\"><span class=\"comment\">// your drawing code</span></span><br><span class=\"line\"><span class=\"built_in\">CGContextEndTransparencyLayer</span>(context);</span><br></pre></td></tr></table></figure>\n<h1 id=\"ending\">Ending</h1>\n<p>当然，Quartz 2D的内容不止这么多，我现在整理的也只是一些简单易用的皮毛，针对于 iOS 应用的一些简易图形绘制应该是没有问题了，总的说来，学无止境，后面可能要继续对Core Image的学习。</p>\n<h1 id=\"reference\">Reference</h1>\n<blockquote>\n<p><a href=\"https://developer.apple.com/library/archive/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/dq_overview/dq_overview.html#//apple_ref/doc/uid/TP30001066-CH202-TPXREF101\" target=\"_blank\" rel=\"noopener\">Quartz 2D Programming Guide</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>最近在网上看文章的时候，看到了一篇<a href=\"http://www.lymanli.com/2019/04/05/ios-opengles-filter/\" target=\"_blank\" rel=\"noopener\">在 iOS 中使用 GLSL 实现抖音特效</a>的文章，忽然兴趣就来了，然后就看到了一系列图片处理专用名词，这反而更加勾起了我的兴趣，主要是之前也看到一些关于 OpenGL 的字眼的文章，但是都没有花很多精力去研究，刚好眼下又看到了这篇文章，刚好这个博主也有对 OpenGL 的基础介绍，所以本是打算边看边学，把这个 OpenGL 搞懂。<br>\n这个博主对于 OpenGL 的研究文章有3篇，本想着应该问题不大，在完成第一篇的简单使用并绘制图片，到第二篇的对图片进行伸缩，我才发现这里面涵盖的东西非常之广，并不是我想象中那么简单的一个框架，这里面已经涉及到了一个大的领域技术，但是这并没有把我劝退，反而我的内心浮现了一个想法。说实话，作为 iOS 开发者这么多年，我还没有一个可以作为自己专业技术领域的特长，在未来的互联网斗争中如何扩大自己的优势呢，我感觉这个图形处理领域可能会是我进军的领域了。<br>\n所以，我打算从最简单的绘图开始 – iOS 绘图框架 Core Graphics。</p>\n</blockquote>\n<h1>Introduction</h1>\n<p>Quartz 2D是一个二维绘图引擎，可以在 iOS 环境和内核之外的所有 Mac OS X 应用程序环境下使用。我们可以使用 Quartz 2D API 来使用功能，比如基于路径的绘图，具有透明度的绘制，阴影，绘制阴影，透明层，颜色管理，抗锯齿渲染，PDF 文档生成，PDF 元数据访问等。在 iOS 中，Quartz 2D 可以使用所有可用的图形和动画技术，比如 Core Animation, OpenGL ES, UIKit 类等。（只讨论 iOS 范畴）</p>\n<h1>Concepts</h1>\n<h2>绘图点：The Graphics Context</h2>\n<p>图形上下文是一种不透明的数据类型（CGContextRef），他封装了 Quartz 用于将图像绘制到输出设备（如 PDF 文件，位图，显示窗口）的信息。图像上下文中的信息包括图像绘制参数和页面上绘制的特定于设备的表示。Quartz 中所有的对象被绘制到或者包含在图像上下文中。<br>\n图像上下文包含以下几种：</p>\n<ol>\n<li>\n<p>A bitmap graphics context：位图图形上下文，允许在位图中绘制 RGB 颜色，CMYK 颜色，灰度模式。位图是像素的矩阵阵列（或光栅），每个像素表示图像中的一个点。位图图形也称为采样图像。</p>\n</li>\n<li>\n<p>A PDF graphics context：PDF 图形上下文，允许创建 PDF 文件。在 PDF 文件中，绘图被保存为一系列命令。PDF 文件与位图之前有以下区别：</p>\n</li>\n</ol>\n<ul>\n<li>PDF 文件不同于位图，可以包含超过一页内容</li>\n<li>当在不同的设备从 PDF 文件中绘制页面时，生成的图像将根据该设备的显示特性进行优化</li>\n<li>PDF 文件本质上是独立于分辨率–在不牺牲图像细节的情况下，他们被绘制的大小可以无限增加或减小；位图图像的用户感知质量与位图的显示分辨率有关</li>\n</ul>\n<ol start=\"3\">\n<li>\n<p>A window graphics context：可以在窗口绘图。（适用于 Mac OS X）</p>\n</li>\n<li>\n<p>A layer context：图层上下文，与另一个图形上下文关联的离屏绘图位置。当将层绘制到创建它的图形上下文时，它的设计是为了获得最佳性能。对于屏幕外绘制，图层上下文比位图图形上下文是更好的选择。</p>\n</li>\n</ol>\n<h2>图形状态：Graphics States</h2>\n<p>Quartz 根据当前图形状态下的参数修改绘图结果。图形上下文包含一组图形状态，当 Quartz 创建上下文，状态是空的，只有当保存图形状态时，才会将图形状态保存到堆栈。当恢复图形状态时，会将当前图形状态从堆栈顶部弹出，弹出状态变为上次保存的状态。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">CGContextSaveGState</span>();  <span class=\"comment\">// 存储状态</span></span><br><span class=\"line\"><span class=\"built_in\">CGContextRestoreGState</span>();   <span class=\"comment\">// 恢复状态</span></span><br></pre></td></tr></table></figure>\n<h2>坐标系：Quartz 2D Coordinate Systems</h2>\n<p>Quartz 2D坐标系：<br>\n<img src=\"/img/article/20190418/1.png\" alt=\"Quartz 2D坐标系\" title=\"Quartz 2D坐标系\"></p>\n<p>由于不同设备具有不同的底层成像功能，所以必须以与设备无关的方式定义设备的位置和大小。Quartz 通过单独的坐标系统–用户空间–将其映射到输出设备–设备空间–使用当前变换矩阵（CTM）来实现设备的独立性。当前的变换矩阵是一种特殊类型的矩阵，成为仿射变换，他通过应用平移、旋转、缩放（移动、旋转、调整坐标系大小）等操作将点从一个坐标系空间映射到另一个坐标系空间。</p>\n<p>有些技术使用不同于 Quartz 使用的默认坐标系来设置他们的图形上下文，相对于 Quartz，这样的坐标系是经过修改的坐标系，在执行一些 Quartz 绘图操作时必须对其进行补偿。最常见的修改坐标系就是讲原点放在上下文的左上角，并将y轴指向页面底部。比如：</p>\n<ul>\n<li>Mac OS X，继承 NSView 并重写 <em>isFlipped</em> 返回 YES</li>\n<li>iOS，UIView 返回的绘图上下文</li>\n<li>iOS，<em>UIGraphicsBeginImageContextWithOptions</em> 调用返回的绘图上下文</li>\n</ul>\n<p>因为 UIKit 本身使用了不同于 Quartz 的默认坐标系约定，所以修改了绘图上下文坐标系；它将转换应用于它创建的 Quartz 上下文以匹配他们的约定。这些变换会导致一系列问题，比如路径绘制过程中，圆弧在默认坐标系中是顺时针绘制，但如果修改了坐标系，则会变成逆时针绘制，就像镜像反射。</p>\n<h1>Paths</h1>\n<p>路径定义了一个或多个形状或子路径。</p>\n<h2>一些基本绘图操作</h2>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// 点 Points</span></span><br><span class=\"line\"><span class=\"built_in\">CGContextMoveToPoint</span>(context, x, y);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 线 Lines</span></span><br><span class=\"line\"><span class=\"built_in\">CGContextAddLineToPoint</span>(context, x, y);</span><br><span class=\"line\"><span class=\"built_in\">CGContextAddLines</span>(context, [points], count)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 圆弧</span></span><br><span class=\"line\"><span class=\"built_in\">CGContextAddArc</span>(context, x, y, radius, startAngle, endAngle, clockwise);</span><br><span class=\"line\"><span class=\"built_in\">CGContextAddArcToPoint</span>(context, x1, y1, x2, y2, radius);    <span class=\"comment\">// 前两个点表示切点</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 曲线 Curves</span></span><br><span class=\"line\"><span class=\"built_in\">CGContextAddCurveToPoint</span>(context, x1, y1, x2, y2, x, y);    <span class=\"comment\">// 前两个点控制切线方向，最后一个点是结点</span></span><br><span class=\"line\"><span class=\"built_in\">CGContextAddQuadCurveToPoint</span>(context, x1, y1, x, y)         <span class=\"comment\">// 第一个点是切点，最后一个点是结点</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 结束一段子路径</span></span><br><span class=\"line\"><span class=\"built_in\">CGContextClosePath</span>(context);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 椭圆 Ellipses</span></span><br><span class=\"line\"><span class=\"built_in\">CGContextAddEllipseInRect</span>(context, rect);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 矩形 Rectangles</span></span><br><span class=\"line\"><span class=\"built_in\">CGContextAddRect</span>(context, rect);</span><br><span class=\"line\"><span class=\"built_in\">CGContextAddRects</span>(context, [rects], count);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 开始绘制路径</span></span><br><span class=\"line\"><span class=\"built_in\">CGContextBeginPath</span>(context);</span><br></pre></td></tr></table></figure>\n<h2>创建路径</h2>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// 获取路径对象</span></span><br><span class=\"line\"><span class=\"built_in\">CGMutablePathRef</span> mutablePath = <span class=\"built_in\">CGPathCreateMutable</span>();</span><br><span class=\"line\"><span class=\"built_in\">CGPathRef</span> path = <span class=\"built_in\">CGContextCopyPath</span>(context);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 移动绘图起始点</span></span><br><span class=\"line\"><span class=\"built_in\">CGPathMoveToPoint</span>(path, <span class=\"literal\">NULL</span>, x, y);    <span class=\"comment\">// 第二个参数，可以修改坐标系（CGContextTranslateCTM, CGContextScaleCTM, or CGContextRotateCTM）</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 其余与上述类似 ...</span></span><br></pre></td></tr></table></figure>\n<h2>闭合路径</h2>\n<ul>\n<li>影响闭合路径的参数：</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// 线条粗细</span></span><br><span class=\"line\"><span class=\"built_in\">CGContextSetLineWidth</span>(context, width);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 线条转折处样式</span></span><br><span class=\"line\"><span class=\"built_in\">CGContextSetLineJoin</span>(context, join);        <span class=\"comment\">// kCGLineJoinMiter (the default), kCGLineJoinRound 圆角, or kCGLineJoinBevel 折角</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 线条转折样式为 Miter 时，</span></span><br><span class=\"line\"><span class=\"built_in\">CGContextSetMiterLimit</span>(context, limit);     <span class=\"comment\">// 斜接的长度除以线的宽度，如果结果大于斜接极限，则样式转换为Bevel。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 线条终起点样式</span></span><br><span class=\"line\"><span class=\"built_in\">CGContextSetLineCap</span>(context, cap);          <span class=\"comment\">// kCGLineCapButt (the default), kCGLineCapRound 圆角, or kCGLineCapSquare 折角</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 线条 虚线样式</span></span><br><span class=\"line\"><span class=\"built_in\">CGContextSetLineDash</span>(context, phase, [lengths], count);     <span class=\"comment\">// phase: 起点处，指定从虚线的哪个位置开始绘制</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 线条颜色</span></span><br><span class=\"line\"><span class=\"built_in\">CGContextSetStrokeColorWithColor</span>(context, color);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>闭合路径的几种方式：</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// 闭合</span></span><br><span class=\"line\"><span class=\"built_in\">CGContextStrokePath</span>(context);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 矩形闭合</span></span><br><span class=\"line\"><span class=\"built_in\">CGContextStrokeRect</span>(context, rect);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 特定线粗细矩形闭合</span></span><br><span class=\"line\"><span class=\"built_in\">CGContextStrokeRectWithWidth</span>(context, rect, width);      <span class=\"comment\">// width: 线粗细</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 椭圆闭合</span></span><br><span class=\"line\"><span class=\"built_in\">CGContextStrokeEllipseInRect</span>(context, rect);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 多条线闭合</span></span><br><span class=\"line\"><span class=\"built_in\">CGContextStrokeLineSegments</span>(context, [points], count);      <span class=\"comment\">// points: 每两个点定义点一条线</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 闭合</span></span><br><span class=\"line\"><span class=\"built_in\">CGContextDrawPath</span>(context, kCGPathFillStroke || kCGPathEOFillStroke);</span><br></pre></td></tr></table></figure>\n<h2>填充路径</h2>\n<p>填充路径的几种方式：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// 填充 奇偶规则 even-odd rule</span></span><br><span class=\"line\"><span class=\"built_in\">CGContextEOFillPath</span>(context);   <span class=\"comment\">// 射线穿过图形，穿过路径+1，奇数为路径内部，偶数为路径外部</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 填充 非零圈数规则 nonzero winding number rule</span></span><br><span class=\"line\"><span class=\"built_in\">CGContextFillPath</span>(context);     <span class=\"comment\">// 射线穿过图形，路径从左到右穿过射线+1，从右到左-1，0位路径外部，非0为路径内部</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 矩形填充</span></span><br><span class=\"line\"><span class=\"built_in\">CGContextFillRect</span>(context, rect);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 椭圆填充</span></span><br><span class=\"line\"><span class=\"built_in\">CGContextFillEllipseInRect</span>(context, rect);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 填充</span></span><br><span class=\"line\"><span class=\"built_in\">CGContextDrawPath</span>(context, kCGPathFill || kCGPathEOFill);</span><br></pre></td></tr></table></figure>\n<h2>修剪路径</h2>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// 修剪 非零圈数规则 nonzero winding number rule</span></span><br><span class=\"line\"><span class=\"built_in\">CGContextClip</span>(context);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 修剪 奇偶规则 even-odd rule</span></span><br><span class=\"line\"><span class=\"built_in\">CGContextEOClip</span>(context);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 矩形修剪</span></span><br><span class=\"line\"><span class=\"built_in\">CGContextClipToRect</span>(context, rect);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 矩形修剪图形</span></span><br><span class=\"line\"><span class=\"built_in\">CGContextClipToMask</span>(context, rect, mask);</span><br></pre></td></tr></table></figure>\n<h1>Transforms</h1>\n<h2>修改用户坐标系</h2>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// 平移</span></span><br><span class=\"line\"><span class=\"built_in\">CGContextTranslateCTM</span>(context, x, y);</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">/// 旋转</span></span><br><span class=\"line\"><span class=\"built_in\">CGContextRotateCTM</span>(context, angle);</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">/// 缩放</span></span><br><span class=\"line\"><span class=\"built_in\">CGContextScaleCTM</span>(context, x, y);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 根据特定矩阵转换用户坐标系</span></span><br><span class=\"line\"><span class=\"built_in\">CGContextConcatCTM</span>(context, transform);</span><br></pre></td></tr></table></figure>\n<h2>创建仿射变换</h2>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// 平移</span></span><br><span class=\"line\"><span class=\"built_in\">CGAffineTransformMakeTranslation</span>(x, y);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 以transform基础进行平移</span></span><br><span class=\"line\"><span class=\"built_in\">CGAffineTransformTranslate</span>(transform, x, y);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 旋转</span></span><br><span class=\"line\"><span class=\"built_in\">CGAffineTransformMakeRotation</span>(angle);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 以transform基础进行旋转</span></span><br><span class=\"line\"><span class=\"built_in\">CGAffineTransformRotate</span>(transform, angle);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 缩放</span></span><br><span class=\"line\"><span class=\"built_in\">CGAffineTransformMakeScale</span>(x, y);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 以transform基础进行缩放</span></span><br><span class=\"line\"><span class=\"built_in\">CGAffineTransformScale</span>(transform, x, y);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 对point进行矩阵变换</span></span><br><span class=\"line\"><span class=\"built_in\">CGPointApplyAffineTransform</span>(point, transform);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 对size进行矩阵变换</span></span><br><span class=\"line\"><span class=\"built_in\">CGSizeApplyAffineTransform</span>(size, transform);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 对rect进行矩阵变换</span></span><br><span class=\"line\"><span class=\"built_in\">CGRectApplyAffineTransform</span>(rect, transform);</span><br></pre></td></tr></table></figure>\n<h2>评估仿射变换</h2>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// 仿射变换是否相同</span></span><br><span class=\"line\"><span class=\"built_in\">CGAffineTransformEqualToTransform</span>(transform1, transform2);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 仿射变换是否为初始状态</span></span><br><span class=\"line\"><span class=\"built_in\">CGAffineTransformIsIdentity</span>(transform);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 初始状态</span></span><br><span class=\"line\"><span class=\"built_in\">CGAffineTransformIdentity</span>;</span><br></pre></td></tr></table></figure>\n<h2>用户空间与设备空间转换</h2>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// point转换</span></span><br><span class=\"line\"><span class=\"built_in\">CGContextConvertPointToDeviceSpace</span>(context, point);</span><br><span class=\"line\"><span class=\"built_in\">CGContextConvertPointToUserSpace</span>(context, point);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// size转换</span></span><br><span class=\"line\"><span class=\"built_in\">CGContextConvertSizeToDeviceSpace</span>(context, size);</span><br><span class=\"line\"><span class=\"built_in\">CGContextConvertRectToUserSpace</span>(context, size);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// rect转换</span></span><br><span class=\"line\"><span class=\"built_in\">CGContextConvertRectToDeviceSpace</span>(context, rect);</span><br><span class=\"line\"><span class=\"built_in\">CGContextConvertRectToUserSpace</span>(context, rect);</span><br></pre></td></tr></table></figure>\n<h1>Patterns</h1>\n<p>Pattern 是一组绘图操作序列，这些操作被反复操作到图形上下文中。可以像使用颜色一样使用 Pattern，Quartz 会把页面划分为一组 Pattern 单元格，每个单元格大小与 Pattern 图形相似，并使用提供的回调函数绘制每个单元格。<br>\n<img src=\"/img/article/20190418/2.png\" alt=\"A Pattern drawn to a window\"></p>\n<h2>编写一个回调函数来绘制一个着色图案单元格</h2>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 绘制着色图案单元格的绘图回调</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param info 指向与图案关联的私有数据的泛型指针</span></span><br><span class=\"line\"><span class=\"comment\"> @param myContext 绘图上下文</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> MyDrawColoredPattern(<span class=\"keyword\">void</span> *info, <span class=\"built_in\">CGContextRef</span> myContext) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">CGFloat</span> subunit = <span class=\"number\">5</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">CGRect</span> myRect1 = &#123;&#123;<span class=\"number\">0</span>, <span class=\"number\">0</span>&#125;, &#123;subunit, subunit&#125;&#125;,</span><br><span class=\"line\">    myRect2 = &#123;&#123;subunit, subunit&#125;, &#123;subunit, subunit&#125;&#125;,</span><br><span class=\"line\">    myRect3 = &#123;&#123;<span class=\"number\">0</span>, subunit&#125;, &#123;subunit, subunit&#125;&#125;,</span><br><span class=\"line\">    myRect4 = &#123;&#123;subunit, <span class=\"number\">0</span>&#125;, &#123;subunit, subunit&#125;&#125;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">CGContextSetRGBFillColor</span>(myContext, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">.5</span>);</span><br><span class=\"line\">    <span class=\"built_in\">CGContextFillRect</span>(myContext, myRect1);</span><br><span class=\"line\">    <span class=\"built_in\">CGContextSetRGBFillColor</span>(myContext, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">.5</span>);</span><br><span class=\"line\">    <span class=\"built_in\">CGContextFillRect</span>(myContext, myRect2);</span><br><span class=\"line\">    <span class=\"built_in\">CGContextSetRGBFillColor</span>(myContext, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">.5</span>);</span><br><span class=\"line\">    <span class=\"built_in\">CGContextFillRect</span>(myContext, myRect3);</span><br><span class=\"line\">    <span class=\"built_in\">CGContextSetRGBFillColor</span>(myContext, <span class=\"number\">.5</span>, <span class=\"number\">0</span>, <span class=\"number\">.5</span>, <span class=\"number\">.5</span>);</span><br><span class=\"line\">    <span class=\"built_in\">CGContextFillRect</span>(myContext, myRect4);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2>设置着色图案颜色空间</h2>\n<p>允许<em>MyDrawColoredPattern</em>代码中使用颜色绘制图案单元格的前提是，将基本图案颜色空间设置为NULL。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">CGColorSpaceRef</span> patternSpace;</span><br><span class=\"line\">patternSpace = <span class=\"built_in\">CGColorSpaceCreatePattern</span>(<span class=\"literal\">NULL</span>);</span><br><span class=\"line\"><span class=\"built_in\">CGContextSetFillColorSpace</span>(context, patternSpace);</span><br><span class=\"line\"><span class=\"built_in\">CGColorSpaceRelease</span>(patternSpace);</span><br></pre></td></tr></table></figure>\n<h2>建立着色图案剖析</h2>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 创建图案</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param NULL 传递到*MyDrawColoredPattern*绘图回调中的info</span></span><br><span class=\"line\"><span class=\"comment\"> @param patternRect 图案rect</span></span><br><span class=\"line\"><span class=\"comment\"> @param CGAffineTransformIdentity 图形变换</span></span><br><span class=\"line\"><span class=\"comment\"> @param 16 单元格之间的水平位移（可以理解为单元格宽）</span></span><br><span class=\"line\"><span class=\"comment\"> @param 18 单元格之间的竖直位移（可以理解为单元格高）</span></span><br><span class=\"line\"><span class=\"comment\"> @param kCGPatternTilingConstantSpacing 拼接方式</span></span><br><span class=\"line\"><span class=\"comment\"> @param YES 是否为着色模式（否则为模板模式，应该是印刷模式）</span></span><br><span class=\"line\"><span class=\"comment\"> @param callbacks 绘图回调函数</span></span><br><span class=\"line\"><span class=\"comment\"> @return 图案</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"built_in\">CGPatternRef</span> myPattern = <span class=\"built_in\">CGPatternCreate</span>(<span class=\"literal\">NULL</span>, patternRect, <span class=\"built_in\">CGAffineTransformIdentity</span>, <span class=\"number\">16</span>, <span class=\"number\">18</span>, kCGPatternTilingConstantSpacing, <span class=\"literal\">YES</span>, &amp;callbacks);</span><br></pre></td></tr></table></figure>\n<h2>将着色图案填充、描边</h2>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">CGFloat</span> alpha = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"built_in\">CGContextSetFillPattern</span>(context, myPattern, &amp;alpha);</span><br></pre></td></tr></table></figure>\n<h2>完整的彩绘封装</h2>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> MyColorPatternPainting(<span class=\"built_in\">CGContextRef</span> myContext, <span class=\"built_in\">CGRect</span> rect) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">CGPatternRef</span> pattern;</span><br><span class=\"line\">    <span class=\"built_in\">CGColorSpaceRef</span> patternSpace;</span><br><span class=\"line\">    <span class=\"built_in\">CGFloat</span> alpha = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"built_in\">CGPatternCallbacks</span> callbacks = &#123;<span class=\"number\">0</span>, &amp;MyDrawColoredPattern, <span class=\"literal\">NULL</span>&#125;;</span><br><span class=\"line\">    <span class=\"built_in\">CGContextSaveGState</span>(myContext);</span><br><span class=\"line\">    patternSpace = <span class=\"built_in\">CGColorSpaceCreatePattern</span>(<span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    <span class=\"built_in\">CGContextSetFillColorSpace</span>(myContext, patternSpace);</span><br><span class=\"line\">    <span class=\"built_in\">CGColorSpaceRelease</span>(patternSpace);</span><br><span class=\"line\">    </span><br><span class=\"line\">    pattern = <span class=\"built_in\">CGPatternCreate</span>(<span class=\"literal\">NULL</span>, <span class=\"built_in\">CGRectMake</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">16</span>, <span class=\"number\">18</span>), <span class=\"built_in\">CGAffineTransformMake</span>(<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>), <span class=\"number\">16</span>, <span class=\"number\">18</span>, kCGPatternTilingConstantSpacing, <span class=\"literal\">true</span>, &amp;callbacks);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">CGContextSetFillPattern</span>(myContext, pattern, &amp;alpha);</span><br><span class=\"line\">    <span class=\"built_in\">CGPatternRelease</span>(pattern);</span><br><span class=\"line\">    <span class=\"built_in\">CGContextFillRect</span>(myContext, rect);</span><br><span class=\"line\">    <span class=\"built_in\">CGContextRestoreGState</span>(myContext);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> MyDrawColoredPattern(<span class=\"keyword\">void</span> *info, <span class=\"built_in\">CGContextRef</span> myContext) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">CGFloat</span> subunit = <span class=\"number\">5</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">CGRect</span> myRect1 = &#123;&#123;<span class=\"number\">0</span>, <span class=\"number\">0</span>&#125;, &#123;subunit, subunit&#125;&#125;,</span><br><span class=\"line\">    myRect2 = &#123;&#123;subunit, subunit&#125;, &#123;subunit, subunit&#125;&#125;,</span><br><span class=\"line\">    myRect3 = &#123;&#123;<span class=\"number\">0</span>, subunit&#125;, &#123;subunit, subunit&#125;&#125;,</span><br><span class=\"line\">    myRect4 = &#123;&#123;subunit, <span class=\"number\">0</span>&#125;, &#123;subunit, subunit&#125;&#125;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">CGContextSetRGBFillColor</span>(myContext, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">.5</span>);</span><br><span class=\"line\">    <span class=\"built_in\">CGContextFillRect</span>(myContext, myRect1);</span><br><span class=\"line\">    <span class=\"built_in\">CGContextSetRGBFillColor</span>(myContext, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">.5</span>);</span><br><span class=\"line\">    <span class=\"built_in\">CGContextFillRect</span>(myContext, myRect2);</span><br><span class=\"line\">    <span class=\"built_in\">CGContextSetRGBFillColor</span>(myContext, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">.5</span>);</span><br><span class=\"line\">    <span class=\"built_in\">CGContextFillRect</span>(myContext, myRect3);</span><br><span class=\"line\">    <span class=\"built_in\">CGContextSetRGBFillColor</span>(myContext, <span class=\"number\">.5</span>, <span class=\"number\">0</span>, <span class=\"number\">.5</span>, <span class=\"number\">.5</span>);</span><br><span class=\"line\">    <span class=\"built_in\">CGContextFillRect</span>(myContext, myRect4);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1>Shadows</h1>\n<h2>阴影的使用</h2>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">CGContextSaveGState</span>(context);</span><br><span class=\"line\"><span class=\"built_in\">CGContextSetShadow</span>(context, offsetsize, blur);  <span class=\"comment\">// offset：偏移量（UIKit下：x向右为正，y向下为正），blur：阴影量，颜色默认为（0, 0, 0, 1.0/3.0）</span></span><br><span class=\"line\"><span class=\"built_in\">CGContextSetShadowWithColor</span>(context, offsetsize, blur, color);</span><br><span class=\"line\"><span class=\"comment\">/* 其他绘图操作 */</span></span><br><span class=\"line\"><span class=\"built_in\">CGContextRestoreGState</span>(context);</span><br></pre></td></tr></table></figure>\n<h1>Gradients</h1>\n<p>Quartz 提供两种数据类型创建渐变色 – <em>CGShadingRef</em> 和 <em>CGGradientRef</em>。同时，这两种数据类型又可以分别创建轴向(axial)或者径向(radial)的渐变线。</p>\n<p>An axial gradient(a linear gradient) – 在定义的两个端点之间沿轴向变化，所有垂直于该轴向的直线上的点具有相同的色值。<br>\nA radial gradient – 在定义的两个端点（通常都是圆）之间沿轴向径向变化的填充，所有圆心落在轴线上圆的圆周上的点具有相同的色值，梯度的圆截面半径由两端半径确定，半径从一端到另一端呈线性变化。</p>\n<h2>CGShading 与 CGGradient 比较</h2>\n<p>CGShadingRef – 可以自己控制渐变中每个点颜色值的计算，非常细节。在创建CGShading对象之前，必须先创建CGFunction对象来定义梯度颜色计算的函数，自定义的函数可以更自由的创建更流畅的颜色梯度。</p>\n<p>CGRadientRef – 是CGShadingRef的子类，使用更加方便。Quartz为我们计算渐变中每个点的颜色，不需要我们提供计算函数，只需要提供作用域和颜色值，Quartz会自动计算每个连续位置的颜色梯度。</p>\n<h2>CGGradient</h2>\n<h3>轴向渐变线</h3>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">CGGradientRef</span> myGradient;</span><br><span class=\"line\"><span class=\"built_in\">CGColorSpaceRef</span> myColorspace;</span><br><span class=\"line\">size_t num_locations = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"built_in\">CGFloat</span> locations[<span class=\"number\">2</span>] = &#123; <span class=\"number\">0.0</span>, <span class=\"number\">1.0</span> &#125;;</span><br><span class=\"line\"><span class=\"built_in\">CGFloat</span> components[<span class=\"number\">8</span>] = &#123;</span><br><span class=\"line\">    <span class=\"number\">1.0</span>, <span class=\"number\">0.5</span>, <span class=\"number\">0.4</span>, <span class=\"number\">1.0</span>,  <span class=\"comment\">// Start color</span></span><br><span class=\"line\">    <span class=\"number\">0.8</span>, <span class=\"number\">0.8</span>, <span class=\"number\">0.3</span>, <span class=\"number\">1.0</span>   <span class=\"comment\">// End color</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">CGPoint</span> myStartPoint, myEndPoint;</span><br><span class=\"line\">myColorspace = <span class=\"built_in\">CGColorSpaceCreateWithName</span>(kCGColorSpaceGenericRGB);</span><br><span class=\"line\">myGradient = <span class=\"built_in\">CGGradientCreateWithColorComponents</span>(myColorspace, components, locations, num_locations);</span><br><span class=\"line\"><span class=\"built_in\">CGContextDrawLinearGradient</span>(context, myGradient, myStartPoint, myEndPoint, kCGGradientDrawsBeforeStartLocation | kCGGradientDrawsAfterEndLocation);</span><br></pre></td></tr></table></figure>\n<h3>径向渐变线</h3>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">CGGradientRef</span> myGradient;</span><br><span class=\"line\"><span class=\"built_in\">CGColorSpaceRef</span> myColorspace;</span><br><span class=\"line\">size_t num_locations = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"built_in\">CGFloat</span> locations[<span class=\"number\">2</span>] = &#123; <span class=\"number\">0.0</span>, <span class=\"number\">1.0</span> &#125;;</span><br><span class=\"line\"><span class=\"built_in\">CGFloat</span> components[<span class=\"number\">8</span>] = &#123;</span><br><span class=\"line\">    <span class=\"number\">1.0</span>, <span class=\"number\">0.5</span>, <span class=\"number\">0.4</span>, <span class=\"number\">1.0</span>,  <span class=\"comment\">// Start color</span></span><br><span class=\"line\">    <span class=\"number\">0.8</span>, <span class=\"number\">0.8</span>, <span class=\"number\">0.3</span>, <span class=\"number\">1.0</span>   <span class=\"comment\">// End color</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">CGFloat</span> myStartRadius, myEndRadius;</span><br><span class=\"line\"><span class=\"built_in\">CGPoint</span> myStartPoint, myEndPoint;</span><br><span class=\"line\">myColorspace = <span class=\"built_in\">CGColorSpaceCreateWithName</span>(kCGColorSpaceGenericRGB);</span><br><span class=\"line\">myGradient = <span class=\"built_in\">CGGradientCreateWithColorComponents</span>(myColorspace, components, locations, num_locations);</span><br><span class=\"line\"><span class=\"built_in\">CGContextDrawRadialGradient</span>(context, myGradient, myStartPoint, myStartRadius, myEndPoint, myEndRadius, <span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure>\n<h2>CGShading</h2>\n<p>暂不予考虑</p>\n<h1>Transparency Layers</h1>\n<p>当多个对象组合成复合图形，如何将复合图形视为单一对象，形成如同单一对象般的应用效果，这就要用到透明层这个概念。</p>\n<p><img src=\"/img/article/20190418/3.png\" alt=\"Transparency Layers\"></p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">CGContextSetShadow</span>(context, <span class=\"built_in\">CGSizeMake</span>(<span class=\"number\">10</span>, <span class=\"number\">20</span>), <span class=\"number\">10</span>);</span><br><span class=\"line\"><span class=\"built_in\">CGContextBeginTransparencyLayer</span>(context, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\"><span class=\"comment\">// your drawing code</span></span><br><span class=\"line\"><span class=\"built_in\">CGContextEndTransparencyLayer</span>(context);</span><br></pre></td></tr></table></figure>\n<h1>Ending</h1>\n<p>当然，Quartz 2D的内容不止这么多，我现在整理的也只是一些简单易用的皮毛，针对于 iOS 应用的一些简易图形绘制应该是没有问题了，总的说来，学无止境，后面可能要继续对Core Image的学习。</p>\n<h1>Reference</h1>\n<blockquote>\n<p><a href=\"https://developer.apple.com/library/archive/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/dq_overview/dq_overview.html#//apple_ref/doc/uid/TP30001066-CH202-TPXREF101\" target=\"_blank\" rel=\"noopener\">Quartz 2D Programming Guide</a></p>\n</blockquote>\n"},{"title":"细谈map，flatMap和compactMap","catalog":true,"toc_nav_num":true,"date":"2020-01-19T12:01:29.000Z","subtitle":"Talk About map, flatMap and compactMap","header-img":"/img/article_header/article_header.png","busuanzi":true,"_content":"\n# 前言\n\n`map`是Swift中常用的函数，同时它还有两个兄弟级函数`flatMap`和`compactMap`，下面就根据官方声明和源码来谈谈这个三个函数之间的联系和区别，加以深刻记忆。\n\n<!-- more -->\n\n# map\n\n首先是`map`函数的使用：\n\n``` swift\nlet nums = [1, 2, 3]\nlet res = nums.map { $0 + 1 }\nprint(res) // [2, 3, 4]\n```\n\n`map`函数接受一个闭包函数作为参数，他会遍历整个序列元素，并对每个元素执行闭包函数中定义的操作。\n\n然后我们再看下`map`函数的官方声明：\n\n``` swift\nfunc map<T>(_ transform: (Value) throws -> T) rethrows -> [T]\n```\n\n我们来稍微解释下这个声明的意思，所需参数`transform`的类型很明显是一个闭包类型：将`(Value)`（序列元素的类型）转换为类型`T`，最终返回一个`T`类型的序列。\n\n这就是`map`的初步了解，我们再看下一个。\n\n# flatMap\n\n`flatMap`的声明和使用有两种，让我们分别来讲解一下。\n\n先看第一种使用方法：\n\n``` swift\nlet nums = [[1, 2], [3, 4]]\nlet mapRes = nums.map { $0.map { $0 + 1 } }\nlet flatRes = nums.flatMap { $0.map { $0 + 1 } }\nprint(mapRes)  // [[2, 3], [4, 5]]\nprint(flatRes) // [2, 3, 4, 5]\n```\n\n这样我们就看出`map`和`flatMap`的区别了。\n\n我们看下`map`函数的官方声明：\n\n``` swift\nfunc flatMap<SegmentOfResult>(_ transform: (Value) throws -> SegmentOfResult) rethrows -> [SegmentOfResult.Element] where SegmentOfResult : Sequence\n```\n\n这个声明比`map`相比就长了很多，但我们可以将它转化一下：\n\n``` swift\nfunc flatMap<T>(_ transform: (Value) throws -> T) rethrows -> [T.Element] where T : Sequence\n```\n\n这么看其实就已经和`map`的声明差不多了，同时不同的地方表现在以下几个方面：`T`的类型有了约束，必须是继承`Sequence`协议，因为它的返回值也变成了`[T.Element]`，这个地方的关键点就是造成与`map`函数不同的地方。\n\n然后我们看下`flatMap`[源码部分](https://github.com/apple/swift/blob/master/stdlib/public/core/FlatMap.swift)：\n\n``` swift\nextension LazySequenceProtocol {\n  /// Returns the concatenated results of mapping the given transformation over\n  /// this sequence.\n  ///\n  /// Use this method to receive a single-level sequence when your\n  /// transformation produces a sequence or collection for each element.\n  /// Calling `flatMap(_:)` on a sequence `s` is equivalent to calling\n  /// `s.map(transform).joined()`.\n  ///\n  /// - Complexity: O(1)\n  @inlinable // lazy-performance\n  public func flatMap<SegmentOfResult>(\n    _ transform: @escaping (Elements.Element) -> SegmentOfResult\n  ) -> LazySequence<\n    FlattenSequence<LazyMapSequence<Elements, SegmentOfResult>>> {\n    return self.map(transform).joined()\n  }\n}\n```\n\n我们通过源码可以看出，`flatMap`函数本身也是调用了`map`函数，同时进行了`joined`操作，`joined`操作可以将序列包裹序列的元素重新组合成一个序列（只能拆第二层的序列，第三层的依旧是原类型），所以这就是`flatMap`函数的不同点。\n\n`flatMap`函数的另一种使用方式其实已经弃用，功能已经划分给`compactMap`函数，但我们可以看下它的声明：\n\n``` swift\n@available(swift, deprecated: 4.1, renamed: \"compactMap(_:)\", message: \"Please use compactMap(_:) for the case where closure returns an optional value\")\nfunc flatMap<ElementOfResult>(_ transform: (Value) throws -> ElementOfResult?) rethrows -> [ElementOfResult] // Deprecated\n```\n\n下面来看下`compactMap`函数。\n\n# compactMap\n\n使用方法：\n\n``` swift\nlet nums = [1, 2, nil, 3, 4]\nlet res = nums.compactMap { $0 }\nprint(res) // [1, 2, 3, 4]\n```\n\n如果使用`map`函数实现上面代码，会直接报错无法运行，但是`compactMap`函数不会报错，还会把`nil`剔除，同时可以将可选类型解包。这在实际场景中是个非常有用的机制，可以用条件闭包将非法或无效的内容过滤。\n\n然后我们先来看下`compactMap`的官方声明：\n\n``` swift\nfunc compactMap<ElementOfResult>(_ transform: (Value) throws -> ElementOfResult?) rethrows -> [ElementOfResult]\n```\n\n将它转化一下：\n\n``` swift\nfunc compactMap<T>(_ transform: (Value) throws -> T?) rethrows -> [T]\n```\n\n和`map`函数不同地方就在于`transform`闭包参数的返回值是`T`的可选类型，最终的返回结果是解包后的`[T]`。\n\n我们在根据[源码](https://github.com/apple/swift/blob/master/stdlib/public/core/FlatMap.swift)分析下它是如何筛选并解包的：\n\n``` swift\nextension LazySequenceProtocol {\n  /// Returns the non-`nil` results of mapping the given transformation over\n  /// this sequence.\n  ///\n  /// Use this method to receive a sequence of non-optional values when your\n  /// transformation produces an optional value.\n  ///\n  /// - Parameter transform: A closure that accepts an element of this sequence\n  ///   as its argument and returns an optional value.\n  ///\n  /// - Complexity: O(1)\n  @inlinable // lazy-performance\n  public func compactMap<ElementOfResult>(\n    _ transform: @escaping (Elements.Element) -> ElementOfResult?\n  ) -> LazyMapSequence<\n    LazyFilterSequence<\n      LazyMapSequence<Elements, ElementOfResult?>>,\n    ElementOfResult\n  > {\n    return self.map(transform).filter { $0 != nil }.map { $0! }\n  }\n}\n```\n\n非常容易理解，同样是调用了`map`函数，并调用`filter`函数进行非空筛选，最终进行解包。这也就不难理解`compactMap`函数的实现结果了。\n\n# 结语\n\n将这个三个函数剖析之后更加利于我们对于函数的理解，在实际场景中也能更好地根据对应情况使用不同的函数。","source":"_posts/2020/talk-about-map-flatmap-compactmap-0119.md","raw":"---\ntitle: \"细谈map，flatMap和compactMap\"\ncatalog: true\ntoc_nav_num: true\ndate: 2020-01-19 20:01:29\nsubtitle: \"Talk About map, flatMap and compactMap\"\nheader-img: \"/img/article_header/article_header.png\"\nbusuanzi: true\ntags:\n- iOS - Swift\n\n---\n\n# 前言\n\n`map`是Swift中常用的函数，同时它还有两个兄弟级函数`flatMap`和`compactMap`，下面就根据官方声明和源码来谈谈这个三个函数之间的联系和区别，加以深刻记忆。\n\n<!-- more -->\n\n# map\n\n首先是`map`函数的使用：\n\n``` swift\nlet nums = [1, 2, 3]\nlet res = nums.map { $0 + 1 }\nprint(res) // [2, 3, 4]\n```\n\n`map`函数接受一个闭包函数作为参数，他会遍历整个序列元素，并对每个元素执行闭包函数中定义的操作。\n\n然后我们再看下`map`函数的官方声明：\n\n``` swift\nfunc map<T>(_ transform: (Value) throws -> T) rethrows -> [T]\n```\n\n我们来稍微解释下这个声明的意思，所需参数`transform`的类型很明显是一个闭包类型：将`(Value)`（序列元素的类型）转换为类型`T`，最终返回一个`T`类型的序列。\n\n这就是`map`的初步了解，我们再看下一个。\n\n# flatMap\n\n`flatMap`的声明和使用有两种，让我们分别来讲解一下。\n\n先看第一种使用方法：\n\n``` swift\nlet nums = [[1, 2], [3, 4]]\nlet mapRes = nums.map { $0.map { $0 + 1 } }\nlet flatRes = nums.flatMap { $0.map { $0 + 1 } }\nprint(mapRes)  // [[2, 3], [4, 5]]\nprint(flatRes) // [2, 3, 4, 5]\n```\n\n这样我们就看出`map`和`flatMap`的区别了。\n\n我们看下`map`函数的官方声明：\n\n``` swift\nfunc flatMap<SegmentOfResult>(_ transform: (Value) throws -> SegmentOfResult) rethrows -> [SegmentOfResult.Element] where SegmentOfResult : Sequence\n```\n\n这个声明比`map`相比就长了很多，但我们可以将它转化一下：\n\n``` swift\nfunc flatMap<T>(_ transform: (Value) throws -> T) rethrows -> [T.Element] where T : Sequence\n```\n\n这么看其实就已经和`map`的声明差不多了，同时不同的地方表现在以下几个方面：`T`的类型有了约束，必须是继承`Sequence`协议，因为它的返回值也变成了`[T.Element]`，这个地方的关键点就是造成与`map`函数不同的地方。\n\n然后我们看下`flatMap`[源码部分](https://github.com/apple/swift/blob/master/stdlib/public/core/FlatMap.swift)：\n\n``` swift\nextension LazySequenceProtocol {\n  /// Returns the concatenated results of mapping the given transformation over\n  /// this sequence.\n  ///\n  /// Use this method to receive a single-level sequence when your\n  /// transformation produces a sequence or collection for each element.\n  /// Calling `flatMap(_:)` on a sequence `s` is equivalent to calling\n  /// `s.map(transform).joined()`.\n  ///\n  /// - Complexity: O(1)\n  @inlinable // lazy-performance\n  public func flatMap<SegmentOfResult>(\n    _ transform: @escaping (Elements.Element) -> SegmentOfResult\n  ) -> LazySequence<\n    FlattenSequence<LazyMapSequence<Elements, SegmentOfResult>>> {\n    return self.map(transform).joined()\n  }\n}\n```\n\n我们通过源码可以看出，`flatMap`函数本身也是调用了`map`函数，同时进行了`joined`操作，`joined`操作可以将序列包裹序列的元素重新组合成一个序列（只能拆第二层的序列，第三层的依旧是原类型），所以这就是`flatMap`函数的不同点。\n\n`flatMap`函数的另一种使用方式其实已经弃用，功能已经划分给`compactMap`函数，但我们可以看下它的声明：\n\n``` swift\n@available(swift, deprecated: 4.1, renamed: \"compactMap(_:)\", message: \"Please use compactMap(_:) for the case where closure returns an optional value\")\nfunc flatMap<ElementOfResult>(_ transform: (Value) throws -> ElementOfResult?) rethrows -> [ElementOfResult] // Deprecated\n```\n\n下面来看下`compactMap`函数。\n\n# compactMap\n\n使用方法：\n\n``` swift\nlet nums = [1, 2, nil, 3, 4]\nlet res = nums.compactMap { $0 }\nprint(res) // [1, 2, 3, 4]\n```\n\n如果使用`map`函数实现上面代码，会直接报错无法运行，但是`compactMap`函数不会报错，还会把`nil`剔除，同时可以将可选类型解包。这在实际场景中是个非常有用的机制，可以用条件闭包将非法或无效的内容过滤。\n\n然后我们先来看下`compactMap`的官方声明：\n\n``` swift\nfunc compactMap<ElementOfResult>(_ transform: (Value) throws -> ElementOfResult?) rethrows -> [ElementOfResult]\n```\n\n将它转化一下：\n\n``` swift\nfunc compactMap<T>(_ transform: (Value) throws -> T?) rethrows -> [T]\n```\n\n和`map`函数不同地方就在于`transform`闭包参数的返回值是`T`的可选类型，最终的返回结果是解包后的`[T]`。\n\n我们在根据[源码](https://github.com/apple/swift/blob/master/stdlib/public/core/FlatMap.swift)分析下它是如何筛选并解包的：\n\n``` swift\nextension LazySequenceProtocol {\n  /// Returns the non-`nil` results of mapping the given transformation over\n  /// this sequence.\n  ///\n  /// Use this method to receive a sequence of non-optional values when your\n  /// transformation produces an optional value.\n  ///\n  /// - Parameter transform: A closure that accepts an element of this sequence\n  ///   as its argument and returns an optional value.\n  ///\n  /// - Complexity: O(1)\n  @inlinable // lazy-performance\n  public func compactMap<ElementOfResult>(\n    _ transform: @escaping (Elements.Element) -> ElementOfResult?\n  ) -> LazyMapSequence<\n    LazyFilterSequence<\n      LazyMapSequence<Elements, ElementOfResult?>>,\n    ElementOfResult\n  > {\n    return self.map(transform).filter { $0 != nil }.map { $0! }\n  }\n}\n```\n\n非常容易理解，同样是调用了`map`函数，并调用`filter`函数进行非空筛选，最终进行解包。这也就不难理解`compactMap`函数的实现结果了。\n\n# 结语\n\n将这个三个函数剖析之后更加利于我们对于函数的理解，在实际场景中也能更好地根据对应情况使用不同的函数。","slug":"2020/talk-about-map-flatmap-compactmap-0119","published":1,"updated":"2022-01-10T09:04:52.811Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cky8gmc400009d1qh2w2bkwv1","content":"<h1 id=\"前言\">前言</h1>\n<p><code>map</code>是Swift中常用的函数，同时它还有两个兄弟级函数<code>flatMap</code>和<code>compactMap</code>，下面就根据官方声明和源码来谈谈这个三个函数之间的联系和区别，加以深刻记忆。</p>\n<a id=\"more\"></a>\n<h1 id=\"map\">map</h1>\n<p>首先是<code>map</code>函数的使用：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> nums = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]</span><br><span class=\"line\"><span class=\"keyword\">let</span> res = nums.<span class=\"built_in\">map</span> &#123; $<span class=\"number\">0</span> + <span class=\"number\">1</span> &#125;</span><br><span class=\"line\"><span class=\"built_in\">print</span>(res) <span class=\"comment\">// [2, 3, 4]</span></span><br></pre></td></tr></table></figure>\n<p><code>map</code>函数接受一个闭包函数作为参数，他会遍历整个序列元素，并对每个元素执行闭包函数中定义的操作。</p>\n<p>然后我们再看下<code>map</code>函数的官方声明：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">map</span>&lt;T&gt;<span class=\"params\">(<span class=\"number\">_</span> transform: <span class=\"params\">(Value)</span></span></span> <span class=\"keyword\">throws</span> -&gt; <span class=\"type\">T</span>) <span class=\"keyword\">rethrows</span> -&gt; [<span class=\"type\">T</span>]</span><br></pre></td></tr></table></figure>\n<p>我们来稍微解释下这个声明的意思，所需参数<code>transform</code>的类型很明显是一个闭包类型：将<code>(Value)</code>（序列元素的类型）转换为类型<code>T</code>，最终返回一个<code>T</code>类型的序列。</p>\n<p>这就是<code>map</code>的初步了解，我们再看下一个。</p>\n<h1 id=\"flatmap\">flatMap</h1>\n<p><code>flatMap</code>的声明和使用有两种，让我们分别来讲解一下。</p>\n<p>先看第一种使用方法：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> nums = [[<span class=\"number\">1</span>, <span class=\"number\">2</span>], [<span class=\"number\">3</span>, <span class=\"number\">4</span>]]</span><br><span class=\"line\"><span class=\"keyword\">let</span> mapRes = nums.<span class=\"built_in\">map</span> &#123; $<span class=\"number\">0</span>.<span class=\"built_in\">map</span> &#123; $<span class=\"number\">0</span> + <span class=\"number\">1</span> &#125; &#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> flatRes = nums.flatMap &#123; $<span class=\"number\">0</span>.<span class=\"built_in\">map</span> &#123; $<span class=\"number\">0</span> + <span class=\"number\">1</span> &#125; &#125;</span><br><span class=\"line\"><span class=\"built_in\">print</span>(mapRes)  <span class=\"comment\">// [[2, 3], [4, 5]]</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(flatRes) <span class=\"comment\">// [2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>\n<p>这样我们就看出<code>map</code>和<code>flatMap</code>的区别了。</p>\n<p>我们看下<code>map</code>函数的官方声明：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">flatMap</span>&lt;SegmentOfResult&gt;<span class=\"params\">(<span class=\"number\">_</span> transform: <span class=\"params\">(Value)</span></span></span> <span class=\"keyword\">throws</span> -&gt; <span class=\"type\">SegmentOfResult</span>) <span class=\"keyword\">rethrows</span> -&gt; [<span class=\"type\">SegmentOfResult</span>.<span class=\"type\">Element</span>] <span class=\"keyword\">where</span> <span class=\"type\">SegmentOfResult</span> : <span class=\"type\">Sequence</span></span><br></pre></td></tr></table></figure>\n<p>这个声明比<code>map</code>相比就长了很多，但我们可以将它转化一下：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">flatMap</span>&lt;T&gt;<span class=\"params\">(<span class=\"number\">_</span> transform: <span class=\"params\">(Value)</span></span></span> <span class=\"keyword\">throws</span> -&gt; <span class=\"type\">T</span>) <span class=\"keyword\">rethrows</span> -&gt; [<span class=\"type\">T</span>.<span class=\"type\">Element</span>] <span class=\"keyword\">where</span> <span class=\"type\">T</span> : <span class=\"type\">Sequence</span></span><br></pre></td></tr></table></figure>\n<p>这么看其实就已经和<code>map</code>的声明差不多了，同时不同的地方表现在以下几个方面：<code>T</code>的类型有了约束，必须是继承<code>Sequence</code>协议，因为它的返回值也变成了<code>[T.Element]</code>，这个地方的关键点就是造成与<code>map</code>函数不同的地方。</p>\n<p>然后我们看下<code>flatMap</code><a href=\"https://github.com/apple/swift/blob/master/stdlib/public/core/FlatMap.swift\" target=\"_blank\" rel=\"noopener\">源码部分</a>：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">LazySequenceProtocol</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">/// Returns the concatenated results of mapping the given transformation over</span></span><br><span class=\"line\">  <span class=\"comment\">/// this sequence.</span></span><br><span class=\"line\">  <span class=\"comment\">///</span></span><br><span class=\"line\">  <span class=\"comment\">/// Use this method to receive a single-level sequence when your</span></span><br><span class=\"line\">  <span class=\"comment\">/// transformation produces a sequence or collection for each element.</span></span><br><span class=\"line\">  <span class=\"comment\">/// Calling `flatMap(_:)` on a sequence `s` is equivalent to calling</span></span><br><span class=\"line\">  <span class=\"comment\">/// `s.map(transform).joined()`.</span></span><br><span class=\"line\">  <span class=\"comment\">///</span></span><br><span class=\"line\">  <span class=\"comment\">/// - Complexity: O(1)</span></span><br><span class=\"line\">  @inlinable <span class=\"comment\">// lazy-performance</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">flatMap</span>&lt;SegmentOfResult&gt;<span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    <span class=\"number\">_</span> transform: @escaping <span class=\"params\">(Elements.Element)</span></span></span> -&gt; <span class=\"type\">SegmentOfResult</span></span><br><span class=\"line\">  ) -&gt; <span class=\"type\">LazySequence</span>&lt;</span><br><span class=\"line\">    <span class=\"type\">FlattenSequence</span>&lt;<span class=\"type\">LazyMapSequence</span>&lt;<span class=\"type\">Elements</span>, <span class=\"type\">SegmentOfResult</span>&gt;&gt;&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>.<span class=\"built_in\">map</span>(transform).joined()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们通过源码可以看出，<code>flatMap</code>函数本身也是调用了<code>map</code>函数，同时进行了<code>joined</code>操作，<code>joined</code>操作可以将序列包裹序列的元素重新组合成一个序列（只能拆第二层的序列，第三层的依旧是原类型），所以这就是<code>flatMap</code>函数的不同点。</p>\n<p><code>flatMap</code>函数的另一种使用方式其实已经弃用，功能已经划分给<code>compactMap</code>函数，但我们可以看下它的声明：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@available</span>(swift, deprecated: <span class=\"number\">4.1</span>, renamed: <span class=\"string\">\"compactMap(_:)\"</span>, message: <span class=\"string\">\"Please use compactMap(_:) for the case where closure returns an optional value\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">flatMap</span>&lt;ElementOfResult&gt;<span class=\"params\">(<span class=\"number\">_</span> transform: <span class=\"params\">(Value)</span></span></span> <span class=\"keyword\">throws</span> -&gt; <span class=\"type\">ElementOfResult</span>?) <span class=\"keyword\">rethrows</span> -&gt; [<span class=\"type\">ElementOfResult</span>] <span class=\"comment\">// Deprecated</span></span><br></pre></td></tr></table></figure>\n<p>下面来看下<code>compactMap</code>函数。</p>\n<h1 id=\"compactmap\">compactMap</h1>\n<p>使用方法：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> nums = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"literal\">nil</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>]</span><br><span class=\"line\"><span class=\"keyword\">let</span> res = nums.compactMap &#123; $<span class=\"number\">0</span> &#125;</span><br><span class=\"line\"><span class=\"built_in\">print</span>(res) <span class=\"comment\">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>\n<p>如果使用<code>map</code>函数实现上面代码，会直接报错无法运行，但是<code>compactMap</code>函数不会报错，还会把<code>nil</code>剔除，同时可以将可选类型解包。这在实际场景中是个非常有用的机制，可以用条件闭包将非法或无效的内容过滤。</p>\n<p>然后我们先来看下<code>compactMap</code>的官方声明：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">compactMap</span>&lt;ElementOfResult&gt;<span class=\"params\">(<span class=\"number\">_</span> transform: <span class=\"params\">(Value)</span></span></span> <span class=\"keyword\">throws</span> -&gt; <span class=\"type\">ElementOfResult</span>?) <span class=\"keyword\">rethrows</span> -&gt; [<span class=\"type\">ElementOfResult</span>]</span><br></pre></td></tr></table></figure>\n<p>将它转化一下：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">compactMap</span>&lt;T&gt;<span class=\"params\">(<span class=\"number\">_</span> transform: <span class=\"params\">(Value)</span></span></span> <span class=\"keyword\">throws</span> -&gt; <span class=\"type\">T</span>?) <span class=\"keyword\">rethrows</span> -&gt; [<span class=\"type\">T</span>]</span><br></pre></td></tr></table></figure>\n<p>和<code>map</code>函数不同地方就在于<code>transform</code>闭包参数的返回值是<code>T</code>的可选类型，最终的返回结果是解包后的<code>[T]</code>。</p>\n<p>我们在根据<a href=\"https://github.com/apple/swift/blob/master/stdlib/public/core/FlatMap.swift\" target=\"_blank\" rel=\"noopener\">源码</a>分析下它是如何筛选并解包的：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">LazySequenceProtocol</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">/// Returns the non-`nil` results of mapping the given transformation over</span></span><br><span class=\"line\">  <span class=\"comment\">/// this sequence.</span></span><br><span class=\"line\">  <span class=\"comment\">///</span></span><br><span class=\"line\">  <span class=\"comment\">/// Use this method to receive a sequence of non-optional values when your</span></span><br><span class=\"line\">  <span class=\"comment\">/// transformation produces an optional value.</span></span><br><span class=\"line\">  <span class=\"comment\">///</span></span><br><span class=\"line\">  <span class=\"comment\">/// - Parameter transform: A closure that accepts an element of this sequence</span></span><br><span class=\"line\">  <span class=\"comment\">///   as its argument and returns an optional value.</span></span><br><span class=\"line\">  <span class=\"comment\">///</span></span><br><span class=\"line\">  <span class=\"comment\">/// - Complexity: O(1)</span></span><br><span class=\"line\">  @inlinable <span class=\"comment\">// lazy-performance</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">compactMap</span>&lt;ElementOfResult&gt;<span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    <span class=\"number\">_</span> transform: @escaping <span class=\"params\">(Elements.Element)</span></span></span> -&gt; <span class=\"type\">ElementOfResult</span>?</span><br><span class=\"line\">  ) -&gt; <span class=\"type\">LazyMapSequence</span>&lt;</span><br><span class=\"line\">    <span class=\"type\">LazyFilterSequence</span>&lt;</span><br><span class=\"line\">      <span class=\"type\">LazyMapSequence</span>&lt;<span class=\"type\">Elements</span>, <span class=\"type\">ElementOfResult</span>?&gt;&gt;,</span><br><span class=\"line\">    <span class=\"type\">ElementOfResult</span></span><br><span class=\"line\">  &gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>.<span class=\"built_in\">map</span>(transform).<span class=\"built_in\">filter</span> &#123; $<span class=\"number\">0</span> != <span class=\"literal\">nil</span> &#125;.<span class=\"built_in\">map</span> &#123; $<span class=\"number\">0</span>! &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>非常容易理解，同样是调用了<code>map</code>函数，并调用<code>filter</code>函数进行非空筛选，最终进行解包。这也就不难理解<code>compactMap</code>函数的实现结果了。</p>\n<h1 id=\"结语\">结语</h1>\n<p>将这个三个函数剖析之后更加利于我们对于函数的理解，在实际场景中也能更好地根据对应情况使用不同的函数。</p>\n","site":{"data":{}},"excerpt":"<h1>前言</h1>\n<p><code>map</code>是Swift中常用的函数，同时它还有两个兄弟级函数<code>flatMap</code>和<code>compactMap</code>，下面就根据官方声明和源码来谈谈这个三个函数之间的联系和区别，加以深刻记忆。</p>","more":"<h1>map</h1>\n<p>首先是<code>map</code>函数的使用：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> nums = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]</span><br><span class=\"line\"><span class=\"keyword\">let</span> res = nums.<span class=\"built_in\">map</span> &#123; $<span class=\"number\">0</span> + <span class=\"number\">1</span> &#125;</span><br><span class=\"line\"><span class=\"built_in\">print</span>(res) <span class=\"comment\">// [2, 3, 4]</span></span><br></pre></td></tr></table></figure>\n<p><code>map</code>函数接受一个闭包函数作为参数，他会遍历整个序列元素，并对每个元素执行闭包函数中定义的操作。</p>\n<p>然后我们再看下<code>map</code>函数的官方声明：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">map</span>&lt;T&gt;<span class=\"params\">(<span class=\"number\">_</span> transform: <span class=\"params\">(Value)</span></span></span> <span class=\"keyword\">throws</span> -&gt; <span class=\"type\">T</span>) <span class=\"keyword\">rethrows</span> -&gt; [<span class=\"type\">T</span>]</span><br></pre></td></tr></table></figure>\n<p>我们来稍微解释下这个声明的意思，所需参数<code>transform</code>的类型很明显是一个闭包类型：将<code>(Value)</code>（序列元素的类型）转换为类型<code>T</code>，最终返回一个<code>T</code>类型的序列。</p>\n<p>这就是<code>map</code>的初步了解，我们再看下一个。</p>\n<h1>flatMap</h1>\n<p><code>flatMap</code>的声明和使用有两种，让我们分别来讲解一下。</p>\n<p>先看第一种使用方法：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> nums = [[<span class=\"number\">1</span>, <span class=\"number\">2</span>], [<span class=\"number\">3</span>, <span class=\"number\">4</span>]]</span><br><span class=\"line\"><span class=\"keyword\">let</span> mapRes = nums.<span class=\"built_in\">map</span> &#123; $<span class=\"number\">0</span>.<span class=\"built_in\">map</span> &#123; $<span class=\"number\">0</span> + <span class=\"number\">1</span> &#125; &#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> flatRes = nums.flatMap &#123; $<span class=\"number\">0</span>.<span class=\"built_in\">map</span> &#123; $<span class=\"number\">0</span> + <span class=\"number\">1</span> &#125; &#125;</span><br><span class=\"line\"><span class=\"built_in\">print</span>(mapRes)  <span class=\"comment\">// [[2, 3], [4, 5]]</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(flatRes) <span class=\"comment\">// [2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>\n<p>这样我们就看出<code>map</code>和<code>flatMap</code>的区别了。</p>\n<p>我们看下<code>map</code>函数的官方声明：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">flatMap</span>&lt;SegmentOfResult&gt;<span class=\"params\">(<span class=\"number\">_</span> transform: <span class=\"params\">(Value)</span></span></span> <span class=\"keyword\">throws</span> -&gt; <span class=\"type\">SegmentOfResult</span>) <span class=\"keyword\">rethrows</span> -&gt; [<span class=\"type\">SegmentOfResult</span>.<span class=\"type\">Element</span>] <span class=\"keyword\">where</span> <span class=\"type\">SegmentOfResult</span> : <span class=\"type\">Sequence</span></span><br></pre></td></tr></table></figure>\n<p>这个声明比<code>map</code>相比就长了很多，但我们可以将它转化一下：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">flatMap</span>&lt;T&gt;<span class=\"params\">(<span class=\"number\">_</span> transform: <span class=\"params\">(Value)</span></span></span> <span class=\"keyword\">throws</span> -&gt; <span class=\"type\">T</span>) <span class=\"keyword\">rethrows</span> -&gt; [<span class=\"type\">T</span>.<span class=\"type\">Element</span>] <span class=\"keyword\">where</span> <span class=\"type\">T</span> : <span class=\"type\">Sequence</span></span><br></pre></td></tr></table></figure>\n<p>这么看其实就已经和<code>map</code>的声明差不多了，同时不同的地方表现在以下几个方面：<code>T</code>的类型有了约束，必须是继承<code>Sequence</code>协议，因为它的返回值也变成了<code>[T.Element]</code>，这个地方的关键点就是造成与<code>map</code>函数不同的地方。</p>\n<p>然后我们看下<code>flatMap</code><a href=\"https://github.com/apple/swift/blob/master/stdlib/public/core/FlatMap.swift\" target=\"_blank\" rel=\"noopener\">源码部分</a>：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">LazySequenceProtocol</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">/// Returns the concatenated results of mapping the given transformation over</span></span><br><span class=\"line\">  <span class=\"comment\">/// this sequence.</span></span><br><span class=\"line\">  <span class=\"comment\">///</span></span><br><span class=\"line\">  <span class=\"comment\">/// Use this method to receive a single-level sequence when your</span></span><br><span class=\"line\">  <span class=\"comment\">/// transformation produces a sequence or collection for each element.</span></span><br><span class=\"line\">  <span class=\"comment\">/// Calling `flatMap(_:)` on a sequence `s` is equivalent to calling</span></span><br><span class=\"line\">  <span class=\"comment\">/// `s.map(transform).joined()`.</span></span><br><span class=\"line\">  <span class=\"comment\">///</span></span><br><span class=\"line\">  <span class=\"comment\">/// - Complexity: O(1)</span></span><br><span class=\"line\">  @inlinable <span class=\"comment\">// lazy-performance</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">flatMap</span>&lt;SegmentOfResult&gt;<span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    <span class=\"number\">_</span> transform: @escaping <span class=\"params\">(Elements.Element)</span></span></span> -&gt; <span class=\"type\">SegmentOfResult</span></span><br><span class=\"line\">  ) -&gt; <span class=\"type\">LazySequence</span>&lt;</span><br><span class=\"line\">    <span class=\"type\">FlattenSequence</span>&lt;<span class=\"type\">LazyMapSequence</span>&lt;<span class=\"type\">Elements</span>, <span class=\"type\">SegmentOfResult</span>&gt;&gt;&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>.<span class=\"built_in\">map</span>(transform).joined()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们通过源码可以看出，<code>flatMap</code>函数本身也是调用了<code>map</code>函数，同时进行了<code>joined</code>操作，<code>joined</code>操作可以将序列包裹序列的元素重新组合成一个序列（只能拆第二层的序列，第三层的依旧是原类型），所以这就是<code>flatMap</code>函数的不同点。</p>\n<p><code>flatMap</code>函数的另一种使用方式其实已经弃用，功能已经划分给<code>compactMap</code>函数，但我们可以看下它的声明：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@available</span>(swift, deprecated: <span class=\"number\">4.1</span>, renamed: <span class=\"string\">\"compactMap(_:)\"</span>, message: <span class=\"string\">\"Please use compactMap(_:) for the case where closure returns an optional value\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">flatMap</span>&lt;ElementOfResult&gt;<span class=\"params\">(<span class=\"number\">_</span> transform: <span class=\"params\">(Value)</span></span></span> <span class=\"keyword\">throws</span> -&gt; <span class=\"type\">ElementOfResult</span>?) <span class=\"keyword\">rethrows</span> -&gt; [<span class=\"type\">ElementOfResult</span>] <span class=\"comment\">// Deprecated</span></span><br></pre></td></tr></table></figure>\n<p>下面来看下<code>compactMap</code>函数。</p>\n<h1>compactMap</h1>\n<p>使用方法：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> nums = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"literal\">nil</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>]</span><br><span class=\"line\"><span class=\"keyword\">let</span> res = nums.compactMap &#123; $<span class=\"number\">0</span> &#125;</span><br><span class=\"line\"><span class=\"built_in\">print</span>(res) <span class=\"comment\">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>\n<p>如果使用<code>map</code>函数实现上面代码，会直接报错无法运行，但是<code>compactMap</code>函数不会报错，还会把<code>nil</code>剔除，同时可以将可选类型解包。这在实际场景中是个非常有用的机制，可以用条件闭包将非法或无效的内容过滤。</p>\n<p>然后我们先来看下<code>compactMap</code>的官方声明：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">compactMap</span>&lt;ElementOfResult&gt;<span class=\"params\">(<span class=\"number\">_</span> transform: <span class=\"params\">(Value)</span></span></span> <span class=\"keyword\">throws</span> -&gt; <span class=\"type\">ElementOfResult</span>?) <span class=\"keyword\">rethrows</span> -&gt; [<span class=\"type\">ElementOfResult</span>]</span><br></pre></td></tr></table></figure>\n<p>将它转化一下：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">compactMap</span>&lt;T&gt;<span class=\"params\">(<span class=\"number\">_</span> transform: <span class=\"params\">(Value)</span></span></span> <span class=\"keyword\">throws</span> -&gt; <span class=\"type\">T</span>?) <span class=\"keyword\">rethrows</span> -&gt; [<span class=\"type\">T</span>]</span><br></pre></td></tr></table></figure>\n<p>和<code>map</code>函数不同地方就在于<code>transform</code>闭包参数的返回值是<code>T</code>的可选类型，最终的返回结果是解包后的<code>[T]</code>。</p>\n<p>我们在根据<a href=\"https://github.com/apple/swift/blob/master/stdlib/public/core/FlatMap.swift\" target=\"_blank\" rel=\"noopener\">源码</a>分析下它是如何筛选并解包的：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">LazySequenceProtocol</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">/// Returns the non-`nil` results of mapping the given transformation over</span></span><br><span class=\"line\">  <span class=\"comment\">/// this sequence.</span></span><br><span class=\"line\">  <span class=\"comment\">///</span></span><br><span class=\"line\">  <span class=\"comment\">/// Use this method to receive a sequence of non-optional values when your</span></span><br><span class=\"line\">  <span class=\"comment\">/// transformation produces an optional value.</span></span><br><span class=\"line\">  <span class=\"comment\">///</span></span><br><span class=\"line\">  <span class=\"comment\">/// - Parameter transform: A closure that accepts an element of this sequence</span></span><br><span class=\"line\">  <span class=\"comment\">///   as its argument and returns an optional value.</span></span><br><span class=\"line\">  <span class=\"comment\">///</span></span><br><span class=\"line\">  <span class=\"comment\">/// - Complexity: O(1)</span></span><br><span class=\"line\">  @inlinable <span class=\"comment\">// lazy-performance</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">compactMap</span>&lt;ElementOfResult&gt;<span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    <span class=\"number\">_</span> transform: @escaping <span class=\"params\">(Elements.Element)</span></span></span> -&gt; <span class=\"type\">ElementOfResult</span>?</span><br><span class=\"line\">  ) -&gt; <span class=\"type\">LazyMapSequence</span>&lt;</span><br><span class=\"line\">    <span class=\"type\">LazyFilterSequence</span>&lt;</span><br><span class=\"line\">      <span class=\"type\">LazyMapSequence</span>&lt;<span class=\"type\">Elements</span>, <span class=\"type\">ElementOfResult</span>?&gt;&gt;,</span><br><span class=\"line\">    <span class=\"type\">ElementOfResult</span></span><br><span class=\"line\">  &gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>.<span class=\"built_in\">map</span>(transform).<span class=\"built_in\">filter</span> &#123; $<span class=\"number\">0</span> != <span class=\"literal\">nil</span> &#125;.<span class=\"built_in\">map</span> &#123; $<span class=\"number\">0</span>! &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>非常容易理解，同样是调用了<code>map</code>函数，并调用<code>filter</code>函数进行非空筛选，最终进行解包。这也就不难理解<code>compactMap</code>函数的实现结果了。</p>\n<h1>结语</h1>\n<p>将这个三个函数剖析之后更加利于我们对于函数的理解，在实际场景中也能更好地根据对应情况使用不同的函数。</p>"},{"title":"图形渲染与动画基础 -- Core Animation","catalog":true,"toc_nav_num":true,"date":"2019-05-03T07:30:10.000Z","subtitle":"About Core Animation","header-img":"/img/article_header/article_header.png","busuanzi":true,"_content":"\n# Introduction\n\nCore Animation是iOS与OS X平台上的图形渲染和动画基础设施，可以在应用中使视图和其他可见元素产生动画。使用Core Animation，绘制动画的每一帧所需的大部分工作都已经实现。我们所需要做的是配置少量动画参数同时启动动画，Core Animation会完成其余部分，将大部分实际绘图工作交给图形硬件实现加速渲染，这种自动图形加速产生高帧率平滑的动画而不会负担CPU和使应用卡顿。\n当我们在写iOS代码时，不管是否知道我们都在使用Core Animation，如果是OS X，则可以非常轻松的利用Core Animation。Core Animation位于AppKit和UIKit下，被紧密集成到Cocoa和Cocoa Touch的视图流中。当然，Core Animation也有一些应用视图暴露的扩展功能接口，可以让我们更细致控制应用程序的动画。\n\n![Core Animation](/img/article/20190503/1.png)\n\n# Core Animation Basics\n\nCore Animation提供一个视图和其他可见元素动画的通用系统，它不是View的替代品，相反，他是一种与视图结合，提供更好性能、为视图提供动画的技术。它将视图的内容缓存到可以直接被图形硬件操作的位图中，在一些情况下，这个缓存操作可能会让我们重新思考我们如何呈现和管理我们的应用内容，但是大多数情况我们不需要知道。除了缓存视图内容，Core Animation同样定义了一种方式，指定任意可视内容，结合视图上的内容，让他和其他任意东西一起动起来。\n\n## Layers提供绘图与动画的基础\n\nLayer对象是三维空间中的二维表面，是Core Animation所做事情的核心。与View一样的是，层级管理其表面的几何、内容、视觉属性信息。与View不同的是，层级不定义他们自己的外观。一个层级仅仅管理位图周围的状态信息，位图本身可以是视图绘制本身的结果，也可以是指定的固定图形的结果。因此，应用中的主要层级被被认为是模型对象，因为他们主要管理数据。这个概念很重要，因为他们影响到动画表现。\n\n### 层级绘制模型\n\n多数层级不是真的绘图，相反，一个Layer捕获内容然后缓存到位图，有时也被称为**后备存储器**。当我们修改一个层级的属性，我们所做的只是修改关联层级的状态信息。当一项改变触发动画，Core Animation将层级的位图和状态信息传递给图形硬件，图形硬件使用新的信息渲染位图。在硬件中操作位图比在软件中可以更快的生成动画。\n\n![How Core Animation draws content](/img/article/20190503/2.png)\n\n因为它操作静态位图，图层绘图与更传统的视图绘图有很大的不同。使用视图绘图，视图本身的修改经常会出发`drawRect:`方法的调用，使用新参数重新绘制内容，但这种方式绘图代价很高因为是在主线程使用CPU完成的。Core Animation尽可能通过在硬件中操作缓存位图来达到相同或类似的效果，以此避免这种开销。\n\n尽管Core Animation尽可能地使用缓存内容，但应用任然必须提供初始内容并不时更新。\n\n### 层级动画\n\n层对象的数据和状态信息与改层内容在屏幕上的可视化表现相互解耦，这种解耦为Core Animation提供的一种方法，使它自我干预，并创建新旧状态的动画。例如，修改一个层级的位置属性会使Core Animation移动层级从当前位置到新状态的位置。\n\n![Examples of animations I can perform on layers](/img/article/20190503/3.png)\n\n在动画制作过程中，Core Animation会在硬件上逐帧完成绘图。我们所要做的就是指定动画的起点与终点，让Core Animation完成剩下的工作，如有必要，可以同样指定自定义的时间信息和动画参数，如果不提供，Core Animation有合适的默认值。\n\n## 层级对象定义自身的几何结构\n\n一个层级的工作就是管理内容的视觉几何结构，视觉几何结构由内容的bounds，屏幕上的位置信息，是否旋转、缩放、位移的信息构成。和View一样，层级有frame和bounds来定位位置，同样，层级也有View没有的属性，比如锚点坐标。指定层级几何的某些方面的方式也和视图指定信息的方式不同。\n\n### Layers使用两种坐标系统\n\nLayers同时使用point-based坐标系和unit坐标系来指定内容的位置。使用哪种坐标系统根据传递信息的类型。当指定直接映射到屏幕坐标系的值或者必须相对于另一个层级的指定，就需要用point-based坐标系，比如一个层级的位置属性。当值与屏幕坐标系无关时使用unit坐标系，比如层级的锚点属性，指定相对于层级自身边界的点。\n\npoint-based坐标系最常见的使用就是指定曾记得大小（bounds）和位置（position）属性，当然也有frame属性，这个属性是由boudns和position属性中派生出来的值，使用频率较低。bounds和frame的坐标系方向：\n\n![The default layer geometries for iOS and OS X](/img/article/20190503/4.png)\n\n图中的position属性在层级的中点位置，这个属性是根据层级锚点属性中的值更改定义的几个属性之一。锚点是几个使用unit坐标系的属性之一，Core Animation使用unit坐标系表示在层级大小修改时可能受影响的属性，我们可以将unit坐标系看作是总值的百分比，每个unit坐标系中的值在0.0-1.0之间。\n\n![The default unit coordinate systems for iOS and OS X](/img/article/20190503/5.png)\n\n### 锚点坐标影响几何操作\n\n一个层级的相关几何操作的发生与层级的锚点相关，我们可以使用锚点属性访问。当操作层级的位置或位移属性时，锚点的作用会更加可见。下图展示了锚点的改变对位置属性的改变：\n\n![How the anchor point affects the layer's position property](/img/article/20190503/6.png)\n\n下图是锚点对于旋转属性的影响：\n\n![How the anchor point affects layer transformations](/img/article/20190503/7.png)\n\n## 层级树反应出动画状态的不同方面\n\n一个使用Core Animation的应用有三种层级对象：\n- Objects in the model layer tree：应用中互动最多的层级，模型对象存储动画的目标值，当我们改变层级的属性时，就使用这个对象\n- Objects in the presentation tree：包含运行动画中的值，虽然模型层级树包含动画的目标值，但是呈现层级树反应动画的当前值。我们不应该修改这个值\n- Objects in the render tree：真正动画实现的层级，Core Animation的私有对象\n\n每个层级对象被组织成已给层级结构，和应用中的视图一样。事实上，当为所有视图启用层级，每个树的层级结构与视图结构完全匹配。但是，一个应用可以添加额外的层级对象，层级和视图并不是相匹配的。在某些情况下，我们可能会这样这样操作来优化不需要视图而造成的开销。\n\n![The layer trees for a window](/img/article/20190503/8.png)\n\n\n## Layers与Views的关系\n\nLayers不能代替Views--我们不能基于层级对象创建可视界面。Layers为Views提供基础，具体地说，Layers可以使视图内容的绘制与动画更加简单有效的同时保证高帧率。当然，Layers不能处理事件，绘制内容，参与响应链等等。\n\n# Settign Up Layer Objects\n\nLayer对象是Core Animation的核心，层级管理应用的可见内容和提供修改样式和可见外观的选项。\n\n## 修改View的Layer对象\n\niOS默认情况下，View会自动创建CALayer类的实例，大多数情况下我们不需要其他类型的层积类。但是，Core Animation提供了不同的层级类，提供可能对我们有用的层级类。[不同的Layer](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CoreAnimation_guide/SettingUpLayerObjects/SettingUpLayerObjects.html#//apple_ref/doc/uid/TP40004514-CH13-SW25)\n\n修改View的Layer类型：\n``` Swift\noverride var layer: CALayer {\n    return CAShapeLayer()\n}\n```\n\n## 提供Layer的Content\n\nLayers是管理内容的数据对象，一个层级的内容包含我们想要展示可视数据的位图，有以下三种方式提供位图的内容：\n- 直接给`contents`属性赋值（适用于层级内容基本不会改变的情况）\n- 实现Layer的代理方法完成内容的绘制（适用于层级内容可能周期性改变并且可以有外部对象提供，比如View）\n- 定义一个Layer的子类同时复写`drawing`方法来自己提供内容（适用于自定义Layer子类或者想要改变层级的基本会话操作）\n\n### Content赋值图片\n\n因为一个层级只是管理位图的容器，我们可以直接给`Contents`属性赋值图片。层级可以直接使用提供的图片，而不用拷贝一份图片，这个操作可以让图片在不同地方使用时节约内存。赋值的图片类型必须是*CGImageRef*类型，同时图片的分辨率要适配原生设备。允许的话，需要适当调整图片的`ContentsScale`属性。\n\n### 通过代理提供Content\n\n如果需要动态修改层级的Content，我们可以使用提供的代理。在显示时，层级会调用以下代理方法：\n- `displayLayer:`方法，该实现负责创建位图并将其分配给`contents`属性\n- `drawLayer:inContext:`方法，Core Animation创建一个位图，创建一个图形上下文来绘制位图，然后调用这个方法填充位图。这个方法就是在提供的图形上下文绘图。\n\n代理必须实现`displayLayer:`和`drawLayer:inContext`两种方法之一，如果同时实现，只会调用`displayLayer`方法。\n\n当应用程序是在想要显示的地方加载或创建位图时，复写`displayLayer:`方法更加合适：\n``` objectivec\n- (void)displayLayer:(CALayer *)theLayer {\n    // Check the value of some state property\n    if (self.displayYesImage) {\n        // Display the Yes image\n        theLayer.contents = [someHelperObject loadStateYesImage];\n    }\n    else {\n        // Display the No image\n        theLayer.contents = [someHelperObject loadStateNoImage];\n    }\n}\n```\n\n> PS：本来这边有个问题，但是后面苹果也自己概述了，对于UIKit下的视图（层支持），我们直接用默认的`drawRect`方法进行绘制内容。而对于OS X环境下，Layer与View不是直接相关联的，`drawRect`与`drawLayer`方法两者之间的区别。`drawRect`是View的视图渲染方法，`drawLayer`是Layer的代理方法，两者都可以绘图。目前的调用机制是这样：同时实现两个方法会只调用`drawLayer`里的实现；无法单独实现`drawLayer`方法，必须空实现`drawRect`方法；`drawLayer`方法也可以由`setNeedsDisplay`方法调用，同`drawRect`方法一样。两者用法的区别：是否需要获取视图在动画过程中的Layer属性，`drawLayer`方法中实现的内容可以实时获取Layer的属性值，`drawRect`方法只能获取Layer的结果值。[是否对仍待考究](https://stackoverflow.com/questions/4979192/ios-using-uiviews-drawrect-vs-its-layers-delegate-drawlayerincontext/36050120#36050120)\n\n如果没有预先编码的图片或者对象来创建位图，可以使用`drawLayer`方法动态绘制内容：\n``` objectivec\n- (void)drawLayer:(CALayer *)theLayer inContext:(CGContextRef)theContext {\n    CGMutablePathRef thePath = CGPathCreateMutable();\n \n    CGPathMoveToPoint(thePath,NULL,15.0f,15.f);\n    CGPathAddCurveToPoint(thePath,\n                          NULL,\n                          15.f,250.0f,\n                          295.0f,250.0f,\n                          295.0f,15.0f);\n \n    CGContextBeginPath(theContext);\n    CGContextAddPath(theContext, thePath);\n \n    CGContextSetLineWidth(theContext, 5);\n    CGContextStrokePath(theContext);\n \n    // Release the path\n    CFRelease(thePath);\n}\n```\n\n对于带有自定义内容的层支持视图，我们应该继续复写视图方法来进行绘图。层支持的绘图自动使自己成为其层的委托，并实现委托所需的委托方法，我们不应该更改这个配置，所以，对于UIView我们还是实现`drawRect`方法来绘制内容.\n\n### 通过子类提供Content\n\n当实现一个自定义Layer类时，我们可以复写Layer类的绘图方法来进行任何绘图：\n- 复写`display`方法，直接设置`contents`属性\n- 复写`drawInContext:`方法，在提供的图形上下文绘制\n\n### 调整Content\n\n当我们设置一个图层的`contents`属性时，`contentsGravity`属性决定了如何操作该图片来适应边界。默认情况下，如果一张图片大于当前边界，图层对象会缩放图片以适应可用空间。如果图层边界的宽高比与图像的宽高比不同，就会导致图像的失真。\n`contentsGravity`属性可以被分为以下两类：\n- 基于位置的重力常量允许我们将图片固定在边缘或角落上，无需缩放图片\n- 基于缩放的重力常量允许我们使用几种选项之一来拉伸图像，可以保持宽高比，也可以拉伸\n\nPosition-based gravity constants for layers:\n![Position-based gravity constants for layers](/img/article/20190503/9.png)\n\nScaling-based gravity constants for layers:\n![Scaling-based gravity constants for layers](/img/article/20190503/10.png)\n\n## 调整Layer的视觉样式和外观\n\n层级对象内置视觉装饰，比如边框、背景色，我们可以用来补充图层的内容。因为这些视觉装饰不需要我们做渲染，所以在某些情况下可以将层作为独立实体使用。我们需要做的就是设置属性，层级会处理必要的绘画，包括动画。\n\n### Layers有自己的背景和边框\n\n除了基于图像的内容外，层级可以显示填充背景和边框。背景色在层级内容图片背后渲染，边框在图片上面渲染，如果层级包含子层级，他们也在边框下面。因为背景色位于图像后面，所以这种颜色通过图像的任何透明部分发光。\n\n如果设置不透明的背景色，考虑设置层级的`opaque`属性为YES，这样做可以在屏幕上合成图层时提高性能，就不需要使用图层的后备存储来管理alpha通道。但是，如果一个层的角半价不为零，则不能设为不透明。\n\n### Layers支持倒角\n\n我们可以为层级创建一个圆角矩形效果，倒角是一种视觉装饰，它掩盖了层级边界矩形的部分角，允许底层内容显示。因为它涉及到透明层蒙版，除非`maskToBounds`属性设置为YES，否则倒角不会影响图层图像。但是，倒角总是影响图层的背景颜色和边框的绘制。\n\n### Layers支持内置阴影\n\nCALayer类包含几种配置阴影效果的属性。阴影通过增加深度使其看起来像漂浮在底层内容之上，这是另一种类型的视觉装饰。我们可以控制阴影颜色，相对于图层内容的位置，不透明度和形状。\n\n层级阴影的不透明度默认为0，这样可以有效地隐藏阴影。将不透明度修改为非零值会使Core Animation绘制阴影。因为阴影默认直接位于层级的最下方，所以需要更改阴影的偏移量才能看到它。但是务必记住，阴影的偏移量是使用图层的本机坐标系。\n\n![Applying a shadow to a layer](/img/article/20190503/11.png)\n\n当向图层添加阴影时，阴影是图层内容的一部分，但实际上扩展到图层的边界之外，所以，当图层启用`maskToBounds`属性时，阴影效果会被剪切到边缘。如果图层包含透明内容，这是会产生一个奇怪的效果，直接在图层下面的阴影部分仍然是可见的，但是超出部分不可见。所以，这是如果想要一个阴影，但也想用`maskTobounds`属性，我们可以使用两层层级，将该图层嵌入到相同大小应用阴影效果的图层中去。\n\n# Animating Layer Content\n\nCore Animation提供的基础设施可以让我们更加容易的创建层级动画，扩展到拥有层级的所有视图。\n\n## 对图层属性的简单修改动画\n\n简单动画包含隐式动画和显示动画。隐式动画使用默认的时间和动画属性，显式动画需要提供属性的配置。简单动画包含修改层级属性，在时间内完成动画，层级定义了很多影响可见外观的属性，改变其中一个属性会让其产生外观动画。\n\n只需要更新层级属性就能触发隐式动画，层级的视觉外观不会立即改变，相反，Core Animation会根据属性变化作为触发器来创建调度一个或多个隐式动画执行。因此，像如下代码所示的改变会让Core Animation创建一个动画对象，并在下一个更新周期执行动画。\n\n``` Swift\ntheLayer.opacity = 0.0\n```\n\n如果想要显式做出如上改变可以创建*CABasicAnimation*对象同时配置动画参数，可以在添加动画前设置动画的起始与结束值，改变持续时间，或者修改其他动画参数。下面代码展示了如何使用一个对话对象淡化一个层级，创建对象时，指定我们想要动画的属性路径，然后设置动画参数。使用`addAnimation:forKey:`方法调用动画。\n\n``` Swift\nlet fadeAnimation = CABasicAnimation(keyPath: \"opacity\")\nfadeAnimation.fromValue = 1.0\nfadeAnimation.toValue = 0.0\nfadeAnimation.duration = 1.0\nlayer.add(fadeAnimation, forKey: \"opacity\")\n\n// Change the actual data value in the layer to the final layer\nlayer.opacity = 0.0\n```\n\n> Tip：当创建显式动画时，推荐使用`fromValue`属性。如果没有指定这个属性，Core Animation默认使用层级的当前值作为初始值。如果已经当前值等于初始值，可能不会得到想要的效果。\n\n和隐式动画不同，显式动画不会改变层级的真正属性值，显式动画只提供动画。在动画的最后，Core Animation移除动画对象，在层级上使用当前值重新绘制。如果我们想要显式动画是永久更改，还必须更新层级的属性。\n\n显式和隐式动画在当前runloop结束后开始执行，当前线程必须应用runloop才能让动画执行。如果层级修改多项属性或添加多个动画，所有的动画会在同时执行。\n\n## 使用关键帧动画修改层级属性\n\n基于属性的动画将属性从初始值更改为结束值，*CAKeyframeAnimation*对象允许我们通过一组目标值进行动画处理，其方式可能是线性的，也可能不是线性的。关键帧动画包含一组目标数据和每个值对应的时间组成。在最简单的配置中，使用指定值和时间。对于层位置的改变，我们还可以使用路径作为改变。动画对象获取指定关键帧，并通过给定时间段内从一个值穿插下一个值来构建动画。\n\n``` Swift\nlet path = CGMutablePath()\npath.move(to: CGPoint(x: 0, y: 0))\npath.addCurve(to: CGPoint(x: 300, y: 600), control1: CGPoint(x: 200, y: 50), control2: CGPoint(x: 400, y: 350))\n\nlet animation = CAKeyframeAnimation(keyPath: \"position\")\nanimation.path = path\nanimation.duration = 2.0\nmyView.layer.add(animation, forKey: \"position\")\n```\n\n### 指定关键帧数值\n\n关键帧数值在动画中是重要组成部分，这些值定义了动画在执行过程中的行为，指定关键帧的主要方式是将数组指定为包含*CGPoint*数据类型的值，当然也可以用*CGPathRef*代替。当指定一组数值，根据属性需要的数据类型提供数据，可以直接添加一些对象，但是一些对象需要转换成id类型，并且所有标量类型或结构体必须由对象包装：\n- 对于*CGRect*属性，将每个矩形转换成*NSValue*对象\n- 对于层级的转换属性，将*CATransform3D*矩阵转换成*NSValue*对象。\n- 对于*borderColo*属性，每个*CGColorRef*数据类型转换成*id*类型，然后添加到数组中\n- 对于*CGFloat*值的属性，将值转换为*NSNumber*对象添加到数组中\n- 对于层级的*Contents*属性，指定一组*CGImageRef*类型的数据\n\n对于*CGPoint*类型数据的属性，可以创建*NSValue*对象的数组或者创建*CGPathRef*对象来指定路径。当我们指定一组点，关键帧动画会在每个连续的点之间画一条线并沿着这条路动画。当我们指定一个*CGPathRef*对象，动画将从路径的起始点开始，并遵循其轮廓，包括沿着任何曲面。\n\n### 指定关键帧动画的时间点\n\n关键帧动画的时间和节奏比基本动画更复杂，我们可以使用以下属性控制它：\n- *calculationMode*属性定义了用于计算动画计时的算法，这个属性值影响其他与时间相关属性的使用。\n    1. 线性和立方动画 -- 当*calculationMode*属性设置为*kCAAnimationLinear*或者*kCAAnimationCubic`时的动画 -- 通过提供的时间信息生成动画，这个模式可以让我们最大程度控制动画时间\n    2. 定步动画 -- 当*calculationMode*属性设置为*kCAAnimationPaced*或者*kCAAnimationCubicPaced*时的动画 -- 不依赖*keyTimes*或*timingFunctions*属性提供的外部计时值，相反，计时值是隐式的，以提供恒定速度的动画\n    3. 离散动画 -- 当*calculationMode*属性设置为*kCAAnimationDiscrete*时的动画 -- 将动画属性从一个关键帧值直接跳转到另一个，而不需要任何中间值。这种计算模式使用*keyTimes*属性中的值，但忽略*timeingFunctions*属性\n- *keyTimes*属性指定应用每个关键帧值的时间标记，仅当计算模式为*kCAAnimationLinear*，*kCAAnimationDiscrete*, *kCAAnimationCubic*时使用，他不是用于定步动画\n- *timingFunctions*属性指定每个关键帧段使用的计时曲线\n\n## 停止正在运行的显式动画\n\n动画正常运行到结束，但我们可以使用以下技术提前停止动画：\n- 从层级移除一个单独的动画对象，可以调用`removeAnimationForKey:`方法。这个方法使用的键是`addAnimation:forKey`方法传递进去的标识符，不可为空\n- 从层级移除所有动画，可以调用`removeAllAnimations`方法。这个方法立即移除所有动画同时使用原始状态重绘层级\n\n## 同时运行多个动画\n\n如果想要在层级同时运行多个动画，我们可以使用*CAAnimationGroup*对象整合他们。使用一个组对象简化了对多个动画的管理，应用于组的时间和持续时间将腐败当个动画中的相同值。\n\n``` Swift\nlet path = CGMutablePath()\npath.move(to: CGPoint(x: 0, y: 0))\npath.addCurve(to: CGPoint(x: 300, y: 600), control1: CGPoint(x: 200, y: 50), control2: CGPoint(x: 400, y: 350))\n\nlet positionAnimation = CAKeyframeAnimation(keyPath: \"position\")\npositionAnimation.path = path\n\nlet colorAnimation = CAKeyframeAnimation(keyPath: \"backgroundColor\")\nlet colorValues = [UIColor.red.cgColor, UIColor.yellow.cgColor, UIColor.cyan.cgColor]\ncolorAnimation.values = colorValues\ncolorAnimation.calculationMode = .paced\n\nlet group = CAAnimationGroup()\ngroup.animations = [positionAnimation, colorAnimation]\ngroup.duration = 5.0\nmyView.layer.add(group, forKey: \"group\")\n```\n\n使用组动画的进阶方法是使用*CATransaction*对象，后面讨论。\n\n## 监测动画的结束\n\nCore Animation提供动画起始与结束的监测，这些通知是执行与动画相关任务的好时机。有两种方式监听动画的状态：\n- 对于*CATransaction*的类方法，设置`setCompletionBlock:`方法，在动画结束后会执行回调\n- 对于*CAAnimation*对象，可以实现他的代理方法`animationDidStart:`和`animationDidStop:finished:`\n\n如果想要一个动画接着一个动画执行，不要使用动画监听。可以使用*beginTime*属性开始一个动画，设置另一个动画的开始时间是这个动画的结束时间。\n\n## 如何在Layer-Backed的视图上动画\n\n如果一个层级属于视图，创建动画推荐的方法是使用UIKit提供的基于视图的动画接口。有一些方法可以直接使用Core Animation接口对层进行动画处理。\n\n对于*UIView*类，总有一个Layer与之对应，类本身直接从层级派生出它的大部分数据，因此，对层级做出的更改也会自动由视图显示出来，这就意味着我们可以同时使用Core Animation或者UIView提供的接口来动画。\n\n如果想要使用Core Animation类来初始化动画，必须在基于视图的动画块中调用Core Animation的方法，*UIView*默认禁止图层动画，但在动画块中重新启动他们。一次，在动画块之外所有的任何更改都不是动画。(针对隐式动画，允许在动画块中启动)\n\n``` Swift\nUIView.animate(withDuration: 2.0) {\n    self.view.layer.opacity = 0.0\n}\n```\n\n# Advanced Animation Tricks\n\n有很多种方法可以配置基于属性或者关键帧的动画，如果想要同时或顺序运行多种动画时可以使用更高级的方式来同步这些动画的时间将他们链接在一起，我们可以使用其他类型的动画对象来创建视觉转换和一些其他有趣的效果。\n\n## 支持对层级视觉改变的转换动画\n\n如题所示，一个转换动画对象为层级创建视觉动画，转换对象的常见用法是协调一个层级显示和另一个层级消失的动画。不同于修改层级属性的动画，一个转换动画操作层级的缓存图片创建视觉效果，仅通过修改属性是难以做到的。标准类型的转换允许我们只想显示、推送、移动、渐入渐出等动画。\n\n要执行转换动画，需要创建*CATransition*对象并将其添加到与之转换相关的层级上，我们可以使用转换动画指定要执行的转换类型以及动画的起点终点。我们也不需要使用整个转换动画，转换对象可以让我们指定动画时使用的开始与结束进度值，这些值让我们在中点位置开始或者结束动画。\n\n下面代码在两个视图中创建推送转换动画，myView1与myView2在父视图的同一个位置但只有一个视图可见，推送转换会导致一个视图从当前位置往左偏移消失而另一个视图从右边开始偏移到位置显示。更新*isHidden*属性用于视图在动画后的正确显示。\n\n``` Swift\nlet transition = CATransition()\ntransition.startProgress = 0.0\ntransition.endProgress = 1.0\ntransition.type = .push\ntransition.subtype = .fromRight\ntransition.duration = 2.0\n\nmyView1.layer.add(transition, forKey: \"transition\")\nmyView2.layer.add(transition, forKey: \"transition\")\n\nmyView1.isHidden = false\nmyView2.isHidden = true\n```\n\n这里可以使用同一种转换动画，也可以根据需要使用不同的转换动画。\n\n## 自定义动画的时间\n\n时间控制是动画的重要组成部分，Core Animation可以通过*CAMediaTiming*代理的方法和属性来指定动画的时间信息。*CAAnimation*和*CALayer*都已经遵循了这个代理，但是封装这些动画的隐式转换对象通常提供了优先级默认的时间信息。\n\n在考虑时间与动画时，理解层级与动画的合作关系是关键的，每个层级有自己的用于管理动画计时的本地时间。通常情况下，两个不同层级的本地时间是相近的，我们可以为每个层级指定相同的时间值而用户不会注意到，但是，一个层级的本地时间会由它的父级或它自己的时间参数改变。例如，改变层级的*speed*属性会导致该图层及其子层级的持续时间按比例改变。\n\n为了帮助我们确定给定层级适应的时间值，*CALayer*类定义了`convertTime:fromLayer:`与`convertTime:toLayer:`方法。我们可以使用这些方法将固定时间转换成层级的本地时间或者从一个层级的时间转换成另一个层级的。这个方法描述了可能影响层级本地时间，返回我们可能在其他层级使用的媒体时间属性。下面代码展示了从层级获取当前本地时间的例子，`CACurrentMediaTime`是返回电脑当前时间的方法，用来转换方法获取并转换成层级时间。\n\n``` Swift\nlet localLayerTime = view.layer.convertTime(CACurrentMediaTime(), from: nil)\n```\n\n一旦获取到了层级的本地时间，我们可以使用这个值来更新有关时间属性的动画或层级，比如如下操作：\n- *beginTime*属性设置动画的启动时间，通常情况下，动画会在下一轮更新开始，但我们可以用来延迟动画的开始。可以用这个属性来合并两个动画，将一个动画的启动时间设置为另一个时间的结束时间。如果需要延迟动画启动，需要我们将*fillMode*设置为*kCAFillModeBackwards*，这个模式会使动画从初始值启动，如果没有设置，动画会在执行之前跳转到结束位置。\n- *autoreverses*属性使动画在指定的持续时间内执行，然后返回到动画的初始值。可以将这个属性与*repeatCount*属性结合，在开始与结束值之间来回动画。设置循环次数是整数时，动画会在初始值的位置停止，设置循环次数为额外的一半时（如1.5），会让动画在结束为止停止。\n- *timeOffset*属性适用于组动画启动一些动画在其他动画之后的时间启动\n\n## 暂停、恢复动画\n\n暂停动画，可以利用实现*CAMediaTiming*协议的层级设置动画速度为0.0，直到重新修改动画速度恢复动画。\n\n``` Swift\nfunc pauseLayer(layer: CALayer) {\n    let pausedTime = layer.convertTime(CACurrentMediaTime(), from: nil)\n    layer.speed = 0.0\n    layer.timeOffset = pausedTime   // 动画暂停时的时间偏移量\n}\n\nfunc resumeLayer(layer: CALayer) {\n    let pausedTime = layer.timeOffset\n    layer.speed = 1.0\n    layer.timeOffset = 0.0\n    layer.beginTime = 0.0\n    let timeSincePause = layer.convertTime(CACurrentMediaTime(), from: nil) - pausedTime\n    layer.beginTime = timeSincePause    // 动画延迟执行时间\n}\n```\n\n## 修改动画参数的显式Transactions\n\n对层做的每一项操作必须是Transactions的一部分，*CATransaction*类管理动画的创建与分组，并在适当的实际执行他们。多数情况下，我们不需要自己创建Transactions，当对层级添加隐式或显式动画时，Core Animation自动创建隐式transaction。当然，我们也可以创建显式transactions更精确的管理动画。\n\n我们可以通过*CATransaction*类创建和管理transactions，调用`begin`方法开始一个新的transaction（隐式），`commit`方法结束transaction。在这些调用之间是我们希望对transaction的一部分改变。\n\n``` Swift\nCATransaction.begin()\nmyView.layer.zPosition = 200.0\nmyView.layer.opacity = 0.0\nCATransaction.commit()\n```\n\n使用transactions的主要原因之一是在显式transaction的范围内，可以修改持续时间、计时函数和其他参数。我们也可以为整个transaction安排一个完成回调，在一组动画完成后发出通知。修改动画参数需要使用`setValue:forKey:`方法修改字典中对应的键。\n\n``` Swift\nCATransaction.begin()\nCATransaction.setValue(10.0, forKey: kCATransactionAnimationDuration)\n// perform the animations\nCATransaction.commit()\n```\n\n我们可以在为不同动画集提供不同的默认值的情况下嵌套transactions，通过再次调用*begin*方法可以嵌套另一个transaction，每个*begin*方法必须对应*commit*方法。只有在提交最外层transaction后，Core Animation才会开始相关动画。\n\n## 为动画添加透视\n\n应用程序可以在三维空间操作图层，但为了简单起见，Core Animation使用并行投影显示图层，实际上试讲场景压成二维平面，这种默认行为导致具有不同*zPosition*值的层以相同的大小出现，尽管他们在z方向上距离很远。我们可以通过修改转换矩阵来更改该行为，以包含透视信息。\n\n修改场景的透视图时，需要修改包含被查看视图的父层级的*sublayerTransform*矩阵，修改父层级将相同的透视信息运用于所有子层级可以简化代码，他还能确保透视图被正确的应用在不同平面上相互重叠的兄弟层级。\n\n```\nvar perspective = CATransform3DIdentity\nperspective.m34 = -1.0/eyePosition\nview.layer.sublayerTransform = perspective\n```\n\n# Changing a Layer's Default Bahavior\n\nCore Animation使用action对象实现它的隐式层级动画行为。action对象是实现*CAAction*协议的对象，它定义了一些要在层上执行的相关行为。所有*CAAnimation*对象实现了该协议，当一个层级属性变化时，这些对象就被安排来执行修改。\n\n动画属性是action的一种，但我们可以定义大多数我们想要操作的actions，不过要做到这一点，我们必须定义action对象并与应用层级对象关联。\n\n## 自定义实现CAAction协议的Action对象\n\n创建自己的action对象，需要一个类实现*CAAction*协议并实现`runActionForKey:object:arguments:`方法，在这个方法中，使用可用的信息来执行我们想要在该层上执行的任何操作。我们可能用这个方法添加一个动画或者一些其他任务。\n\n当我们定义一个action对象，我们需要觉得触发的条件，这个action的触发是我们用来注册这个action使用的key，也可以在以下情况下被触发：\n- 层级的一个属性改变了，可以是层级的任意属性，不仅仅是动画的这个（我们还可以把自定义属性的actions和层级相关联），标识action的键是这个属性的名字\n- 层级变得可见或者添加到层级结构中，标识的键为*kCAOnOrderIn*\n- 层级从层级结构移除，标识的键为*kCAOnOrderOut*\n- 层级涉及转换动画，标识的键为*kCATransition*\n\n## action对象必须在层级上才能产生效果\n\n在action操作之前，层级需要找到相应的action对象，层级相关action的键是正在修改属性的名称或特殊字符。当适当的事件发生在层级，层级调用*actionForKey:*方法查找对应键的action对象，我们可以在搜索过程中插入多个点并为该键提供相关的action对象。\n\nCore Animation查找action对象的顺序如下：\n1. 如果层级的代理实现了`actionForLayer:forKey:`方法，层级会调用这个方法。代理必须执行以下一项：\n    - 返回给定键的action对象\n    - 返回nil，如果不处理action，查找继续\n    - 返回NSNull对象，查找结束\n2. 层级在actions字典中查找对应的键\n3. 层级在[style](https://developer.apple.com/documentation/quartzcore/calayer/1410875-style)字典中包含该键的actions字典（换句话说，包含actions键的style字典也是字典，层级在第二层字典查找对应键）\n4. 层级调用`defaultActionForKey:`方法\n5. 层级执行Core Animation定义的隐式action\n\n如果我们在任意查询点提供了action对象，层级将停止查询并执行返回的action对象。当查找到一个action对象，层级调用`runActionForKey:object:arguments:`方法执行操作。如果给定键定义的action已经是*CAAnimation*类的实例，则可以使用这个方法的默认实现执行动画。如果是我们自定义实现*CAAction*协议的对象，则必须使用该方法对象实现来执行适当的操作。\n\n在何处安装action对象取决于我们如何修改层级：\n- 对于可能只在特定环境应用的actions，或对于已经使用代理的对象，提供代理并实现`actionForLayer:forKey`方法\n- 对于层级对象补偿使用代理，可以添加action到层级的actions字典中\n- 对于与层对象上定义的自定义属性相关的actions，可以在style字典中包含该action\n- 对于层行为的基本actions，继承层级并复写`defaultActionForKey:`方法\n\n``` objectivec\n- (id<CAAction>)actionForLayer:(CALayer *)theLayer\n                        forKey:(NSString *)theKey {\n    CATransition *theAnimation=nil;\n \n    if ([theKey isEqualToString:@\"contents\"]) {\n \n        theAnimation = [[CATransition alloc] init];\n        theAnimation.duration = 1.0;\n        theAnimation.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseIn];\n        theAnimation.type = kCATransitionPush;\n        theAnimation.subtype = kCATransitionFromRight;\n    }\n    return theAnimation;\n}\n```\n\n## 使用CATransaction类临时禁用actions\n\n我们可以使用*CATransaction*类临时禁用actions，当修改一个层级的属性时，Core Animation通常会创建隐式transaction执行修改，如果不想修改，我们可以创建显式transaction并设置*kCATransactionDisableActions*属性为true禁用隐式动画。\n\n``` objectivec\n[CATransaction begin];\n[CATransaction setValue:(id)kCFBooleanTrue\n                 forKey:kCATransactionDisableActions];\n[aLayer removeFromSuperlayer];\n[CATransaction commit];\n```\n\n# Ending\n\n这一章主要是对于Layer动画的内容、概念的学习，毕竟要熟练运用需要到实际场景中反复使用，其实更关键的是数学模型，有了数学模型生成的路径、时间规划，才能有绚丽的动画。\n\n# Reference\n\n> [About Core Animation](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CoreAnimation_guide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40004514-CH1-SW1)","source":"_posts/2019/core-animation-study-0503.md","raw":"---\ntitle: \"图形渲染与动画基础 -- Core Animation\"\ncatalog: true\ntoc_nav_num: true\ndate: 2019-05-03 15:30:10\nsubtitle: \"About Core Animation\"\nheader-img: \"/img/article_header/article_header.png\"\nbusuanzi: true\ntags:\n- iOS\n\n---\n\n# Introduction\n\nCore Animation是iOS与OS X平台上的图形渲染和动画基础设施，可以在应用中使视图和其他可见元素产生动画。使用Core Animation，绘制动画的每一帧所需的大部分工作都已经实现。我们所需要做的是配置少量动画参数同时启动动画，Core Animation会完成其余部分，将大部分实际绘图工作交给图形硬件实现加速渲染，这种自动图形加速产生高帧率平滑的动画而不会负担CPU和使应用卡顿。\n当我们在写iOS代码时，不管是否知道我们都在使用Core Animation，如果是OS X，则可以非常轻松的利用Core Animation。Core Animation位于AppKit和UIKit下，被紧密集成到Cocoa和Cocoa Touch的视图流中。当然，Core Animation也有一些应用视图暴露的扩展功能接口，可以让我们更细致控制应用程序的动画。\n\n![Core Animation](/img/article/20190503/1.png)\n\n# Core Animation Basics\n\nCore Animation提供一个视图和其他可见元素动画的通用系统，它不是View的替代品，相反，他是一种与视图结合，提供更好性能、为视图提供动画的技术。它将视图的内容缓存到可以直接被图形硬件操作的位图中，在一些情况下，这个缓存操作可能会让我们重新思考我们如何呈现和管理我们的应用内容，但是大多数情况我们不需要知道。除了缓存视图内容，Core Animation同样定义了一种方式，指定任意可视内容，结合视图上的内容，让他和其他任意东西一起动起来。\n\n## Layers提供绘图与动画的基础\n\nLayer对象是三维空间中的二维表面，是Core Animation所做事情的核心。与View一样的是，层级管理其表面的几何、内容、视觉属性信息。与View不同的是，层级不定义他们自己的外观。一个层级仅仅管理位图周围的状态信息，位图本身可以是视图绘制本身的结果，也可以是指定的固定图形的结果。因此，应用中的主要层级被被认为是模型对象，因为他们主要管理数据。这个概念很重要，因为他们影响到动画表现。\n\n### 层级绘制模型\n\n多数层级不是真的绘图，相反，一个Layer捕获内容然后缓存到位图，有时也被称为**后备存储器**。当我们修改一个层级的属性，我们所做的只是修改关联层级的状态信息。当一项改变触发动画，Core Animation将层级的位图和状态信息传递给图形硬件，图形硬件使用新的信息渲染位图。在硬件中操作位图比在软件中可以更快的生成动画。\n\n![How Core Animation draws content](/img/article/20190503/2.png)\n\n因为它操作静态位图，图层绘图与更传统的视图绘图有很大的不同。使用视图绘图，视图本身的修改经常会出发`drawRect:`方法的调用，使用新参数重新绘制内容，但这种方式绘图代价很高因为是在主线程使用CPU完成的。Core Animation尽可能通过在硬件中操作缓存位图来达到相同或类似的效果，以此避免这种开销。\n\n尽管Core Animation尽可能地使用缓存内容，但应用任然必须提供初始内容并不时更新。\n\n### 层级动画\n\n层对象的数据和状态信息与改层内容在屏幕上的可视化表现相互解耦，这种解耦为Core Animation提供的一种方法，使它自我干预，并创建新旧状态的动画。例如，修改一个层级的位置属性会使Core Animation移动层级从当前位置到新状态的位置。\n\n![Examples of animations I can perform on layers](/img/article/20190503/3.png)\n\n在动画制作过程中，Core Animation会在硬件上逐帧完成绘图。我们所要做的就是指定动画的起点与终点，让Core Animation完成剩下的工作，如有必要，可以同样指定自定义的时间信息和动画参数，如果不提供，Core Animation有合适的默认值。\n\n## 层级对象定义自身的几何结构\n\n一个层级的工作就是管理内容的视觉几何结构，视觉几何结构由内容的bounds，屏幕上的位置信息，是否旋转、缩放、位移的信息构成。和View一样，层级有frame和bounds来定位位置，同样，层级也有View没有的属性，比如锚点坐标。指定层级几何的某些方面的方式也和视图指定信息的方式不同。\n\n### Layers使用两种坐标系统\n\nLayers同时使用point-based坐标系和unit坐标系来指定内容的位置。使用哪种坐标系统根据传递信息的类型。当指定直接映射到屏幕坐标系的值或者必须相对于另一个层级的指定，就需要用point-based坐标系，比如一个层级的位置属性。当值与屏幕坐标系无关时使用unit坐标系，比如层级的锚点属性，指定相对于层级自身边界的点。\n\npoint-based坐标系最常见的使用就是指定曾记得大小（bounds）和位置（position）属性，当然也有frame属性，这个属性是由boudns和position属性中派生出来的值，使用频率较低。bounds和frame的坐标系方向：\n\n![The default layer geometries for iOS and OS X](/img/article/20190503/4.png)\n\n图中的position属性在层级的中点位置，这个属性是根据层级锚点属性中的值更改定义的几个属性之一。锚点是几个使用unit坐标系的属性之一，Core Animation使用unit坐标系表示在层级大小修改时可能受影响的属性，我们可以将unit坐标系看作是总值的百分比，每个unit坐标系中的值在0.0-1.0之间。\n\n![The default unit coordinate systems for iOS and OS X](/img/article/20190503/5.png)\n\n### 锚点坐标影响几何操作\n\n一个层级的相关几何操作的发生与层级的锚点相关，我们可以使用锚点属性访问。当操作层级的位置或位移属性时，锚点的作用会更加可见。下图展示了锚点的改变对位置属性的改变：\n\n![How the anchor point affects the layer's position property](/img/article/20190503/6.png)\n\n下图是锚点对于旋转属性的影响：\n\n![How the anchor point affects layer transformations](/img/article/20190503/7.png)\n\n## 层级树反应出动画状态的不同方面\n\n一个使用Core Animation的应用有三种层级对象：\n- Objects in the model layer tree：应用中互动最多的层级，模型对象存储动画的目标值，当我们改变层级的属性时，就使用这个对象\n- Objects in the presentation tree：包含运行动画中的值，虽然模型层级树包含动画的目标值，但是呈现层级树反应动画的当前值。我们不应该修改这个值\n- Objects in the render tree：真正动画实现的层级，Core Animation的私有对象\n\n每个层级对象被组织成已给层级结构，和应用中的视图一样。事实上，当为所有视图启用层级，每个树的层级结构与视图结构完全匹配。但是，一个应用可以添加额外的层级对象，层级和视图并不是相匹配的。在某些情况下，我们可能会这样这样操作来优化不需要视图而造成的开销。\n\n![The layer trees for a window](/img/article/20190503/8.png)\n\n\n## Layers与Views的关系\n\nLayers不能代替Views--我们不能基于层级对象创建可视界面。Layers为Views提供基础，具体地说，Layers可以使视图内容的绘制与动画更加简单有效的同时保证高帧率。当然，Layers不能处理事件，绘制内容，参与响应链等等。\n\n# Settign Up Layer Objects\n\nLayer对象是Core Animation的核心，层级管理应用的可见内容和提供修改样式和可见外观的选项。\n\n## 修改View的Layer对象\n\niOS默认情况下，View会自动创建CALayer类的实例，大多数情况下我们不需要其他类型的层积类。但是，Core Animation提供了不同的层级类，提供可能对我们有用的层级类。[不同的Layer](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CoreAnimation_guide/SettingUpLayerObjects/SettingUpLayerObjects.html#//apple_ref/doc/uid/TP40004514-CH13-SW25)\n\n修改View的Layer类型：\n``` Swift\noverride var layer: CALayer {\n    return CAShapeLayer()\n}\n```\n\n## 提供Layer的Content\n\nLayers是管理内容的数据对象，一个层级的内容包含我们想要展示可视数据的位图，有以下三种方式提供位图的内容：\n- 直接给`contents`属性赋值（适用于层级内容基本不会改变的情况）\n- 实现Layer的代理方法完成内容的绘制（适用于层级内容可能周期性改变并且可以有外部对象提供，比如View）\n- 定义一个Layer的子类同时复写`drawing`方法来自己提供内容（适用于自定义Layer子类或者想要改变层级的基本会话操作）\n\n### Content赋值图片\n\n因为一个层级只是管理位图的容器，我们可以直接给`Contents`属性赋值图片。层级可以直接使用提供的图片，而不用拷贝一份图片，这个操作可以让图片在不同地方使用时节约内存。赋值的图片类型必须是*CGImageRef*类型，同时图片的分辨率要适配原生设备。允许的话，需要适当调整图片的`ContentsScale`属性。\n\n### 通过代理提供Content\n\n如果需要动态修改层级的Content，我们可以使用提供的代理。在显示时，层级会调用以下代理方法：\n- `displayLayer:`方法，该实现负责创建位图并将其分配给`contents`属性\n- `drawLayer:inContext:`方法，Core Animation创建一个位图，创建一个图形上下文来绘制位图，然后调用这个方法填充位图。这个方法就是在提供的图形上下文绘图。\n\n代理必须实现`displayLayer:`和`drawLayer:inContext`两种方法之一，如果同时实现，只会调用`displayLayer`方法。\n\n当应用程序是在想要显示的地方加载或创建位图时，复写`displayLayer:`方法更加合适：\n``` objectivec\n- (void)displayLayer:(CALayer *)theLayer {\n    // Check the value of some state property\n    if (self.displayYesImage) {\n        // Display the Yes image\n        theLayer.contents = [someHelperObject loadStateYesImage];\n    }\n    else {\n        // Display the No image\n        theLayer.contents = [someHelperObject loadStateNoImage];\n    }\n}\n```\n\n> PS：本来这边有个问题，但是后面苹果也自己概述了，对于UIKit下的视图（层支持），我们直接用默认的`drawRect`方法进行绘制内容。而对于OS X环境下，Layer与View不是直接相关联的，`drawRect`与`drawLayer`方法两者之间的区别。`drawRect`是View的视图渲染方法，`drawLayer`是Layer的代理方法，两者都可以绘图。目前的调用机制是这样：同时实现两个方法会只调用`drawLayer`里的实现；无法单独实现`drawLayer`方法，必须空实现`drawRect`方法；`drawLayer`方法也可以由`setNeedsDisplay`方法调用，同`drawRect`方法一样。两者用法的区别：是否需要获取视图在动画过程中的Layer属性，`drawLayer`方法中实现的内容可以实时获取Layer的属性值，`drawRect`方法只能获取Layer的结果值。[是否对仍待考究](https://stackoverflow.com/questions/4979192/ios-using-uiviews-drawrect-vs-its-layers-delegate-drawlayerincontext/36050120#36050120)\n\n如果没有预先编码的图片或者对象来创建位图，可以使用`drawLayer`方法动态绘制内容：\n``` objectivec\n- (void)drawLayer:(CALayer *)theLayer inContext:(CGContextRef)theContext {\n    CGMutablePathRef thePath = CGPathCreateMutable();\n \n    CGPathMoveToPoint(thePath,NULL,15.0f,15.f);\n    CGPathAddCurveToPoint(thePath,\n                          NULL,\n                          15.f,250.0f,\n                          295.0f,250.0f,\n                          295.0f,15.0f);\n \n    CGContextBeginPath(theContext);\n    CGContextAddPath(theContext, thePath);\n \n    CGContextSetLineWidth(theContext, 5);\n    CGContextStrokePath(theContext);\n \n    // Release the path\n    CFRelease(thePath);\n}\n```\n\n对于带有自定义内容的层支持视图，我们应该继续复写视图方法来进行绘图。层支持的绘图自动使自己成为其层的委托，并实现委托所需的委托方法，我们不应该更改这个配置，所以，对于UIView我们还是实现`drawRect`方法来绘制内容.\n\n### 通过子类提供Content\n\n当实现一个自定义Layer类时，我们可以复写Layer类的绘图方法来进行任何绘图：\n- 复写`display`方法，直接设置`contents`属性\n- 复写`drawInContext:`方法，在提供的图形上下文绘制\n\n### 调整Content\n\n当我们设置一个图层的`contents`属性时，`contentsGravity`属性决定了如何操作该图片来适应边界。默认情况下，如果一张图片大于当前边界，图层对象会缩放图片以适应可用空间。如果图层边界的宽高比与图像的宽高比不同，就会导致图像的失真。\n`contentsGravity`属性可以被分为以下两类：\n- 基于位置的重力常量允许我们将图片固定在边缘或角落上，无需缩放图片\n- 基于缩放的重力常量允许我们使用几种选项之一来拉伸图像，可以保持宽高比，也可以拉伸\n\nPosition-based gravity constants for layers:\n![Position-based gravity constants for layers](/img/article/20190503/9.png)\n\nScaling-based gravity constants for layers:\n![Scaling-based gravity constants for layers](/img/article/20190503/10.png)\n\n## 调整Layer的视觉样式和外观\n\n层级对象内置视觉装饰，比如边框、背景色，我们可以用来补充图层的内容。因为这些视觉装饰不需要我们做渲染，所以在某些情况下可以将层作为独立实体使用。我们需要做的就是设置属性，层级会处理必要的绘画，包括动画。\n\n### Layers有自己的背景和边框\n\n除了基于图像的内容外，层级可以显示填充背景和边框。背景色在层级内容图片背后渲染，边框在图片上面渲染，如果层级包含子层级，他们也在边框下面。因为背景色位于图像后面，所以这种颜色通过图像的任何透明部分发光。\n\n如果设置不透明的背景色，考虑设置层级的`opaque`属性为YES，这样做可以在屏幕上合成图层时提高性能，就不需要使用图层的后备存储来管理alpha通道。但是，如果一个层的角半价不为零，则不能设为不透明。\n\n### Layers支持倒角\n\n我们可以为层级创建一个圆角矩形效果，倒角是一种视觉装饰，它掩盖了层级边界矩形的部分角，允许底层内容显示。因为它涉及到透明层蒙版，除非`maskToBounds`属性设置为YES，否则倒角不会影响图层图像。但是，倒角总是影响图层的背景颜色和边框的绘制。\n\n### Layers支持内置阴影\n\nCALayer类包含几种配置阴影效果的属性。阴影通过增加深度使其看起来像漂浮在底层内容之上，这是另一种类型的视觉装饰。我们可以控制阴影颜色，相对于图层内容的位置，不透明度和形状。\n\n层级阴影的不透明度默认为0，这样可以有效地隐藏阴影。将不透明度修改为非零值会使Core Animation绘制阴影。因为阴影默认直接位于层级的最下方，所以需要更改阴影的偏移量才能看到它。但是务必记住，阴影的偏移量是使用图层的本机坐标系。\n\n![Applying a shadow to a layer](/img/article/20190503/11.png)\n\n当向图层添加阴影时，阴影是图层内容的一部分，但实际上扩展到图层的边界之外，所以，当图层启用`maskToBounds`属性时，阴影效果会被剪切到边缘。如果图层包含透明内容，这是会产生一个奇怪的效果，直接在图层下面的阴影部分仍然是可见的，但是超出部分不可见。所以，这是如果想要一个阴影，但也想用`maskTobounds`属性，我们可以使用两层层级，将该图层嵌入到相同大小应用阴影效果的图层中去。\n\n# Animating Layer Content\n\nCore Animation提供的基础设施可以让我们更加容易的创建层级动画，扩展到拥有层级的所有视图。\n\n## 对图层属性的简单修改动画\n\n简单动画包含隐式动画和显示动画。隐式动画使用默认的时间和动画属性，显式动画需要提供属性的配置。简单动画包含修改层级属性，在时间内完成动画，层级定义了很多影响可见外观的属性，改变其中一个属性会让其产生外观动画。\n\n只需要更新层级属性就能触发隐式动画，层级的视觉外观不会立即改变，相反，Core Animation会根据属性变化作为触发器来创建调度一个或多个隐式动画执行。因此，像如下代码所示的改变会让Core Animation创建一个动画对象，并在下一个更新周期执行动画。\n\n``` Swift\ntheLayer.opacity = 0.0\n```\n\n如果想要显式做出如上改变可以创建*CABasicAnimation*对象同时配置动画参数，可以在添加动画前设置动画的起始与结束值，改变持续时间，或者修改其他动画参数。下面代码展示了如何使用一个对话对象淡化一个层级，创建对象时，指定我们想要动画的属性路径，然后设置动画参数。使用`addAnimation:forKey:`方法调用动画。\n\n``` Swift\nlet fadeAnimation = CABasicAnimation(keyPath: \"opacity\")\nfadeAnimation.fromValue = 1.0\nfadeAnimation.toValue = 0.0\nfadeAnimation.duration = 1.0\nlayer.add(fadeAnimation, forKey: \"opacity\")\n\n// Change the actual data value in the layer to the final layer\nlayer.opacity = 0.0\n```\n\n> Tip：当创建显式动画时，推荐使用`fromValue`属性。如果没有指定这个属性，Core Animation默认使用层级的当前值作为初始值。如果已经当前值等于初始值，可能不会得到想要的效果。\n\n和隐式动画不同，显式动画不会改变层级的真正属性值，显式动画只提供动画。在动画的最后，Core Animation移除动画对象，在层级上使用当前值重新绘制。如果我们想要显式动画是永久更改，还必须更新层级的属性。\n\n显式和隐式动画在当前runloop结束后开始执行，当前线程必须应用runloop才能让动画执行。如果层级修改多项属性或添加多个动画，所有的动画会在同时执行。\n\n## 使用关键帧动画修改层级属性\n\n基于属性的动画将属性从初始值更改为结束值，*CAKeyframeAnimation*对象允许我们通过一组目标值进行动画处理，其方式可能是线性的，也可能不是线性的。关键帧动画包含一组目标数据和每个值对应的时间组成。在最简单的配置中，使用指定值和时间。对于层位置的改变，我们还可以使用路径作为改变。动画对象获取指定关键帧，并通过给定时间段内从一个值穿插下一个值来构建动画。\n\n``` Swift\nlet path = CGMutablePath()\npath.move(to: CGPoint(x: 0, y: 0))\npath.addCurve(to: CGPoint(x: 300, y: 600), control1: CGPoint(x: 200, y: 50), control2: CGPoint(x: 400, y: 350))\n\nlet animation = CAKeyframeAnimation(keyPath: \"position\")\nanimation.path = path\nanimation.duration = 2.0\nmyView.layer.add(animation, forKey: \"position\")\n```\n\n### 指定关键帧数值\n\n关键帧数值在动画中是重要组成部分，这些值定义了动画在执行过程中的行为，指定关键帧的主要方式是将数组指定为包含*CGPoint*数据类型的值，当然也可以用*CGPathRef*代替。当指定一组数值，根据属性需要的数据类型提供数据，可以直接添加一些对象，但是一些对象需要转换成id类型，并且所有标量类型或结构体必须由对象包装：\n- 对于*CGRect*属性，将每个矩形转换成*NSValue*对象\n- 对于层级的转换属性，将*CATransform3D*矩阵转换成*NSValue*对象。\n- 对于*borderColo*属性，每个*CGColorRef*数据类型转换成*id*类型，然后添加到数组中\n- 对于*CGFloat*值的属性，将值转换为*NSNumber*对象添加到数组中\n- 对于层级的*Contents*属性，指定一组*CGImageRef*类型的数据\n\n对于*CGPoint*类型数据的属性，可以创建*NSValue*对象的数组或者创建*CGPathRef*对象来指定路径。当我们指定一组点，关键帧动画会在每个连续的点之间画一条线并沿着这条路动画。当我们指定一个*CGPathRef*对象，动画将从路径的起始点开始，并遵循其轮廓，包括沿着任何曲面。\n\n### 指定关键帧动画的时间点\n\n关键帧动画的时间和节奏比基本动画更复杂，我们可以使用以下属性控制它：\n- *calculationMode*属性定义了用于计算动画计时的算法，这个属性值影响其他与时间相关属性的使用。\n    1. 线性和立方动画 -- 当*calculationMode*属性设置为*kCAAnimationLinear*或者*kCAAnimationCubic`时的动画 -- 通过提供的时间信息生成动画，这个模式可以让我们最大程度控制动画时间\n    2. 定步动画 -- 当*calculationMode*属性设置为*kCAAnimationPaced*或者*kCAAnimationCubicPaced*时的动画 -- 不依赖*keyTimes*或*timingFunctions*属性提供的外部计时值，相反，计时值是隐式的，以提供恒定速度的动画\n    3. 离散动画 -- 当*calculationMode*属性设置为*kCAAnimationDiscrete*时的动画 -- 将动画属性从一个关键帧值直接跳转到另一个，而不需要任何中间值。这种计算模式使用*keyTimes*属性中的值，但忽略*timeingFunctions*属性\n- *keyTimes*属性指定应用每个关键帧值的时间标记，仅当计算模式为*kCAAnimationLinear*，*kCAAnimationDiscrete*, *kCAAnimationCubic*时使用，他不是用于定步动画\n- *timingFunctions*属性指定每个关键帧段使用的计时曲线\n\n## 停止正在运行的显式动画\n\n动画正常运行到结束，但我们可以使用以下技术提前停止动画：\n- 从层级移除一个单独的动画对象，可以调用`removeAnimationForKey:`方法。这个方法使用的键是`addAnimation:forKey`方法传递进去的标识符，不可为空\n- 从层级移除所有动画，可以调用`removeAllAnimations`方法。这个方法立即移除所有动画同时使用原始状态重绘层级\n\n## 同时运行多个动画\n\n如果想要在层级同时运行多个动画，我们可以使用*CAAnimationGroup*对象整合他们。使用一个组对象简化了对多个动画的管理，应用于组的时间和持续时间将腐败当个动画中的相同值。\n\n``` Swift\nlet path = CGMutablePath()\npath.move(to: CGPoint(x: 0, y: 0))\npath.addCurve(to: CGPoint(x: 300, y: 600), control1: CGPoint(x: 200, y: 50), control2: CGPoint(x: 400, y: 350))\n\nlet positionAnimation = CAKeyframeAnimation(keyPath: \"position\")\npositionAnimation.path = path\n\nlet colorAnimation = CAKeyframeAnimation(keyPath: \"backgroundColor\")\nlet colorValues = [UIColor.red.cgColor, UIColor.yellow.cgColor, UIColor.cyan.cgColor]\ncolorAnimation.values = colorValues\ncolorAnimation.calculationMode = .paced\n\nlet group = CAAnimationGroup()\ngroup.animations = [positionAnimation, colorAnimation]\ngroup.duration = 5.0\nmyView.layer.add(group, forKey: \"group\")\n```\n\n使用组动画的进阶方法是使用*CATransaction*对象，后面讨论。\n\n## 监测动画的结束\n\nCore Animation提供动画起始与结束的监测，这些通知是执行与动画相关任务的好时机。有两种方式监听动画的状态：\n- 对于*CATransaction*的类方法，设置`setCompletionBlock:`方法，在动画结束后会执行回调\n- 对于*CAAnimation*对象，可以实现他的代理方法`animationDidStart:`和`animationDidStop:finished:`\n\n如果想要一个动画接着一个动画执行，不要使用动画监听。可以使用*beginTime*属性开始一个动画，设置另一个动画的开始时间是这个动画的结束时间。\n\n## 如何在Layer-Backed的视图上动画\n\n如果一个层级属于视图，创建动画推荐的方法是使用UIKit提供的基于视图的动画接口。有一些方法可以直接使用Core Animation接口对层进行动画处理。\n\n对于*UIView*类，总有一个Layer与之对应，类本身直接从层级派生出它的大部分数据，因此，对层级做出的更改也会自动由视图显示出来，这就意味着我们可以同时使用Core Animation或者UIView提供的接口来动画。\n\n如果想要使用Core Animation类来初始化动画，必须在基于视图的动画块中调用Core Animation的方法，*UIView*默认禁止图层动画，但在动画块中重新启动他们。一次，在动画块之外所有的任何更改都不是动画。(针对隐式动画，允许在动画块中启动)\n\n``` Swift\nUIView.animate(withDuration: 2.0) {\n    self.view.layer.opacity = 0.0\n}\n```\n\n# Advanced Animation Tricks\n\n有很多种方法可以配置基于属性或者关键帧的动画，如果想要同时或顺序运行多种动画时可以使用更高级的方式来同步这些动画的时间将他们链接在一起，我们可以使用其他类型的动画对象来创建视觉转换和一些其他有趣的效果。\n\n## 支持对层级视觉改变的转换动画\n\n如题所示，一个转换动画对象为层级创建视觉动画，转换对象的常见用法是协调一个层级显示和另一个层级消失的动画。不同于修改层级属性的动画，一个转换动画操作层级的缓存图片创建视觉效果，仅通过修改属性是难以做到的。标准类型的转换允许我们只想显示、推送、移动、渐入渐出等动画。\n\n要执行转换动画，需要创建*CATransition*对象并将其添加到与之转换相关的层级上，我们可以使用转换动画指定要执行的转换类型以及动画的起点终点。我们也不需要使用整个转换动画，转换对象可以让我们指定动画时使用的开始与结束进度值，这些值让我们在中点位置开始或者结束动画。\n\n下面代码在两个视图中创建推送转换动画，myView1与myView2在父视图的同一个位置但只有一个视图可见，推送转换会导致一个视图从当前位置往左偏移消失而另一个视图从右边开始偏移到位置显示。更新*isHidden*属性用于视图在动画后的正确显示。\n\n``` Swift\nlet transition = CATransition()\ntransition.startProgress = 0.0\ntransition.endProgress = 1.0\ntransition.type = .push\ntransition.subtype = .fromRight\ntransition.duration = 2.0\n\nmyView1.layer.add(transition, forKey: \"transition\")\nmyView2.layer.add(transition, forKey: \"transition\")\n\nmyView1.isHidden = false\nmyView2.isHidden = true\n```\n\n这里可以使用同一种转换动画，也可以根据需要使用不同的转换动画。\n\n## 自定义动画的时间\n\n时间控制是动画的重要组成部分，Core Animation可以通过*CAMediaTiming*代理的方法和属性来指定动画的时间信息。*CAAnimation*和*CALayer*都已经遵循了这个代理，但是封装这些动画的隐式转换对象通常提供了优先级默认的时间信息。\n\n在考虑时间与动画时，理解层级与动画的合作关系是关键的，每个层级有自己的用于管理动画计时的本地时间。通常情况下，两个不同层级的本地时间是相近的，我们可以为每个层级指定相同的时间值而用户不会注意到，但是，一个层级的本地时间会由它的父级或它自己的时间参数改变。例如，改变层级的*speed*属性会导致该图层及其子层级的持续时间按比例改变。\n\n为了帮助我们确定给定层级适应的时间值，*CALayer*类定义了`convertTime:fromLayer:`与`convertTime:toLayer:`方法。我们可以使用这些方法将固定时间转换成层级的本地时间或者从一个层级的时间转换成另一个层级的。这个方法描述了可能影响层级本地时间，返回我们可能在其他层级使用的媒体时间属性。下面代码展示了从层级获取当前本地时间的例子，`CACurrentMediaTime`是返回电脑当前时间的方法，用来转换方法获取并转换成层级时间。\n\n``` Swift\nlet localLayerTime = view.layer.convertTime(CACurrentMediaTime(), from: nil)\n```\n\n一旦获取到了层级的本地时间，我们可以使用这个值来更新有关时间属性的动画或层级，比如如下操作：\n- *beginTime*属性设置动画的启动时间，通常情况下，动画会在下一轮更新开始，但我们可以用来延迟动画的开始。可以用这个属性来合并两个动画，将一个动画的启动时间设置为另一个时间的结束时间。如果需要延迟动画启动，需要我们将*fillMode*设置为*kCAFillModeBackwards*，这个模式会使动画从初始值启动，如果没有设置，动画会在执行之前跳转到结束位置。\n- *autoreverses*属性使动画在指定的持续时间内执行，然后返回到动画的初始值。可以将这个属性与*repeatCount*属性结合，在开始与结束值之间来回动画。设置循环次数是整数时，动画会在初始值的位置停止，设置循环次数为额外的一半时（如1.5），会让动画在结束为止停止。\n- *timeOffset*属性适用于组动画启动一些动画在其他动画之后的时间启动\n\n## 暂停、恢复动画\n\n暂停动画，可以利用实现*CAMediaTiming*协议的层级设置动画速度为0.0，直到重新修改动画速度恢复动画。\n\n``` Swift\nfunc pauseLayer(layer: CALayer) {\n    let pausedTime = layer.convertTime(CACurrentMediaTime(), from: nil)\n    layer.speed = 0.0\n    layer.timeOffset = pausedTime   // 动画暂停时的时间偏移量\n}\n\nfunc resumeLayer(layer: CALayer) {\n    let pausedTime = layer.timeOffset\n    layer.speed = 1.0\n    layer.timeOffset = 0.0\n    layer.beginTime = 0.0\n    let timeSincePause = layer.convertTime(CACurrentMediaTime(), from: nil) - pausedTime\n    layer.beginTime = timeSincePause    // 动画延迟执行时间\n}\n```\n\n## 修改动画参数的显式Transactions\n\n对层做的每一项操作必须是Transactions的一部分，*CATransaction*类管理动画的创建与分组，并在适当的实际执行他们。多数情况下，我们不需要自己创建Transactions，当对层级添加隐式或显式动画时，Core Animation自动创建隐式transaction。当然，我们也可以创建显式transactions更精确的管理动画。\n\n我们可以通过*CATransaction*类创建和管理transactions，调用`begin`方法开始一个新的transaction（隐式），`commit`方法结束transaction。在这些调用之间是我们希望对transaction的一部分改变。\n\n``` Swift\nCATransaction.begin()\nmyView.layer.zPosition = 200.0\nmyView.layer.opacity = 0.0\nCATransaction.commit()\n```\n\n使用transactions的主要原因之一是在显式transaction的范围内，可以修改持续时间、计时函数和其他参数。我们也可以为整个transaction安排一个完成回调，在一组动画完成后发出通知。修改动画参数需要使用`setValue:forKey:`方法修改字典中对应的键。\n\n``` Swift\nCATransaction.begin()\nCATransaction.setValue(10.0, forKey: kCATransactionAnimationDuration)\n// perform the animations\nCATransaction.commit()\n```\n\n我们可以在为不同动画集提供不同的默认值的情况下嵌套transactions，通过再次调用*begin*方法可以嵌套另一个transaction，每个*begin*方法必须对应*commit*方法。只有在提交最外层transaction后，Core Animation才会开始相关动画。\n\n## 为动画添加透视\n\n应用程序可以在三维空间操作图层，但为了简单起见，Core Animation使用并行投影显示图层，实际上试讲场景压成二维平面，这种默认行为导致具有不同*zPosition*值的层以相同的大小出现，尽管他们在z方向上距离很远。我们可以通过修改转换矩阵来更改该行为，以包含透视信息。\n\n修改场景的透视图时，需要修改包含被查看视图的父层级的*sublayerTransform*矩阵，修改父层级将相同的透视信息运用于所有子层级可以简化代码，他还能确保透视图被正确的应用在不同平面上相互重叠的兄弟层级。\n\n```\nvar perspective = CATransform3DIdentity\nperspective.m34 = -1.0/eyePosition\nview.layer.sublayerTransform = perspective\n```\n\n# Changing a Layer's Default Bahavior\n\nCore Animation使用action对象实现它的隐式层级动画行为。action对象是实现*CAAction*协议的对象，它定义了一些要在层上执行的相关行为。所有*CAAnimation*对象实现了该协议，当一个层级属性变化时，这些对象就被安排来执行修改。\n\n动画属性是action的一种，但我们可以定义大多数我们想要操作的actions，不过要做到这一点，我们必须定义action对象并与应用层级对象关联。\n\n## 自定义实现CAAction协议的Action对象\n\n创建自己的action对象，需要一个类实现*CAAction*协议并实现`runActionForKey:object:arguments:`方法，在这个方法中，使用可用的信息来执行我们想要在该层上执行的任何操作。我们可能用这个方法添加一个动画或者一些其他任务。\n\n当我们定义一个action对象，我们需要觉得触发的条件，这个action的触发是我们用来注册这个action使用的key，也可以在以下情况下被触发：\n- 层级的一个属性改变了，可以是层级的任意属性，不仅仅是动画的这个（我们还可以把自定义属性的actions和层级相关联），标识action的键是这个属性的名字\n- 层级变得可见或者添加到层级结构中，标识的键为*kCAOnOrderIn*\n- 层级从层级结构移除，标识的键为*kCAOnOrderOut*\n- 层级涉及转换动画，标识的键为*kCATransition*\n\n## action对象必须在层级上才能产生效果\n\n在action操作之前，层级需要找到相应的action对象，层级相关action的键是正在修改属性的名称或特殊字符。当适当的事件发生在层级，层级调用*actionForKey:*方法查找对应键的action对象，我们可以在搜索过程中插入多个点并为该键提供相关的action对象。\n\nCore Animation查找action对象的顺序如下：\n1. 如果层级的代理实现了`actionForLayer:forKey:`方法，层级会调用这个方法。代理必须执行以下一项：\n    - 返回给定键的action对象\n    - 返回nil，如果不处理action，查找继续\n    - 返回NSNull对象，查找结束\n2. 层级在actions字典中查找对应的键\n3. 层级在[style](https://developer.apple.com/documentation/quartzcore/calayer/1410875-style)字典中包含该键的actions字典（换句话说，包含actions键的style字典也是字典，层级在第二层字典查找对应键）\n4. 层级调用`defaultActionForKey:`方法\n5. 层级执行Core Animation定义的隐式action\n\n如果我们在任意查询点提供了action对象，层级将停止查询并执行返回的action对象。当查找到一个action对象，层级调用`runActionForKey:object:arguments:`方法执行操作。如果给定键定义的action已经是*CAAnimation*类的实例，则可以使用这个方法的默认实现执行动画。如果是我们自定义实现*CAAction*协议的对象，则必须使用该方法对象实现来执行适当的操作。\n\n在何处安装action对象取决于我们如何修改层级：\n- 对于可能只在特定环境应用的actions，或对于已经使用代理的对象，提供代理并实现`actionForLayer:forKey`方法\n- 对于层级对象补偿使用代理，可以添加action到层级的actions字典中\n- 对于与层对象上定义的自定义属性相关的actions，可以在style字典中包含该action\n- 对于层行为的基本actions，继承层级并复写`defaultActionForKey:`方法\n\n``` objectivec\n- (id<CAAction>)actionForLayer:(CALayer *)theLayer\n                        forKey:(NSString *)theKey {\n    CATransition *theAnimation=nil;\n \n    if ([theKey isEqualToString:@\"contents\"]) {\n \n        theAnimation = [[CATransition alloc] init];\n        theAnimation.duration = 1.0;\n        theAnimation.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseIn];\n        theAnimation.type = kCATransitionPush;\n        theAnimation.subtype = kCATransitionFromRight;\n    }\n    return theAnimation;\n}\n```\n\n## 使用CATransaction类临时禁用actions\n\n我们可以使用*CATransaction*类临时禁用actions，当修改一个层级的属性时，Core Animation通常会创建隐式transaction执行修改，如果不想修改，我们可以创建显式transaction并设置*kCATransactionDisableActions*属性为true禁用隐式动画。\n\n``` objectivec\n[CATransaction begin];\n[CATransaction setValue:(id)kCFBooleanTrue\n                 forKey:kCATransactionDisableActions];\n[aLayer removeFromSuperlayer];\n[CATransaction commit];\n```\n\n# Ending\n\n这一章主要是对于Layer动画的内容、概念的学习，毕竟要熟练运用需要到实际场景中反复使用，其实更关键的是数学模型，有了数学模型生成的路径、时间规划，才能有绚丽的动画。\n\n# Reference\n\n> [About Core Animation](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CoreAnimation_guide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40004514-CH1-SW1)","slug":"2019/core-animation-study-0503","published":1,"updated":"2022-01-10T09:04:52.803Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cky8gmc42000cd1qh3wdjyt9f","content":"<h1 id=\"introduction\">Introduction</h1>\n<p>Core Animation是iOS与OS X平台上的图形渲染和动画基础设施，可以在应用中使视图和其他可见元素产生动画。使用Core Animation，绘制动画的每一帧所需的大部分工作都已经实现。我们所需要做的是配置少量动画参数同时启动动画，Core Animation会完成其余部分，将大部分实际绘图工作交给图形硬件实现加速渲染，这种自动图形加速产生高帧率平滑的动画而不会负担CPU和使应用卡顿。<br>\n当我们在写iOS代码时，不管是否知道我们都在使用Core Animation，如果是OS X，则可以非常轻松的利用Core Animation。Core Animation位于AppKit和UIKit下，被紧密集成到Cocoa和Cocoa Touch的视图流中。当然，Core Animation也有一些应用视图暴露的扩展功能接口，可以让我们更细致控制应用程序的动画。</p>\n<p><img src=\"/img/article/20190503/1.png\" alt=\"Core Animation\"></p>\n<h1 id=\"core-animation-basics\">Core Animation Basics</h1>\n<p>Core Animation提供一个视图和其他可见元素动画的通用系统，它不是View的替代品，相反，他是一种与视图结合，提供更好性能、为视图提供动画的技术。它将视图的内容缓存到可以直接被图形硬件操作的位图中，在一些情况下，这个缓存操作可能会让我们重新思考我们如何呈现和管理我们的应用内容，但是大多数情况我们不需要知道。除了缓存视图内容，Core Animation同样定义了一种方式，指定任意可视内容，结合视图上的内容，让他和其他任意东西一起动起来。</p>\n<h2 id=\"layers提供绘图与动画的基础\">Layers提供绘图与动画的基础</h2>\n<p>Layer对象是三维空间中的二维表面，是Core Animation所做事情的核心。与View一样的是，层级管理其表面的几何、内容、视觉属性信息。与View不同的是，层级不定义他们自己的外观。一个层级仅仅管理位图周围的状态信息，位图本身可以是视图绘制本身的结果，也可以是指定的固定图形的结果。因此，应用中的主要层级被被认为是模型对象，因为他们主要管理数据。这个概念很重要，因为他们影响到动画表现。</p>\n<h3 id=\"层级绘制模型\">层级绘制模型</h3>\n<p>多数层级不是真的绘图，相反，一个Layer捕获内容然后缓存到位图，有时也被称为<strong>后备存储器</strong>。当我们修改一个层级的属性，我们所做的只是修改关联层级的状态信息。当一项改变触发动画，Core Animation将层级的位图和状态信息传递给图形硬件，图形硬件使用新的信息渲染位图。在硬件中操作位图比在软件中可以更快的生成动画。</p>\n<p><img src=\"/img/article/20190503/2.png\" alt=\"How Core Animation draws content\"></p>\n<p>因为它操作静态位图，图层绘图与更传统的视图绘图有很大的不同。使用视图绘图，视图本身的修改经常会出发<code>drawRect:</code>方法的调用，使用新参数重新绘制内容，但这种方式绘图代价很高因为是在主线程使用CPU完成的。Core Animation尽可能通过在硬件中操作缓存位图来达到相同或类似的效果，以此避免这种开销。</p>\n<p>尽管Core Animation尽可能地使用缓存内容，但应用任然必须提供初始内容并不时更新。</p>\n<h3 id=\"层级动画\">层级动画</h3>\n<p>层对象的数据和状态信息与改层内容在屏幕上的可视化表现相互解耦，这种解耦为Core Animation提供的一种方法，使它自我干预，并创建新旧状态的动画。例如，修改一个层级的位置属性会使Core Animation移动层级从当前位置到新状态的位置。</p>\n<p><img src=\"/img/article/20190503/3.png\" alt=\"Examples of animations I can perform on layers\"></p>\n<p>在动画制作过程中，Core Animation会在硬件上逐帧完成绘图。我们所要做的就是指定动画的起点与终点，让Core Animation完成剩下的工作，如有必要，可以同样指定自定义的时间信息和动画参数，如果不提供，Core Animation有合适的默认值。</p>\n<h2 id=\"层级对象定义自身的几何结构\">层级对象定义自身的几何结构</h2>\n<p>一个层级的工作就是管理内容的视觉几何结构，视觉几何结构由内容的bounds，屏幕上的位置信息，是否旋转、缩放、位移的信息构成。和View一样，层级有frame和bounds来定位位置，同样，层级也有View没有的属性，比如锚点坐标。指定层级几何的某些方面的方式也和视图指定信息的方式不同。</p>\n<h3 id=\"layers使用两种坐标系统\">Layers使用两种坐标系统</h3>\n<p>Layers同时使用point-based坐标系和unit坐标系来指定内容的位置。使用哪种坐标系统根据传递信息的类型。当指定直接映射到屏幕坐标系的值或者必须相对于另一个层级的指定，就需要用point-based坐标系，比如一个层级的位置属性。当值与屏幕坐标系无关时使用unit坐标系，比如层级的锚点属性，指定相对于层级自身边界的点。</p>\n<p>point-based坐标系最常见的使用就是指定曾记得大小（bounds）和位置（position）属性，当然也有frame属性，这个属性是由boudns和position属性中派生出来的值，使用频率较低。bounds和frame的坐标系方向：</p>\n<p><img src=\"/img/article/20190503/4.png\" alt=\"The default layer geometries for iOS and OS X\"></p>\n<p>图中的position属性在层级的中点位置，这个属性是根据层级锚点属性中的值更改定义的几个属性之一。锚点是几个使用unit坐标系的属性之一，Core Animation使用unit坐标系表示在层级大小修改时可能受影响的属性，我们可以将unit坐标系看作是总值的百分比，每个unit坐标系中的值在0.0-1.0之间。</p>\n<p><img src=\"/img/article/20190503/5.png\" alt=\"The default unit coordinate systems for iOS and OS X\"></p>\n<h3 id=\"锚点坐标影响几何操作\">锚点坐标影响几何操作</h3>\n<p>一个层级的相关几何操作的发生与层级的锚点相关，我们可以使用锚点属性访问。当操作层级的位置或位移属性时，锚点的作用会更加可见。下图展示了锚点的改变对位置属性的改变：</p>\n<p><img src=\"/img/article/20190503/6.png\" alt=\"How the anchor point affects the layer's position property\"></p>\n<p>下图是锚点对于旋转属性的影响：</p>\n<p><img src=\"/img/article/20190503/7.png\" alt=\"How the anchor point affects layer transformations\"></p>\n<h2 id=\"层级树反应出动画状态的不同方面\">层级树反应出动画状态的不同方面</h2>\n<p>一个使用Core Animation的应用有三种层级对象：</p>\n<ul>\n<li>Objects in the model layer tree：应用中互动最多的层级，模型对象存储动画的目标值，当我们改变层级的属性时，就使用这个对象</li>\n<li>Objects in the presentation tree：包含运行动画中的值，虽然模型层级树包含动画的目标值，但是呈现层级树反应动画的当前值。我们不应该修改这个值</li>\n<li>Objects in the render tree：真正动画实现的层级，Core Animation的私有对象</li>\n</ul>\n<p>每个层级对象被组织成已给层级结构，和应用中的视图一样。事实上，当为所有视图启用层级，每个树的层级结构与视图结构完全匹配。但是，一个应用可以添加额外的层级对象，层级和视图并不是相匹配的。在某些情况下，我们可能会这样这样操作来优化不需要视图而造成的开销。</p>\n<p><img src=\"/img/article/20190503/8.png\" alt=\"The layer trees for a window\"></p>\n<h2 id=\"layers与views的关系\">Layers与Views的关系</h2>\n<p>Layers不能代替Views–我们不能基于层级对象创建可视界面。Layers为Views提供基础，具体地说，Layers可以使视图内容的绘制与动画更加简单有效的同时保证高帧率。当然，Layers不能处理事件，绘制内容，参与响应链等等。</p>\n<h1 id=\"settign-up-layer-objects\">Settign Up Layer Objects</h1>\n<p>Layer对象是Core Animation的核心，层级管理应用的可见内容和提供修改样式和可见外观的选项。</p>\n<h2 id=\"修改view的layer对象\">修改View的Layer对象</h2>\n<p>iOS默认情况下，View会自动创建CALayer类的实例，大多数情况下我们不需要其他类型的层积类。但是，Core Animation提供了不同的层级类，提供可能对我们有用的层级类。<a href=\"https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CoreAnimation_guide/SettingUpLayerObjects/SettingUpLayerObjects.html#//apple_ref/doc/uid/TP40004514-CH13-SW25\" target=\"_blank\" rel=\"noopener\">不同的Layer</a></p>\n<p>修改View的Layer类型：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"keyword\">var</span> layer: <span class=\"type\">CALayer</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"type\">CAShapeLayer</span>()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"提供layer的content\">提供Layer的Content</h2>\n<p>Layers是管理内容的数据对象，一个层级的内容包含我们想要展示可视数据的位图，有以下三种方式提供位图的内容：</p>\n<ul>\n<li>直接给<code>contents</code>属性赋值（适用于层级内容基本不会改变的情况）</li>\n<li>实现Layer的代理方法完成内容的绘制（适用于层级内容可能周期性改变并且可以有外部对象提供，比如View）</li>\n<li>定义一个Layer的子类同时复写<code>drawing</code>方法来自己提供内容（适用于自定义Layer子类或者想要改变层级的基本会话操作）</li>\n</ul>\n<h3 id=\"content赋值图片\">Content赋值图片</h3>\n<p>因为一个层级只是管理位图的容器，我们可以直接给<code>Contents</code>属性赋值图片。层级可以直接使用提供的图片，而不用拷贝一份图片，这个操作可以让图片在不同地方使用时节约内存。赋值的图片类型必须是<em>CGImageRef</em>类型，同时图片的分辨率要适配原生设备。允许的话，需要适当调整图片的<code>ContentsScale</code>属性。</p>\n<h3 id=\"通过代理提供content\">通过代理提供Content</h3>\n<p>如果需要动态修改层级的Content，我们可以使用提供的代理。在显示时，层级会调用以下代理方法：</p>\n<ul>\n<li><code>displayLayer:</code>方法，该实现负责创建位图并将其分配给<code>contents</code>属性</li>\n<li><code>drawLayer:inContext:</code>方法，Core Animation创建一个位图，创建一个图形上下文来绘制位图，然后调用这个方法填充位图。这个方法就是在提供的图形上下文绘图。</li>\n</ul>\n<p>代理必须实现<code>displayLayer:</code>和<code>drawLayer:inContext</code>两种方法之一，如果同时实现，只会调用<code>displayLayer</code>方法。</p>\n<p>当应用程序是在想要显示的地方加载或创建位图时，复写<code>displayLayer:</code>方法更加合适：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)displayLayer:(<span class=\"built_in\">CALayer</span> *)theLayer &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Check the value of some state property</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.displayYesImage) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Display the Yes image</span></span><br><span class=\"line\">        theLayer.contents = [someHelperObject loadStateYesImage];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Display the No image</span></span><br><span class=\"line\">        theLayer.contents = [someHelperObject loadStateNoImage];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>PS：本来这边有个问题，但是后面苹果也自己概述了，对于UIKit下的视图（层支持），我们直接用默认的<code>drawRect</code>方法进行绘制内容。而对于OS X环境下，Layer与View不是直接相关联的，<code>drawRect</code>与<code>drawLayer</code>方法两者之间的区别。<code>drawRect</code>是View的视图渲染方法，<code>drawLayer</code>是Layer的代理方法，两者都可以绘图。目前的调用机制是这样：同时实现两个方法会只调用<code>drawLayer</code>里的实现；无法单独实现<code>drawLayer</code>方法，必须空实现<code>drawRect</code>方法；<code>drawLayer</code>方法也可以由<code>setNeedsDisplay</code>方法调用，同<code>drawRect</code>方法一样。两者用法的区别：是否需要获取视图在动画过程中的Layer属性，<code>drawLayer</code>方法中实现的内容可以实时获取Layer的属性值，<code>drawRect</code>方法只能获取Layer的结果值。<a href=\"https://stackoverflow.com/questions/4979192/ios-using-uiviews-drawrect-vs-its-layers-delegate-drawlayerincontext/36050120#36050120\" target=\"_blank\" rel=\"noopener\">是否对仍待考究</a></p>\n</blockquote>\n<p>如果没有预先编码的图片或者对象来创建位图，可以使用<code>drawLayer</code>方法动态绘制内容：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)drawLayer:(<span class=\"built_in\">CALayer</span> *)theLayer inContext:(<span class=\"built_in\">CGContextRef</span>)theContext &#123;</span><br><span class=\"line\">    <span class=\"built_in\">CGMutablePathRef</span> thePath = <span class=\"built_in\">CGPathCreateMutable</span>();</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"built_in\">CGPathMoveToPoint</span>(thePath,<span class=\"literal\">NULL</span>,<span class=\"number\">15.0</span>f,<span class=\"number\">15.</span>f);</span><br><span class=\"line\">    <span class=\"built_in\">CGPathAddCurveToPoint</span>(thePath,</span><br><span class=\"line\">                          <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">                          <span class=\"number\">15.</span>f,<span class=\"number\">250.0</span>f,</span><br><span class=\"line\">                          <span class=\"number\">295.0</span>f,<span class=\"number\">250.0</span>f,</span><br><span class=\"line\">                          <span class=\"number\">295.0</span>f,<span class=\"number\">15.0</span>f);</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"built_in\">CGContextBeginPath</span>(theContext);</span><br><span class=\"line\">    <span class=\"built_in\">CGContextAddPath</span>(theContext, thePath);</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"built_in\">CGContextSetLineWidth</span>(theContext, <span class=\"number\">5</span>);</span><br><span class=\"line\">    <span class=\"built_in\">CGContextStrokePath</span>(theContext);</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">// Release the path</span></span><br><span class=\"line\">    <span class=\"built_in\">CFRelease</span>(thePath);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对于带有自定义内容的层支持视图，我们应该继续复写视图方法来进行绘图。层支持的绘图自动使自己成为其层的委托，并实现委托所需的委托方法，我们不应该更改这个配置，所以，对于UIView我们还是实现<code>drawRect</code>方法来绘制内容.</p>\n<h3 id=\"通过子类提供content\">通过子类提供Content</h3>\n<p>当实现一个自定义Layer类时，我们可以复写Layer类的绘图方法来进行任何绘图：</p>\n<ul>\n<li>复写<code>display</code>方法，直接设置<code>contents</code>属性</li>\n<li>复写<code>drawInContext:</code>方法，在提供的图形上下文绘制</li>\n</ul>\n<h3 id=\"调整content\">调整Content</h3>\n<p>当我们设置一个图层的<code>contents</code>属性时，<code>contentsGravity</code>属性决定了如何操作该图片来适应边界。默认情况下，如果一张图片大于当前边界，图层对象会缩放图片以适应可用空间。如果图层边界的宽高比与图像的宽高比不同，就会导致图像的失真。<br>\n<code>contentsGravity</code>属性可以被分为以下两类：</p>\n<ul>\n<li>基于位置的重力常量允许我们将图片固定在边缘或角落上，无需缩放图片</li>\n<li>基于缩放的重力常量允许我们使用几种选项之一来拉伸图像，可以保持宽高比，也可以拉伸</li>\n</ul>\n<p>Position-based gravity constants for layers:<br>\n<img src=\"/img/article/20190503/9.png\" alt=\"Position-based gravity constants for layers\"></p>\n<p>Scaling-based gravity constants for layers:<br>\n<img src=\"/img/article/20190503/10.png\" alt=\"Scaling-based gravity constants for layers\"></p>\n<h2 id=\"调整layer的视觉样式和外观\">调整Layer的视觉样式和外观</h2>\n<p>层级对象内置视觉装饰，比如边框、背景色，我们可以用来补充图层的内容。因为这些视觉装饰不需要我们做渲染，所以在某些情况下可以将层作为独立实体使用。我们需要做的就是设置属性，层级会处理必要的绘画，包括动画。</p>\n<h3 id=\"layers有自己的背景和边框\">Layers有自己的背景和边框</h3>\n<p>除了基于图像的内容外，层级可以显示填充背景和边框。背景色在层级内容图片背后渲染，边框在图片上面渲染，如果层级包含子层级，他们也在边框下面。因为背景色位于图像后面，所以这种颜色通过图像的任何透明部分发光。</p>\n<p>如果设置不透明的背景色，考虑设置层级的<code>opaque</code>属性为YES，这样做可以在屏幕上合成图层时提高性能，就不需要使用图层的后备存储来管理alpha通道。但是，如果一个层的角半价不为零，则不能设为不透明。</p>\n<h3 id=\"layers支持倒角\">Layers支持倒角</h3>\n<p>我们可以为层级创建一个圆角矩形效果，倒角是一种视觉装饰，它掩盖了层级边界矩形的部分角，允许底层内容显示。因为它涉及到透明层蒙版，除非<code>maskToBounds</code>属性设置为YES，否则倒角不会影响图层图像。但是，倒角总是影响图层的背景颜色和边框的绘制。</p>\n<h3 id=\"layers支持内置阴影\">Layers支持内置阴影</h3>\n<p>CALayer类包含几种配置阴影效果的属性。阴影通过增加深度使其看起来像漂浮在底层内容之上，这是另一种类型的视觉装饰。我们可以控制阴影颜色，相对于图层内容的位置，不透明度和形状。</p>\n<p>层级阴影的不透明度默认为0，这样可以有效地隐藏阴影。将不透明度修改为非零值会使Core Animation绘制阴影。因为阴影默认直接位于层级的最下方，所以需要更改阴影的偏移量才能看到它。但是务必记住，阴影的偏移量是使用图层的本机坐标系。</p>\n<p><img src=\"/img/article/20190503/11.png\" alt=\"Applying a shadow to a layer\"></p>\n<p>当向图层添加阴影时，阴影是图层内容的一部分，但实际上扩展到图层的边界之外，所以，当图层启用<code>maskToBounds</code>属性时，阴影效果会被剪切到边缘。如果图层包含透明内容，这是会产生一个奇怪的效果，直接在图层下面的阴影部分仍然是可见的，但是超出部分不可见。所以，这是如果想要一个阴影，但也想用<code>maskTobounds</code>属性，我们可以使用两层层级，将该图层嵌入到相同大小应用阴影效果的图层中去。</p>\n<h1 id=\"animating-layer-content\">Animating Layer Content</h1>\n<p>Core Animation提供的基础设施可以让我们更加容易的创建层级动画，扩展到拥有层级的所有视图。</p>\n<h2 id=\"对图层属性的简单修改动画\">对图层属性的简单修改动画</h2>\n<p>简单动画包含隐式动画和显示动画。隐式动画使用默认的时间和动画属性，显式动画需要提供属性的配置。简单动画包含修改层级属性，在时间内完成动画，层级定义了很多影响可见外观的属性，改变其中一个属性会让其产生外观动画。</p>\n<p>只需要更新层级属性就能触发隐式动画，层级的视觉外观不会立即改变，相反，Core Animation会根据属性变化作为触发器来创建调度一个或多个隐式动画执行。因此，像如下代码所示的改变会让Core Animation创建一个动画对象，并在下一个更新周期执行动画。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">theLayer.opacity = <span class=\"number\">0.0</span></span><br></pre></td></tr></table></figure>\n<p>如果想要显式做出如上改变可以创建<em>CABasicAnimation</em>对象同时配置动画参数，可以在添加动画前设置动画的起始与结束值，改变持续时间，或者修改其他动画参数。下面代码展示了如何使用一个对话对象淡化一个层级，创建对象时，指定我们想要动画的属性路径，然后设置动画参数。使用<code>addAnimation:forKey:</code>方法调用动画。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> fadeAnimation = <span class=\"type\">CABasicAnimation</span>(keyPath: <span class=\"string\">\"opacity\"</span>)</span><br><span class=\"line\">fadeAnimation.fromValue = <span class=\"number\">1.0</span></span><br><span class=\"line\">fadeAnimation.toValue = <span class=\"number\">0.0</span></span><br><span class=\"line\">fadeAnimation.duration = <span class=\"number\">1.0</span></span><br><span class=\"line\">layer.add(fadeAnimation, forKey: <span class=\"string\">\"opacity\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Change the actual data value in the layer to the final layer</span></span><br><span class=\"line\">layer.opacity = <span class=\"number\">0.0</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>Tip：当创建显式动画时，推荐使用<code>fromValue</code>属性。如果没有指定这个属性，Core Animation默认使用层级的当前值作为初始值。如果已经当前值等于初始值，可能不会得到想要的效果。</p>\n</blockquote>\n<p>和隐式动画不同，显式动画不会改变层级的真正属性值，显式动画只提供动画。在动画的最后，Core Animation移除动画对象，在层级上使用当前值重新绘制。如果我们想要显式动画是永久更改，还必须更新层级的属性。</p>\n<p>显式和隐式动画在当前runloop结束后开始执行，当前线程必须应用runloop才能让动画执行。如果层级修改多项属性或添加多个动画，所有的动画会在同时执行。</p>\n<h2 id=\"使用关键帧动画修改层级属性\">使用关键帧动画修改层级属性</h2>\n<p>基于属性的动画将属性从初始值更改为结束值，<em>CAKeyframeAnimation</em>对象允许我们通过一组目标值进行动画处理，其方式可能是线性的，也可能不是线性的。关键帧动画包含一组目标数据和每个值对应的时间组成。在最简单的配置中，使用指定值和时间。对于层位置的改变，我们还可以使用路径作为改变。动画对象获取指定关键帧，并通过给定时间段内从一个值穿插下一个值来构建动画。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> path = <span class=\"type\">CGMutablePath</span>()</span><br><span class=\"line\">path.move(to: <span class=\"type\">CGPoint</span>(x: <span class=\"number\">0</span>, y: <span class=\"number\">0</span>))</span><br><span class=\"line\">path.addCurve(to: <span class=\"type\">CGPoint</span>(x: <span class=\"number\">300</span>, y: <span class=\"number\">600</span>), control1: <span class=\"type\">CGPoint</span>(x: <span class=\"number\">200</span>, y: <span class=\"number\">50</span>), control2: <span class=\"type\">CGPoint</span>(x: <span class=\"number\">400</span>, y: <span class=\"number\">350</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> animation = <span class=\"type\">CAKeyframeAnimation</span>(keyPath: <span class=\"string\">\"position\"</span>)</span><br><span class=\"line\">animation.path = path</span><br><span class=\"line\">animation.duration = <span class=\"number\">2.0</span></span><br><span class=\"line\">myView.layer.add(animation, forKey: <span class=\"string\">\"position\"</span>)</span><br></pre></td></tr></table></figure>\n<h3 id=\"指定关键帧数值\">指定关键帧数值</h3>\n<p>关键帧数值在动画中是重要组成部分，这些值定义了动画在执行过程中的行为，指定关键帧的主要方式是将数组指定为包含<em>CGPoint</em>数据类型的值，当然也可以用<em>CGPathRef</em>代替。当指定一组数值，根据属性需要的数据类型提供数据，可以直接添加一些对象，但是一些对象需要转换成id类型，并且所有标量类型或结构体必须由对象包装：</p>\n<ul>\n<li>对于<em>CGRect</em>属性，将每个矩形转换成<em>NSValue</em>对象</li>\n<li>对于层级的转换属性，将<em>CATransform3D</em>矩阵转换成<em>NSValue</em>对象。</li>\n<li>对于<em>borderColo</em>属性，每个<em>CGColorRef</em>数据类型转换成<em>id</em>类型，然后添加到数组中</li>\n<li>对于<em>CGFloat</em>值的属性，将值转换为<em>NSNumber</em>对象添加到数组中</li>\n<li>对于层级的<em>Contents</em>属性，指定一组<em>CGImageRef</em>类型的数据</li>\n</ul>\n<p>对于<em>CGPoint</em>类型数据的属性，可以创建<em>NSValue</em>对象的数组或者创建<em>CGPathRef</em>对象来指定路径。当我们指定一组点，关键帧动画会在每个连续的点之间画一条线并沿着这条路动画。当我们指定一个<em>CGPathRef</em>对象，动画将从路径的起始点开始，并遵循其轮廓，包括沿着任何曲面。</p>\n<h3 id=\"指定关键帧动画的时间点\">指定关键帧动画的时间点</h3>\n<p>关键帧动画的时间和节奏比基本动画更复杂，我们可以使用以下属性控制它：</p>\n<ul>\n<li><em>calculationMode</em>属性定义了用于计算动画计时的算法，这个属性值影响其他与时间相关属性的使用。\n<ol>\n<li>线性和立方动画 – 当<em>calculationMode</em>属性设置为<em>kCAAnimationLinear</em>或者*kCAAnimationCubic`时的动画 – 通过提供的时间信息生成动画，这个模式可以让我们最大程度控制动画时间</li>\n<li>定步动画 – 当<em>calculationMode</em>属性设置为<em>kCAAnimationPaced</em>或者<em>kCAAnimationCubicPaced</em>时的动画 – 不依赖<em>keyTimes</em>或<em>timingFunctions</em>属性提供的外部计时值，相反，计时值是隐式的，以提供恒定速度的动画</li>\n<li>离散动画 – 当<em>calculationMode</em>属性设置为<em>kCAAnimationDiscrete</em>时的动画 – 将动画属性从一个关键帧值直接跳转到另一个，而不需要任何中间值。这种计算模式使用<em>keyTimes</em>属性中的值，但忽略<em>timeingFunctions</em>属性</li>\n</ol>\n</li>\n<li><em>keyTimes</em>属性指定应用每个关键帧值的时间标记，仅当计算模式为<em>kCAAnimationLinear</em>，<em>kCAAnimationDiscrete</em>, <em>kCAAnimationCubic</em>时使用，他不是用于定步动画</li>\n<li><em>timingFunctions</em>属性指定每个关键帧段使用的计时曲线</li>\n</ul>\n<h2 id=\"停止正在运行的显式动画\">停止正在运行的显式动画</h2>\n<p>动画正常运行到结束，但我们可以使用以下技术提前停止动画：</p>\n<ul>\n<li>从层级移除一个单独的动画对象，可以调用<code>removeAnimationForKey:</code>方法。这个方法使用的键是<code>addAnimation:forKey</code>方法传递进去的标识符，不可为空</li>\n<li>从层级移除所有动画，可以调用<code>removeAllAnimations</code>方法。这个方法立即移除所有动画同时使用原始状态重绘层级</li>\n</ul>\n<h2 id=\"同时运行多个动画\">同时运行多个动画</h2>\n<p>如果想要在层级同时运行多个动画，我们可以使用<em>CAAnimationGroup</em>对象整合他们。使用一个组对象简化了对多个动画的管理，应用于组的时间和持续时间将腐败当个动画中的相同值。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> path = <span class=\"type\">CGMutablePath</span>()</span><br><span class=\"line\">path.move(to: <span class=\"type\">CGPoint</span>(x: <span class=\"number\">0</span>, y: <span class=\"number\">0</span>))</span><br><span class=\"line\">path.addCurve(to: <span class=\"type\">CGPoint</span>(x: <span class=\"number\">300</span>, y: <span class=\"number\">600</span>), control1: <span class=\"type\">CGPoint</span>(x: <span class=\"number\">200</span>, y: <span class=\"number\">50</span>), control2: <span class=\"type\">CGPoint</span>(x: <span class=\"number\">400</span>, y: <span class=\"number\">350</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> positionAnimation = <span class=\"type\">CAKeyframeAnimation</span>(keyPath: <span class=\"string\">\"position\"</span>)</span><br><span class=\"line\">positionAnimation.path = path</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> colorAnimation = <span class=\"type\">CAKeyframeAnimation</span>(keyPath: <span class=\"string\">\"backgroundColor\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> colorValues = [<span class=\"type\">UIColor</span>.red.cgColor, <span class=\"type\">UIColor</span>.yellow.cgColor, <span class=\"type\">UIColor</span>.cyan.cgColor]</span><br><span class=\"line\">colorAnimation.values = colorValues</span><br><span class=\"line\">colorAnimation.calculationMode = .paced</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> group = <span class=\"type\">CAAnimationGroup</span>()</span><br><span class=\"line\">group.animations = [positionAnimation, colorAnimation]</span><br><span class=\"line\">group.duration = <span class=\"number\">5.0</span></span><br><span class=\"line\">myView.layer.add(group, forKey: <span class=\"string\">\"group\"</span>)</span><br></pre></td></tr></table></figure>\n<p>使用组动画的进阶方法是使用<em>CATransaction</em>对象，后面讨论。</p>\n<h2 id=\"监测动画的结束\">监测动画的结束</h2>\n<p>Core Animation提供动画起始与结束的监测，这些通知是执行与动画相关任务的好时机。有两种方式监听动画的状态：</p>\n<ul>\n<li>对于<em>CATransaction</em>的类方法，设置<code>setCompletionBlock:</code>方法，在动画结束后会执行回调</li>\n<li>对于<em>CAAnimation</em>对象，可以实现他的代理方法<code>animationDidStart:</code>和<code>animationDidStop:finished:</code></li>\n</ul>\n<p>如果想要一个动画接着一个动画执行，不要使用动画监听。可以使用<em>beginTime</em>属性开始一个动画，设置另一个动画的开始时间是这个动画的结束时间。</p>\n<h2 id=\"如何在layer-backed的视图上动画\">如何在Layer-Backed的视图上动画</h2>\n<p>如果一个层级属于视图，创建动画推荐的方法是使用UIKit提供的基于视图的动画接口。有一些方法可以直接使用Core Animation接口对层进行动画处理。</p>\n<p>对于<em>UIView</em>类，总有一个Layer与之对应，类本身直接从层级派生出它的大部分数据，因此，对层级做出的更改也会自动由视图显示出来，这就意味着我们可以同时使用Core Animation或者UIView提供的接口来动画。</p>\n<p>如果想要使用Core Animation类来初始化动画，必须在基于视图的动画块中调用Core Animation的方法，<em>UIView</em>默认禁止图层动画，但在动画块中重新启动他们。一次，在动画块之外所有的任何更改都不是动画。(针对隐式动画，允许在动画块中启动)</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">UIView</span>.animate(withDuration: <span class=\"number\">2.0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.view.layer.opacity = <span class=\"number\">0.0</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"advanced-animation-tricks\">Advanced Animation Tricks</h1>\n<p>有很多种方法可以配置基于属性或者关键帧的动画，如果想要同时或顺序运行多种动画时可以使用更高级的方式来同步这些动画的时间将他们链接在一起，我们可以使用其他类型的动画对象来创建视觉转换和一些其他有趣的效果。</p>\n<h2 id=\"支持对层级视觉改变的转换动画\">支持对层级视觉改变的转换动画</h2>\n<p>如题所示，一个转换动画对象为层级创建视觉动画，转换对象的常见用法是协调一个层级显示和另一个层级消失的动画。不同于修改层级属性的动画，一个转换动画操作层级的缓存图片创建视觉效果，仅通过修改属性是难以做到的。标准类型的转换允许我们只想显示、推送、移动、渐入渐出等动画。</p>\n<p>要执行转换动画，需要创建<em>CATransition</em>对象并将其添加到与之转换相关的层级上，我们可以使用转换动画指定要执行的转换类型以及动画的起点终点。我们也不需要使用整个转换动画，转换对象可以让我们指定动画时使用的开始与结束进度值，这些值让我们在中点位置开始或者结束动画。</p>\n<p>下面代码在两个视图中创建推送转换动画，myView1与myView2在父视图的同一个位置但只有一个视图可见，推送转换会导致一个视图从当前位置往左偏移消失而另一个视图从右边开始偏移到位置显示。更新<em>isHidden</em>属性用于视图在动画后的正确显示。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> transition = <span class=\"type\">CATransition</span>()</span><br><span class=\"line\">transition.startProgress = <span class=\"number\">0.0</span></span><br><span class=\"line\">transition.endProgress = <span class=\"number\">1.0</span></span><br><span class=\"line\">transition.type = .push</span><br><span class=\"line\">transition.subtype = .fromRight</span><br><span class=\"line\">transition.duration = <span class=\"number\">2.0</span></span><br><span class=\"line\"></span><br><span class=\"line\">myView1.layer.add(transition, forKey: <span class=\"string\">\"transition\"</span>)</span><br><span class=\"line\">myView2.layer.add(transition, forKey: <span class=\"string\">\"transition\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">myView1.isHidden = <span class=\"literal\">false</span></span><br><span class=\"line\">myView2.isHidden = <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n<p>这里可以使用同一种转换动画，也可以根据需要使用不同的转换动画。</p>\n<h2 id=\"自定义动画的时间\">自定义动画的时间</h2>\n<p>时间控制是动画的重要组成部分，Core Animation可以通过<em>CAMediaTiming</em>代理的方法和属性来指定动画的时间信息。<em>CAAnimation</em>和<em>CALayer</em>都已经遵循了这个代理，但是封装这些动画的隐式转换对象通常提供了优先级默认的时间信息。</p>\n<p>在考虑时间与动画时，理解层级与动画的合作关系是关键的，每个层级有自己的用于管理动画计时的本地时间。通常情况下，两个不同层级的本地时间是相近的，我们可以为每个层级指定相同的时间值而用户不会注意到，但是，一个层级的本地时间会由它的父级或它自己的时间参数改变。例如，改变层级的<em>speed</em>属性会导致该图层及其子层级的持续时间按比例改变。</p>\n<p>为了帮助我们确定给定层级适应的时间值，<em>CALayer</em>类定义了<code>convertTime:fromLayer:</code>与<code>convertTime:toLayer:</code>方法。我们可以使用这些方法将固定时间转换成层级的本地时间或者从一个层级的时间转换成另一个层级的。这个方法描述了可能影响层级本地时间，返回我们可能在其他层级使用的媒体时间属性。下面代码展示了从层级获取当前本地时间的例子，<code>CACurrentMediaTime</code>是返回电脑当前时间的方法，用来转换方法获取并转换成层级时间。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> localLayerTime = view.layer.convertTime(<span class=\"type\">CACurrentMediaTime</span>(), from: <span class=\"literal\">nil</span>)</span><br></pre></td></tr></table></figure>\n<p>一旦获取到了层级的本地时间，我们可以使用这个值来更新有关时间属性的动画或层级，比如如下操作：</p>\n<ul>\n<li><em>beginTime</em>属性设置动画的启动时间，通常情况下，动画会在下一轮更新开始，但我们可以用来延迟动画的开始。可以用这个属性来合并两个动画，将一个动画的启动时间设置为另一个时间的结束时间。如果需要延迟动画启动，需要我们将<em>fillMode</em>设置为<em>kCAFillModeBackwards</em>，这个模式会使动画从初始值启动，如果没有设置，动画会在执行之前跳转到结束位置。</li>\n<li><em>autoreverses</em>属性使动画在指定的持续时间内执行，然后返回到动画的初始值。可以将这个属性与<em>repeatCount</em>属性结合，在开始与结束值之间来回动画。设置循环次数是整数时，动画会在初始值的位置停止，设置循环次数为额外的一半时（如1.5），会让动画在结束为止停止。</li>\n<li><em>timeOffset</em>属性适用于组动画启动一些动画在其他动画之后的时间启动</li>\n</ul>\n<h2 id=\"暂停-恢复动画\">暂停、恢复动画</h2>\n<p>暂停动画，可以利用实现<em>CAMediaTiming</em>协议的层级设置动画速度为0.0，直到重新修改动画速度恢复动画。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">pauseLayer</span><span class=\"params\">(layer: CALayer)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> pausedTime = layer.convertTime(<span class=\"type\">CACurrentMediaTime</span>(), from: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">    layer.speed = <span class=\"number\">0.0</span></span><br><span class=\"line\">    layer.timeOffset = pausedTime   <span class=\"comment\">// 动画暂停时的时间偏移量</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">resumeLayer</span><span class=\"params\">(layer: CALayer)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> pausedTime = layer.timeOffset</span><br><span class=\"line\">    layer.speed = <span class=\"number\">1.0</span></span><br><span class=\"line\">    layer.timeOffset = <span class=\"number\">0.0</span></span><br><span class=\"line\">    layer.beginTime = <span class=\"number\">0.0</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> timeSincePause = layer.convertTime(<span class=\"type\">CACurrentMediaTime</span>(), from: <span class=\"literal\">nil</span>) - pausedTime</span><br><span class=\"line\">    layer.beginTime = timeSincePause    <span class=\"comment\">// 动画延迟执行时间</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"修改动画参数的显式transactions\">修改动画参数的显式Transactions</h2>\n<p>对层做的每一项操作必须是Transactions的一部分，<em>CATransaction</em>类管理动画的创建与分组，并在适当的实际执行他们。多数情况下，我们不需要自己创建Transactions，当对层级添加隐式或显式动画时，Core Animation自动创建隐式transaction。当然，我们也可以创建显式transactions更精确的管理动画。</p>\n<p>我们可以通过<em>CATransaction</em>类创建和管理transactions，调用<code>begin</code>方法开始一个新的transaction（隐式），<code>commit</code>方法结束transaction。在这些调用之间是我们希望对transaction的一部分改变。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">CATransaction</span>.begin()</span><br><span class=\"line\">myView.layer.zPosition = <span class=\"number\">200.0</span></span><br><span class=\"line\">myView.layer.opacity = <span class=\"number\">0.0</span></span><br><span class=\"line\"><span class=\"type\">CATransaction</span>.commit()</span><br></pre></td></tr></table></figure>\n<p>使用transactions的主要原因之一是在显式transaction的范围内，可以修改持续时间、计时函数和其他参数。我们也可以为整个transaction安排一个完成回调，在一组动画完成后发出通知。修改动画参数需要使用<code>setValue:forKey:</code>方法修改字典中对应的键。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">CATransaction</span>.begin()</span><br><span class=\"line\"><span class=\"type\">CATransaction</span>.setValue(<span class=\"number\">10.0</span>, forKey: kCATransactionAnimationDuration)</span><br><span class=\"line\"><span class=\"comment\">// perform the animations</span></span><br><span class=\"line\"><span class=\"type\">CATransaction</span>.commit()</span><br></pre></td></tr></table></figure>\n<p>我们可以在为不同动画集提供不同的默认值的情况下嵌套transactions，通过再次调用<em>begin</em>方法可以嵌套另一个transaction，每个<em>begin</em>方法必须对应<em>commit</em>方法。只有在提交最外层transaction后，Core Animation才会开始相关动画。</p>\n<h2 id=\"为动画添加透视\">为动画添加透视</h2>\n<p>应用程序可以在三维空间操作图层，但为了简单起见，Core Animation使用并行投影显示图层，实际上试讲场景压成二维平面，这种默认行为导致具有不同<em>zPosition</em>值的层以相同的大小出现，尽管他们在z方向上距离很远。我们可以通过修改转换矩阵来更改该行为，以包含透视信息。</p>\n<p>修改场景的透视图时，需要修改包含被查看视图的父层级的<em>sublayerTransform</em>矩阵，修改父层级将相同的透视信息运用于所有子层级可以简化代码，他还能确保透视图被正确的应用在不同平面上相互重叠的兄弟层级。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var perspective = CATransform3DIdentity</span><br><span class=\"line\">perspective.m34 = -1.0/eyePosition</span><br><span class=\"line\">view.layer.sublayerTransform = perspective</span><br></pre></td></tr></table></figure>\n<h1 id=\"changing-a-layers-default-bahavior\">Changing a Layer’s Default Bahavior</h1>\n<p>Core Animation使用action对象实现它的隐式层级动画行为。action对象是实现<em>CAAction</em>协议的对象，它定义了一些要在层上执行的相关行为。所有<em>CAAnimation</em>对象实现了该协议，当一个层级属性变化时，这些对象就被安排来执行修改。</p>\n<p>动画属性是action的一种，但我们可以定义大多数我们想要操作的actions，不过要做到这一点，我们必须定义action对象并与应用层级对象关联。</p>\n<h2 id=\"自定义实现caaction协议的action对象\">自定义实现CAAction协议的Action对象</h2>\n<p>创建自己的action对象，需要一个类实现<em>CAAction</em>协议并实现<code>runActionForKey:object:arguments:</code>方法，在这个方法中，使用可用的信息来执行我们想要在该层上执行的任何操作。我们可能用这个方法添加一个动画或者一些其他任务。</p>\n<p>当我们定义一个action对象，我们需要觉得触发的条件，这个action的触发是我们用来注册这个action使用的key，也可以在以下情况下被触发：</p>\n<ul>\n<li>层级的一个属性改变了，可以是层级的任意属性，不仅仅是动画的这个（我们还可以把自定义属性的actions和层级相关联），标识action的键是这个属性的名字</li>\n<li>层级变得可见或者添加到层级结构中，标识的键为<em>kCAOnOrderIn</em></li>\n<li>层级从层级结构移除，标识的键为<em>kCAOnOrderOut</em></li>\n<li>层级涉及转换动画，标识的键为<em>kCATransition</em></li>\n</ul>\n<h2 id=\"action对象必须在层级上才能产生效果\">action对象必须在层级上才能产生效果</h2>\n<p>在action操作之前，层级需要找到相应的action对象，层级相关action的键是正在修改属性的名称或特殊字符。当适当的事件发生在层级，层级调用*actionForKey:*方法查找对应键的action对象，我们可以在搜索过程中插入多个点并为该键提供相关的action对象。</p>\n<p>Core Animation查找action对象的顺序如下：</p>\n<ol>\n<li>如果层级的代理实现了<code>actionForLayer:forKey:</code>方法，层级会调用这个方法。代理必须执行以下一项：\n<ul>\n<li>返回给定键的action对象</li>\n<li>返回nil，如果不处理action，查找继续</li>\n<li>返回NSNull对象，查找结束</li>\n</ul>\n</li>\n<li>层级在actions字典中查找对应的键</li>\n<li>层级在<a href=\"https://developer.apple.com/documentation/quartzcore/calayer/1410875-style\" target=\"_blank\" rel=\"noopener\">style</a>字典中包含该键的actions字典（换句话说，包含actions键的style字典也是字典，层级在第二层字典查找对应键）</li>\n<li>层级调用<code>defaultActionForKey:</code>方法</li>\n<li>层级执行Core Animation定义的隐式action</li>\n</ol>\n<p>如果我们在任意查询点提供了action对象，层级将停止查询并执行返回的action对象。当查找到一个action对象，层级调用<code>runActionForKey:object:arguments:</code>方法执行操作。如果给定键定义的action已经是<em>CAAnimation</em>类的实例，则可以使用这个方法的默认实现执行动画。如果是我们自定义实现<em>CAAction</em>协议的对象，则必须使用该方法对象实现来执行适当的操作。</p>\n<p>在何处安装action对象取决于我们如何修改层级：</p>\n<ul>\n<li>对于可能只在特定环境应用的actions，或对于已经使用代理的对象，提供代理并实现<code>actionForLayer:forKey</code>方法</li>\n<li>对于层级对象补偿使用代理，可以添加action到层级的actions字典中</li>\n<li>对于与层对象上定义的自定义属性相关的actions，可以在style字典中包含该action</li>\n<li>对于层行为的基本actions，继承层级并复写<code>defaultActionForKey:</code>方法</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">id</span>&lt;<span class=\"built_in\">CAAction</span>&gt;)actionForLayer:(<span class=\"built_in\">CALayer</span> *)theLayer</span><br><span class=\"line\">                        forKey:(<span class=\"built_in\">NSString</span> *)theKey &#123;</span><br><span class=\"line\">    <span class=\"built_in\">CATransition</span> *theAnimation=<span class=\"literal\">nil</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">if</span> ([theKey isEqualToString:<span class=\"string\">@\"contents\"</span>]) &#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">        theAnimation = [[<span class=\"built_in\">CATransition</span> alloc] init];</span><br><span class=\"line\">        theAnimation.duration = <span class=\"number\">1.0</span>;</span><br><span class=\"line\">        theAnimation.timingFunction = [<span class=\"built_in\">CAMediaTimingFunction</span> functionWithName:kCAMediaTimingFunctionEaseIn];</span><br><span class=\"line\">        theAnimation.type = kCATransitionPush;</span><br><span class=\"line\">        theAnimation.subtype = kCATransitionFromRight;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> theAnimation;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"使用catransaction类临时禁用actions\">使用CATransaction类临时禁用actions</h2>\n<p>我们可以使用<em>CATransaction</em>类临时禁用actions，当修改一个层级的属性时，Core Animation通常会创建隐式transaction执行修改，如果不想修改，我们可以创建显式transaction并设置<em>kCATransactionDisableActions</em>属性为true禁用隐式动画。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"built_in\">CATransaction</span> begin];</span><br><span class=\"line\">[<span class=\"built_in\">CATransaction</span> setValue:(<span class=\"keyword\">id</span>)kCFBooleanTrue</span><br><span class=\"line\">                 forKey:kCATransactionDisableActions];</span><br><span class=\"line\">[aLayer removeFromSuperlayer];</span><br><span class=\"line\">[<span class=\"built_in\">CATransaction</span> commit];</span><br></pre></td></tr></table></figure>\n<h1 id=\"ending\">Ending</h1>\n<p>这一章主要是对于Layer动画的内容、概念的学习，毕竟要熟练运用需要到实际场景中反复使用，其实更关键的是数学模型，有了数学模型生成的路径、时间规划，才能有绚丽的动画。</p>\n<h1 id=\"reference\">Reference</h1>\n<blockquote>\n<p><a href=\"https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CoreAnimation_guide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40004514-CH1-SW1\" target=\"_blank\" rel=\"noopener\">About Core Animation</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1>Introduction</h1>\n<p>Core Animation是iOS与OS X平台上的图形渲染和动画基础设施，可以在应用中使视图和其他可见元素产生动画。使用Core Animation，绘制动画的每一帧所需的大部分工作都已经实现。我们所需要做的是配置少量动画参数同时启动动画，Core Animation会完成其余部分，将大部分实际绘图工作交给图形硬件实现加速渲染，这种自动图形加速产生高帧率平滑的动画而不会负担CPU和使应用卡顿。<br>\n当我们在写iOS代码时，不管是否知道我们都在使用Core Animation，如果是OS X，则可以非常轻松的利用Core Animation。Core Animation位于AppKit和UIKit下，被紧密集成到Cocoa和Cocoa Touch的视图流中。当然，Core Animation也有一些应用视图暴露的扩展功能接口，可以让我们更细致控制应用程序的动画。</p>\n<p><img src=\"/img/article/20190503/1.png\" alt=\"Core Animation\"></p>\n<h1>Core Animation Basics</h1>\n<p>Core Animation提供一个视图和其他可见元素动画的通用系统，它不是View的替代品，相反，他是一种与视图结合，提供更好性能、为视图提供动画的技术。它将视图的内容缓存到可以直接被图形硬件操作的位图中，在一些情况下，这个缓存操作可能会让我们重新思考我们如何呈现和管理我们的应用内容，但是大多数情况我们不需要知道。除了缓存视图内容，Core Animation同样定义了一种方式，指定任意可视内容，结合视图上的内容，让他和其他任意东西一起动起来。</p>\n<h2>Layers提供绘图与动画的基础</h2>\n<p>Layer对象是三维空间中的二维表面，是Core Animation所做事情的核心。与View一样的是，层级管理其表面的几何、内容、视觉属性信息。与View不同的是，层级不定义他们自己的外观。一个层级仅仅管理位图周围的状态信息，位图本身可以是视图绘制本身的结果，也可以是指定的固定图形的结果。因此，应用中的主要层级被被认为是模型对象，因为他们主要管理数据。这个概念很重要，因为他们影响到动画表现。</p>\n<h3>层级绘制模型</h3>\n<p>多数层级不是真的绘图，相反，一个Layer捕获内容然后缓存到位图，有时也被称为<strong>后备存储器</strong>。当我们修改一个层级的属性，我们所做的只是修改关联层级的状态信息。当一项改变触发动画，Core Animation将层级的位图和状态信息传递给图形硬件，图形硬件使用新的信息渲染位图。在硬件中操作位图比在软件中可以更快的生成动画。</p>\n<p><img src=\"/img/article/20190503/2.png\" alt=\"How Core Animation draws content\"></p>\n<p>因为它操作静态位图，图层绘图与更传统的视图绘图有很大的不同。使用视图绘图，视图本身的修改经常会出发<code>drawRect:</code>方法的调用，使用新参数重新绘制内容，但这种方式绘图代价很高因为是在主线程使用CPU完成的。Core Animation尽可能通过在硬件中操作缓存位图来达到相同或类似的效果，以此避免这种开销。</p>\n<p>尽管Core Animation尽可能地使用缓存内容，但应用任然必须提供初始内容并不时更新。</p>\n<h3>层级动画</h3>\n<p>层对象的数据和状态信息与改层内容在屏幕上的可视化表现相互解耦，这种解耦为Core Animation提供的一种方法，使它自我干预，并创建新旧状态的动画。例如，修改一个层级的位置属性会使Core Animation移动层级从当前位置到新状态的位置。</p>\n<p><img src=\"/img/article/20190503/3.png\" alt=\"Examples of animations I can perform on layers\"></p>\n<p>在动画制作过程中，Core Animation会在硬件上逐帧完成绘图。我们所要做的就是指定动画的起点与终点，让Core Animation完成剩下的工作，如有必要，可以同样指定自定义的时间信息和动画参数，如果不提供，Core Animation有合适的默认值。</p>\n<h2>层级对象定义自身的几何结构</h2>\n<p>一个层级的工作就是管理内容的视觉几何结构，视觉几何结构由内容的bounds，屏幕上的位置信息，是否旋转、缩放、位移的信息构成。和View一样，层级有frame和bounds来定位位置，同样，层级也有View没有的属性，比如锚点坐标。指定层级几何的某些方面的方式也和视图指定信息的方式不同。</p>\n<h3>Layers使用两种坐标系统</h3>\n<p>Layers同时使用point-based坐标系和unit坐标系来指定内容的位置。使用哪种坐标系统根据传递信息的类型。当指定直接映射到屏幕坐标系的值或者必须相对于另一个层级的指定，就需要用point-based坐标系，比如一个层级的位置属性。当值与屏幕坐标系无关时使用unit坐标系，比如层级的锚点属性，指定相对于层级自身边界的点。</p>\n<p>point-based坐标系最常见的使用就是指定曾记得大小（bounds）和位置（position）属性，当然也有frame属性，这个属性是由boudns和position属性中派生出来的值，使用频率较低。bounds和frame的坐标系方向：</p>\n<p><img src=\"/img/article/20190503/4.png\" alt=\"The default layer geometries for iOS and OS X\"></p>\n<p>图中的position属性在层级的中点位置，这个属性是根据层级锚点属性中的值更改定义的几个属性之一。锚点是几个使用unit坐标系的属性之一，Core Animation使用unit坐标系表示在层级大小修改时可能受影响的属性，我们可以将unit坐标系看作是总值的百分比，每个unit坐标系中的值在0.0-1.0之间。</p>\n<p><img src=\"/img/article/20190503/5.png\" alt=\"The default unit coordinate systems for iOS and OS X\"></p>\n<h3>锚点坐标影响几何操作</h3>\n<p>一个层级的相关几何操作的发生与层级的锚点相关，我们可以使用锚点属性访问。当操作层级的位置或位移属性时，锚点的作用会更加可见。下图展示了锚点的改变对位置属性的改变：</p>\n<p><img src=\"/img/article/20190503/6.png\" alt=\"How the anchor point affects the layer's position property\"></p>\n<p>下图是锚点对于旋转属性的影响：</p>\n<p><img src=\"/img/article/20190503/7.png\" alt=\"How the anchor point affects layer transformations\"></p>\n<h2>层级树反应出动画状态的不同方面</h2>\n<p>一个使用Core Animation的应用有三种层级对象：</p>\n<ul>\n<li>Objects in the model layer tree：应用中互动最多的层级，模型对象存储动画的目标值，当我们改变层级的属性时，就使用这个对象</li>\n<li>Objects in the presentation tree：包含运行动画中的值，虽然模型层级树包含动画的目标值，但是呈现层级树反应动画的当前值。我们不应该修改这个值</li>\n<li>Objects in the render tree：真正动画实现的层级，Core Animation的私有对象</li>\n</ul>\n<p>每个层级对象被组织成已给层级结构，和应用中的视图一样。事实上，当为所有视图启用层级，每个树的层级结构与视图结构完全匹配。但是，一个应用可以添加额外的层级对象，层级和视图并不是相匹配的。在某些情况下，我们可能会这样这样操作来优化不需要视图而造成的开销。</p>\n<p><img src=\"/img/article/20190503/8.png\" alt=\"The layer trees for a window\"></p>\n<h2>Layers与Views的关系</h2>\n<p>Layers不能代替Views–我们不能基于层级对象创建可视界面。Layers为Views提供基础，具体地说，Layers可以使视图内容的绘制与动画更加简单有效的同时保证高帧率。当然，Layers不能处理事件，绘制内容，参与响应链等等。</p>\n<h1>Settign Up Layer Objects</h1>\n<p>Layer对象是Core Animation的核心，层级管理应用的可见内容和提供修改样式和可见外观的选项。</p>\n<h2>修改View的Layer对象</h2>\n<p>iOS默认情况下，View会自动创建CALayer类的实例，大多数情况下我们不需要其他类型的层积类。但是，Core Animation提供了不同的层级类，提供可能对我们有用的层级类。<a href=\"https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CoreAnimation_guide/SettingUpLayerObjects/SettingUpLayerObjects.html#//apple_ref/doc/uid/TP40004514-CH13-SW25\" target=\"_blank\" rel=\"noopener\">不同的Layer</a></p>\n<p>修改View的Layer类型：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"keyword\">var</span> layer: <span class=\"type\">CALayer</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"type\">CAShapeLayer</span>()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2>提供Layer的Content</h2>\n<p>Layers是管理内容的数据对象，一个层级的内容包含我们想要展示可视数据的位图，有以下三种方式提供位图的内容：</p>\n<ul>\n<li>直接给<code>contents</code>属性赋值（适用于层级内容基本不会改变的情况）</li>\n<li>实现Layer的代理方法完成内容的绘制（适用于层级内容可能周期性改变并且可以有外部对象提供，比如View）</li>\n<li>定义一个Layer的子类同时复写<code>drawing</code>方法来自己提供内容（适用于自定义Layer子类或者想要改变层级的基本会话操作）</li>\n</ul>\n<h3>Content赋值图片</h3>\n<p>因为一个层级只是管理位图的容器，我们可以直接给<code>Contents</code>属性赋值图片。层级可以直接使用提供的图片，而不用拷贝一份图片，这个操作可以让图片在不同地方使用时节约内存。赋值的图片类型必须是<em>CGImageRef</em>类型，同时图片的分辨率要适配原生设备。允许的话，需要适当调整图片的<code>ContentsScale</code>属性。</p>\n<h3>通过代理提供Content</h3>\n<p>如果需要动态修改层级的Content，我们可以使用提供的代理。在显示时，层级会调用以下代理方法：</p>\n<ul>\n<li><code>displayLayer:</code>方法，该实现负责创建位图并将其分配给<code>contents</code>属性</li>\n<li><code>drawLayer:inContext:</code>方法，Core Animation创建一个位图，创建一个图形上下文来绘制位图，然后调用这个方法填充位图。这个方法就是在提供的图形上下文绘图。</li>\n</ul>\n<p>代理必须实现<code>displayLayer:</code>和<code>drawLayer:inContext</code>两种方法之一，如果同时实现，只会调用<code>displayLayer</code>方法。</p>\n<p>当应用程序是在想要显示的地方加载或创建位图时，复写<code>displayLayer:</code>方法更加合适：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)displayLayer:(<span class=\"built_in\">CALayer</span> *)theLayer &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Check the value of some state property</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.displayYesImage) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Display the Yes image</span></span><br><span class=\"line\">        theLayer.contents = [someHelperObject loadStateYesImage];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Display the No image</span></span><br><span class=\"line\">        theLayer.contents = [someHelperObject loadStateNoImage];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>PS：本来这边有个问题，但是后面苹果也自己概述了，对于UIKit下的视图（层支持），我们直接用默认的<code>drawRect</code>方法进行绘制内容。而对于OS X环境下，Layer与View不是直接相关联的，<code>drawRect</code>与<code>drawLayer</code>方法两者之间的区别。<code>drawRect</code>是View的视图渲染方法，<code>drawLayer</code>是Layer的代理方法，两者都可以绘图。目前的调用机制是这样：同时实现两个方法会只调用<code>drawLayer</code>里的实现；无法单独实现<code>drawLayer</code>方法，必须空实现<code>drawRect</code>方法；<code>drawLayer</code>方法也可以由<code>setNeedsDisplay</code>方法调用，同<code>drawRect</code>方法一样。两者用法的区别：是否需要获取视图在动画过程中的Layer属性，<code>drawLayer</code>方法中实现的内容可以实时获取Layer的属性值，<code>drawRect</code>方法只能获取Layer的结果值。<a href=\"https://stackoverflow.com/questions/4979192/ios-using-uiviews-drawrect-vs-its-layers-delegate-drawlayerincontext/36050120#36050120\" target=\"_blank\" rel=\"noopener\">是否对仍待考究</a></p>\n</blockquote>\n<p>如果没有预先编码的图片或者对象来创建位图，可以使用<code>drawLayer</code>方法动态绘制内容：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)drawLayer:(<span class=\"built_in\">CALayer</span> *)theLayer inContext:(<span class=\"built_in\">CGContextRef</span>)theContext &#123;</span><br><span class=\"line\">    <span class=\"built_in\">CGMutablePathRef</span> thePath = <span class=\"built_in\">CGPathCreateMutable</span>();</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"built_in\">CGPathMoveToPoint</span>(thePath,<span class=\"literal\">NULL</span>,<span class=\"number\">15.0</span>f,<span class=\"number\">15.</span>f);</span><br><span class=\"line\">    <span class=\"built_in\">CGPathAddCurveToPoint</span>(thePath,</span><br><span class=\"line\">                          <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">                          <span class=\"number\">15.</span>f,<span class=\"number\">250.0</span>f,</span><br><span class=\"line\">                          <span class=\"number\">295.0</span>f,<span class=\"number\">250.0</span>f,</span><br><span class=\"line\">                          <span class=\"number\">295.0</span>f,<span class=\"number\">15.0</span>f);</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"built_in\">CGContextBeginPath</span>(theContext);</span><br><span class=\"line\">    <span class=\"built_in\">CGContextAddPath</span>(theContext, thePath);</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"built_in\">CGContextSetLineWidth</span>(theContext, <span class=\"number\">5</span>);</span><br><span class=\"line\">    <span class=\"built_in\">CGContextStrokePath</span>(theContext);</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">// Release the path</span></span><br><span class=\"line\">    <span class=\"built_in\">CFRelease</span>(thePath);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对于带有自定义内容的层支持视图，我们应该继续复写视图方法来进行绘图。层支持的绘图自动使自己成为其层的委托，并实现委托所需的委托方法，我们不应该更改这个配置，所以，对于UIView我们还是实现<code>drawRect</code>方法来绘制内容.</p>\n<h3>通过子类提供Content</h3>\n<p>当实现一个自定义Layer类时，我们可以复写Layer类的绘图方法来进行任何绘图：</p>\n<ul>\n<li>复写<code>display</code>方法，直接设置<code>contents</code>属性</li>\n<li>复写<code>drawInContext:</code>方法，在提供的图形上下文绘制</li>\n</ul>\n<h3>调整Content</h3>\n<p>当我们设置一个图层的<code>contents</code>属性时，<code>contentsGravity</code>属性决定了如何操作该图片来适应边界。默认情况下，如果一张图片大于当前边界，图层对象会缩放图片以适应可用空间。如果图层边界的宽高比与图像的宽高比不同，就会导致图像的失真。<br>\n<code>contentsGravity</code>属性可以被分为以下两类：</p>\n<ul>\n<li>基于位置的重力常量允许我们将图片固定在边缘或角落上，无需缩放图片</li>\n<li>基于缩放的重力常量允许我们使用几种选项之一来拉伸图像，可以保持宽高比，也可以拉伸</li>\n</ul>\n<p>Position-based gravity constants for layers:<br>\n<img src=\"/img/article/20190503/9.png\" alt=\"Position-based gravity constants for layers\"></p>\n<p>Scaling-based gravity constants for layers:<br>\n<img src=\"/img/article/20190503/10.png\" alt=\"Scaling-based gravity constants for layers\"></p>\n<h2>调整Layer的视觉样式和外观</h2>\n<p>层级对象内置视觉装饰，比如边框、背景色，我们可以用来补充图层的内容。因为这些视觉装饰不需要我们做渲染，所以在某些情况下可以将层作为独立实体使用。我们需要做的就是设置属性，层级会处理必要的绘画，包括动画。</p>\n<h3>Layers有自己的背景和边框</h3>\n<p>除了基于图像的内容外，层级可以显示填充背景和边框。背景色在层级内容图片背后渲染，边框在图片上面渲染，如果层级包含子层级，他们也在边框下面。因为背景色位于图像后面，所以这种颜色通过图像的任何透明部分发光。</p>\n<p>如果设置不透明的背景色，考虑设置层级的<code>opaque</code>属性为YES，这样做可以在屏幕上合成图层时提高性能，就不需要使用图层的后备存储来管理alpha通道。但是，如果一个层的角半价不为零，则不能设为不透明。</p>\n<h3>Layers支持倒角</h3>\n<p>我们可以为层级创建一个圆角矩形效果，倒角是一种视觉装饰，它掩盖了层级边界矩形的部分角，允许底层内容显示。因为它涉及到透明层蒙版，除非<code>maskToBounds</code>属性设置为YES，否则倒角不会影响图层图像。但是，倒角总是影响图层的背景颜色和边框的绘制。</p>\n<h3>Layers支持内置阴影</h3>\n<p>CALayer类包含几种配置阴影效果的属性。阴影通过增加深度使其看起来像漂浮在底层内容之上，这是另一种类型的视觉装饰。我们可以控制阴影颜色，相对于图层内容的位置，不透明度和形状。</p>\n<p>层级阴影的不透明度默认为0，这样可以有效地隐藏阴影。将不透明度修改为非零值会使Core Animation绘制阴影。因为阴影默认直接位于层级的最下方，所以需要更改阴影的偏移量才能看到它。但是务必记住，阴影的偏移量是使用图层的本机坐标系。</p>\n<p><img src=\"/img/article/20190503/11.png\" alt=\"Applying a shadow to a layer\"></p>\n<p>当向图层添加阴影时，阴影是图层内容的一部分，但实际上扩展到图层的边界之外，所以，当图层启用<code>maskToBounds</code>属性时，阴影效果会被剪切到边缘。如果图层包含透明内容，这是会产生一个奇怪的效果，直接在图层下面的阴影部分仍然是可见的，但是超出部分不可见。所以，这是如果想要一个阴影，但也想用<code>maskTobounds</code>属性，我们可以使用两层层级，将该图层嵌入到相同大小应用阴影效果的图层中去。</p>\n<h1>Animating Layer Content</h1>\n<p>Core Animation提供的基础设施可以让我们更加容易的创建层级动画，扩展到拥有层级的所有视图。</p>\n<h2>对图层属性的简单修改动画</h2>\n<p>简单动画包含隐式动画和显示动画。隐式动画使用默认的时间和动画属性，显式动画需要提供属性的配置。简单动画包含修改层级属性，在时间内完成动画，层级定义了很多影响可见外观的属性，改变其中一个属性会让其产生外观动画。</p>\n<p>只需要更新层级属性就能触发隐式动画，层级的视觉外观不会立即改变，相反，Core Animation会根据属性变化作为触发器来创建调度一个或多个隐式动画执行。因此，像如下代码所示的改变会让Core Animation创建一个动画对象，并在下一个更新周期执行动画。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">theLayer.opacity = <span class=\"number\">0.0</span></span><br></pre></td></tr></table></figure>\n<p>如果想要显式做出如上改变可以创建<em>CABasicAnimation</em>对象同时配置动画参数，可以在添加动画前设置动画的起始与结束值，改变持续时间，或者修改其他动画参数。下面代码展示了如何使用一个对话对象淡化一个层级，创建对象时，指定我们想要动画的属性路径，然后设置动画参数。使用<code>addAnimation:forKey:</code>方法调用动画。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> fadeAnimation = <span class=\"type\">CABasicAnimation</span>(keyPath: <span class=\"string\">\"opacity\"</span>)</span><br><span class=\"line\">fadeAnimation.fromValue = <span class=\"number\">1.0</span></span><br><span class=\"line\">fadeAnimation.toValue = <span class=\"number\">0.0</span></span><br><span class=\"line\">fadeAnimation.duration = <span class=\"number\">1.0</span></span><br><span class=\"line\">layer.add(fadeAnimation, forKey: <span class=\"string\">\"opacity\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Change the actual data value in the layer to the final layer</span></span><br><span class=\"line\">layer.opacity = <span class=\"number\">0.0</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>Tip：当创建显式动画时，推荐使用<code>fromValue</code>属性。如果没有指定这个属性，Core Animation默认使用层级的当前值作为初始值。如果已经当前值等于初始值，可能不会得到想要的效果。</p>\n</blockquote>\n<p>和隐式动画不同，显式动画不会改变层级的真正属性值，显式动画只提供动画。在动画的最后，Core Animation移除动画对象，在层级上使用当前值重新绘制。如果我们想要显式动画是永久更改，还必须更新层级的属性。</p>\n<p>显式和隐式动画在当前runloop结束后开始执行，当前线程必须应用runloop才能让动画执行。如果层级修改多项属性或添加多个动画，所有的动画会在同时执行。</p>\n<h2>使用关键帧动画修改层级属性</h2>\n<p>基于属性的动画将属性从初始值更改为结束值，<em>CAKeyframeAnimation</em>对象允许我们通过一组目标值进行动画处理，其方式可能是线性的，也可能不是线性的。关键帧动画包含一组目标数据和每个值对应的时间组成。在最简单的配置中，使用指定值和时间。对于层位置的改变，我们还可以使用路径作为改变。动画对象获取指定关键帧，并通过给定时间段内从一个值穿插下一个值来构建动画。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> path = <span class=\"type\">CGMutablePath</span>()</span><br><span class=\"line\">path.move(to: <span class=\"type\">CGPoint</span>(x: <span class=\"number\">0</span>, y: <span class=\"number\">0</span>))</span><br><span class=\"line\">path.addCurve(to: <span class=\"type\">CGPoint</span>(x: <span class=\"number\">300</span>, y: <span class=\"number\">600</span>), control1: <span class=\"type\">CGPoint</span>(x: <span class=\"number\">200</span>, y: <span class=\"number\">50</span>), control2: <span class=\"type\">CGPoint</span>(x: <span class=\"number\">400</span>, y: <span class=\"number\">350</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> animation = <span class=\"type\">CAKeyframeAnimation</span>(keyPath: <span class=\"string\">\"position\"</span>)</span><br><span class=\"line\">animation.path = path</span><br><span class=\"line\">animation.duration = <span class=\"number\">2.0</span></span><br><span class=\"line\">myView.layer.add(animation, forKey: <span class=\"string\">\"position\"</span>)</span><br></pre></td></tr></table></figure>\n<h3>指定关键帧数值</h3>\n<p>关键帧数值在动画中是重要组成部分，这些值定义了动画在执行过程中的行为，指定关键帧的主要方式是将数组指定为包含<em>CGPoint</em>数据类型的值，当然也可以用<em>CGPathRef</em>代替。当指定一组数值，根据属性需要的数据类型提供数据，可以直接添加一些对象，但是一些对象需要转换成id类型，并且所有标量类型或结构体必须由对象包装：</p>\n<ul>\n<li>对于<em>CGRect</em>属性，将每个矩形转换成<em>NSValue</em>对象</li>\n<li>对于层级的转换属性，将<em>CATransform3D</em>矩阵转换成<em>NSValue</em>对象。</li>\n<li>对于<em>borderColo</em>属性，每个<em>CGColorRef</em>数据类型转换成<em>id</em>类型，然后添加到数组中</li>\n<li>对于<em>CGFloat</em>值的属性，将值转换为<em>NSNumber</em>对象添加到数组中</li>\n<li>对于层级的<em>Contents</em>属性，指定一组<em>CGImageRef</em>类型的数据</li>\n</ul>\n<p>对于<em>CGPoint</em>类型数据的属性，可以创建<em>NSValue</em>对象的数组或者创建<em>CGPathRef</em>对象来指定路径。当我们指定一组点，关键帧动画会在每个连续的点之间画一条线并沿着这条路动画。当我们指定一个<em>CGPathRef</em>对象，动画将从路径的起始点开始，并遵循其轮廓，包括沿着任何曲面。</p>\n<h3>指定关键帧动画的时间点</h3>\n<p>关键帧动画的时间和节奏比基本动画更复杂，我们可以使用以下属性控制它：</p>\n<ul>\n<li><em>calculationMode</em>属性定义了用于计算动画计时的算法，这个属性值影响其他与时间相关属性的使用。\n<ol>\n<li>线性和立方动画 – 当<em>calculationMode</em>属性设置为<em>kCAAnimationLinear</em>或者*kCAAnimationCubic`时的动画 – 通过提供的时间信息生成动画，这个模式可以让我们最大程度控制动画时间</li>\n<li>定步动画 – 当<em>calculationMode</em>属性设置为<em>kCAAnimationPaced</em>或者<em>kCAAnimationCubicPaced</em>时的动画 – 不依赖<em>keyTimes</em>或<em>timingFunctions</em>属性提供的外部计时值，相反，计时值是隐式的，以提供恒定速度的动画</li>\n<li>离散动画 – 当<em>calculationMode</em>属性设置为<em>kCAAnimationDiscrete</em>时的动画 – 将动画属性从一个关键帧值直接跳转到另一个，而不需要任何中间值。这种计算模式使用<em>keyTimes</em>属性中的值，但忽略<em>timeingFunctions</em>属性</li>\n</ol>\n</li>\n<li><em>keyTimes</em>属性指定应用每个关键帧值的时间标记，仅当计算模式为<em>kCAAnimationLinear</em>，<em>kCAAnimationDiscrete</em>, <em>kCAAnimationCubic</em>时使用，他不是用于定步动画</li>\n<li><em>timingFunctions</em>属性指定每个关键帧段使用的计时曲线</li>\n</ul>\n<h2>停止正在运行的显式动画</h2>\n<p>动画正常运行到结束，但我们可以使用以下技术提前停止动画：</p>\n<ul>\n<li>从层级移除一个单独的动画对象，可以调用<code>removeAnimationForKey:</code>方法。这个方法使用的键是<code>addAnimation:forKey</code>方法传递进去的标识符，不可为空</li>\n<li>从层级移除所有动画，可以调用<code>removeAllAnimations</code>方法。这个方法立即移除所有动画同时使用原始状态重绘层级</li>\n</ul>\n<h2>同时运行多个动画</h2>\n<p>如果想要在层级同时运行多个动画，我们可以使用<em>CAAnimationGroup</em>对象整合他们。使用一个组对象简化了对多个动画的管理，应用于组的时间和持续时间将腐败当个动画中的相同值。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> path = <span class=\"type\">CGMutablePath</span>()</span><br><span class=\"line\">path.move(to: <span class=\"type\">CGPoint</span>(x: <span class=\"number\">0</span>, y: <span class=\"number\">0</span>))</span><br><span class=\"line\">path.addCurve(to: <span class=\"type\">CGPoint</span>(x: <span class=\"number\">300</span>, y: <span class=\"number\">600</span>), control1: <span class=\"type\">CGPoint</span>(x: <span class=\"number\">200</span>, y: <span class=\"number\">50</span>), control2: <span class=\"type\">CGPoint</span>(x: <span class=\"number\">400</span>, y: <span class=\"number\">350</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> positionAnimation = <span class=\"type\">CAKeyframeAnimation</span>(keyPath: <span class=\"string\">\"position\"</span>)</span><br><span class=\"line\">positionAnimation.path = path</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> colorAnimation = <span class=\"type\">CAKeyframeAnimation</span>(keyPath: <span class=\"string\">\"backgroundColor\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> colorValues = [<span class=\"type\">UIColor</span>.red.cgColor, <span class=\"type\">UIColor</span>.yellow.cgColor, <span class=\"type\">UIColor</span>.cyan.cgColor]</span><br><span class=\"line\">colorAnimation.values = colorValues</span><br><span class=\"line\">colorAnimation.calculationMode = .paced</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> group = <span class=\"type\">CAAnimationGroup</span>()</span><br><span class=\"line\">group.animations = [positionAnimation, colorAnimation]</span><br><span class=\"line\">group.duration = <span class=\"number\">5.0</span></span><br><span class=\"line\">myView.layer.add(group, forKey: <span class=\"string\">\"group\"</span>)</span><br></pre></td></tr></table></figure>\n<p>使用组动画的进阶方法是使用<em>CATransaction</em>对象，后面讨论。</p>\n<h2>监测动画的结束</h2>\n<p>Core Animation提供动画起始与结束的监测，这些通知是执行与动画相关任务的好时机。有两种方式监听动画的状态：</p>\n<ul>\n<li>对于<em>CATransaction</em>的类方法，设置<code>setCompletionBlock:</code>方法，在动画结束后会执行回调</li>\n<li>对于<em>CAAnimation</em>对象，可以实现他的代理方法<code>animationDidStart:</code>和<code>animationDidStop:finished:</code></li>\n</ul>\n<p>如果想要一个动画接着一个动画执行，不要使用动画监听。可以使用<em>beginTime</em>属性开始一个动画，设置另一个动画的开始时间是这个动画的结束时间。</p>\n<h2>如何在Layer-Backed的视图上动画</h2>\n<p>如果一个层级属于视图，创建动画推荐的方法是使用UIKit提供的基于视图的动画接口。有一些方法可以直接使用Core Animation接口对层进行动画处理。</p>\n<p>对于<em>UIView</em>类，总有一个Layer与之对应，类本身直接从层级派生出它的大部分数据，因此，对层级做出的更改也会自动由视图显示出来，这就意味着我们可以同时使用Core Animation或者UIView提供的接口来动画。</p>\n<p>如果想要使用Core Animation类来初始化动画，必须在基于视图的动画块中调用Core Animation的方法，<em>UIView</em>默认禁止图层动画，但在动画块中重新启动他们。一次，在动画块之外所有的任何更改都不是动画。(针对隐式动画，允许在动画块中启动)</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">UIView</span>.animate(withDuration: <span class=\"number\">2.0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.view.layer.opacity = <span class=\"number\">0.0</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1>Advanced Animation Tricks</h1>\n<p>有很多种方法可以配置基于属性或者关键帧的动画，如果想要同时或顺序运行多种动画时可以使用更高级的方式来同步这些动画的时间将他们链接在一起，我们可以使用其他类型的动画对象来创建视觉转换和一些其他有趣的效果。</p>\n<h2>支持对层级视觉改变的转换动画</h2>\n<p>如题所示，一个转换动画对象为层级创建视觉动画，转换对象的常见用法是协调一个层级显示和另一个层级消失的动画。不同于修改层级属性的动画，一个转换动画操作层级的缓存图片创建视觉效果，仅通过修改属性是难以做到的。标准类型的转换允许我们只想显示、推送、移动、渐入渐出等动画。</p>\n<p>要执行转换动画，需要创建<em>CATransition</em>对象并将其添加到与之转换相关的层级上，我们可以使用转换动画指定要执行的转换类型以及动画的起点终点。我们也不需要使用整个转换动画，转换对象可以让我们指定动画时使用的开始与结束进度值，这些值让我们在中点位置开始或者结束动画。</p>\n<p>下面代码在两个视图中创建推送转换动画，myView1与myView2在父视图的同一个位置但只有一个视图可见，推送转换会导致一个视图从当前位置往左偏移消失而另一个视图从右边开始偏移到位置显示。更新<em>isHidden</em>属性用于视图在动画后的正确显示。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> transition = <span class=\"type\">CATransition</span>()</span><br><span class=\"line\">transition.startProgress = <span class=\"number\">0.0</span></span><br><span class=\"line\">transition.endProgress = <span class=\"number\">1.0</span></span><br><span class=\"line\">transition.type = .push</span><br><span class=\"line\">transition.subtype = .fromRight</span><br><span class=\"line\">transition.duration = <span class=\"number\">2.0</span></span><br><span class=\"line\"></span><br><span class=\"line\">myView1.layer.add(transition, forKey: <span class=\"string\">\"transition\"</span>)</span><br><span class=\"line\">myView2.layer.add(transition, forKey: <span class=\"string\">\"transition\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">myView1.isHidden = <span class=\"literal\">false</span></span><br><span class=\"line\">myView2.isHidden = <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n<p>这里可以使用同一种转换动画，也可以根据需要使用不同的转换动画。</p>\n<h2>自定义动画的时间</h2>\n<p>时间控制是动画的重要组成部分，Core Animation可以通过<em>CAMediaTiming</em>代理的方法和属性来指定动画的时间信息。<em>CAAnimation</em>和<em>CALayer</em>都已经遵循了这个代理，但是封装这些动画的隐式转换对象通常提供了优先级默认的时间信息。</p>\n<p>在考虑时间与动画时，理解层级与动画的合作关系是关键的，每个层级有自己的用于管理动画计时的本地时间。通常情况下，两个不同层级的本地时间是相近的，我们可以为每个层级指定相同的时间值而用户不会注意到，但是，一个层级的本地时间会由它的父级或它自己的时间参数改变。例如，改变层级的<em>speed</em>属性会导致该图层及其子层级的持续时间按比例改变。</p>\n<p>为了帮助我们确定给定层级适应的时间值，<em>CALayer</em>类定义了<code>convertTime:fromLayer:</code>与<code>convertTime:toLayer:</code>方法。我们可以使用这些方法将固定时间转换成层级的本地时间或者从一个层级的时间转换成另一个层级的。这个方法描述了可能影响层级本地时间，返回我们可能在其他层级使用的媒体时间属性。下面代码展示了从层级获取当前本地时间的例子，<code>CACurrentMediaTime</code>是返回电脑当前时间的方法，用来转换方法获取并转换成层级时间。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> localLayerTime = view.layer.convertTime(<span class=\"type\">CACurrentMediaTime</span>(), from: <span class=\"literal\">nil</span>)</span><br></pre></td></tr></table></figure>\n<p>一旦获取到了层级的本地时间，我们可以使用这个值来更新有关时间属性的动画或层级，比如如下操作：</p>\n<ul>\n<li><em>beginTime</em>属性设置动画的启动时间，通常情况下，动画会在下一轮更新开始，但我们可以用来延迟动画的开始。可以用这个属性来合并两个动画，将一个动画的启动时间设置为另一个时间的结束时间。如果需要延迟动画启动，需要我们将<em>fillMode</em>设置为<em>kCAFillModeBackwards</em>，这个模式会使动画从初始值启动，如果没有设置，动画会在执行之前跳转到结束位置。</li>\n<li><em>autoreverses</em>属性使动画在指定的持续时间内执行，然后返回到动画的初始值。可以将这个属性与<em>repeatCount</em>属性结合，在开始与结束值之间来回动画。设置循环次数是整数时，动画会在初始值的位置停止，设置循环次数为额外的一半时（如1.5），会让动画在结束为止停止。</li>\n<li><em>timeOffset</em>属性适用于组动画启动一些动画在其他动画之后的时间启动</li>\n</ul>\n<h2>暂停、恢复动画</h2>\n<p>暂停动画，可以利用实现<em>CAMediaTiming</em>协议的层级设置动画速度为0.0，直到重新修改动画速度恢复动画。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">pauseLayer</span><span class=\"params\">(layer: CALayer)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> pausedTime = layer.convertTime(<span class=\"type\">CACurrentMediaTime</span>(), from: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">    layer.speed = <span class=\"number\">0.0</span></span><br><span class=\"line\">    layer.timeOffset = pausedTime   <span class=\"comment\">// 动画暂停时的时间偏移量</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">resumeLayer</span><span class=\"params\">(layer: CALayer)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> pausedTime = layer.timeOffset</span><br><span class=\"line\">    layer.speed = <span class=\"number\">1.0</span></span><br><span class=\"line\">    layer.timeOffset = <span class=\"number\">0.0</span></span><br><span class=\"line\">    layer.beginTime = <span class=\"number\">0.0</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> timeSincePause = layer.convertTime(<span class=\"type\">CACurrentMediaTime</span>(), from: <span class=\"literal\">nil</span>) - pausedTime</span><br><span class=\"line\">    layer.beginTime = timeSincePause    <span class=\"comment\">// 动画延迟执行时间</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2>修改动画参数的显式Transactions</h2>\n<p>对层做的每一项操作必须是Transactions的一部分，<em>CATransaction</em>类管理动画的创建与分组，并在适当的实际执行他们。多数情况下，我们不需要自己创建Transactions，当对层级添加隐式或显式动画时，Core Animation自动创建隐式transaction。当然，我们也可以创建显式transactions更精确的管理动画。</p>\n<p>我们可以通过<em>CATransaction</em>类创建和管理transactions，调用<code>begin</code>方法开始一个新的transaction（隐式），<code>commit</code>方法结束transaction。在这些调用之间是我们希望对transaction的一部分改变。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">CATransaction</span>.begin()</span><br><span class=\"line\">myView.layer.zPosition = <span class=\"number\">200.0</span></span><br><span class=\"line\">myView.layer.opacity = <span class=\"number\">0.0</span></span><br><span class=\"line\"><span class=\"type\">CATransaction</span>.commit()</span><br></pre></td></tr></table></figure>\n<p>使用transactions的主要原因之一是在显式transaction的范围内，可以修改持续时间、计时函数和其他参数。我们也可以为整个transaction安排一个完成回调，在一组动画完成后发出通知。修改动画参数需要使用<code>setValue:forKey:</code>方法修改字典中对应的键。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">CATransaction</span>.begin()</span><br><span class=\"line\"><span class=\"type\">CATransaction</span>.setValue(<span class=\"number\">10.0</span>, forKey: kCATransactionAnimationDuration)</span><br><span class=\"line\"><span class=\"comment\">// perform the animations</span></span><br><span class=\"line\"><span class=\"type\">CATransaction</span>.commit()</span><br></pre></td></tr></table></figure>\n<p>我们可以在为不同动画集提供不同的默认值的情况下嵌套transactions，通过再次调用<em>begin</em>方法可以嵌套另一个transaction，每个<em>begin</em>方法必须对应<em>commit</em>方法。只有在提交最外层transaction后，Core Animation才会开始相关动画。</p>\n<h2>为动画添加透视</h2>\n<p>应用程序可以在三维空间操作图层，但为了简单起见，Core Animation使用并行投影显示图层，实际上试讲场景压成二维平面，这种默认行为导致具有不同<em>zPosition</em>值的层以相同的大小出现，尽管他们在z方向上距离很远。我们可以通过修改转换矩阵来更改该行为，以包含透视信息。</p>\n<p>修改场景的透视图时，需要修改包含被查看视图的父层级的<em>sublayerTransform</em>矩阵，修改父层级将相同的透视信息运用于所有子层级可以简化代码，他还能确保透视图被正确的应用在不同平面上相互重叠的兄弟层级。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var perspective = CATransform3DIdentity</span><br><span class=\"line\">perspective.m34 = -1.0/eyePosition</span><br><span class=\"line\">view.layer.sublayerTransform = perspective</span><br></pre></td></tr></table></figure>\n<h1>Changing a Layer’s Default Bahavior</h1>\n<p>Core Animation使用action对象实现它的隐式层级动画行为。action对象是实现<em>CAAction</em>协议的对象，它定义了一些要在层上执行的相关行为。所有<em>CAAnimation</em>对象实现了该协议，当一个层级属性变化时，这些对象就被安排来执行修改。</p>\n<p>动画属性是action的一种，但我们可以定义大多数我们想要操作的actions，不过要做到这一点，我们必须定义action对象并与应用层级对象关联。</p>\n<h2>自定义实现CAAction协议的Action对象</h2>\n<p>创建自己的action对象，需要一个类实现<em>CAAction</em>协议并实现<code>runActionForKey:object:arguments:</code>方法，在这个方法中，使用可用的信息来执行我们想要在该层上执行的任何操作。我们可能用这个方法添加一个动画或者一些其他任务。</p>\n<p>当我们定义一个action对象，我们需要觉得触发的条件，这个action的触发是我们用来注册这个action使用的key，也可以在以下情况下被触发：</p>\n<ul>\n<li>层级的一个属性改变了，可以是层级的任意属性，不仅仅是动画的这个（我们还可以把自定义属性的actions和层级相关联），标识action的键是这个属性的名字</li>\n<li>层级变得可见或者添加到层级结构中，标识的键为<em>kCAOnOrderIn</em></li>\n<li>层级从层级结构移除，标识的键为<em>kCAOnOrderOut</em></li>\n<li>层级涉及转换动画，标识的键为<em>kCATransition</em></li>\n</ul>\n<h2>action对象必须在层级上才能产生效果</h2>\n<p>在action操作之前，层级需要找到相应的action对象，层级相关action的键是正在修改属性的名称或特殊字符。当适当的事件发生在层级，层级调用*actionForKey:*方法查找对应键的action对象，我们可以在搜索过程中插入多个点并为该键提供相关的action对象。</p>\n<p>Core Animation查找action对象的顺序如下：</p>\n<ol>\n<li>如果层级的代理实现了<code>actionForLayer:forKey:</code>方法，层级会调用这个方法。代理必须执行以下一项：\n<ul>\n<li>返回给定键的action对象</li>\n<li>返回nil，如果不处理action，查找继续</li>\n<li>返回NSNull对象，查找结束</li>\n</ul>\n</li>\n<li>层级在actions字典中查找对应的键</li>\n<li>层级在<a href=\"https://developer.apple.com/documentation/quartzcore/calayer/1410875-style\" target=\"_blank\" rel=\"noopener\">style</a>字典中包含该键的actions字典（换句话说，包含actions键的style字典也是字典，层级在第二层字典查找对应键）</li>\n<li>层级调用<code>defaultActionForKey:</code>方法</li>\n<li>层级执行Core Animation定义的隐式action</li>\n</ol>\n<p>如果我们在任意查询点提供了action对象，层级将停止查询并执行返回的action对象。当查找到一个action对象，层级调用<code>runActionForKey:object:arguments:</code>方法执行操作。如果给定键定义的action已经是<em>CAAnimation</em>类的实例，则可以使用这个方法的默认实现执行动画。如果是我们自定义实现<em>CAAction</em>协议的对象，则必须使用该方法对象实现来执行适当的操作。</p>\n<p>在何处安装action对象取决于我们如何修改层级：</p>\n<ul>\n<li>对于可能只在特定环境应用的actions，或对于已经使用代理的对象，提供代理并实现<code>actionForLayer:forKey</code>方法</li>\n<li>对于层级对象补偿使用代理，可以添加action到层级的actions字典中</li>\n<li>对于与层对象上定义的自定义属性相关的actions，可以在style字典中包含该action</li>\n<li>对于层行为的基本actions，继承层级并复写<code>defaultActionForKey:</code>方法</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">id</span>&lt;<span class=\"built_in\">CAAction</span>&gt;)actionForLayer:(<span class=\"built_in\">CALayer</span> *)theLayer</span><br><span class=\"line\">                        forKey:(<span class=\"built_in\">NSString</span> *)theKey &#123;</span><br><span class=\"line\">    <span class=\"built_in\">CATransition</span> *theAnimation=<span class=\"literal\">nil</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">if</span> ([theKey isEqualToString:<span class=\"string\">@\"contents\"</span>]) &#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">        theAnimation = [[<span class=\"built_in\">CATransition</span> alloc] init];</span><br><span class=\"line\">        theAnimation.duration = <span class=\"number\">1.0</span>;</span><br><span class=\"line\">        theAnimation.timingFunction = [<span class=\"built_in\">CAMediaTimingFunction</span> functionWithName:kCAMediaTimingFunctionEaseIn];</span><br><span class=\"line\">        theAnimation.type = kCATransitionPush;</span><br><span class=\"line\">        theAnimation.subtype = kCATransitionFromRight;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> theAnimation;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2>使用CATransaction类临时禁用actions</h2>\n<p>我们可以使用<em>CATransaction</em>类临时禁用actions，当修改一个层级的属性时，Core Animation通常会创建隐式transaction执行修改，如果不想修改，我们可以创建显式transaction并设置<em>kCATransactionDisableActions</em>属性为true禁用隐式动画。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"built_in\">CATransaction</span> begin];</span><br><span class=\"line\">[<span class=\"built_in\">CATransaction</span> setValue:(<span class=\"keyword\">id</span>)kCFBooleanTrue</span><br><span class=\"line\">                 forKey:kCATransactionDisableActions];</span><br><span class=\"line\">[aLayer removeFromSuperlayer];</span><br><span class=\"line\">[<span class=\"built_in\">CATransaction</span> commit];</span><br></pre></td></tr></table></figure>\n<h1>Ending</h1>\n<p>这一章主要是对于Layer动画的内容、概念的学习，毕竟要熟练运用需要到实际场景中反复使用，其实更关键的是数学模型，有了数学模型生成的路径、时间规划，才能有绚丽的动画。</p>\n<h1>Reference</h1>\n<blockquote>\n<p><a href=\"https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CoreAnimation_guide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40004514-CH1-SW1\" target=\"_blank\" rel=\"noopener\">About Core Animation</a></p>\n</blockquote>\n"},{"title":"创建自己的 GitHub 博客","catalog":true,"toc_nav_num":true,"date":"2019-02-12T05:40:24.000Z","subtitle":"基于 Hexo 搭建 GitHub Pages","header-img":"/img/article_header/article_header.png","busuanzi":true,"_content":"\n# Introduction\n\n本人是个懒人，一直想动手写博客，却一拖再拖，总觉得自己的辞藻不够华丽，写出来不够工整漂亮。但是，这次，让我动手这件事情的原因，却是公司把技术分享或者博客作为绩效的考评，相比较技术分享，博客这个不用动嘴的方式却是不二之选。\n\n既然要写博客，当然是选择高大上的基于 GitHub 平台创建的博客啦。GitHub，开源代码库以及版本控制系统，大家都知道的网站。之前我也只是用来找找开源项目，成熟的解决方案，没想到还能作为博客站，真是一个让人愉悦的网站。\n\n这篇文章就是我在创建博客过程中的一些心得（怨念）。\n\n# Build GitHub Pages  \n\n1. 进入 [GitHub](https://github.com/new) 主页创建新仓库，\n![GitHub](/img/article/20190212/1.png)\n\n2. 进入刚刚创建的仓库，点击 Setting，找到下面的 GitHub Pages，\n![GitHub](/img/article/20190212/2.png)\n任意选择一个主题之后既可以通过 **用户名.github.io** 访问你的博客了。\n\n# Set Up Hexo  \n\n1. 安装 [Hexo](https://github.com/hexojs/hexo)，\n``` Shell\n$ npm install hexo-cli -g\n```\n\n2. Hexo 常用命令\n``` Shell\nhexo n == hexo new 新建文章\nhexo g == hexo generate 生成部署\nhexo s == hexo server 本地预览\nhexo d == hexo deploy 上传云端\nhexo clean 清空部署\n```\n通过上述命令，可以创建一个默认主题的 blog 页面，即可[生成本地预览](http://localhost:4000/)。\n\n3. 安装主题 [themes](https://hexo.io/themes/)，\n在对应的 blog 文件夹下\n``` Shell\nhexo clean\ngit clone https://github.com/huweihuang/hexo-theme-huweihuang.git ./hexo-huweihuang （举例）\n```\n在对应 blog 目录下找到 _config.yml 文件，修改 theme 属性设置为对应的主题名字，即安装主题成功。\n\n4. 部署到 GitHub\n继续在上述的 _config.yml 文件下编辑，\n![blog](/img/article/20190212/3.png)\n完成之后就可以通过 **hexo d**上传同步到 GitHub。\n\n# More Questions\n\n每个主题在对应的 _config.yml 都有对应的配置，修改对应配置即可对自己的 blog 页面进行调整。\n下面是我想要添加的两个功能点分享：\n\n## Page View statistics - 不蒜子\n\n> “不蒜子”与百度统计谷歌分析等有区别：“不蒜子”可直接将访问次数显示在您在网页上（也可不显示）；对于已经上线一段时间的网站，“不蒜子”允许初始化首次数据。。\n\n1. 安装脚本\n``` JavaScript\n<script async src=\"//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js\">\n</script>\n```\n打开对应 *themes/layout/_partial/footer.ejs* 目录下添加上述脚本即可，当然你也可以添加到其他地方。\n\n2. 显示站点总访问量\n复制下面代码添加到你需要显示的位置即可。有两种算法可选：\n算法a：pv的方式，单个用户连续点击n篇文章，记录n次访问量。\n``` CSS\n<span id=\"busuanzi_container_site_pv\">\n    本站总访问量<span id=\"busuanzi_value_site_pv\"></span>次\n</span>\n```\n算法b：uv的方式，单个用户连续点击n篇文章，只记录1次访客数。\n``` CSS\n<span id=\"busuanzi_container_site_uv\">\n  本站访客数<span id=\"busuanzi_value_site_uv\"></span>人次\n</span>\n```\n\n3. 显示单页面访问量\n算法：pv的方式，单个用户点击1篇文章，本篇文章记录1次阅读量。\n``` CSS\n<span id=\"busuanzi_container_page_pv\">\n  本文总阅读量<span id=\"busuanzi_value_page_pv\"></span>次\n</span>\n```\n\n4. 自定义样式\n'不蒜子'被称为极客的算子，正是因为不蒜子自身只提供标签+数字，至于显示的style和css动画效果，任你发挥。\n- busuanzi_value_site_pv 的作用是异步回填访问数，这个id一定要正确。\n- busuanzi_container_site_pv的作用是为防止计数服务访问出错或超时（3秒）的情况下，使整个标签自动隐藏显示，带来更好的体验。这个id可以省略。\n所以，你也可以使用极简模式：\n``` CSS\n本站总访问量<span id=\"busuanzi_value_site_pv\"></span>次\n本站访客数<span id=\"busuanzi_value_site_uv\"></span>人次\n本文总阅读量<span id=\"busuanzi_value_page_pv\"></span>次\n```\n\n## Add comments module - Disqus\n\n> 多说已于2017年6月1日正式关停服务，缅怀..\n\n封装好的主题本身已经携带了 多说 与 Disqus 两种评论方式，同样只要在 _config.yml 文件下填写 disqus_username 就可以了，\n``` Shell\n# Disqus settings\ndisqus_username: username\n```\n如果有这么简单，我就不会写分享了，中间坑点满满。\n\n1. 首先，自然是去 [Disqus](https://disqus.com) 官网注册，同时前往右上角的**头像-View Profile**获取到对应的用户信息，回来填写到对应的 disqus_username 上，然后预览发现什么都没有发生。\n\n2. 然后，我们需要前往右上角的**头像-Install on Site**，将你的账号与你的网页关联起来，同时在这时候你会找到你的 Shortname, 他才是最终填写到 disqus_username 位置上的名称，\n![Disqus](/img/article/20190212/4.png)\n然后预览你可能会遇到*We were unable to load Disqus.*，如果没有，恭喜你，你已经成功启动了评论功能，如果没有，那你还得看下一步。\n\n3. 参考 [issue #876](https://github.com/iissnan/hexo-theme-next/issues/876)，可能的原因是我们需要把 disqus_url 变量赋值去掉，有disqus_identifier 就可以。至于页面的链接，Disqus 会自动取 `window.location.href`，Hexo 生成的都是静态的页面，这个值也是正确的。然后，我们预览最终会出现评论页面了。\n\n# End\n\n好了，我的第一篇正规博客结束了，看到自己也有了博客站，心里也是美滋滋。\n刚好，这篇博客是在2019年初完成的，预示着一个完美的开始，希望我能把他运营下去吧，加油！\n\n# Reference\n\n> [我是如何利用Github Pages搭建起我的博客，细数一路的坑](https://www.cnblogs.com/jackyroc/p/7681938.html)\n> [不蒜子](http://ibruce.info/2015/04/04/busuanzi/)\n> [正确的Disqus使用姿势](https://www.jianshu.com/p/7e4453421b8f)","source":"_posts/2019/create-github-pages-0212.md","raw":"---\ntitle: \"创建自己的 GitHub 博客\"\ncatalog: true\ntoc_nav_num: true\ndate: 2019-02-12 13:40:24\nsubtitle: \"基于 Hexo 搭建 GitHub Pages\"\nheader-img: \"/img/article_header/article_header.png\"\nbusuanzi: true\ntags:\n- GitHub\n\n---\n\n# Introduction\n\n本人是个懒人，一直想动手写博客，却一拖再拖，总觉得自己的辞藻不够华丽，写出来不够工整漂亮。但是，这次，让我动手这件事情的原因，却是公司把技术分享或者博客作为绩效的考评，相比较技术分享，博客这个不用动嘴的方式却是不二之选。\n\n既然要写博客，当然是选择高大上的基于 GitHub 平台创建的博客啦。GitHub，开源代码库以及版本控制系统，大家都知道的网站。之前我也只是用来找找开源项目，成熟的解决方案，没想到还能作为博客站，真是一个让人愉悦的网站。\n\n这篇文章就是我在创建博客过程中的一些心得（怨念）。\n\n# Build GitHub Pages  \n\n1. 进入 [GitHub](https://github.com/new) 主页创建新仓库，\n![GitHub](/img/article/20190212/1.png)\n\n2. 进入刚刚创建的仓库，点击 Setting，找到下面的 GitHub Pages，\n![GitHub](/img/article/20190212/2.png)\n任意选择一个主题之后既可以通过 **用户名.github.io** 访问你的博客了。\n\n# Set Up Hexo  \n\n1. 安装 [Hexo](https://github.com/hexojs/hexo)，\n``` Shell\n$ npm install hexo-cli -g\n```\n\n2. Hexo 常用命令\n``` Shell\nhexo n == hexo new 新建文章\nhexo g == hexo generate 生成部署\nhexo s == hexo server 本地预览\nhexo d == hexo deploy 上传云端\nhexo clean 清空部署\n```\n通过上述命令，可以创建一个默认主题的 blog 页面，即可[生成本地预览](http://localhost:4000/)。\n\n3. 安装主题 [themes](https://hexo.io/themes/)，\n在对应的 blog 文件夹下\n``` Shell\nhexo clean\ngit clone https://github.com/huweihuang/hexo-theme-huweihuang.git ./hexo-huweihuang （举例）\n```\n在对应 blog 目录下找到 _config.yml 文件，修改 theme 属性设置为对应的主题名字，即安装主题成功。\n\n4. 部署到 GitHub\n继续在上述的 _config.yml 文件下编辑，\n![blog](/img/article/20190212/3.png)\n完成之后就可以通过 **hexo d**上传同步到 GitHub。\n\n# More Questions\n\n每个主题在对应的 _config.yml 都有对应的配置，修改对应配置即可对自己的 blog 页面进行调整。\n下面是我想要添加的两个功能点分享：\n\n## Page View statistics - 不蒜子\n\n> “不蒜子”与百度统计谷歌分析等有区别：“不蒜子”可直接将访问次数显示在您在网页上（也可不显示）；对于已经上线一段时间的网站，“不蒜子”允许初始化首次数据。。\n\n1. 安装脚本\n``` JavaScript\n<script async src=\"//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js\">\n</script>\n```\n打开对应 *themes/layout/_partial/footer.ejs* 目录下添加上述脚本即可，当然你也可以添加到其他地方。\n\n2. 显示站点总访问量\n复制下面代码添加到你需要显示的位置即可。有两种算法可选：\n算法a：pv的方式，单个用户连续点击n篇文章，记录n次访问量。\n``` CSS\n<span id=\"busuanzi_container_site_pv\">\n    本站总访问量<span id=\"busuanzi_value_site_pv\"></span>次\n</span>\n```\n算法b：uv的方式，单个用户连续点击n篇文章，只记录1次访客数。\n``` CSS\n<span id=\"busuanzi_container_site_uv\">\n  本站访客数<span id=\"busuanzi_value_site_uv\"></span>人次\n</span>\n```\n\n3. 显示单页面访问量\n算法：pv的方式，单个用户点击1篇文章，本篇文章记录1次阅读量。\n``` CSS\n<span id=\"busuanzi_container_page_pv\">\n  本文总阅读量<span id=\"busuanzi_value_page_pv\"></span>次\n</span>\n```\n\n4. 自定义样式\n'不蒜子'被称为极客的算子，正是因为不蒜子自身只提供标签+数字，至于显示的style和css动画效果，任你发挥。\n- busuanzi_value_site_pv 的作用是异步回填访问数，这个id一定要正确。\n- busuanzi_container_site_pv的作用是为防止计数服务访问出错或超时（3秒）的情况下，使整个标签自动隐藏显示，带来更好的体验。这个id可以省略。\n所以，你也可以使用极简模式：\n``` CSS\n本站总访问量<span id=\"busuanzi_value_site_pv\"></span>次\n本站访客数<span id=\"busuanzi_value_site_uv\"></span>人次\n本文总阅读量<span id=\"busuanzi_value_page_pv\"></span>次\n```\n\n## Add comments module - Disqus\n\n> 多说已于2017年6月1日正式关停服务，缅怀..\n\n封装好的主题本身已经携带了 多说 与 Disqus 两种评论方式，同样只要在 _config.yml 文件下填写 disqus_username 就可以了，\n``` Shell\n# Disqus settings\ndisqus_username: username\n```\n如果有这么简单，我就不会写分享了，中间坑点满满。\n\n1. 首先，自然是去 [Disqus](https://disqus.com) 官网注册，同时前往右上角的**头像-View Profile**获取到对应的用户信息，回来填写到对应的 disqus_username 上，然后预览发现什么都没有发生。\n\n2. 然后，我们需要前往右上角的**头像-Install on Site**，将你的账号与你的网页关联起来，同时在这时候你会找到你的 Shortname, 他才是最终填写到 disqus_username 位置上的名称，\n![Disqus](/img/article/20190212/4.png)\n然后预览你可能会遇到*We were unable to load Disqus.*，如果没有，恭喜你，你已经成功启动了评论功能，如果没有，那你还得看下一步。\n\n3. 参考 [issue #876](https://github.com/iissnan/hexo-theme-next/issues/876)，可能的原因是我们需要把 disqus_url 变量赋值去掉，有disqus_identifier 就可以。至于页面的链接，Disqus 会自动取 `window.location.href`，Hexo 生成的都是静态的页面，这个值也是正确的。然后，我们预览最终会出现评论页面了。\n\n# End\n\n好了，我的第一篇正规博客结束了，看到自己也有了博客站，心里也是美滋滋。\n刚好，这篇博客是在2019年初完成的，预示着一个完美的开始，希望我能把他运营下去吧，加油！\n\n# Reference\n\n> [我是如何利用Github Pages搭建起我的博客，细数一路的坑](https://www.cnblogs.com/jackyroc/p/7681938.html)\n> [不蒜子](http://ibruce.info/2015/04/04/busuanzi/)\n> [正确的Disqus使用姿势](https://www.jianshu.com/p/7e4453421b8f)","slug":"2019/create-github-pages-0212","published":1,"updated":"2022-01-10T09:04:52.804Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cky8gmc43000dd1qhnl5t58pr","content":"<h1 id=\"introduction\">Introduction</h1>\n<p>本人是个懒人，一直想动手写博客，却一拖再拖，总觉得自己的辞藻不够华丽，写出来不够工整漂亮。但是，这次，让我动手这件事情的原因，却是公司把技术分享或者博客作为绩效的考评，相比较技术分享，博客这个不用动嘴的方式却是不二之选。</p>\n<p>既然要写博客，当然是选择高大上的基于 GitHub 平台创建的博客啦。GitHub，开源代码库以及版本控制系统，大家都知道的网站。之前我也只是用来找找开源项目，成熟的解决方案，没想到还能作为博客站，真是一个让人愉悦的网站。</p>\n<p>这篇文章就是我在创建博客过程中的一些心得（怨念）。</p>\n<h1 id=\"build-github-pages\">Build GitHub Pages</h1>\n<ol>\n<li>\n<p>进入 <a href=\"https://github.com/new\" target=\"_blank\" rel=\"noopener\">GitHub</a> 主页创建新仓库，<br>\n<img src=\"/img/article/20190212/1.png\" alt=\"GitHub\"></p>\n</li>\n<li>\n<p>进入刚刚创建的仓库，点击 Setting，找到下面的 GitHub Pages，<br>\n<img src=\"/img/article/20190212/2.png\" alt=\"GitHub\"><br>\n任意选择一个主题之后既可以通过 <strong><a href=\"http://xn--eqr924avxo.github.io\" target=\"_blank\" rel=\"noopener\">用户名.github.io</a></strong> 访问你的博客了。</p>\n</li>\n</ol>\n<h1 id=\"set-up-hexo\">Set Up Hexo</h1>\n<ol>\n<li>安装 <a href=\"https://github.com/hexojs/hexo\" target=\"_blank\" rel=\"noopener\">Hexo</a>，</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> npm install hexo-cli -g</span></span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>Hexo 常用命令</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo n == hexo new 新建文章</span><br><span class=\"line\">hexo g == hexo generate 生成部署</span><br><span class=\"line\">hexo s == hexo server 本地预览</span><br><span class=\"line\">hexo d == hexo deploy 上传云端</span><br><span class=\"line\">hexo clean 清空部署</span><br></pre></td></tr></table></figure>\n<p>通过上述命令，可以创建一个默认主题的 blog 页面，即可<a href=\"http://localhost:4000/\" target=\"_blank\" rel=\"noopener\">生成本地预览</a>。</p>\n<ol start=\"3\">\n<li>安装主题 <a href=\"https://hexo.io/themes/\" target=\"_blank\" rel=\"noopener\">themes</a>，<br>\n在对应的 blog 文件夹下</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo clean</span><br><span class=\"line\">git clone https://github.com/huweihuang/hexo-theme-huweihuang.git ./hexo-huweihuang （举例）</span><br></pre></td></tr></table></figure>\n<p>在对应 blog 目录下找到 _config.yml 文件，修改 theme 属性设置为对应的主题名字，即安装主题成功。</p>\n<ol start=\"4\">\n<li>部署到 GitHub<br>\n继续在上述的 _config.yml 文件下编辑，<br>\n<img src=\"/img/article/20190212/3.png\" alt=\"blog\"><br>\n完成之后就可以通过 <strong>hexo d</strong>上传同步到 GitHub。</li>\n</ol>\n<h1 id=\"more-questions\">More Questions</h1>\n<p>每个主题在对应的 _config.yml 都有对应的配置，修改对应配置即可对自己的 blog 页面进行调整。<br>\n下面是我想要添加的两个功能点分享：</p>\n<h2 id=\"page-view-statistics-不蒜子\">Page View statistics - 不蒜子</h2>\n<blockquote>\n<p>“不蒜子”与百度统计谷歌分析等有区别：“不蒜子”可直接将访问次数显示在您在网页上（也可不显示）；对于已经上线一段时间的网站，“不蒜子”允许初始化首次数据。。</p>\n</blockquote>\n<ol>\n<li>安装脚本</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script <span class=\"keyword\">async</span> src=<span class=\"string\">\"//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js\"</span>&gt;</span><br><span class=\"line\">&lt;<span class=\"regexp\">/script&gt;</span></span><br></pre></td></tr></table></figure>\n<p>打开对应 <em>themes/layout/_partial/footer.ejs</em> 目录下添加上述脚本即可，当然你也可以添加到其他地方。</p>\n<ol start=\"2\">\n<li>显示站点总访问量<br>\n复制下面代码添加到你需要显示的位置即可。有两种算法可选：<br>\n算法a：pv的方式，单个用户连续点击n篇文章，记录n次访问量。</li>\n</ol>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;span id=\"busuanzi_container_site_pv\"&gt;</span><br><span class=\"line\">    本站总访问量&lt;span id=\"busuanzi_value_site_pv\"&gt;&lt;/span&gt;次</span><br><span class=\"line\">&lt;/span&gt;</span><br></pre></td></tr></table></figure>\n<p>算法b：uv的方式，单个用户连续点击n篇文章，只记录1次访客数。</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;span id=\"busuanzi_container_site_uv\"&gt;</span><br><span class=\"line\">  本站访客数&lt;span id=\"busuanzi_value_site_uv\"&gt;&lt;/span&gt;人次</span><br><span class=\"line\">&lt;/span&gt;</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>显示单页面访问量<br>\n算法：pv的方式，单个用户点击1篇文章，本篇文章记录1次阅读量。</li>\n</ol>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;span id=\"busuanzi_container_page_pv\"&gt;</span><br><span class=\"line\">  本文总阅读量&lt;span id=\"busuanzi_value_page_pv\"&gt;&lt;/span&gt;次</span><br><span class=\"line\">&lt;/span&gt;</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>自定义样式<br>\n’不蒜子’被称为极客的算子，正是因为不蒜子自身只提供标签+数字，至于显示的style和css动画效果，任你发挥。</li>\n</ol>\n<ul>\n<li>busuanzi_value_site_pv 的作用是异步回填访问数，这个id一定要正确。</li>\n<li>busuanzi_container_site_pv的作用是为防止计数服务访问出错或超时（3秒）的情况下，使整个标签自动隐藏显示，带来更好的体验。这个id可以省略。<br>\n所以，你也可以使用极简模式：</li>\n</ul>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">本站总访问量&lt;span id=\"busuanzi_value_site_pv\"&gt;&lt;/span&gt;次</span><br><span class=\"line\">本站访客数&lt;span id=\"busuanzi_value_site_uv\"&gt;&lt;/span&gt;人次</span><br><span class=\"line\">本文总阅读量&lt;span id=\"busuanzi_value_page_pv\"&gt;&lt;/span&gt;次</span><br></pre></td></tr></table></figure>\n<h2 id=\"add-comments-module-disqus\">Add comments module - Disqus</h2>\n<blockquote>\n<p>多说已于2017年6月1日正式关停服务，缅怀…</p>\n</blockquote>\n<p>封装好的主题本身已经携带了 多说 与 Disqus 两种评论方式，同样只要在 _config.yml 文件下填写 disqus_username 就可以了，</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Disqus settings</span></span><br><span class=\"line\">disqus_username: username</span><br></pre></td></tr></table></figure>\n<p>如果有这么简单，我就不会写分享了，中间坑点满满。</p>\n<ol>\n<li>\n<p>首先，自然是去 <a href=\"https://disqus.com\" target=\"_blank\" rel=\"noopener\">Disqus</a> 官网注册，同时前往右上角的<strong>头像-View Profile</strong>获取到对应的用户信息，回来填写到对应的 disqus_username 上，然后预览发现什么都没有发生。</p>\n</li>\n<li>\n<p>然后，我们需要前往右上角的<strong>头像-Install on Site</strong>，将你的账号与你的网页关联起来，同时在这时候你会找到你的 Shortname, 他才是最终填写到 disqus_username 位置上的名称，<br>\n<img src=\"/img/article/20190212/4.png\" alt=\"Disqus\"><br>\n然后预览你可能会遇到<em>We were unable to load Disqus.</em>，如果没有，恭喜你，你已经成功启动了评论功能，如果没有，那你还得看下一步。</p>\n</li>\n<li>\n<p>参考 <a href=\"https://github.com/iissnan/hexo-theme-next/issues/876\" target=\"_blank\" rel=\"noopener\">issue #876</a>，可能的原因是我们需要把 disqus_url 变量赋值去掉，有disqus_identifier 就可以。至于页面的链接，Disqus 会自动取 <code>window.location.href</code>，Hexo 生成的都是静态的页面，这个值也是正确的。然后，我们预览最终会出现评论页面了。</p>\n</li>\n</ol>\n<h1 id=\"end\">End</h1>\n<p>好了，我的第一篇正规博客结束了，看到自己也有了博客站，心里也是美滋滋。<br>\n刚好，这篇博客是在2019年初完成的，预示着一个完美的开始，希望我能把他运营下去吧，加油！</p>\n<h1 id=\"reference\">Reference</h1>\n<blockquote>\n<p><a href=\"https://www.cnblogs.com/jackyroc/p/7681938.html\" target=\"_blank\" rel=\"noopener\">我是如何利用Github Pages搭建起我的博客，细数一路的坑</a><br>\n<a href=\"http://ibruce.info/2015/04/04/busuanzi/\" target=\"_blank\" rel=\"noopener\">不蒜子</a><br>\n<a href=\"https://www.jianshu.com/p/7e4453421b8f\" target=\"_blank\" rel=\"noopener\">正确的Disqus使用姿势</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1>Introduction</h1>\n<p>本人是个懒人，一直想动手写博客，却一拖再拖，总觉得自己的辞藻不够华丽，写出来不够工整漂亮。但是，这次，让我动手这件事情的原因，却是公司把技术分享或者博客作为绩效的考评，相比较技术分享，博客这个不用动嘴的方式却是不二之选。</p>\n<p>既然要写博客，当然是选择高大上的基于 GitHub 平台创建的博客啦。GitHub，开源代码库以及版本控制系统，大家都知道的网站。之前我也只是用来找找开源项目，成熟的解决方案，没想到还能作为博客站，真是一个让人愉悦的网站。</p>\n<p>这篇文章就是我在创建博客过程中的一些心得（怨念）。</p>\n<h1>Build GitHub Pages</h1>\n<ol>\n<li>\n<p>进入 <a href=\"https://github.com/new\" target=\"_blank\" rel=\"noopener\">GitHub</a> 主页创建新仓库，<br>\n<img src=\"/img/article/20190212/1.png\" alt=\"GitHub\"></p>\n</li>\n<li>\n<p>进入刚刚创建的仓库，点击 Setting，找到下面的 GitHub Pages，<br>\n<img src=\"/img/article/20190212/2.png\" alt=\"GitHub\"><br>\n任意选择一个主题之后既可以通过 <strong><a href=\"http://xn--eqr924avxo.github.io\" target=\"_blank\" rel=\"noopener\">用户名.github.io</a></strong> 访问你的博客了。</p>\n</li>\n</ol>\n<h1>Set Up Hexo</h1>\n<ol>\n<li>安装 <a href=\"https://github.com/hexojs/hexo\" target=\"_blank\" rel=\"noopener\">Hexo</a>，</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> npm install hexo-cli -g</span></span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>Hexo 常用命令</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo n == hexo new 新建文章</span><br><span class=\"line\">hexo g == hexo generate 生成部署</span><br><span class=\"line\">hexo s == hexo server 本地预览</span><br><span class=\"line\">hexo d == hexo deploy 上传云端</span><br><span class=\"line\">hexo clean 清空部署</span><br></pre></td></tr></table></figure>\n<p>通过上述命令，可以创建一个默认主题的 blog 页面，即可<a href=\"http://localhost:4000/\" target=\"_blank\" rel=\"noopener\">生成本地预览</a>。</p>\n<ol start=\"3\">\n<li>安装主题 <a href=\"https://hexo.io/themes/\" target=\"_blank\" rel=\"noopener\">themes</a>，<br>\n在对应的 blog 文件夹下</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo clean</span><br><span class=\"line\">git clone https://github.com/huweihuang/hexo-theme-huweihuang.git ./hexo-huweihuang （举例）</span><br></pre></td></tr></table></figure>\n<p>在对应 blog 目录下找到 _config.yml 文件，修改 theme 属性设置为对应的主题名字，即安装主题成功。</p>\n<ol start=\"4\">\n<li>部署到 GitHub<br>\n继续在上述的 _config.yml 文件下编辑，<br>\n<img src=\"/img/article/20190212/3.png\" alt=\"blog\"><br>\n完成之后就可以通过 <strong>hexo d</strong>上传同步到 GitHub。</li>\n</ol>\n<h1>More Questions</h1>\n<p>每个主题在对应的 _config.yml 都有对应的配置，修改对应配置即可对自己的 blog 页面进行调整。<br>\n下面是我想要添加的两个功能点分享：</p>\n<h2>Page View statistics - 不蒜子</h2>\n<blockquote>\n<p>“不蒜子”与百度统计谷歌分析等有区别：“不蒜子”可直接将访问次数显示在您在网页上（也可不显示）；对于已经上线一段时间的网站，“不蒜子”允许初始化首次数据。。</p>\n</blockquote>\n<ol>\n<li>安装脚本</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script <span class=\"keyword\">async</span> src=<span class=\"string\">\"//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js\"</span>&gt;</span><br><span class=\"line\">&lt;<span class=\"regexp\">/script&gt;</span></span><br></pre></td></tr></table></figure>\n<p>打开对应 <em>themes/layout/_partial/footer.ejs</em> 目录下添加上述脚本即可，当然你也可以添加到其他地方。</p>\n<ol start=\"2\">\n<li>显示站点总访问量<br>\n复制下面代码添加到你需要显示的位置即可。有两种算法可选：<br>\n算法a：pv的方式，单个用户连续点击n篇文章，记录n次访问量。</li>\n</ol>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;span id=\"busuanzi_container_site_pv\"&gt;</span><br><span class=\"line\">    本站总访问量&lt;span id=\"busuanzi_value_site_pv\"&gt;&lt;/span&gt;次</span><br><span class=\"line\">&lt;/span&gt;</span><br></pre></td></tr></table></figure>\n<p>算法b：uv的方式，单个用户连续点击n篇文章，只记录1次访客数。</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;span id=\"busuanzi_container_site_uv\"&gt;</span><br><span class=\"line\">  本站访客数&lt;span id=\"busuanzi_value_site_uv\"&gt;&lt;/span&gt;人次</span><br><span class=\"line\">&lt;/span&gt;</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>显示单页面访问量<br>\n算法：pv的方式，单个用户点击1篇文章，本篇文章记录1次阅读量。</li>\n</ol>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;span id=\"busuanzi_container_page_pv\"&gt;</span><br><span class=\"line\">  本文总阅读量&lt;span id=\"busuanzi_value_page_pv\"&gt;&lt;/span&gt;次</span><br><span class=\"line\">&lt;/span&gt;</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>自定义样式<br>\n’不蒜子’被称为极客的算子，正是因为不蒜子自身只提供标签+数字，至于显示的style和css动画效果，任你发挥。</li>\n</ol>\n<ul>\n<li>busuanzi_value_site_pv 的作用是异步回填访问数，这个id一定要正确。</li>\n<li>busuanzi_container_site_pv的作用是为防止计数服务访问出错或超时（3秒）的情况下，使整个标签自动隐藏显示，带来更好的体验。这个id可以省略。<br>\n所以，你也可以使用极简模式：</li>\n</ul>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">本站总访问量&lt;span id=\"busuanzi_value_site_pv\"&gt;&lt;/span&gt;次</span><br><span class=\"line\">本站访客数&lt;span id=\"busuanzi_value_site_uv\"&gt;&lt;/span&gt;人次</span><br><span class=\"line\">本文总阅读量&lt;span id=\"busuanzi_value_page_pv\"&gt;&lt;/span&gt;次</span><br></pre></td></tr></table></figure>\n<h2>Add comments module - Disqus</h2>\n<blockquote>\n<p>多说已于2017年6月1日正式关停服务，缅怀…</p>\n</blockquote>\n<p>封装好的主题本身已经携带了 多说 与 Disqus 两种评论方式，同样只要在 _config.yml 文件下填写 disqus_username 就可以了，</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Disqus settings</span></span><br><span class=\"line\">disqus_username: username</span><br></pre></td></tr></table></figure>\n<p>如果有这么简单，我就不会写分享了，中间坑点满满。</p>\n<ol>\n<li>\n<p>首先，自然是去 <a href=\"https://disqus.com\" target=\"_blank\" rel=\"noopener\">Disqus</a> 官网注册，同时前往右上角的<strong>头像-View Profile</strong>获取到对应的用户信息，回来填写到对应的 disqus_username 上，然后预览发现什么都没有发生。</p>\n</li>\n<li>\n<p>然后，我们需要前往右上角的<strong>头像-Install on Site</strong>，将你的账号与你的网页关联起来，同时在这时候你会找到你的 Shortname, 他才是最终填写到 disqus_username 位置上的名称，<br>\n<img src=\"/img/article/20190212/4.png\" alt=\"Disqus\"><br>\n然后预览你可能会遇到<em>We were unable to load Disqus.</em>，如果没有，恭喜你，你已经成功启动了评论功能，如果没有，那你还得看下一步。</p>\n</li>\n<li>\n<p>参考 <a href=\"https://github.com/iissnan/hexo-theme-next/issues/876\" target=\"_blank\" rel=\"noopener\">issue #876</a>，可能的原因是我们需要把 disqus_url 变量赋值去掉，有disqus_identifier 就可以。至于页面的链接，Disqus 会自动取 <code>window.location.href</code>，Hexo 生成的都是静态的页面，这个值也是正确的。然后，我们预览最终会出现评论页面了。</p>\n</li>\n</ol>\n<h1>End</h1>\n<p>好了，我的第一篇正规博客结束了，看到自己也有了博客站，心里也是美滋滋。<br>\n刚好，这篇博客是在2019年初完成的，预示着一个完美的开始，希望我能把他运营下去吧，加油！</p>\n<h1>Reference</h1>\n<blockquote>\n<p><a href=\"https://www.cnblogs.com/jackyroc/p/7681938.html\" target=\"_blank\" rel=\"noopener\">我是如何利用Github Pages搭建起我的博客，细数一路的坑</a><br>\n<a href=\"http://ibruce.info/2015/04/04/busuanzi/\" target=\"_blank\" rel=\"noopener\">不蒜子</a><br>\n<a href=\"https://www.jianshu.com/p/7e4453421b8f\" target=\"_blank\" rel=\"noopener\">正确的Disqus使用姿势</a></p>\n</blockquote>\n"},{"title":"图像处理与分析 -- Core Image","catalog":true,"toc_nav_num":true,"date":"2019-04-25T10:40:24.000Z","subtitle":"About Core Image","header-img":"/img/article_header/article_header.png","busuanzi":true,"_content":"\n# Introduction\n\nCore Image 是一种图像处理和分析技术，旨在为静态或者视频图片提供近乎实时的处理。它对来自Core Graphics，Core Video，Image I/O框架中的图片数据类型进行操作，使用GPU或CPU渲染路径。Core Image通过提供一个易于使用的API隐藏底层图片处理的细节，我们不需要知道OpenGL，OpenGL ES，Metal的细节来可以利用GPU的能力，也不需要知道任何关于GCD的知识就可以进行多核处理，所有的细节Core Image都会帮我们处理。\n\n![Core Image](/img/article/20190425/1.png)\n\nCore Image 提供以下功能：\n- 访问内置的图像处理过滤器\n- 特征检测能力\n- 支持自动图像增强\n- 将多个滤镜链接一起形成自定义效果的能力\n- 支持创建运行在GPU上的自定义滤镜\n- 基于反馈的图像处理能力\nMacOS还提供一种打包自定义滤镜以供其他应用使用的方法。\n\n# Processing Images\n\n处理图片意味着应用滤镜 -- 图片滤镜是一种逐像素检测输入图片并通过算法应用一些效果来生成输出图片的软件。图片处理主要依靠描述滤镜及其输入输出的CIFilter和CIImage类，我们可以使用Core Image与其他系统框架或者创建通过CIContext创建自己的渲染工作流来应用滤镜、显示或导出结果。\n\n在图片上应用滤镜的基本代码：\n``` Swift\nlet context = CIContext()\nlet filter = CIFilter(name: \"CISepiaTone\")\nfilter?.setValue(0.8, forKey: kCIInputIntensityKey)\nlet image = CIImage(contentsOf: Bundle.main.url(forResource: \"\", withExtension: \"\")!)\nfilter?.setValue(image, forKey: kCIInputImageKey)\nlet result = filter?.outputImage\nif let result = result {\n    let cgImage = context.createCGImage(result, from: result.extent)\n}\n```\n\n滤镜处理并制作图片，CIImage实例是表示一张图片的不可变对象，这些对象不直接表示图片位图数据，相反，CIImage对象是制作图片的一种方式。一种方式可能要求直接从文件中加载图片，另一种可能是从滤镜或过滤器链的输出，Core Image 仅当我们要求将一张图片渲染作为显示或者输出时执行这些方法。\n\n应用滤镜的方式，创建一个或多个CIImage对象表示被滤镜处理的图片同时配置滤镜的输入参数，我们可以从以下几种图片数据中创建CIImage对象：\n- 被加载图片文件的URL引用或者被加载包含图片文件数据的NSData对象\n- Quartz2D，UIKit，或者AppKit的图片代表（CGImageRef，UIImage，NSBitmapImageRep）\n- Metal，OpenGL，OpenGl ES纹理\n- CoreVideo图片或者像素缓存（CVImageBufferRef，CVPixelBufferRef）\n- 进程间分享的图片数据 -- IOSurfaceRef\n- 内存中的位图数据（对象指针，按需提供数据的CIImageProvider）\n\n因为CIImage对象描述了如何制作图片（而不是包含图片数据），他同样可以表示滤镜输出。当访问CIFilter对象的outputImage属性时，Core Image只标识和存储执行滤镜需要的步骤，这些步骤只有在请求显示或输出而渲染图片时运行。\n\n## 描述图片处理效果 -- 滤镜\n\nCIFilter对象是代表图片处理效果和控制效果行为系列参数的可变对象，使用滤镜的方式：创建CIFilter对象，设置输入参数，然后访问它的输出图像。[各类滤镜](https://developer.apple.com/library/archive/documentation/GraphicsImaging/Reference/CoreImageFilterReference/index.html#//apple_ref/doc/uid/TP40004346)\n\n### 复杂效果 -- 链式滤镜\n\n每个Core Image提供一个CIImage输出对象，可以把这个输出对象作为另一个滤镜的输入。\n\n![Construct a filter chain by connecting filter inputs and outputs](/img/article/20190425/2.png)\n\nCore Image 优化了滤镜链的应用，以快速高效的方式渲染结果，链中的每个CIImage对象不是完全渲染过的图片，而是渲染的方式，Core Image不需要单独执行每个滤镜操作，这样会非常浪费时间和内存，相反，Core Image将滤镜组合成一个单独的操作，甚至以不同的顺序重新组织滤镜，从而更有效的生成相同的结果。\n\n![Core Image optimizes a filter chain to a single operation](/img/20190425/2.png)\n\n我们可以看出，Crop滤镜操作从最后移动到优先执行，这个滤镜用于输出裁剪后的图片，因此不需要对裁剪外的像素使用颜色和锐化过滤器，所以Core Image首先执行裁剪，确保消耗巨大的图形处理操作只适用于最终输出可见的像素内。\n\n``` Swift\nfunc applyFilterChain(to image: CIImage) -> CIImage? {\n    let colorFilter = CIFilter(name: \"CIPhotoEffectProcess\", parameters: [kCIInputImageKey: image])\n    guard let image = colorFilter?.outputImage else {\n        return nil\n    }\n    let bloomImage = image.applyingFilter(\"CIBloom\", parameters: [kCIInputRadiusKey: 10.0, kCIInputIntensityKey: 1.0])\n    let cropRect = CGRect(x: 0, y: 0, width: 150, height: 150)  // 左下角为坐标原点\n    let croppedImage = bloomImage.cropped(to: cropRect) // 用于常用的筛选操作，比如croped, clamped\n    return croppedImage\n}\n```\n\n### 特殊类型的滤镜\n\n[生成二维码](https://developer.apple.com/library/archive/documentation/GraphicsImaging/Reference/CoreImageFilterReference/index.html#//apple_ref/doc/filter/ci/CIQRCodeGenerator)\n[生成条形码](https://developer.apple.com/library/archive/documentation/GraphicsImaging/Reference/CoreImageFilterReference/index.html#//apple_ref/doc/filter/ci/CICode128BarcodeGenerator)\n[其他](https://developer.apple.com/library/archive/documentation/GraphicsImaging/Conceptual/CoreImaging/ci_tasks/ci_tasks.html#//apple_ref/doc/uid/TP30001185-CH3-DontLinkElementID_6)\n\n## 用Core Image上下文构建自己的工作流\n\n主要涉及Metal，OpenGL，OpenGL ES等实时渲染，后面学到Metal的时候再来看。\n\n# Detecting Faces in an Image\n\nCore Image可以在图片中解析找到人脸。它执行的是人脸检测而不是人脸识别，人脸检测是包含人脸特征的矩形的识别，而人脸识别是对特定人脸的识别。Core Image检测人脸后，可以提供人脸特征信息，例如眼睛或鼻子的位置。它也可以跟踪视频中人脸的位置。\n\n``` Swift\nDispatchQueue.global().async {\n    let image = CIImage(contentsOf: Bundle.main.url(forResource: \"7\", withExtension: \"jpg\")!)\n    let context = CIContext()\n    let opts = [CIDetectorAccuracy: CIDetectorAccuracyHigh]\n    let detector = CIDetector(ofType: CIDetectorTypeFace, context: context, options: opts)\n    let features = detector?.features(in: image!) as? [CIFaceFeature]\n    if let features = features {\n        for feature in features {\n            print(feature.bounds)\n            \n            if feature.hasLeftEyePosition {\n                print(\"Left eye \\(feature.leftEyePosition.x) \\(feature.leftEyePosition.y)\")\n            }\n            \n            if feature.hasRightEyePosition {\n                print(\"Right eye \\(feature.rightEyePosition.x) \\(feature.rightEyePosition.y)\")\n            }\n            \n            if feature.hasMouthPosition {\n                print(\"Mouth \\(feature.mouthPosition)\")\n            }\n        }\n    }\n}\n```\n\n# Auto Enhancing Images\n\nCore Image的自动优化特征用于分析图片的直方图，人脸区域内容，元数据属性，然后它返回一个CIFilter对象数组，这些对象已经被设置为改进后图片的输入参数。\n\n下面展示了Core Image用于自动优化图片的滤镜：\n- CIRedEyeCorrection：修复由于相机闪光灯造成的红眼、琥珀眼、白眼\n- CIFaceBalance：调整脸部颜色，使皮肤更适应\n- CIVibrance：增强图片饱和度而不扭曲肤色\n- CIToneCurve：调整图像对比度\n- CIHighlightShadowAdjust：调整阴影细节\n\n``` Swift\nlet adjustments = image.autoAdjustmentFilters()\nfor filter in adjustments {\n    filter.setValue(image, forKey: kCIInputImageKey)\n    image = filter.outputImage!\n}\n```\n\n# Subclassing CIFilter: Reciptes for Custom Effects\n\n我们可以通过图片的输出作为另一个的输入合并多个喜欢的滤镜来创建自定义的效果，当多次通过这个方式创建效果时，可以考虑继承CIFilter来封装一个滤镜。\n\n## Subclassing CIFilter to Create the CIColorInvert Filter\n\n当我们继承CIFilter后，我们可以通过重新编写默认值或合并滤镜来修改已有的滤镜。Core Image用这项技术实现一些内置滤镜。\n继承一个滤镜我们需要实现以下内容：\n- 定义滤镜的输入参数属性，必须以`input`作为参数名开头，比如*inputImage*\n- 如有必要复写`setDefaults`方法\n- 如些`outputImage`方法\n\nCore Image提供的CIColorInvert滤镜是CIColorMatrix滤镜的改进，顾名思义，CIColorInvert为CIColorMatrix提供向量，将输入图片的颜色反转。\n\n``` Swift\nclass CIColorInvert: CIFilter {\n    public var inputImage: CIImage?\n    \n    override var outputImage: CIImage? {\n        get {\n            guard let inputImage = inputImage else {\n                return nil\n            }\n            let filter = CIFilter(name: \"CIColorMatrix\",\n                                  parameters: [kCIInputImageKey: inputImage,\n                                               \"inputRVector\": CIVector(x: -1, y: 0, z: 0),\n                                               \"inputGVector\": CIVector(x: 0, y: -1, z: 0),\n                                               \"inputBVector\": CIVector(x: 0, y: 0, z: -1),\n                                               \"inputBiasVector\": CIVector(x: 1, y: 1, z: 1)])\n            return filter?.outputImage\n        }\n    }\n}\n```\n\n## Chrome Key Filter Recipe\n\n从资源图移除背景颜然后与新背景融合。\n创建色度滤镜：\n- 创建一个我们想要移除颜色数据的立方体映射，使他们透明\n- 使用CIColorCube滤镜从图片中移除对应色度的颜色\n- 使用CISourceOverCompositing滤镜将源图与背景图混合\n\n### 创建立方体映射\n\n一个颜色立方体是一个3D颜色查询表。CIColorCube滤镜把色值作为输入，在表中查询这些值，默认的查询表是一个标识矩阵--意味着对提供的数据不做任何操作。但是，这个方法要求我们删除一种颜色绿色。\n我们需要从图片中移除所有的绿色，把绿色的可见度设为0。”绿色“包含系列颜色，最直接的方法是把颜色从RGBA转换成HSV类型值，在HSV中，H表示为围绕圆柱体中轴的一个角，在这种表示中，我们可以把颜色作为一个饼状切片，然后简单的删除对应颜色块。\n移除绿色，我们需要定义包含绿色最大最小角度值，然后，所有范围内的值的可见度都设为0，纯绿色对应120°，最大最小角度应该围绕这个值。\n立方体映射数据必须提前乘以alpha，所以创建数据的最后一步是将RGB值乘以计算出来的alpha值，对于绿色，alpha为0，其他为1.0.\n\n``` Swift\nlet size = 64\nlet count = size * size * size * 4\nlet cubeData = UnsafeMutablePointer<Float>.allocate(capacity: count)\nvar rgb: [Double] = [0, 0, 0], hsv: [Double] = [0, 0, 0]\nfor z in 0..<size {\n    rgb[2] = (Double(z)) / Double(size - 1)\n    for y in 0..<size {\n        rgb[1] = Double(y) / Double(size - 1)\n        for x in 0..<size {\n            rgb[0] = Double(x) / Double(size - 1)\n            // rgbToHSV(rgb, hsv)\n            let alpha = (hsv[0] > minHugAngle && hsv[0] < maxHueAngle) ? 0.0f : 1.0f\n            let offset = x * 4 + y * size * 4 + z * size * size * 4\n            cubeData[offset] = Float(rgb[0] * alpha)\n            cubeData[offset + 1] = Float(rgb[1] * alpha)\n            cubeData[offset + 2] = Float(rgb[2] * alpha)\n            cubeData[offset + 3] = Float(alpha)\n            cubeData.moveAssign(from: cubeData + 3, count: 4)\n        }\n    }\n}\nlet data = Data(bytesNoCopy: cubeData, count: count, deallocator: .free)\nlet colorCube = CIFilter(name: \"CIColorCube\")\ncolorCube?.setValue(NSNumber(value: size), forKey: \"inputCubeDimension\")\ncolorCube?.setValue(data, forKey: \"inputCubeData\")\n```\n\n### 从源图移除绿色\n\n``` Swift\ncolorCube?.setValue(inputImage, forKey: kCIInputImageKey)\nlet result = colorCube?.outputImage\n```\n\n### 融合处理后源图与背景图\n\n运用CISourceOverCompositing滤镜融合图片：\n- 设置inputImage为处理后的源图\n- 设置inputBackgroundImage为新的背景图\n\n# Getting the Best Performance\n\nCore Image提供多种选项创建图片，上下文，渲染上下文。看我们如何选择完成一项任务：\n- 应用多久执行一次任务\n- 应用使用静态还是视频图片\n- 是否需要支持实时处理和分析\n- 颜色保真度对用户的重要性\n\n## 性能最佳实践\n\n- 不要在每次渲染时创建CIContext对象；上下文存储非常多状态信息；复用更加有效\n- 评估应用是否需要颜色管理；如非必要不要使用\n- 避免在GPU渲染CIImage对象时使用Core Animation动画；如果想要同时使用，则用CPU\n- 确保图片不超过CPU与GPU的限制；CIContext对象的图片大小限制取决于使用的是CPU还是GPU\n- 尽可能使用小图；性能随输出像素改变\n- UIImageView与静态图片更适配\n- 避免CPU与GPU之间非必要的纹理传输\n- 考虑使用简单的滤镜类似于算法滤镜产生的结果\n- 利用iOS 6.0及更高版本对YUV图片的支持；相机像素缓存是天生的YUV，但大多数图像处理算法期望RGBA数据，两者之间的转换是有成本的；Core Image支持从CVPixelBuffer对象读取YUB并应用适当的颜色转换\n\n# Creating Custom Filters\n\n[What You Need to Know Before Writing a Custom Filter](https://developer.apple.com/library/archive/documentation/GraphicsImaging/Conceptual/CoreImaging/ci_advanced_concepts/ci.advanced_concepts.html#//apple_ref/doc/uid/TP30001185-CH9-SW1)\n\n[Creating Custom Filters](https://developer.apple.com/library/archive/documentation/GraphicsImaging/Conceptual/CoreImaging/ci_custom_filters/ci_custom_filters.html#//apple_ref/doc/uid/TP30001185-CH6-TPXREF101)\n\n# Ending\n\n这章主要是对图片处理的学习，主要就是滤镜的使用，人脸解析功能，更加深入的就是自定义滤镜，多适用于对图片要求较高或本身就是图片处理的应用。\n\n# Reference\n\n> [About Core Image](https://developer.apple.com/library/archive/documentation/GraphicsImaging/Conceptual/CoreImaging/ci_intro/ci_intro.html#//apple_ref/doc/uid/TP30001185-CH1-TPXREF101)","source":"_posts/2019/core-image-study-0425.md","raw":"---\ntitle: \"图像处理与分析 -- Core Image\"\ncatalog: true\ntoc_nav_num: true\ndate: 2019-04-25 18:40:24\nsubtitle: \"About Core Image\"\nheader-img: \"/img/article_header/article_header.png\"\nbusuanzi: true\ntags:\n- iOS\n\n---\n\n# Introduction\n\nCore Image 是一种图像处理和分析技术，旨在为静态或者视频图片提供近乎实时的处理。它对来自Core Graphics，Core Video，Image I/O框架中的图片数据类型进行操作，使用GPU或CPU渲染路径。Core Image通过提供一个易于使用的API隐藏底层图片处理的细节，我们不需要知道OpenGL，OpenGL ES，Metal的细节来可以利用GPU的能力，也不需要知道任何关于GCD的知识就可以进行多核处理，所有的细节Core Image都会帮我们处理。\n\n![Core Image](/img/article/20190425/1.png)\n\nCore Image 提供以下功能：\n- 访问内置的图像处理过滤器\n- 特征检测能力\n- 支持自动图像增强\n- 将多个滤镜链接一起形成自定义效果的能力\n- 支持创建运行在GPU上的自定义滤镜\n- 基于反馈的图像处理能力\nMacOS还提供一种打包自定义滤镜以供其他应用使用的方法。\n\n# Processing Images\n\n处理图片意味着应用滤镜 -- 图片滤镜是一种逐像素检测输入图片并通过算法应用一些效果来生成输出图片的软件。图片处理主要依靠描述滤镜及其输入输出的CIFilter和CIImage类，我们可以使用Core Image与其他系统框架或者创建通过CIContext创建自己的渲染工作流来应用滤镜、显示或导出结果。\n\n在图片上应用滤镜的基本代码：\n``` Swift\nlet context = CIContext()\nlet filter = CIFilter(name: \"CISepiaTone\")\nfilter?.setValue(0.8, forKey: kCIInputIntensityKey)\nlet image = CIImage(contentsOf: Bundle.main.url(forResource: \"\", withExtension: \"\")!)\nfilter?.setValue(image, forKey: kCIInputImageKey)\nlet result = filter?.outputImage\nif let result = result {\n    let cgImage = context.createCGImage(result, from: result.extent)\n}\n```\n\n滤镜处理并制作图片，CIImage实例是表示一张图片的不可变对象，这些对象不直接表示图片位图数据，相反，CIImage对象是制作图片的一种方式。一种方式可能要求直接从文件中加载图片，另一种可能是从滤镜或过滤器链的输出，Core Image 仅当我们要求将一张图片渲染作为显示或者输出时执行这些方法。\n\n应用滤镜的方式，创建一个或多个CIImage对象表示被滤镜处理的图片同时配置滤镜的输入参数，我们可以从以下几种图片数据中创建CIImage对象：\n- 被加载图片文件的URL引用或者被加载包含图片文件数据的NSData对象\n- Quartz2D，UIKit，或者AppKit的图片代表（CGImageRef，UIImage，NSBitmapImageRep）\n- Metal，OpenGL，OpenGl ES纹理\n- CoreVideo图片或者像素缓存（CVImageBufferRef，CVPixelBufferRef）\n- 进程间分享的图片数据 -- IOSurfaceRef\n- 内存中的位图数据（对象指针，按需提供数据的CIImageProvider）\n\n因为CIImage对象描述了如何制作图片（而不是包含图片数据），他同样可以表示滤镜输出。当访问CIFilter对象的outputImage属性时，Core Image只标识和存储执行滤镜需要的步骤，这些步骤只有在请求显示或输出而渲染图片时运行。\n\n## 描述图片处理效果 -- 滤镜\n\nCIFilter对象是代表图片处理效果和控制效果行为系列参数的可变对象，使用滤镜的方式：创建CIFilter对象，设置输入参数，然后访问它的输出图像。[各类滤镜](https://developer.apple.com/library/archive/documentation/GraphicsImaging/Reference/CoreImageFilterReference/index.html#//apple_ref/doc/uid/TP40004346)\n\n### 复杂效果 -- 链式滤镜\n\n每个Core Image提供一个CIImage输出对象，可以把这个输出对象作为另一个滤镜的输入。\n\n![Construct a filter chain by connecting filter inputs and outputs](/img/article/20190425/2.png)\n\nCore Image 优化了滤镜链的应用，以快速高效的方式渲染结果，链中的每个CIImage对象不是完全渲染过的图片，而是渲染的方式，Core Image不需要单独执行每个滤镜操作，这样会非常浪费时间和内存，相反，Core Image将滤镜组合成一个单独的操作，甚至以不同的顺序重新组织滤镜，从而更有效的生成相同的结果。\n\n![Core Image optimizes a filter chain to a single operation](/img/20190425/2.png)\n\n我们可以看出，Crop滤镜操作从最后移动到优先执行，这个滤镜用于输出裁剪后的图片，因此不需要对裁剪外的像素使用颜色和锐化过滤器，所以Core Image首先执行裁剪，确保消耗巨大的图形处理操作只适用于最终输出可见的像素内。\n\n``` Swift\nfunc applyFilterChain(to image: CIImage) -> CIImage? {\n    let colorFilter = CIFilter(name: \"CIPhotoEffectProcess\", parameters: [kCIInputImageKey: image])\n    guard let image = colorFilter?.outputImage else {\n        return nil\n    }\n    let bloomImage = image.applyingFilter(\"CIBloom\", parameters: [kCIInputRadiusKey: 10.0, kCIInputIntensityKey: 1.0])\n    let cropRect = CGRect(x: 0, y: 0, width: 150, height: 150)  // 左下角为坐标原点\n    let croppedImage = bloomImage.cropped(to: cropRect) // 用于常用的筛选操作，比如croped, clamped\n    return croppedImage\n}\n```\n\n### 特殊类型的滤镜\n\n[生成二维码](https://developer.apple.com/library/archive/documentation/GraphicsImaging/Reference/CoreImageFilterReference/index.html#//apple_ref/doc/filter/ci/CIQRCodeGenerator)\n[生成条形码](https://developer.apple.com/library/archive/documentation/GraphicsImaging/Reference/CoreImageFilterReference/index.html#//apple_ref/doc/filter/ci/CICode128BarcodeGenerator)\n[其他](https://developer.apple.com/library/archive/documentation/GraphicsImaging/Conceptual/CoreImaging/ci_tasks/ci_tasks.html#//apple_ref/doc/uid/TP30001185-CH3-DontLinkElementID_6)\n\n## 用Core Image上下文构建自己的工作流\n\n主要涉及Metal，OpenGL，OpenGL ES等实时渲染，后面学到Metal的时候再来看。\n\n# Detecting Faces in an Image\n\nCore Image可以在图片中解析找到人脸。它执行的是人脸检测而不是人脸识别，人脸检测是包含人脸特征的矩形的识别，而人脸识别是对特定人脸的识别。Core Image检测人脸后，可以提供人脸特征信息，例如眼睛或鼻子的位置。它也可以跟踪视频中人脸的位置。\n\n``` Swift\nDispatchQueue.global().async {\n    let image = CIImage(contentsOf: Bundle.main.url(forResource: \"7\", withExtension: \"jpg\")!)\n    let context = CIContext()\n    let opts = [CIDetectorAccuracy: CIDetectorAccuracyHigh]\n    let detector = CIDetector(ofType: CIDetectorTypeFace, context: context, options: opts)\n    let features = detector?.features(in: image!) as? [CIFaceFeature]\n    if let features = features {\n        for feature in features {\n            print(feature.bounds)\n            \n            if feature.hasLeftEyePosition {\n                print(\"Left eye \\(feature.leftEyePosition.x) \\(feature.leftEyePosition.y)\")\n            }\n            \n            if feature.hasRightEyePosition {\n                print(\"Right eye \\(feature.rightEyePosition.x) \\(feature.rightEyePosition.y)\")\n            }\n            \n            if feature.hasMouthPosition {\n                print(\"Mouth \\(feature.mouthPosition)\")\n            }\n        }\n    }\n}\n```\n\n# Auto Enhancing Images\n\nCore Image的自动优化特征用于分析图片的直方图，人脸区域内容，元数据属性，然后它返回一个CIFilter对象数组，这些对象已经被设置为改进后图片的输入参数。\n\n下面展示了Core Image用于自动优化图片的滤镜：\n- CIRedEyeCorrection：修复由于相机闪光灯造成的红眼、琥珀眼、白眼\n- CIFaceBalance：调整脸部颜色，使皮肤更适应\n- CIVibrance：增强图片饱和度而不扭曲肤色\n- CIToneCurve：调整图像对比度\n- CIHighlightShadowAdjust：调整阴影细节\n\n``` Swift\nlet adjustments = image.autoAdjustmentFilters()\nfor filter in adjustments {\n    filter.setValue(image, forKey: kCIInputImageKey)\n    image = filter.outputImage!\n}\n```\n\n# Subclassing CIFilter: Reciptes for Custom Effects\n\n我们可以通过图片的输出作为另一个的输入合并多个喜欢的滤镜来创建自定义的效果，当多次通过这个方式创建效果时，可以考虑继承CIFilter来封装一个滤镜。\n\n## Subclassing CIFilter to Create the CIColorInvert Filter\n\n当我们继承CIFilter后，我们可以通过重新编写默认值或合并滤镜来修改已有的滤镜。Core Image用这项技术实现一些内置滤镜。\n继承一个滤镜我们需要实现以下内容：\n- 定义滤镜的输入参数属性，必须以`input`作为参数名开头，比如*inputImage*\n- 如有必要复写`setDefaults`方法\n- 如些`outputImage`方法\n\nCore Image提供的CIColorInvert滤镜是CIColorMatrix滤镜的改进，顾名思义，CIColorInvert为CIColorMatrix提供向量，将输入图片的颜色反转。\n\n``` Swift\nclass CIColorInvert: CIFilter {\n    public var inputImage: CIImage?\n    \n    override var outputImage: CIImage? {\n        get {\n            guard let inputImage = inputImage else {\n                return nil\n            }\n            let filter = CIFilter(name: \"CIColorMatrix\",\n                                  parameters: [kCIInputImageKey: inputImage,\n                                               \"inputRVector\": CIVector(x: -1, y: 0, z: 0),\n                                               \"inputGVector\": CIVector(x: 0, y: -1, z: 0),\n                                               \"inputBVector\": CIVector(x: 0, y: 0, z: -1),\n                                               \"inputBiasVector\": CIVector(x: 1, y: 1, z: 1)])\n            return filter?.outputImage\n        }\n    }\n}\n```\n\n## Chrome Key Filter Recipe\n\n从资源图移除背景颜然后与新背景融合。\n创建色度滤镜：\n- 创建一个我们想要移除颜色数据的立方体映射，使他们透明\n- 使用CIColorCube滤镜从图片中移除对应色度的颜色\n- 使用CISourceOverCompositing滤镜将源图与背景图混合\n\n### 创建立方体映射\n\n一个颜色立方体是一个3D颜色查询表。CIColorCube滤镜把色值作为输入，在表中查询这些值，默认的查询表是一个标识矩阵--意味着对提供的数据不做任何操作。但是，这个方法要求我们删除一种颜色绿色。\n我们需要从图片中移除所有的绿色，把绿色的可见度设为0。”绿色“包含系列颜色，最直接的方法是把颜色从RGBA转换成HSV类型值，在HSV中，H表示为围绕圆柱体中轴的一个角，在这种表示中，我们可以把颜色作为一个饼状切片，然后简单的删除对应颜色块。\n移除绿色，我们需要定义包含绿色最大最小角度值，然后，所有范围内的值的可见度都设为0，纯绿色对应120°，最大最小角度应该围绕这个值。\n立方体映射数据必须提前乘以alpha，所以创建数据的最后一步是将RGB值乘以计算出来的alpha值，对于绿色，alpha为0，其他为1.0.\n\n``` Swift\nlet size = 64\nlet count = size * size * size * 4\nlet cubeData = UnsafeMutablePointer<Float>.allocate(capacity: count)\nvar rgb: [Double] = [0, 0, 0], hsv: [Double] = [0, 0, 0]\nfor z in 0..<size {\n    rgb[2] = (Double(z)) / Double(size - 1)\n    for y in 0..<size {\n        rgb[1] = Double(y) / Double(size - 1)\n        for x in 0..<size {\n            rgb[0] = Double(x) / Double(size - 1)\n            // rgbToHSV(rgb, hsv)\n            let alpha = (hsv[0] > minHugAngle && hsv[0] < maxHueAngle) ? 0.0f : 1.0f\n            let offset = x * 4 + y * size * 4 + z * size * size * 4\n            cubeData[offset] = Float(rgb[0] * alpha)\n            cubeData[offset + 1] = Float(rgb[1] * alpha)\n            cubeData[offset + 2] = Float(rgb[2] * alpha)\n            cubeData[offset + 3] = Float(alpha)\n            cubeData.moveAssign(from: cubeData + 3, count: 4)\n        }\n    }\n}\nlet data = Data(bytesNoCopy: cubeData, count: count, deallocator: .free)\nlet colorCube = CIFilter(name: \"CIColorCube\")\ncolorCube?.setValue(NSNumber(value: size), forKey: \"inputCubeDimension\")\ncolorCube?.setValue(data, forKey: \"inputCubeData\")\n```\n\n### 从源图移除绿色\n\n``` Swift\ncolorCube?.setValue(inputImage, forKey: kCIInputImageKey)\nlet result = colorCube?.outputImage\n```\n\n### 融合处理后源图与背景图\n\n运用CISourceOverCompositing滤镜融合图片：\n- 设置inputImage为处理后的源图\n- 设置inputBackgroundImage为新的背景图\n\n# Getting the Best Performance\n\nCore Image提供多种选项创建图片，上下文，渲染上下文。看我们如何选择完成一项任务：\n- 应用多久执行一次任务\n- 应用使用静态还是视频图片\n- 是否需要支持实时处理和分析\n- 颜色保真度对用户的重要性\n\n## 性能最佳实践\n\n- 不要在每次渲染时创建CIContext对象；上下文存储非常多状态信息；复用更加有效\n- 评估应用是否需要颜色管理；如非必要不要使用\n- 避免在GPU渲染CIImage对象时使用Core Animation动画；如果想要同时使用，则用CPU\n- 确保图片不超过CPU与GPU的限制；CIContext对象的图片大小限制取决于使用的是CPU还是GPU\n- 尽可能使用小图；性能随输出像素改变\n- UIImageView与静态图片更适配\n- 避免CPU与GPU之间非必要的纹理传输\n- 考虑使用简单的滤镜类似于算法滤镜产生的结果\n- 利用iOS 6.0及更高版本对YUV图片的支持；相机像素缓存是天生的YUV，但大多数图像处理算法期望RGBA数据，两者之间的转换是有成本的；Core Image支持从CVPixelBuffer对象读取YUB并应用适当的颜色转换\n\n# Creating Custom Filters\n\n[What You Need to Know Before Writing a Custom Filter](https://developer.apple.com/library/archive/documentation/GraphicsImaging/Conceptual/CoreImaging/ci_advanced_concepts/ci.advanced_concepts.html#//apple_ref/doc/uid/TP30001185-CH9-SW1)\n\n[Creating Custom Filters](https://developer.apple.com/library/archive/documentation/GraphicsImaging/Conceptual/CoreImaging/ci_custom_filters/ci_custom_filters.html#//apple_ref/doc/uid/TP30001185-CH6-TPXREF101)\n\n# Ending\n\n这章主要是对图片处理的学习，主要就是滤镜的使用，人脸解析功能，更加深入的就是自定义滤镜，多适用于对图片要求较高或本身就是图片处理的应用。\n\n# Reference\n\n> [About Core Image](https://developer.apple.com/library/archive/documentation/GraphicsImaging/Conceptual/CoreImaging/ci_intro/ci_intro.html#//apple_ref/doc/uid/TP30001185-CH1-TPXREF101)","slug":"2019/core-image-study-0425","published":1,"updated":"2022-01-10T09:04:52.804Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cky8gmc44000gd1qh2r2gok41","content":"<h1 id=\"introduction\">Introduction</h1>\n<p>Core Image 是一种图像处理和分析技术，旨在为静态或者视频图片提供近乎实时的处理。它对来自Core Graphics，Core Video，Image I/O框架中的图片数据类型进行操作，使用GPU或CPU渲染路径。Core Image通过提供一个易于使用的API隐藏底层图片处理的细节，我们不需要知道OpenGL，OpenGL ES，Metal的细节来可以利用GPU的能力，也不需要知道任何关于GCD的知识就可以进行多核处理，所有的细节Core Image都会帮我们处理。</p>\n<p><img src=\"/img/article/20190425/1.png\" alt=\"Core Image\"></p>\n<p>Core Image 提供以下功能：</p>\n<ul>\n<li>访问内置的图像处理过滤器</li>\n<li>特征检测能力</li>\n<li>支持自动图像增强</li>\n<li>将多个滤镜链接一起形成自定义效果的能力</li>\n<li>支持创建运行在GPU上的自定义滤镜</li>\n<li>基于反馈的图像处理能力<br>\nMacOS还提供一种打包自定义滤镜以供其他应用使用的方法。</li>\n</ul>\n<h1 id=\"processing-images\">Processing Images</h1>\n<p>处理图片意味着应用滤镜 – 图片滤镜是一种逐像素检测输入图片并通过算法应用一些效果来生成输出图片的软件。图片处理主要依靠描述滤镜及其输入输出的CIFilter和CIImage类，我们可以使用Core Image与其他系统框架或者创建通过CIContext创建自己的渲染工作流来应用滤镜、显示或导出结果。</p>\n<p>在图片上应用滤镜的基本代码：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> context = <span class=\"type\">CIContext</span>()</span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"built_in\">filter</span> = <span class=\"type\">CIFilter</span>(name: <span class=\"string\">\"CISepiaTone\"</span>)</span><br><span class=\"line\"><span class=\"built_in\">filter</span>?.setValue(<span class=\"number\">0.8</span>, forKey: kCIInputIntensityKey)</span><br><span class=\"line\"><span class=\"keyword\">let</span> image = <span class=\"type\">CIImage</span>(contentsOf: <span class=\"type\">Bundle</span>.main.url(forResource: <span class=\"string\">\"\"</span>, withExtension: <span class=\"string\">\"\"</span>)!)</span><br><span class=\"line\"><span class=\"built_in\">filter</span>?.setValue(image, forKey: kCIInputImageKey)</span><br><span class=\"line\"><span class=\"keyword\">let</span> result = <span class=\"built_in\">filter</span>?.outputImage</span><br><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">let</span> result = result &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> cgImage = context.createCGImage(result, from: result.extent)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>滤镜处理并制作图片，CIImage实例是表示一张图片的不可变对象，这些对象不直接表示图片位图数据，相反，CIImage对象是制作图片的一种方式。一种方式可能要求直接从文件中加载图片，另一种可能是从滤镜或过滤器链的输出，Core Image 仅当我们要求将一张图片渲染作为显示或者输出时执行这些方法。</p>\n<p>应用滤镜的方式，创建一个或多个CIImage对象表示被滤镜处理的图片同时配置滤镜的输入参数，我们可以从以下几种图片数据中创建CIImage对象：</p>\n<ul>\n<li>被加载图片文件的URL引用或者被加载包含图片文件数据的NSData对象</li>\n<li>Quartz2D，UIKit，或者AppKit的图片代表（CGImageRef，UIImage，NSBitmapImageRep）</li>\n<li>Metal，OpenGL，OpenGl ES纹理</li>\n<li>CoreVideo图片或者像素缓存（CVImageBufferRef，CVPixelBufferRef）</li>\n<li>进程间分享的图片数据 – IOSurfaceRef</li>\n<li>内存中的位图数据（对象指针，按需提供数据的CIImageProvider）</li>\n</ul>\n<p>因为CIImage对象描述了如何制作图片（而不是包含图片数据），他同样可以表示滤镜输出。当访问CIFilter对象的outputImage属性时，Core Image只标识和存储执行滤镜需要的步骤，这些步骤只有在请求显示或输出而渲染图片时运行。</p>\n<h2 id=\"描述图片处理效果-滤镜\">描述图片处理效果 – 滤镜</h2>\n<p>CIFilter对象是代表图片处理效果和控制效果行为系列参数的可变对象，使用滤镜的方式：创建CIFilter对象，设置输入参数，然后访问它的输出图像。<a href=\"https://developer.apple.com/library/archive/documentation/GraphicsImaging/Reference/CoreImageFilterReference/index.html#//apple_ref/doc/uid/TP40004346\" target=\"_blank\" rel=\"noopener\">各类滤镜</a></p>\n<h3 id=\"复杂效果-链式滤镜\">复杂效果 – 链式滤镜</h3>\n<p>每个Core Image提供一个CIImage输出对象，可以把这个输出对象作为另一个滤镜的输入。</p>\n<p><img src=\"/img/article/20190425/2.png\" alt=\"Construct a filter chain by connecting filter inputs and outputs\"></p>\n<p>Core Image 优化了滤镜链的应用，以快速高效的方式渲染结果，链中的每个CIImage对象不是完全渲染过的图片，而是渲染的方式，Core Image不需要单独执行每个滤镜操作，这样会非常浪费时间和内存，相反，Core Image将滤镜组合成一个单独的操作，甚至以不同的顺序重新组织滤镜，从而更有效的生成相同的结果。</p>\n<p><img src=\"/img/20190425/2.png\" alt=\"Core Image optimizes a filter chain to a single operation\"></p>\n<p>我们可以看出，Crop滤镜操作从最后移动到优先执行，这个滤镜用于输出裁剪后的图片，因此不需要对裁剪外的像素使用颜色和锐化过滤器，所以Core Image首先执行裁剪，确保消耗巨大的图形处理操作只适用于最终输出可见的像素内。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">applyFilterChain</span><span class=\"params\">(to image: CIImage)</span></span> -&gt; <span class=\"type\">CIImage</span>? &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> colorFilter = <span class=\"type\">CIFilter</span>(name: <span class=\"string\">\"CIPhotoEffectProcess\"</span>, parameters: [kCIInputImageKey: image])</span><br><span class=\"line\">    <span class=\"keyword\">guard</span> <span class=\"keyword\">let</span> image = colorFilter?.outputImage <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> bloomImage = image.applyingFilter(<span class=\"string\">\"CIBloom\"</span>, parameters: [kCIInputRadiusKey: <span class=\"number\">10.0</span>, kCIInputIntensityKey: <span class=\"number\">1.0</span>])</span><br><span class=\"line\">    <span class=\"keyword\">let</span> cropRect = <span class=\"type\">CGRect</span>(x: <span class=\"number\">0</span>, y: <span class=\"number\">0</span>, width: <span class=\"number\">150</span>, height: <span class=\"number\">150</span>)  <span class=\"comment\">// 左下角为坐标原点</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> croppedImage = bloomImage.cropped(to: cropRect) <span class=\"comment\">// 用于常用的筛选操作，比如croped, clamped</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> croppedImage</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"特殊类型的滤镜\">特殊类型的滤镜</h3>\n<p><a href=\"https://developer.apple.com/library/archive/documentation/GraphicsImaging/Reference/CoreImageFilterReference/index.html#//apple_ref/doc/filter/ci/CIQRCodeGenerator\" target=\"_blank\" rel=\"noopener\">生成二维码</a><br>\n<a href=\"https://developer.apple.com/library/archive/documentation/GraphicsImaging/Reference/CoreImageFilterReference/index.html#//apple_ref/doc/filter/ci/CICode128BarcodeGenerator\" target=\"_blank\" rel=\"noopener\">生成条形码</a><br>\n<a href=\"https://developer.apple.com/library/archive/documentation/GraphicsImaging/Conceptual/CoreImaging/ci_tasks/ci_tasks.html#//apple_ref/doc/uid/TP30001185-CH3-DontLinkElementID_6\" target=\"_blank\" rel=\"noopener\">其他</a></p>\n<h2 id=\"用core-image上下文构建自己的工作流\">用Core Image上下文构建自己的工作流</h2>\n<p>主要涉及Metal，OpenGL，OpenGL ES等实时渲染，后面学到Metal的时候再来看。</p>\n<h1 id=\"detecting-faces-in-an-image\">Detecting Faces in an Image</h1>\n<p>Core Image可以在图片中解析找到人脸。它执行的是人脸检测而不是人脸识别，人脸检测是包含人脸特征的矩形的识别，而人脸识别是对特定人脸的识别。Core Image检测人脸后，可以提供人脸特征信息，例如眼睛或鼻子的位置。它也可以跟踪视频中人脸的位置。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">DispatchQueue</span>.global().async &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> image = <span class=\"type\">CIImage</span>(contentsOf: <span class=\"type\">Bundle</span>.main.url(forResource: <span class=\"string\">\"7\"</span>, withExtension: <span class=\"string\">\"jpg\"</span>)!)</span><br><span class=\"line\">    <span class=\"keyword\">let</span> context = <span class=\"type\">CIContext</span>()</span><br><span class=\"line\">    <span class=\"keyword\">let</span> opts = [<span class=\"type\">CIDetectorAccuracy</span>: <span class=\"type\">CIDetectorAccuracyHigh</span>]</span><br><span class=\"line\">    <span class=\"keyword\">let</span> detector = <span class=\"type\">CIDetector</span>(ofType: <span class=\"type\">CIDetectorTypeFace</span>, context: context, options: opts)</span><br><span class=\"line\">    <span class=\"keyword\">let</span> features = detector?.features(<span class=\"keyword\">in</span>: image!) <span class=\"keyword\">as</span>? [<span class=\"type\">CIFaceFeature</span>]</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> features = features &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> feature <span class=\"keyword\">in</span> features &#123;</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(feature.bounds)</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span> feature.hasLeftEyePosition &#123;</span><br><span class=\"line\">                <span class=\"built_in\">print</span>(<span class=\"string\">\"Left eye \\(feature.leftEyePosition.x) \\(feature.leftEyePosition.y)\"</span>)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span> feature.hasRightEyePosition &#123;</span><br><span class=\"line\">                <span class=\"built_in\">print</span>(<span class=\"string\">\"Right eye \\(feature.rightEyePosition.x) \\(feature.rightEyePosition.y)\"</span>)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span> feature.hasMouthPosition &#123;</span><br><span class=\"line\">                <span class=\"built_in\">print</span>(<span class=\"string\">\"Mouth \\(feature.mouthPosition)\"</span>)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"auto-enhancing-images\">Auto Enhancing Images</h1>\n<p>Core Image的自动优化特征用于分析图片的直方图，人脸区域内容，元数据属性，然后它返回一个CIFilter对象数组，这些对象已经被设置为改进后图片的输入参数。</p>\n<p>下面展示了Core Image用于自动优化图片的滤镜：</p>\n<ul>\n<li>CIRedEyeCorrection：修复由于相机闪光灯造成的红眼、琥珀眼、白眼</li>\n<li>CIFaceBalance：调整脸部颜色，使皮肤更适应</li>\n<li>CIVibrance：增强图片饱和度而不扭曲肤色</li>\n<li>CIToneCurve：调整图像对比度</li>\n<li>CIHighlightShadowAdjust：调整阴影细节</li>\n</ul>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> adjustments = image.autoAdjustmentFilters()</span><br><span class=\"line\"><span class=\"keyword\">for</span> <span class=\"built_in\">filter</span> <span class=\"keyword\">in</span> adjustments &#123;</span><br><span class=\"line\">    <span class=\"built_in\">filter</span>.setValue(image, forKey: kCIInputImageKey)</span><br><span class=\"line\">    image = <span class=\"built_in\">filter</span>.outputImage!</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"subclassing-cifilter-reciptes-for-custom-effects\">Subclassing CIFilter: Reciptes for Custom Effects</h1>\n<p>我们可以通过图片的输出作为另一个的输入合并多个喜欢的滤镜来创建自定义的效果，当多次通过这个方式创建效果时，可以考虑继承CIFilter来封装一个滤镜。</p>\n<h2 id=\"subclassing-cifilter-to-create-the-cicolorinvert-filter\">Subclassing CIFilter to Create the CIColorInvert Filter</h2>\n<p>当我们继承CIFilter后，我们可以通过重新编写默认值或合并滤镜来修改已有的滤镜。Core Image用这项技术实现一些内置滤镜。<br>\n继承一个滤镜我们需要实现以下内容：</p>\n<ul>\n<li>定义滤镜的输入参数属性，必须以<code>input</code>作为参数名开头，比如<em>inputImage</em></li>\n<li>如有必要复写<code>setDefaults</code>方法</li>\n<li>如些<code>outputImage</code>方法</li>\n</ul>\n<p>Core Image提供的CIColorInvert滤镜是CIColorMatrix滤镜的改进，顾名思义，CIColorInvert为CIColorMatrix提供向量，将输入图片的颜色反转。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CIColorInvert</span>: <span class=\"title\">CIFilter</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">var</span> inputImage: <span class=\"type\">CIImage</span>?</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"keyword\">var</span> outputImage: <span class=\"type\">CIImage</span>? &#123;</span><br><span class=\"line\">        <span class=\"keyword\">get</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">guard</span> <span class=\"keyword\">let</span> inputImage = inputImage <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> <span class=\"built_in\">filter</span> = <span class=\"type\">CIFilter</span>(name: <span class=\"string\">\"CIColorMatrix\"</span>,</span><br><span class=\"line\">                                  parameters: [kCIInputImageKey: inputImage,</span><br><span class=\"line\">                                               <span class=\"string\">\"inputRVector\"</span>: <span class=\"type\">CIVector</span>(x: -<span class=\"number\">1</span>, y: <span class=\"number\">0</span>, z: <span class=\"number\">0</span>),</span><br><span class=\"line\">                                               <span class=\"string\">\"inputGVector\"</span>: <span class=\"type\">CIVector</span>(x: <span class=\"number\">0</span>, y: -<span class=\"number\">1</span>, z: <span class=\"number\">0</span>),</span><br><span class=\"line\">                                               <span class=\"string\">\"inputBVector\"</span>: <span class=\"type\">CIVector</span>(x: <span class=\"number\">0</span>, y: <span class=\"number\">0</span>, z: -<span class=\"number\">1</span>),</span><br><span class=\"line\">                                               <span class=\"string\">\"inputBiasVector\"</span>: <span class=\"type\">CIVector</span>(x: <span class=\"number\">1</span>, y: <span class=\"number\">1</span>, z: <span class=\"number\">1</span>)])</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">filter</span>?.outputImage</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"chrome-key-filter-recipe\">Chrome Key Filter Recipe</h2>\n<p>从资源图移除背景颜然后与新背景融合。<br>\n创建色度滤镜：</p>\n<ul>\n<li>创建一个我们想要移除颜色数据的立方体映射，使他们透明</li>\n<li>使用CIColorCube滤镜从图片中移除对应色度的颜色</li>\n<li>使用CISourceOverCompositing滤镜将源图与背景图混合</li>\n</ul>\n<h3 id=\"创建立方体映射\">创建立方体映射</h3>\n<p>一个颜色立方体是一个3D颜色查询表。CIColorCube滤镜把色值作为输入，在表中查询这些值，默认的查询表是一个标识矩阵–意味着对提供的数据不做任何操作。但是，这个方法要求我们删除一种颜色绿色。<br>\n我们需要从图片中移除所有的绿色，把绿色的可见度设为0。”绿色“包含系列颜色，最直接的方法是把颜色从RGBA转换成HSV类型值，在HSV中，H表示为围绕圆柱体中轴的一个角，在这种表示中，我们可以把颜色作为一个饼状切片，然后简单的删除对应颜色块。<br>\n移除绿色，我们需要定义包含绿色最大最小角度值，然后，所有范围内的值的可见度都设为0，纯绿色对应120°，最大最小角度应该围绕这个值。<br>\n立方体映射数据必须提前乘以alpha，所以创建数据的最后一步是将RGB值乘以计算出来的alpha值，对于绿色，alpha为0，其他为1.0.</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> size = <span class=\"number\">64</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"built_in\">count</span> = size * size * size * <span class=\"number\">4</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> cubeData = <span class=\"type\">UnsafeMutablePointer</span>&lt;<span class=\"type\">Float</span>&gt;.allocate(capacity: <span class=\"built_in\">count</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> rgb: [<span class=\"type\">Double</span>] = [<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>], hsv: [<span class=\"type\">Double</span>] = [<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>]</span><br><span class=\"line\"><span class=\"keyword\">for</span> z <span class=\"keyword\">in</span> <span class=\"number\">0</span>..&lt;size &#123;</span><br><span class=\"line\">    rgb[<span class=\"number\">2</span>] = (<span class=\"type\">Double</span>(z)) / <span class=\"type\">Double</span>(size - <span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> y <span class=\"keyword\">in</span> <span class=\"number\">0</span>..&lt;size &#123;</span><br><span class=\"line\">        rgb[<span class=\"number\">1</span>] = <span class=\"type\">Double</span>(y) / <span class=\"type\">Double</span>(size - <span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> <span class=\"number\">0</span>..&lt;size &#123;</span><br><span class=\"line\">            rgb[<span class=\"number\">0</span>] = <span class=\"type\">Double</span>(x) / <span class=\"type\">Double</span>(size - <span class=\"number\">1</span>)</span><br><span class=\"line\">            <span class=\"comment\">// rgbToHSV(rgb, hsv)</span></span><br><span class=\"line\">            <span class=\"keyword\">let</span> alpha = (hsv[<span class=\"number\">0</span>] &gt; minHugAngle &amp;&amp; hsv[<span class=\"number\">0</span>] &lt; maxHueAngle) ? <span class=\"number\">0</span>.0f : <span class=\"number\">1</span>.0f</span><br><span class=\"line\">            <span class=\"keyword\">let</span> offset = x * <span class=\"number\">4</span> + y * size * <span class=\"number\">4</span> + z * size * size * <span class=\"number\">4</span></span><br><span class=\"line\">            cubeData[offset] = <span class=\"type\">Float</span>(rgb[<span class=\"number\">0</span>] * alpha)</span><br><span class=\"line\">            cubeData[offset + <span class=\"number\">1</span>] = <span class=\"type\">Float</span>(rgb[<span class=\"number\">1</span>] * alpha)</span><br><span class=\"line\">            cubeData[offset + <span class=\"number\">2</span>] = <span class=\"type\">Float</span>(rgb[<span class=\"number\">2</span>] * alpha)</span><br><span class=\"line\">            cubeData[offset + <span class=\"number\">3</span>] = <span class=\"type\">Float</span>(alpha)</span><br><span class=\"line\">            cubeData.moveAssign(from: cubeData + <span class=\"number\">3</span>, <span class=\"built_in\">count</span>: <span class=\"number\">4</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> data = <span class=\"type\">Data</span>(bytesNoCopy: cubeData, <span class=\"built_in\">count</span>: <span class=\"built_in\">count</span>, deallocator: .free)</span><br><span class=\"line\"><span class=\"keyword\">let</span> colorCube = <span class=\"type\">CIFilter</span>(name: <span class=\"string\">\"CIColorCube\"</span>)</span><br><span class=\"line\">colorCube?.setValue(<span class=\"type\">NSNumber</span>(value: size), forKey: <span class=\"string\">\"inputCubeDimension\"</span>)</span><br><span class=\"line\">colorCube?.setValue(data, forKey: <span class=\"string\">\"inputCubeData\"</span>)</span><br></pre></td></tr></table></figure>\n<h3 id=\"从源图移除绿色\">从源图移除绿色</h3>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">colorCube?.setValue(inputImage, forKey: kCIInputImageKey)</span><br><span class=\"line\"><span class=\"keyword\">let</span> result = colorCube?.outputImage</span><br></pre></td></tr></table></figure>\n<h3 id=\"融合处理后源图与背景图\">融合处理后源图与背景图</h3>\n<p>运用CISourceOverCompositing滤镜融合图片：</p>\n<ul>\n<li>设置inputImage为处理后的源图</li>\n<li>设置inputBackgroundImage为新的背景图</li>\n</ul>\n<h1 id=\"getting-the-best-performance\">Getting the Best Performance</h1>\n<p>Core Image提供多种选项创建图片，上下文，渲染上下文。看我们如何选择完成一项任务：</p>\n<ul>\n<li>应用多久执行一次任务</li>\n<li>应用使用静态还是视频图片</li>\n<li>是否需要支持实时处理和分析</li>\n<li>颜色保真度对用户的重要性</li>\n</ul>\n<h2 id=\"性能最佳实践\">性能最佳实践</h2>\n<ul>\n<li>不要在每次渲染时创建CIContext对象；上下文存储非常多状态信息；复用更加有效</li>\n<li>评估应用是否需要颜色管理；如非必要不要使用</li>\n<li>避免在GPU渲染CIImage对象时使用Core Animation动画；如果想要同时使用，则用CPU</li>\n<li>确保图片不超过CPU与GPU的限制；CIContext对象的图片大小限制取决于使用的是CPU还是GPU</li>\n<li>尽可能使用小图；性能随输出像素改变</li>\n<li>UIImageView与静态图片更适配</li>\n<li>避免CPU与GPU之间非必要的纹理传输</li>\n<li>考虑使用简单的滤镜类似于算法滤镜产生的结果</li>\n<li>利用iOS 6.0及更高版本对YUV图片的支持；相机像素缓存是天生的YUV，但大多数图像处理算法期望RGBA数据，两者之间的转换是有成本的；Core Image支持从CVPixelBuffer对象读取YUB并应用适当的颜色转换</li>\n</ul>\n<h1 id=\"creating-custom-filters\">Creating Custom Filters</h1>\n<p><a href=\"https://developer.apple.com/library/archive/documentation/GraphicsImaging/Conceptual/CoreImaging/ci_advanced_concepts/ci.advanced_concepts.html#//apple_ref/doc/uid/TP30001185-CH9-SW1\" target=\"_blank\" rel=\"noopener\">What You Need to Know Before Writing a Custom Filter</a></p>\n<p><a href=\"https://developer.apple.com/library/archive/documentation/GraphicsImaging/Conceptual/CoreImaging/ci_custom_filters/ci_custom_filters.html#//apple_ref/doc/uid/TP30001185-CH6-TPXREF101\" target=\"_blank\" rel=\"noopener\">Creating Custom Filters</a></p>\n<h1 id=\"ending\">Ending</h1>\n<p>这章主要是对图片处理的学习，主要就是滤镜的使用，人脸解析功能，更加深入的就是自定义滤镜，多适用于对图片要求较高或本身就是图片处理的应用。</p>\n<h1 id=\"reference\">Reference</h1>\n<blockquote>\n<p><a href=\"https://developer.apple.com/library/archive/documentation/GraphicsImaging/Conceptual/CoreImaging/ci_intro/ci_intro.html#//apple_ref/doc/uid/TP30001185-CH1-TPXREF101\" target=\"_blank\" rel=\"noopener\">About Core Image</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1>Introduction</h1>\n<p>Core Image 是一种图像处理和分析技术，旨在为静态或者视频图片提供近乎实时的处理。它对来自Core Graphics，Core Video，Image I/O框架中的图片数据类型进行操作，使用GPU或CPU渲染路径。Core Image通过提供一个易于使用的API隐藏底层图片处理的细节，我们不需要知道OpenGL，OpenGL ES，Metal的细节来可以利用GPU的能力，也不需要知道任何关于GCD的知识就可以进行多核处理，所有的细节Core Image都会帮我们处理。</p>\n<p><img src=\"/img/article/20190425/1.png\" alt=\"Core Image\"></p>\n<p>Core Image 提供以下功能：</p>\n<ul>\n<li>访问内置的图像处理过滤器</li>\n<li>特征检测能力</li>\n<li>支持自动图像增强</li>\n<li>将多个滤镜链接一起形成自定义效果的能力</li>\n<li>支持创建运行在GPU上的自定义滤镜</li>\n<li>基于反馈的图像处理能力<br>\nMacOS还提供一种打包自定义滤镜以供其他应用使用的方法。</li>\n</ul>\n<h1>Processing Images</h1>\n<p>处理图片意味着应用滤镜 – 图片滤镜是一种逐像素检测输入图片并通过算法应用一些效果来生成输出图片的软件。图片处理主要依靠描述滤镜及其输入输出的CIFilter和CIImage类，我们可以使用Core Image与其他系统框架或者创建通过CIContext创建自己的渲染工作流来应用滤镜、显示或导出结果。</p>\n<p>在图片上应用滤镜的基本代码：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> context = <span class=\"type\">CIContext</span>()</span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"built_in\">filter</span> = <span class=\"type\">CIFilter</span>(name: <span class=\"string\">\"CISepiaTone\"</span>)</span><br><span class=\"line\"><span class=\"built_in\">filter</span>?.setValue(<span class=\"number\">0.8</span>, forKey: kCIInputIntensityKey)</span><br><span class=\"line\"><span class=\"keyword\">let</span> image = <span class=\"type\">CIImage</span>(contentsOf: <span class=\"type\">Bundle</span>.main.url(forResource: <span class=\"string\">\"\"</span>, withExtension: <span class=\"string\">\"\"</span>)!)</span><br><span class=\"line\"><span class=\"built_in\">filter</span>?.setValue(image, forKey: kCIInputImageKey)</span><br><span class=\"line\"><span class=\"keyword\">let</span> result = <span class=\"built_in\">filter</span>?.outputImage</span><br><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">let</span> result = result &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> cgImage = context.createCGImage(result, from: result.extent)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>滤镜处理并制作图片，CIImage实例是表示一张图片的不可变对象，这些对象不直接表示图片位图数据，相反，CIImage对象是制作图片的一种方式。一种方式可能要求直接从文件中加载图片，另一种可能是从滤镜或过滤器链的输出，Core Image 仅当我们要求将一张图片渲染作为显示或者输出时执行这些方法。</p>\n<p>应用滤镜的方式，创建一个或多个CIImage对象表示被滤镜处理的图片同时配置滤镜的输入参数，我们可以从以下几种图片数据中创建CIImage对象：</p>\n<ul>\n<li>被加载图片文件的URL引用或者被加载包含图片文件数据的NSData对象</li>\n<li>Quartz2D，UIKit，或者AppKit的图片代表（CGImageRef，UIImage，NSBitmapImageRep）</li>\n<li>Metal，OpenGL，OpenGl ES纹理</li>\n<li>CoreVideo图片或者像素缓存（CVImageBufferRef，CVPixelBufferRef）</li>\n<li>进程间分享的图片数据 – IOSurfaceRef</li>\n<li>内存中的位图数据（对象指针，按需提供数据的CIImageProvider）</li>\n</ul>\n<p>因为CIImage对象描述了如何制作图片（而不是包含图片数据），他同样可以表示滤镜输出。当访问CIFilter对象的outputImage属性时，Core Image只标识和存储执行滤镜需要的步骤，这些步骤只有在请求显示或输出而渲染图片时运行。</p>\n<h2>描述图片处理效果 – 滤镜</h2>\n<p>CIFilter对象是代表图片处理效果和控制效果行为系列参数的可变对象，使用滤镜的方式：创建CIFilter对象，设置输入参数，然后访问它的输出图像。<a href=\"https://developer.apple.com/library/archive/documentation/GraphicsImaging/Reference/CoreImageFilterReference/index.html#//apple_ref/doc/uid/TP40004346\" target=\"_blank\" rel=\"noopener\">各类滤镜</a></p>\n<h3>复杂效果 – 链式滤镜</h3>\n<p>每个Core Image提供一个CIImage输出对象，可以把这个输出对象作为另一个滤镜的输入。</p>\n<p><img src=\"/img/article/20190425/2.png\" alt=\"Construct a filter chain by connecting filter inputs and outputs\"></p>\n<p>Core Image 优化了滤镜链的应用，以快速高效的方式渲染结果，链中的每个CIImage对象不是完全渲染过的图片，而是渲染的方式，Core Image不需要单独执行每个滤镜操作，这样会非常浪费时间和内存，相反，Core Image将滤镜组合成一个单独的操作，甚至以不同的顺序重新组织滤镜，从而更有效的生成相同的结果。</p>\n<p><img src=\"/img/20190425/2.png\" alt=\"Core Image optimizes a filter chain to a single operation\"></p>\n<p>我们可以看出，Crop滤镜操作从最后移动到优先执行，这个滤镜用于输出裁剪后的图片，因此不需要对裁剪外的像素使用颜色和锐化过滤器，所以Core Image首先执行裁剪，确保消耗巨大的图形处理操作只适用于最终输出可见的像素内。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">applyFilterChain</span><span class=\"params\">(to image: CIImage)</span></span> -&gt; <span class=\"type\">CIImage</span>? &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> colorFilter = <span class=\"type\">CIFilter</span>(name: <span class=\"string\">\"CIPhotoEffectProcess\"</span>, parameters: [kCIInputImageKey: image])</span><br><span class=\"line\">    <span class=\"keyword\">guard</span> <span class=\"keyword\">let</span> image = colorFilter?.outputImage <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> bloomImage = image.applyingFilter(<span class=\"string\">\"CIBloom\"</span>, parameters: [kCIInputRadiusKey: <span class=\"number\">10.0</span>, kCIInputIntensityKey: <span class=\"number\">1.0</span>])</span><br><span class=\"line\">    <span class=\"keyword\">let</span> cropRect = <span class=\"type\">CGRect</span>(x: <span class=\"number\">0</span>, y: <span class=\"number\">0</span>, width: <span class=\"number\">150</span>, height: <span class=\"number\">150</span>)  <span class=\"comment\">// 左下角为坐标原点</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> croppedImage = bloomImage.cropped(to: cropRect) <span class=\"comment\">// 用于常用的筛选操作，比如croped, clamped</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> croppedImage</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3>特殊类型的滤镜</h3>\n<p><a href=\"https://developer.apple.com/library/archive/documentation/GraphicsImaging/Reference/CoreImageFilterReference/index.html#//apple_ref/doc/filter/ci/CIQRCodeGenerator\" target=\"_blank\" rel=\"noopener\">生成二维码</a><br>\n<a href=\"https://developer.apple.com/library/archive/documentation/GraphicsImaging/Reference/CoreImageFilterReference/index.html#//apple_ref/doc/filter/ci/CICode128BarcodeGenerator\" target=\"_blank\" rel=\"noopener\">生成条形码</a><br>\n<a href=\"https://developer.apple.com/library/archive/documentation/GraphicsImaging/Conceptual/CoreImaging/ci_tasks/ci_tasks.html#//apple_ref/doc/uid/TP30001185-CH3-DontLinkElementID_6\" target=\"_blank\" rel=\"noopener\">其他</a></p>\n<h2>用Core Image上下文构建自己的工作流</h2>\n<p>主要涉及Metal，OpenGL，OpenGL ES等实时渲染，后面学到Metal的时候再来看。</p>\n<h1>Detecting Faces in an Image</h1>\n<p>Core Image可以在图片中解析找到人脸。它执行的是人脸检测而不是人脸识别，人脸检测是包含人脸特征的矩形的识别，而人脸识别是对特定人脸的识别。Core Image检测人脸后，可以提供人脸特征信息，例如眼睛或鼻子的位置。它也可以跟踪视频中人脸的位置。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">DispatchQueue</span>.global().async &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> image = <span class=\"type\">CIImage</span>(contentsOf: <span class=\"type\">Bundle</span>.main.url(forResource: <span class=\"string\">\"7\"</span>, withExtension: <span class=\"string\">\"jpg\"</span>)!)</span><br><span class=\"line\">    <span class=\"keyword\">let</span> context = <span class=\"type\">CIContext</span>()</span><br><span class=\"line\">    <span class=\"keyword\">let</span> opts = [<span class=\"type\">CIDetectorAccuracy</span>: <span class=\"type\">CIDetectorAccuracyHigh</span>]</span><br><span class=\"line\">    <span class=\"keyword\">let</span> detector = <span class=\"type\">CIDetector</span>(ofType: <span class=\"type\">CIDetectorTypeFace</span>, context: context, options: opts)</span><br><span class=\"line\">    <span class=\"keyword\">let</span> features = detector?.features(<span class=\"keyword\">in</span>: image!) <span class=\"keyword\">as</span>? [<span class=\"type\">CIFaceFeature</span>]</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> features = features &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> feature <span class=\"keyword\">in</span> features &#123;</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(feature.bounds)</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span> feature.hasLeftEyePosition &#123;</span><br><span class=\"line\">                <span class=\"built_in\">print</span>(<span class=\"string\">\"Left eye \\(feature.leftEyePosition.x) \\(feature.leftEyePosition.y)\"</span>)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span> feature.hasRightEyePosition &#123;</span><br><span class=\"line\">                <span class=\"built_in\">print</span>(<span class=\"string\">\"Right eye \\(feature.rightEyePosition.x) \\(feature.rightEyePosition.y)\"</span>)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span> feature.hasMouthPosition &#123;</span><br><span class=\"line\">                <span class=\"built_in\">print</span>(<span class=\"string\">\"Mouth \\(feature.mouthPosition)\"</span>)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1>Auto Enhancing Images</h1>\n<p>Core Image的自动优化特征用于分析图片的直方图，人脸区域内容，元数据属性，然后它返回一个CIFilter对象数组，这些对象已经被设置为改进后图片的输入参数。</p>\n<p>下面展示了Core Image用于自动优化图片的滤镜：</p>\n<ul>\n<li>CIRedEyeCorrection：修复由于相机闪光灯造成的红眼、琥珀眼、白眼</li>\n<li>CIFaceBalance：调整脸部颜色，使皮肤更适应</li>\n<li>CIVibrance：增强图片饱和度而不扭曲肤色</li>\n<li>CIToneCurve：调整图像对比度</li>\n<li>CIHighlightShadowAdjust：调整阴影细节</li>\n</ul>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> adjustments = image.autoAdjustmentFilters()</span><br><span class=\"line\"><span class=\"keyword\">for</span> <span class=\"built_in\">filter</span> <span class=\"keyword\">in</span> adjustments &#123;</span><br><span class=\"line\">    <span class=\"built_in\">filter</span>.setValue(image, forKey: kCIInputImageKey)</span><br><span class=\"line\">    image = <span class=\"built_in\">filter</span>.outputImage!</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1>Subclassing CIFilter: Reciptes for Custom Effects</h1>\n<p>我们可以通过图片的输出作为另一个的输入合并多个喜欢的滤镜来创建自定义的效果，当多次通过这个方式创建效果时，可以考虑继承CIFilter来封装一个滤镜。</p>\n<h2>Subclassing CIFilter to Create the CIColorInvert Filter</h2>\n<p>当我们继承CIFilter后，我们可以通过重新编写默认值或合并滤镜来修改已有的滤镜。Core Image用这项技术实现一些内置滤镜。<br>\n继承一个滤镜我们需要实现以下内容：</p>\n<ul>\n<li>定义滤镜的输入参数属性，必须以<code>input</code>作为参数名开头，比如<em>inputImage</em></li>\n<li>如有必要复写<code>setDefaults</code>方法</li>\n<li>如些<code>outputImage</code>方法</li>\n</ul>\n<p>Core Image提供的CIColorInvert滤镜是CIColorMatrix滤镜的改进，顾名思义，CIColorInvert为CIColorMatrix提供向量，将输入图片的颜色反转。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CIColorInvert</span>: <span class=\"title\">CIFilter</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">var</span> inputImage: <span class=\"type\">CIImage</span>?</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"keyword\">var</span> outputImage: <span class=\"type\">CIImage</span>? &#123;</span><br><span class=\"line\">        <span class=\"keyword\">get</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">guard</span> <span class=\"keyword\">let</span> inputImage = inputImage <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> <span class=\"built_in\">filter</span> = <span class=\"type\">CIFilter</span>(name: <span class=\"string\">\"CIColorMatrix\"</span>,</span><br><span class=\"line\">                                  parameters: [kCIInputImageKey: inputImage,</span><br><span class=\"line\">                                               <span class=\"string\">\"inputRVector\"</span>: <span class=\"type\">CIVector</span>(x: -<span class=\"number\">1</span>, y: <span class=\"number\">0</span>, z: <span class=\"number\">0</span>),</span><br><span class=\"line\">                                               <span class=\"string\">\"inputGVector\"</span>: <span class=\"type\">CIVector</span>(x: <span class=\"number\">0</span>, y: -<span class=\"number\">1</span>, z: <span class=\"number\">0</span>),</span><br><span class=\"line\">                                               <span class=\"string\">\"inputBVector\"</span>: <span class=\"type\">CIVector</span>(x: <span class=\"number\">0</span>, y: <span class=\"number\">0</span>, z: -<span class=\"number\">1</span>),</span><br><span class=\"line\">                                               <span class=\"string\">\"inputBiasVector\"</span>: <span class=\"type\">CIVector</span>(x: <span class=\"number\">1</span>, y: <span class=\"number\">1</span>, z: <span class=\"number\">1</span>)])</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">filter</span>?.outputImage</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2>Chrome Key Filter Recipe</h2>\n<p>从资源图移除背景颜然后与新背景融合。<br>\n创建色度滤镜：</p>\n<ul>\n<li>创建一个我们想要移除颜色数据的立方体映射，使他们透明</li>\n<li>使用CIColorCube滤镜从图片中移除对应色度的颜色</li>\n<li>使用CISourceOverCompositing滤镜将源图与背景图混合</li>\n</ul>\n<h3>创建立方体映射</h3>\n<p>一个颜色立方体是一个3D颜色查询表。CIColorCube滤镜把色值作为输入，在表中查询这些值，默认的查询表是一个标识矩阵–意味着对提供的数据不做任何操作。但是，这个方法要求我们删除一种颜色绿色。<br>\n我们需要从图片中移除所有的绿色，把绿色的可见度设为0。”绿色“包含系列颜色，最直接的方法是把颜色从RGBA转换成HSV类型值，在HSV中，H表示为围绕圆柱体中轴的一个角，在这种表示中，我们可以把颜色作为一个饼状切片，然后简单的删除对应颜色块。<br>\n移除绿色，我们需要定义包含绿色最大最小角度值，然后，所有范围内的值的可见度都设为0，纯绿色对应120°，最大最小角度应该围绕这个值。<br>\n立方体映射数据必须提前乘以alpha，所以创建数据的最后一步是将RGB值乘以计算出来的alpha值，对于绿色，alpha为0，其他为1.0.</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> size = <span class=\"number\">64</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"built_in\">count</span> = size * size * size * <span class=\"number\">4</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> cubeData = <span class=\"type\">UnsafeMutablePointer</span>&lt;<span class=\"type\">Float</span>&gt;.allocate(capacity: <span class=\"built_in\">count</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> rgb: [<span class=\"type\">Double</span>] = [<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>], hsv: [<span class=\"type\">Double</span>] = [<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>]</span><br><span class=\"line\"><span class=\"keyword\">for</span> z <span class=\"keyword\">in</span> <span class=\"number\">0</span>..&lt;size &#123;</span><br><span class=\"line\">    rgb[<span class=\"number\">2</span>] = (<span class=\"type\">Double</span>(z)) / <span class=\"type\">Double</span>(size - <span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> y <span class=\"keyword\">in</span> <span class=\"number\">0</span>..&lt;size &#123;</span><br><span class=\"line\">        rgb[<span class=\"number\">1</span>] = <span class=\"type\">Double</span>(y) / <span class=\"type\">Double</span>(size - <span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> <span class=\"number\">0</span>..&lt;size &#123;</span><br><span class=\"line\">            rgb[<span class=\"number\">0</span>] = <span class=\"type\">Double</span>(x) / <span class=\"type\">Double</span>(size - <span class=\"number\">1</span>)</span><br><span class=\"line\">            <span class=\"comment\">// rgbToHSV(rgb, hsv)</span></span><br><span class=\"line\">            <span class=\"keyword\">let</span> alpha = (hsv[<span class=\"number\">0</span>] &gt; minHugAngle &amp;&amp; hsv[<span class=\"number\">0</span>] &lt; maxHueAngle) ? <span class=\"number\">0</span>.0f : <span class=\"number\">1</span>.0f</span><br><span class=\"line\">            <span class=\"keyword\">let</span> offset = x * <span class=\"number\">4</span> + y * size * <span class=\"number\">4</span> + z * size * size * <span class=\"number\">4</span></span><br><span class=\"line\">            cubeData[offset] = <span class=\"type\">Float</span>(rgb[<span class=\"number\">0</span>] * alpha)</span><br><span class=\"line\">            cubeData[offset + <span class=\"number\">1</span>] = <span class=\"type\">Float</span>(rgb[<span class=\"number\">1</span>] * alpha)</span><br><span class=\"line\">            cubeData[offset + <span class=\"number\">2</span>] = <span class=\"type\">Float</span>(rgb[<span class=\"number\">2</span>] * alpha)</span><br><span class=\"line\">            cubeData[offset + <span class=\"number\">3</span>] = <span class=\"type\">Float</span>(alpha)</span><br><span class=\"line\">            cubeData.moveAssign(from: cubeData + <span class=\"number\">3</span>, <span class=\"built_in\">count</span>: <span class=\"number\">4</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> data = <span class=\"type\">Data</span>(bytesNoCopy: cubeData, <span class=\"built_in\">count</span>: <span class=\"built_in\">count</span>, deallocator: .free)</span><br><span class=\"line\"><span class=\"keyword\">let</span> colorCube = <span class=\"type\">CIFilter</span>(name: <span class=\"string\">\"CIColorCube\"</span>)</span><br><span class=\"line\">colorCube?.setValue(<span class=\"type\">NSNumber</span>(value: size), forKey: <span class=\"string\">\"inputCubeDimension\"</span>)</span><br><span class=\"line\">colorCube?.setValue(data, forKey: <span class=\"string\">\"inputCubeData\"</span>)</span><br></pre></td></tr></table></figure>\n<h3>从源图移除绿色</h3>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">colorCube?.setValue(inputImage, forKey: kCIInputImageKey)</span><br><span class=\"line\"><span class=\"keyword\">let</span> result = colorCube?.outputImage</span><br></pre></td></tr></table></figure>\n<h3>融合处理后源图与背景图</h3>\n<p>运用CISourceOverCompositing滤镜融合图片：</p>\n<ul>\n<li>设置inputImage为处理后的源图</li>\n<li>设置inputBackgroundImage为新的背景图</li>\n</ul>\n<h1>Getting the Best Performance</h1>\n<p>Core Image提供多种选项创建图片，上下文，渲染上下文。看我们如何选择完成一项任务：</p>\n<ul>\n<li>应用多久执行一次任务</li>\n<li>应用使用静态还是视频图片</li>\n<li>是否需要支持实时处理和分析</li>\n<li>颜色保真度对用户的重要性</li>\n</ul>\n<h2>性能最佳实践</h2>\n<ul>\n<li>不要在每次渲染时创建CIContext对象；上下文存储非常多状态信息；复用更加有效</li>\n<li>评估应用是否需要颜色管理；如非必要不要使用</li>\n<li>避免在GPU渲染CIImage对象时使用Core Animation动画；如果想要同时使用，则用CPU</li>\n<li>确保图片不超过CPU与GPU的限制；CIContext对象的图片大小限制取决于使用的是CPU还是GPU</li>\n<li>尽可能使用小图；性能随输出像素改变</li>\n<li>UIImageView与静态图片更适配</li>\n<li>避免CPU与GPU之间非必要的纹理传输</li>\n<li>考虑使用简单的滤镜类似于算法滤镜产生的结果</li>\n<li>利用iOS 6.0及更高版本对YUV图片的支持；相机像素缓存是天生的YUV，但大多数图像处理算法期望RGBA数据，两者之间的转换是有成本的；Core Image支持从CVPixelBuffer对象读取YUB并应用适当的颜色转换</li>\n</ul>\n<h1>Creating Custom Filters</h1>\n<p><a href=\"https://developer.apple.com/library/archive/documentation/GraphicsImaging/Conceptual/CoreImaging/ci_advanced_concepts/ci.advanced_concepts.html#//apple_ref/doc/uid/TP30001185-CH9-SW1\" target=\"_blank\" rel=\"noopener\">What You Need to Know Before Writing a Custom Filter</a></p>\n<p><a href=\"https://developer.apple.com/library/archive/documentation/GraphicsImaging/Conceptual/CoreImaging/ci_custom_filters/ci_custom_filters.html#//apple_ref/doc/uid/TP30001185-CH6-TPXREF101\" target=\"_blank\" rel=\"noopener\">Creating Custom Filters</a></p>\n<h1>Ending</h1>\n<p>这章主要是对图片处理的学习，主要就是滤镜的使用，人脸解析功能，更加深入的就是自定义滤镜，多适用于对图片要求较高或本身就是图片处理的应用。</p>\n<h1>Reference</h1>\n<blockquote>\n<p><a href=\"https://developer.apple.com/library/archive/documentation/GraphicsImaging/Conceptual/CoreImaging/ci_intro/ci_intro.html#//apple_ref/doc/uid/TP30001185-CH1-TPXREF101\" target=\"_blank\" rel=\"noopener\">About Core Image</a></p>\n</blockquote>\n"},{"title":"Kth Smallest/Largest Element in ...","catalog":true,"toc_nav_num":true,"date":"2019-12-16T09:30:51.000Z","subtitle":"Leet Code","header-img":"/img/article_header/article_header.png","busuanzi":true,"_content":"\n# Introduction\n\nHere is the summary about the kth problems in LeetCode.\n\n# Kth Largest Element in an Array\n\nFind the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.\n\n**Example 1:**\n\n```\nInput: [3,2,1,5,6,4] and k = 2\nOutput: 5\n```\n\n**Example 2:**\n\n```\nInput: [3,2,3,1,2,4,5,5,6] and k = 4\nOutput: 4\n```\n\n**Algorithm**\n\n``` swift\nclass Solution {\n    func findKthLargest(_ nums: [Int], _ k: Int) -> Int {\n        func quickSort(_ nums: inout [Int], _ l: Int, _ r: Int) -> Int {\n            var l = l, r = r\n            let key = nums[l]\n            while l < r {\n                while l < r, key >= nums[r] {\n                    r -= 1\n                }\n                nums[l] = nums[r]\n                while l < r, key <= nums[l] {\n                    l += 1\n                }\n                nums[r] = nums[l]\n            }\n            nums[l] = key\n            return l\n        }\n        var l = 0, r = nums.count-1, nums = nums\n        while l < r {\n            let index = quickSort(&nums, l, r)\n            switch index {\n            case k - 1:\n                return nums[index]\n            case 0..<k-1:\n                l = index + 1\n                break\n            default:\n                r = index - 1\n                break\n            }\n        }\n        return nums[k-1]\n    }\n}\n```\n\nFrom leetCode [215. Kth Largest Element in an Array](https://leetcode.com/problems/kth-largest-element-in-an-array/)\n\n# Kth Smallest Element in a BST\n\nGiven a binary search tree, write a function kthSmallest to find the kth smallest element in it.\n\n**Note:**\n\nYou may assume k is always valid, 1 ≤ k ≤ BST's total elements.\n\n**Example 1:**\n\n```\nInput: root = [3,1,4,null,2], k = 1\n   3\n  / \\\n 1   4\n  \\\n   2\nOutput: 1\n```\n\n**Exapmle 2:**\n\n```\nInput: root = [5,3,6,2,4,null,null,1], k = 3\n       5\n      / \\\n     3   6\n    / \\\n   2   4\n  /\n 1\nOutput: 3\n```\n\n**Algorithm:**\n\n``` swift\npublic class TreeNode {\n    public var val: Int\n    public var left: TreeNode?\n    public var right: TreeNode?\n    public init(_ val: Int) {\n        self.val = val\n        self.left = nil\n        self.right = nil\n    }\n}\nclass Solution {\n    func kthSmallest(_ root: TreeNode?, _ k: Int) -> Int {\n        var stack = [TreeNode]()\n        var cur = root\n        var k = k\n        while cur != nil || !stack.isEmpty {\n            if let temp = cur {\n                stack.append(temp)\n                cur = temp.left\n            } else {\n                let last = stack.removeLast()\n                k -= 1\n                if k == 0 {\n                    return last.val\n                }\n                cur = last.right\n            }\n        }\n        return 0\n    }\n}\n```\n\nFrom leetCode [230. Kth Smallest Element in a BST](https://leetcode.com/problems/kth-smallest-element-in-a-bst/)\n\n# Find K Pairs with Smallest Sums\n\nYou are given two integer arrays nums1 and nums2 sorted in ascending order and an integer k.\n\nDefine a pair (u,v) which consists of one element from the first array and one element from the second array.\n\nFind the k pairs (u1,v1),(u2,v2) ...(uk,vk) with the smallest sums.\n\n**Example 1:**\n\n```\nInput: nums1 = [1,7,11], nums2 = [2,4,6], k = 3\nOutput: [[1,2],[1,4],[1,6]] \nExplanation: The first 3 pairs are returned from the sequence: \n             [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]\n```\n\n**Example 2:**\n\n```\nInput: nums1 = [1,1,2], nums2 = [1,2,3], k = 2\nOutput: [1,1],[1,1]\nExplanation: The first 2 pairs are returned from the sequence: \n             [1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]\n```\n\n**Example 3:**\n\n```\nInput: nums1 = [1,2], nums2 = [3], k = 3\nOutput: [1,3],[2,3]\nExplanation: All possible pairs are returned from the sequence: [1,3],[2,3]\n```\n\n**Algorithm:**\n\n``` swift\nclass Solution {\n    func kSmallestPairs(_ nums1: [Int], _ nums2: [Int], _ k: Int) -> [[Int]] {\n        guard !nums1.isEmpty, !nums2.isEmpty, k >= 0 else {\n            return []\n        }\n        func insert(_ arr: inout [(Int, Int, Int)], _ new: (Int, Int, Int)) {\n            var s = 0, e = arr.count-1\n            while s <= e {\n                let mid = (s + e) >> 1\n                if (mid == 0 && new.0 <= arr[mid].0) ||\n                    (mid > 0 && new.0 >= arr[mid-1].0 && new.0 <= arr[mid].0) {\n                    arr.insert(new, at: mid)\n                    return\n                } else if new.0 > arr[mid].0 {\n                    s = mid + 1\n                } else {\n                    e = mid - 1\n                }\n            }\n            arr.insert(new, at: arr.count)\n        }\n        var arr = [(Int, Int, Int)]()\n        for i in nums1.indices {\n            arr.append((nums1[i]+nums2[0], i, 0))\n        }\n        var res = [[Int]]()\n        while !arr.isEmpty, res.count < k {\n            let (_, i, j) = arr.removeFirst()\n            res.append([nums1[i], nums2[j]])\n            if j < nums2.count-1 {\n                insert(&arr, (nums1[i]+nums2[j+1], i, j+1))\n            }\n        }\n        return res\n    }\n}\n```\n\n**Comment:**\n\nHere is a simple example demonstrate how this algorithm works:\n\n![example](/img/article/20191216/1.png)\n\nFrom leetCode [373. Find K Pairs with Smallest Sums](https://leetcode.com/problems/find-k-pairs-with-smallest-sums/)\n\n# Kth Smallest Element in a Sorted Matrix\n\nGiven a n x n matrix where each of the rows and columns are sorted in ascending order, find the kth smallest element in the matrix.\n\nNote that it is the kth smallest element in the sorted order, not the kth distinct element.\n\n**Example:**\n\n```\nmatrix = [\n   [ 1,  5,  9],\n   [10, 11, 13],\n   [12, 13, 15]\n],\nk = 8,\n\nreturn 13.\n```\n\n**Algorithm:**\n\n``` swift\nclass Solution {\n    func kthSmallest(_ matrix: [[Int]], _ k: Int) -> Int {\n        guard !matrix.isEmpty, !matrix.first!.isEmpty, k > 0 else {\n            return 0\n        }\n        func insert(_ arr: inout [(Int, Int, Int)], _ new: (Int, Int, Int)) {\n            var s = 0, e = arr.count-1\n            while s <= e {\n                let mid = (s + e) >> 1\n                if (mid == 0 && new.0 <= arr[mid].0) ||\n                    (mid > 0 && new.0 > arr[mid-1].0 && new.0 <= arr[mid].0) {\n                    arr.insert(new, at: mid)\n                    return\n                } else if new.0 > arr[mid].0 {\n                    s = mid + 1\n                } else {\n                    e = mid - 1\n                }\n            }\n            arr.insert(new, at: arr.count)\n        }\n        var arr = [(Int, Int, Int)]()\n        for i in matrix.indices {\n            arr.append((matrix[i][0], i, 0))\n        }\n        var k = k, i = 0, j = 0\n        while !arr.isEmpty, k > 0 {\n            (_, i, j) = arr.removeFirst()\n            if j < matrix.first!.count-1 {\n                insert(&arr, (matrix[i][j+1], i, j+1))\n            }\n            k -= 1\n        }\n        return matrix[i][j]\n    }\n}\n```\n\n``` swift\nclass Solution {\n    func kthSmallest(_ matrix: [[Int]], _ k: Int) -> Int {\n        guard !matrix.isEmpty else {\n            return 0\n        }\n        let n = matrix.count-1\n        var lo = matrix[0][0], hi = matrix[n][n]\n        while lo < hi {\n            let mid = (lo + hi) >> 1\n            var count = 0, j = n\n            for i in 0...n {\n                while j >= 0, matrix[i][j] > mid {\n                    j -= 1\n                }\n                count += j + 1\n            }\n            if count < k {\n                lo = mid + 1\n            } else {\n                hi = mid\n            }\n        }\n        return lo\n    }\n}\n```\n\nFrom leetCode [378. Kth Smallest Element in a Sorted Matrix](https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/)\n\n# Kth Smallest Number in Multiplication Table\n\nNearly every one have used the Multiplication Table. But could you find out the k-th smallest number quickly from the multiplication table?\n\nGiven the height m and the length n of a m * n Multiplication Table, and a positive integer k, you need to return the k-th smallest number in this table.\n\n**Example 1:**\n\n```\nInput: m = 3, n = 3, k = 5\nOutput: \nExplanation: \nThe Multiplication Table:\n1\t2\t3\n2\t4\t6\n3\t6\t9\n\nThe 5-th smallest number is 3 (1, 2, 2, 3, 3).\n```\n\n**Example 2:**\n\n```\nInput: m = 2, n = 3, k = 6\nOutput: \nExplanation: \nThe Multiplication Table:\n1\t2\t3\n2\t4\t6\n\nThe 6-th smallest number is 6 (1, 2, 2, 3, 4, 6).\n```\n\n**Note:**\n\n1. The m and n will be in the range [1, 30000].\n2. The k will be in the range [1, m * n]\n\n**Algorithm:**\n\n``` swift\nclass Solution {\n    func findKthNumber(_ m: Int, _ n: Int, _ k: Int) -> Int {\n        guard m > 0, n > 0, k > 0 else {\n            return 0\n        }\n        var lo = 1, hi = m * n\n        while lo < hi {\n            let mid = (lo + hi) >> 1\n            var count = 0, nN = n\n            for i in 1...m {\n                while nN > 0, i * nN > mid {\n                    nN -= 1\n                }\n                count += nN\n            }\n            if count < k {\n                lo = mid + 1\n            } else {\n                hi = mid\n            }\n        }\n        return lo\n    }\n}\n```\n\nFrom leetCode [668. Kth Smallest Number in Multiplication Table](https://leetcode.com/problems/kth-smallest-number-in-multiplication-table/)\n\n# Find K-th Smallest Pair Distance\n\nGiven an integer array, return the k-th smallest distance among all the pairs. The distance of a pair (A, B) is defined as the absolute difference between A and B.\n\n**Example 1:**\n\n```\nInput:\nnums = [1,3,1]\nk = 1\nOutput: 0 \nExplanation:\nHere are all the pairs:\n(1,3) -> 2\n(1,1) -> 0\n(3,1) -> 2\nThen the 1st smallest distance pair is (1,1), and its distance is 0.\n```\n\n**Note:**\n\n1. 2 <= len(nums) <= 10000.\n2. 0 <= nums[i] < 1000000.\n3. 1 <= k <= len(nums) * (len(nums) - 1) / 2.\n\n**Algorithm:**\n\n``` swift\nclass Solution {\n    func smallestDistancePair(_ nums: [Int], _ k: Int) -> Int {\n        guard nums.count > 1 else {\n            return 0\n        }\n        let sortedNums = nums.sorted()\n        var lo = 0, hi = sortedNums.last! - sortedNums.first!\n        while lo < hi {\n            let mid = (lo + hi) >> 1\n            var count = 0, i = 0\n            for j in 0..<sortedNums.count {\n                while i < sortedNums.count, sortedNums[j] - sortedNums[i] > mid {\n                    i += 1\n                }\n                count += j-i\n            }\n            if count < k {\n                lo = mid + 1\n            } else {\n                hi = mid\n            }\n        }\n        return lo\n    }\n}\n```\n\nFrom leetCode [719. Find K-th Smallest Pair Distance](https://leetcode.com/problems/find-k-th-smallest-pair-distance/)\n\n# K-th Smallest Prime Fraction\n\nA sorted list A contains 1, plus some number of primes.  Then, for every p < q in the list, we consider the fraction p/q.\n\nWhat is the K-th smallest fraction considered?  Return your answer as an array of ints, where answer[0] = p and answer[1] = q.\n\n**Example:**\n\n```\nInput: A = [1, 2, 3, 5], K = 3\nOutput: [2, 5]\nExplanation:\nThe fractions to be considered in sorted order are:\n1/5, 1/3, 2/5, 1/2, 3/5, 2/3.\nThe third fraction is 2/5.\n\nInput: A = [1, 7], K = 1\nOutput: [1, 7]\n```\n\n**Note:**\n\n- A will have length between 2 and 2000.\n- Each A[i] will be between 1 and 30000.\n- K will be between 1 and A.length * (A.length - 1) / 2.\n\n**Algorithm:**\n\n``` swift\nclass Solution {\n    func kthSmallestPrimeFraction(_ A: [Int], _ K: Int) -> [Int] {\n        let n = A.count\n        guard n > 1, K > 0 else {\n            return []\n        }\n        var lo = 0.0, hi = 1.0\n        while lo < hi {\n            let mid = (lo + hi) / 2\n            var j = 1, count = 0, maxVal = 0.0, res = (0, 0)\n            for i in 0..<n-1 {\n                while j < n, Double(A[i]) > mid * Double(A[j]) {\n                    j += 1\n                }\n                if n == j {\n                    break\n                }\n                count += n-j\n                let val = Double(A[i]) / Double(A[j])\n                if val > maxVal {\n                    res = (i, j)\n                    maxVal = val\n                }\n            }\n            if count < K {\n                lo = mid\n            } else if count == K {\n                return [A[res.0], A[res.1]]\n            } else {\n                hi = mid\n            }\n        }\n        return []\n    }\n}\n```\n\nFrom leetCode [786. K-th Smallest Prime Fraction](https://leetcode.com/problems/k-th-smallest-prime-fraction/)\n\n# Minimum Cost to Hire K Workers\n\nThere are N workers.  The i-th worker has a quality[i] and a minimum wage expectation wage[i].\n\nNow we want to hire exactly K workers to form a paid group.  When hiring a group of K workers, we must pay them according to the following rules:\n1. Every worker in the paid group should be paid in the ratio of their quality compared to other workers in the paid group.\n2. Every worker in the paid group must be paid at least their minimum wage expectation.\n\nReturn the least amount of money needed to form a paid group satisfying the above conditions.\n\n**Example 1:**\n\n```\nInput: quality = [10,20,5], wage = [70,50,30], K = 2\nOutput: 105.00000\nExplanation: We pay 70 to 0-th worker and 35 to 2-th worker.\n```\n\n**Example 2:**\n\n```\nInput: quality = [3,1,10,10,1], wage = [4,8,2,2,7], K = 3\nOutput: 30.66667\nExplanation: We pay 4 to 0-th worker, 13.33333 to 2-th and 3-th workers seperately. \n```\n\n**Note:**\n\n1. 1 <= K <= N <= 10000, where N = quality.length = wage.length\n2. 1 <= quality[i] <= 10000\n3. 1 <= wage[i] <= 10000\n4. Answers within 10^-5 of the correct answer will be considered correct.\n\n**Algorithm:**\n\n``` swift\nclass Solution {\n    func mincostToHireWorkers(_ quality: [Int], _ wage: [Int], _ K: Int) -> Double {\n        func insert<T: Comparable>(_ new: (T, Int), _ arr: inout [(T, Int)]) {\n            var l = 0, r = arr.count-1\n            while l <= r {\n                let mid = (l+r) >> 1\n                if (mid == 0 && new.0 <= arr[mid].0) ||\n                    (mid > 0 && new.0 <= arr[mid].0 && new.0 > arr[mid-1].0) {\n                    arr.insert(new, at: mid)\n                    return\n                } else if new.0 > arr[mid].0 {\n                    l = mid + 1\n                } else {\n                    r = mid - 1\n                }\n            }\n            arr.insert(new, at: arr.count)\n        }\n        var arr = [(Double, Int)]()\n        for i in quality.indices {\n            insert((Double(wage[i]) / Double(quality[i]), i), &arr)\n        }\n        var res = pow(10.0, 10.0)\n        var qualities = [(Int, Int)]()\n        var sump = 0\n        for i in 0..<arr.count {\n            let temp = quality[arr[i].1]\n            insert((temp, arr[i].1), &qualities)\n            sump += temp\n            if qualities.count > K {\n                sump -= qualities.popLast()!.0\n            }\n            if qualities.count == K {\n                let ratio = arr[i].0\n                res = min(res, Double(sump) * ratio)\n            }\n        }\n        return res\n    }\n}\n```\n\nFrom leetCode [857. Minimum Cost to Hire K Workers](https://leetcode.com/problems/minimum-cost-to-hire-k-workers/)","source":"_posts/2019/leetcode-kth-problems-1216.md","raw":"---\ntitle: \"Kth Smallest/Largest Element in ...\"\ncatalog: true\ntoc_nav_num: true\ndate: 2019-12-16 17:30:51\nsubtitle: \"Leet Code\"\nheader-img: \"/img/article_header/article_header.png\"\nbusuanzi: true\ntags:\n- iOS - Swift\n\n---\n\n# Introduction\n\nHere is the summary about the kth problems in LeetCode.\n\n# Kth Largest Element in an Array\n\nFind the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.\n\n**Example 1:**\n\n```\nInput: [3,2,1,5,6,4] and k = 2\nOutput: 5\n```\n\n**Example 2:**\n\n```\nInput: [3,2,3,1,2,4,5,5,6] and k = 4\nOutput: 4\n```\n\n**Algorithm**\n\n``` swift\nclass Solution {\n    func findKthLargest(_ nums: [Int], _ k: Int) -> Int {\n        func quickSort(_ nums: inout [Int], _ l: Int, _ r: Int) -> Int {\n            var l = l, r = r\n            let key = nums[l]\n            while l < r {\n                while l < r, key >= nums[r] {\n                    r -= 1\n                }\n                nums[l] = nums[r]\n                while l < r, key <= nums[l] {\n                    l += 1\n                }\n                nums[r] = nums[l]\n            }\n            nums[l] = key\n            return l\n        }\n        var l = 0, r = nums.count-1, nums = nums\n        while l < r {\n            let index = quickSort(&nums, l, r)\n            switch index {\n            case k - 1:\n                return nums[index]\n            case 0..<k-1:\n                l = index + 1\n                break\n            default:\n                r = index - 1\n                break\n            }\n        }\n        return nums[k-1]\n    }\n}\n```\n\nFrom leetCode [215. Kth Largest Element in an Array](https://leetcode.com/problems/kth-largest-element-in-an-array/)\n\n# Kth Smallest Element in a BST\n\nGiven a binary search tree, write a function kthSmallest to find the kth smallest element in it.\n\n**Note:**\n\nYou may assume k is always valid, 1 ≤ k ≤ BST's total elements.\n\n**Example 1:**\n\n```\nInput: root = [3,1,4,null,2], k = 1\n   3\n  / \\\n 1   4\n  \\\n   2\nOutput: 1\n```\n\n**Exapmle 2:**\n\n```\nInput: root = [5,3,6,2,4,null,null,1], k = 3\n       5\n      / \\\n     3   6\n    / \\\n   2   4\n  /\n 1\nOutput: 3\n```\n\n**Algorithm:**\n\n``` swift\npublic class TreeNode {\n    public var val: Int\n    public var left: TreeNode?\n    public var right: TreeNode?\n    public init(_ val: Int) {\n        self.val = val\n        self.left = nil\n        self.right = nil\n    }\n}\nclass Solution {\n    func kthSmallest(_ root: TreeNode?, _ k: Int) -> Int {\n        var stack = [TreeNode]()\n        var cur = root\n        var k = k\n        while cur != nil || !stack.isEmpty {\n            if let temp = cur {\n                stack.append(temp)\n                cur = temp.left\n            } else {\n                let last = stack.removeLast()\n                k -= 1\n                if k == 0 {\n                    return last.val\n                }\n                cur = last.right\n            }\n        }\n        return 0\n    }\n}\n```\n\nFrom leetCode [230. Kth Smallest Element in a BST](https://leetcode.com/problems/kth-smallest-element-in-a-bst/)\n\n# Find K Pairs with Smallest Sums\n\nYou are given two integer arrays nums1 and nums2 sorted in ascending order and an integer k.\n\nDefine a pair (u,v) which consists of one element from the first array and one element from the second array.\n\nFind the k pairs (u1,v1),(u2,v2) ...(uk,vk) with the smallest sums.\n\n**Example 1:**\n\n```\nInput: nums1 = [1,7,11], nums2 = [2,4,6], k = 3\nOutput: [[1,2],[1,4],[1,6]] \nExplanation: The first 3 pairs are returned from the sequence: \n             [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]\n```\n\n**Example 2:**\n\n```\nInput: nums1 = [1,1,2], nums2 = [1,2,3], k = 2\nOutput: [1,1],[1,1]\nExplanation: The first 2 pairs are returned from the sequence: \n             [1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]\n```\n\n**Example 3:**\n\n```\nInput: nums1 = [1,2], nums2 = [3], k = 3\nOutput: [1,3],[2,3]\nExplanation: All possible pairs are returned from the sequence: [1,3],[2,3]\n```\n\n**Algorithm:**\n\n``` swift\nclass Solution {\n    func kSmallestPairs(_ nums1: [Int], _ nums2: [Int], _ k: Int) -> [[Int]] {\n        guard !nums1.isEmpty, !nums2.isEmpty, k >= 0 else {\n            return []\n        }\n        func insert(_ arr: inout [(Int, Int, Int)], _ new: (Int, Int, Int)) {\n            var s = 0, e = arr.count-1\n            while s <= e {\n                let mid = (s + e) >> 1\n                if (mid == 0 && new.0 <= arr[mid].0) ||\n                    (mid > 0 && new.0 >= arr[mid-1].0 && new.0 <= arr[mid].0) {\n                    arr.insert(new, at: mid)\n                    return\n                } else if new.0 > arr[mid].0 {\n                    s = mid + 1\n                } else {\n                    e = mid - 1\n                }\n            }\n            arr.insert(new, at: arr.count)\n        }\n        var arr = [(Int, Int, Int)]()\n        for i in nums1.indices {\n            arr.append((nums1[i]+nums2[0], i, 0))\n        }\n        var res = [[Int]]()\n        while !arr.isEmpty, res.count < k {\n            let (_, i, j) = arr.removeFirst()\n            res.append([nums1[i], nums2[j]])\n            if j < nums2.count-1 {\n                insert(&arr, (nums1[i]+nums2[j+1], i, j+1))\n            }\n        }\n        return res\n    }\n}\n```\n\n**Comment:**\n\nHere is a simple example demonstrate how this algorithm works:\n\n![example](/img/article/20191216/1.png)\n\nFrom leetCode [373. Find K Pairs with Smallest Sums](https://leetcode.com/problems/find-k-pairs-with-smallest-sums/)\n\n# Kth Smallest Element in a Sorted Matrix\n\nGiven a n x n matrix where each of the rows and columns are sorted in ascending order, find the kth smallest element in the matrix.\n\nNote that it is the kth smallest element in the sorted order, not the kth distinct element.\n\n**Example:**\n\n```\nmatrix = [\n   [ 1,  5,  9],\n   [10, 11, 13],\n   [12, 13, 15]\n],\nk = 8,\n\nreturn 13.\n```\n\n**Algorithm:**\n\n``` swift\nclass Solution {\n    func kthSmallest(_ matrix: [[Int]], _ k: Int) -> Int {\n        guard !matrix.isEmpty, !matrix.first!.isEmpty, k > 0 else {\n            return 0\n        }\n        func insert(_ arr: inout [(Int, Int, Int)], _ new: (Int, Int, Int)) {\n            var s = 0, e = arr.count-1\n            while s <= e {\n                let mid = (s + e) >> 1\n                if (mid == 0 && new.0 <= arr[mid].0) ||\n                    (mid > 0 && new.0 > arr[mid-1].0 && new.0 <= arr[mid].0) {\n                    arr.insert(new, at: mid)\n                    return\n                } else if new.0 > arr[mid].0 {\n                    s = mid + 1\n                } else {\n                    e = mid - 1\n                }\n            }\n            arr.insert(new, at: arr.count)\n        }\n        var arr = [(Int, Int, Int)]()\n        for i in matrix.indices {\n            arr.append((matrix[i][0], i, 0))\n        }\n        var k = k, i = 0, j = 0\n        while !arr.isEmpty, k > 0 {\n            (_, i, j) = arr.removeFirst()\n            if j < matrix.first!.count-1 {\n                insert(&arr, (matrix[i][j+1], i, j+1))\n            }\n            k -= 1\n        }\n        return matrix[i][j]\n    }\n}\n```\n\n``` swift\nclass Solution {\n    func kthSmallest(_ matrix: [[Int]], _ k: Int) -> Int {\n        guard !matrix.isEmpty else {\n            return 0\n        }\n        let n = matrix.count-1\n        var lo = matrix[0][0], hi = matrix[n][n]\n        while lo < hi {\n            let mid = (lo + hi) >> 1\n            var count = 0, j = n\n            for i in 0...n {\n                while j >= 0, matrix[i][j] > mid {\n                    j -= 1\n                }\n                count += j + 1\n            }\n            if count < k {\n                lo = mid + 1\n            } else {\n                hi = mid\n            }\n        }\n        return lo\n    }\n}\n```\n\nFrom leetCode [378. Kth Smallest Element in a Sorted Matrix](https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/)\n\n# Kth Smallest Number in Multiplication Table\n\nNearly every one have used the Multiplication Table. But could you find out the k-th smallest number quickly from the multiplication table?\n\nGiven the height m and the length n of a m * n Multiplication Table, and a positive integer k, you need to return the k-th smallest number in this table.\n\n**Example 1:**\n\n```\nInput: m = 3, n = 3, k = 5\nOutput: \nExplanation: \nThe Multiplication Table:\n1\t2\t3\n2\t4\t6\n3\t6\t9\n\nThe 5-th smallest number is 3 (1, 2, 2, 3, 3).\n```\n\n**Example 2:**\n\n```\nInput: m = 2, n = 3, k = 6\nOutput: \nExplanation: \nThe Multiplication Table:\n1\t2\t3\n2\t4\t6\n\nThe 6-th smallest number is 6 (1, 2, 2, 3, 4, 6).\n```\n\n**Note:**\n\n1. The m and n will be in the range [1, 30000].\n2. The k will be in the range [1, m * n]\n\n**Algorithm:**\n\n``` swift\nclass Solution {\n    func findKthNumber(_ m: Int, _ n: Int, _ k: Int) -> Int {\n        guard m > 0, n > 0, k > 0 else {\n            return 0\n        }\n        var lo = 1, hi = m * n\n        while lo < hi {\n            let mid = (lo + hi) >> 1\n            var count = 0, nN = n\n            for i in 1...m {\n                while nN > 0, i * nN > mid {\n                    nN -= 1\n                }\n                count += nN\n            }\n            if count < k {\n                lo = mid + 1\n            } else {\n                hi = mid\n            }\n        }\n        return lo\n    }\n}\n```\n\nFrom leetCode [668. Kth Smallest Number in Multiplication Table](https://leetcode.com/problems/kth-smallest-number-in-multiplication-table/)\n\n# Find K-th Smallest Pair Distance\n\nGiven an integer array, return the k-th smallest distance among all the pairs. The distance of a pair (A, B) is defined as the absolute difference between A and B.\n\n**Example 1:**\n\n```\nInput:\nnums = [1,3,1]\nk = 1\nOutput: 0 \nExplanation:\nHere are all the pairs:\n(1,3) -> 2\n(1,1) -> 0\n(3,1) -> 2\nThen the 1st smallest distance pair is (1,1), and its distance is 0.\n```\n\n**Note:**\n\n1. 2 <= len(nums) <= 10000.\n2. 0 <= nums[i] < 1000000.\n3. 1 <= k <= len(nums) * (len(nums) - 1) / 2.\n\n**Algorithm:**\n\n``` swift\nclass Solution {\n    func smallestDistancePair(_ nums: [Int], _ k: Int) -> Int {\n        guard nums.count > 1 else {\n            return 0\n        }\n        let sortedNums = nums.sorted()\n        var lo = 0, hi = sortedNums.last! - sortedNums.first!\n        while lo < hi {\n            let mid = (lo + hi) >> 1\n            var count = 0, i = 0\n            for j in 0..<sortedNums.count {\n                while i < sortedNums.count, sortedNums[j] - sortedNums[i] > mid {\n                    i += 1\n                }\n                count += j-i\n            }\n            if count < k {\n                lo = mid + 1\n            } else {\n                hi = mid\n            }\n        }\n        return lo\n    }\n}\n```\n\nFrom leetCode [719. Find K-th Smallest Pair Distance](https://leetcode.com/problems/find-k-th-smallest-pair-distance/)\n\n# K-th Smallest Prime Fraction\n\nA sorted list A contains 1, plus some number of primes.  Then, for every p < q in the list, we consider the fraction p/q.\n\nWhat is the K-th smallest fraction considered?  Return your answer as an array of ints, where answer[0] = p and answer[1] = q.\n\n**Example:**\n\n```\nInput: A = [1, 2, 3, 5], K = 3\nOutput: [2, 5]\nExplanation:\nThe fractions to be considered in sorted order are:\n1/5, 1/3, 2/5, 1/2, 3/5, 2/3.\nThe third fraction is 2/5.\n\nInput: A = [1, 7], K = 1\nOutput: [1, 7]\n```\n\n**Note:**\n\n- A will have length between 2 and 2000.\n- Each A[i] will be between 1 and 30000.\n- K will be between 1 and A.length * (A.length - 1) / 2.\n\n**Algorithm:**\n\n``` swift\nclass Solution {\n    func kthSmallestPrimeFraction(_ A: [Int], _ K: Int) -> [Int] {\n        let n = A.count\n        guard n > 1, K > 0 else {\n            return []\n        }\n        var lo = 0.0, hi = 1.0\n        while lo < hi {\n            let mid = (lo + hi) / 2\n            var j = 1, count = 0, maxVal = 0.0, res = (0, 0)\n            for i in 0..<n-1 {\n                while j < n, Double(A[i]) > mid * Double(A[j]) {\n                    j += 1\n                }\n                if n == j {\n                    break\n                }\n                count += n-j\n                let val = Double(A[i]) / Double(A[j])\n                if val > maxVal {\n                    res = (i, j)\n                    maxVal = val\n                }\n            }\n            if count < K {\n                lo = mid\n            } else if count == K {\n                return [A[res.0], A[res.1]]\n            } else {\n                hi = mid\n            }\n        }\n        return []\n    }\n}\n```\n\nFrom leetCode [786. K-th Smallest Prime Fraction](https://leetcode.com/problems/k-th-smallest-prime-fraction/)\n\n# Minimum Cost to Hire K Workers\n\nThere are N workers.  The i-th worker has a quality[i] and a minimum wage expectation wage[i].\n\nNow we want to hire exactly K workers to form a paid group.  When hiring a group of K workers, we must pay them according to the following rules:\n1. Every worker in the paid group should be paid in the ratio of their quality compared to other workers in the paid group.\n2. Every worker in the paid group must be paid at least their minimum wage expectation.\n\nReturn the least amount of money needed to form a paid group satisfying the above conditions.\n\n**Example 1:**\n\n```\nInput: quality = [10,20,5], wage = [70,50,30], K = 2\nOutput: 105.00000\nExplanation: We pay 70 to 0-th worker and 35 to 2-th worker.\n```\n\n**Example 2:**\n\n```\nInput: quality = [3,1,10,10,1], wage = [4,8,2,2,7], K = 3\nOutput: 30.66667\nExplanation: We pay 4 to 0-th worker, 13.33333 to 2-th and 3-th workers seperately. \n```\n\n**Note:**\n\n1. 1 <= K <= N <= 10000, where N = quality.length = wage.length\n2. 1 <= quality[i] <= 10000\n3. 1 <= wage[i] <= 10000\n4. Answers within 10^-5 of the correct answer will be considered correct.\n\n**Algorithm:**\n\n``` swift\nclass Solution {\n    func mincostToHireWorkers(_ quality: [Int], _ wage: [Int], _ K: Int) -> Double {\n        func insert<T: Comparable>(_ new: (T, Int), _ arr: inout [(T, Int)]) {\n            var l = 0, r = arr.count-1\n            while l <= r {\n                let mid = (l+r) >> 1\n                if (mid == 0 && new.0 <= arr[mid].0) ||\n                    (mid > 0 && new.0 <= arr[mid].0 && new.0 > arr[mid-1].0) {\n                    arr.insert(new, at: mid)\n                    return\n                } else if new.0 > arr[mid].0 {\n                    l = mid + 1\n                } else {\n                    r = mid - 1\n                }\n            }\n            arr.insert(new, at: arr.count)\n        }\n        var arr = [(Double, Int)]()\n        for i in quality.indices {\n            insert((Double(wage[i]) / Double(quality[i]), i), &arr)\n        }\n        var res = pow(10.0, 10.0)\n        var qualities = [(Int, Int)]()\n        var sump = 0\n        for i in 0..<arr.count {\n            let temp = quality[arr[i].1]\n            insert((temp, arr[i].1), &qualities)\n            sump += temp\n            if qualities.count > K {\n                sump -= qualities.popLast()!.0\n            }\n            if qualities.count == K {\n                let ratio = arr[i].0\n                res = min(res, Double(sump) * ratio)\n            }\n        }\n        return res\n    }\n}\n```\n\nFrom leetCode [857. Minimum Cost to Hire K Workers](https://leetcode.com/problems/minimum-cost-to-hire-k-workers/)","slug":"2019/leetcode-kth-problems-1216","published":1,"updated":"2022-01-10T09:04:52.804Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cky8gmc45000hd1qherblnfh9","content":"<h1 id=\"introduction\">Introduction</h1>\n<p>Here is the summary about the kth problems in LeetCode.</p>\n<h1 id=\"kth-largest-element-in-an-array\">Kth Largest Element in an Array</h1>\n<p>Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: [3,2,1,5,6,4] and k = 2</span><br><span class=\"line\">Output: 5</span><br></pre></td></tr></table></figure>\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: [3,2,3,1,2,4,5,5,6] and k = 4</span><br><span class=\"line\">Output: 4</span><br></pre></td></tr></table></figure>\n<p><strong>Algorithm</strong></p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">findKthLargest</span><span class=\"params\">(<span class=\"number\">_</span> nums: [Int], <span class=\"number\">_</span> k: Int)</span></span> -&gt; <span class=\"type\">Int</span> &#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">quickSort</span><span class=\"params\">(<span class=\"number\">_</span> nums: <span class=\"keyword\">inout</span> [Int], <span class=\"number\">_</span> l: Int, <span class=\"number\">_</span> r: Int)</span></span> -&gt; <span class=\"type\">Int</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> l = l, r = r</span><br><span class=\"line\">            <span class=\"keyword\">let</span> key = nums[l]</span><br><span class=\"line\">            <span class=\"keyword\">while</span> l &lt; r &#123;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> l &lt; r, key &gt;= nums[r] &#123;</span><br><span class=\"line\">                    r -= <span class=\"number\">1</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                nums[l] = nums[r]</span><br><span class=\"line\">                <span class=\"keyword\">while</span> l &lt; r, key &lt;= nums[l] &#123;</span><br><span class=\"line\">                    l += <span class=\"number\">1</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                nums[r] = nums[l]</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            nums[l] = key</span><br><span class=\"line\">            <span class=\"keyword\">return</span> l</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> l = <span class=\"number\">0</span>, r = nums.<span class=\"built_in\">count</span>-<span class=\"number\">1</span>, nums = nums</span><br><span class=\"line\">        <span class=\"keyword\">while</span> l &lt; r &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> index = <span class=\"built_in\">quickSort</span>(&amp;nums, l, r)</span><br><span class=\"line\">            <span class=\"keyword\">switch</span> index &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> k - <span class=\"number\">1</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> nums[index]</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">0</span>..&lt;k-<span class=\"number\">1</span>:</span><br><span class=\"line\">                l = index + <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">            <span class=\"keyword\">default</span>:</span><br><span class=\"line\">                r = index - <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nums[k-<span class=\"number\">1</span>]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>From leetCode <a href=\"https://leetcode.com/problems/kth-largest-element-in-an-array/\" target=\"_blank\" rel=\"noopener\">215. Kth Largest Element in an Array</a></p>\n<h1 id=\"kth-smallest-element-in-a-bst\">Kth Smallest Element in a BST</h1>\n<p>Given a binary search tree, write a function kthSmallest to find the kth smallest element in it.</p>\n<p><strong>Note:</strong></p>\n<p>You may assume k is always valid, 1 ≤ k ≤ BST’s total elements.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: root = [3,1,4,null,2], k = 1</span><br><span class=\"line\">   3</span><br><span class=\"line\">  / \\</span><br><span class=\"line\"> 1   4</span><br><span class=\"line\">  \\</span><br><span class=\"line\">   2</span><br><span class=\"line\">Output: 1</span><br></pre></td></tr></table></figure>\n<p><strong>Exapmle 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: root = [5,3,6,2,4,null,null,1], k = 3</span><br><span class=\"line\">       5</span><br><span class=\"line\">      / \\</span><br><span class=\"line\">     3   6</span><br><span class=\"line\">    / \\</span><br><span class=\"line\">   2   4</span><br><span class=\"line\">  /</span><br><span class=\"line\"> 1</span><br><span class=\"line\">Output: 3</span><br></pre></td></tr></table></figure>\n<p><strong>Algorithm:</strong></p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TreeNode</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">var</span> val: <span class=\"type\">Int</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">var</span> <span class=\"keyword\">left</span>: <span class=\"type\">TreeNode</span>?</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">var</span> <span class=\"keyword\">right</span>: <span class=\"type\">TreeNode</span>?</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">init</span>(<span class=\"number\">_</span> val: <span class=\"type\">Int</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.val = val</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.<span class=\"keyword\">left</span> = <span class=\"literal\">nil</span></span><br><span class=\"line\">        <span class=\"keyword\">self</span>.<span class=\"keyword\">right</span> = <span class=\"literal\">nil</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">kthSmallest</span><span class=\"params\">(<span class=\"number\">_</span> root: TreeNode?, <span class=\"number\">_</span> k: Int)</span></span> -&gt; <span class=\"type\">Int</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> stack = [<span class=\"type\">TreeNode</span>]()</span><br><span class=\"line\">        <span class=\"keyword\">var</span> cur = root</span><br><span class=\"line\">        <span class=\"keyword\">var</span> k = k</span><br><span class=\"line\">        <span class=\"keyword\">while</span> cur != <span class=\"literal\">nil</span> || !stack.isEmpty &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> temp = cur &#123;</span><br><span class=\"line\">                stack.append(temp)</span><br><span class=\"line\">                cur = temp.<span class=\"keyword\">left</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">let</span> last = stack.removeLast()</span><br><span class=\"line\">                k -= <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> k == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> last.val</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                cur = last.<span class=\"keyword\">right</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>From leetCode <a href=\"https://leetcode.com/problems/kth-smallest-element-in-a-bst/\" target=\"_blank\" rel=\"noopener\">230. Kth Smallest Element in a BST</a></p>\n<h1 id=\"find-k-pairs-with-smallest-sums\">Find K Pairs with Smallest Sums</h1>\n<p>You are given two integer arrays nums1 and nums2 sorted in ascending order and an integer k.</p>\n<p>Define a pair (u,v) which consists of one element from the first array and one element from the second array.</p>\n<p>Find the k pairs (u1,v1),(u2,v2) …(uk,vk) with the smallest sums.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: nums1 = [1,7,11], nums2 = [2,4,6], k = 3</span><br><span class=\"line\">Output: [[1,2],[1,4],[1,6]] </span><br><span class=\"line\">Explanation: The first 3 pairs are returned from the sequence: </span><br><span class=\"line\">             [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]</span><br></pre></td></tr></table></figure>\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: nums1 = [1,1,2], nums2 = [1,2,3], k = 2</span><br><span class=\"line\">Output: [1,1],[1,1]</span><br><span class=\"line\">Explanation: The first 2 pairs are returned from the sequence: </span><br><span class=\"line\">             [1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]</span><br></pre></td></tr></table></figure>\n<p><strong>Example 3:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: nums1 = [1,2], nums2 = [3], k = 3</span><br><span class=\"line\">Output: [1,3],[2,3]</span><br><span class=\"line\">Explanation: All possible pairs are returned from the sequence: [1,3],[2,3]</span><br></pre></td></tr></table></figure>\n<p><strong>Algorithm:</strong></p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">kSmallestPairs</span><span class=\"params\">(<span class=\"number\">_</span> nums1: [Int], <span class=\"number\">_</span> nums2: [Int], <span class=\"number\">_</span> k: Int)</span></span> -&gt; [[<span class=\"type\">Int</span>]] &#123;</span><br><span class=\"line\">        <span class=\"keyword\">guard</span> !nums1.isEmpty, !nums2.isEmpty, k &gt;= <span class=\"number\">0</span> <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> []</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">insert</span><span class=\"params\">(<span class=\"number\">_</span> arr: <span class=\"keyword\">inout</span> [<span class=\"params\">(Int, Int, Int)</span></span></span>], <span class=\"number\">_</span> new: (<span class=\"type\">Int</span>, <span class=\"type\">Int</span>, <span class=\"type\">Int</span>)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> s = <span class=\"number\">0</span>, e = arr.<span class=\"built_in\">count</span>-<span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> s &lt;= e &#123;</span><br><span class=\"line\">                <span class=\"keyword\">let</span> mid = (s + e) &gt;&gt; <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (mid == <span class=\"number\">0</span> &amp;&amp; new.<span class=\"number\">0</span> &lt;= arr[mid].<span class=\"number\">0</span>) ||</span><br><span class=\"line\">                    (mid &gt; <span class=\"number\">0</span> &amp;&amp; new.<span class=\"number\">0</span> &gt;= arr[mid-<span class=\"number\">1</span>].<span class=\"number\">0</span> &amp;&amp; new.<span class=\"number\">0</span> &lt;= arr[mid].<span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    arr.insert(new, at: mid)</span><br><span class=\"line\">                    <span class=\"keyword\">return</span></span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> new.<span class=\"number\">0</span> &gt; arr[mid].<span class=\"number\">0</span> &#123;</span><br><span class=\"line\">                    s = mid + <span class=\"number\">1</span></span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    e = mid - <span class=\"number\">1</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            arr.insert(new, at: arr.<span class=\"built_in\">count</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> arr = [(<span class=\"type\">Int</span>, <span class=\"type\">Int</span>, <span class=\"type\">Int</span>)]()</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> nums1.<span class=\"built_in\">indices</span> &#123;</span><br><span class=\"line\">            arr.append((nums1[i]+nums2[<span class=\"number\">0</span>], i, <span class=\"number\">0</span>))</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> res = [[<span class=\"type\">Int</span>]]()</span><br><span class=\"line\">        <span class=\"keyword\">while</span> !arr.isEmpty, res.<span class=\"built_in\">count</span> &lt; k &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> (<span class=\"number\">_</span>, i, j) = arr.removeFirst()</span><br><span class=\"line\">            res.append([nums1[i], nums2[j]])</span><br><span class=\"line\">            <span class=\"keyword\">if</span> j &lt; nums2.<span class=\"built_in\">count</span>-<span class=\"number\">1</span> &#123;</span><br><span class=\"line\">                insert(&amp;arr, (nums1[i]+nums2[j+<span class=\"number\">1</span>], i, j+<span class=\"number\">1</span>))</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>Comment:</strong></p>\n<p>Here is a simple example demonstrate how this algorithm works:</p>\n<p><img src=\"/img/article/20191216/1.png\" alt=\"example\"></p>\n<p>From leetCode <a href=\"https://leetcode.com/problems/find-k-pairs-with-smallest-sums/\" target=\"_blank\" rel=\"noopener\">373. Find K Pairs with Smallest Sums</a></p>\n<h1 id=\"kth-smallest-element-in-a-sorted-matrix\">Kth Smallest Element in a Sorted Matrix</h1>\n<p>Given a n x n matrix where each of the rows and columns are sorted in ascending order, find the kth smallest element in the matrix.</p>\n<p>Note that it is the kth smallest element in the sorted order, not the kth distinct element.</p>\n<p><strong>Example:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">matrix = [</span><br><span class=\"line\">   [ 1,  5,  9],</span><br><span class=\"line\">   [10, 11, 13],</span><br><span class=\"line\">   [12, 13, 15]</span><br><span class=\"line\">],</span><br><span class=\"line\">k = 8,</span><br><span class=\"line\"></span><br><span class=\"line\">return 13.</span><br></pre></td></tr></table></figure>\n<p><strong>Algorithm:</strong></p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">kthSmallest</span><span class=\"params\">(<span class=\"number\">_</span> matrix: [[Int]], <span class=\"number\">_</span> k: Int)</span></span> -&gt; <span class=\"type\">Int</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">guard</span> !matrix.isEmpty, !matrix.first!.isEmpty, k &gt; <span class=\"number\">0</span> <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">insert</span><span class=\"params\">(<span class=\"number\">_</span> arr: <span class=\"keyword\">inout</span> [<span class=\"params\">(Int, Int, Int)</span></span></span>], <span class=\"number\">_</span> new: (<span class=\"type\">Int</span>, <span class=\"type\">Int</span>, <span class=\"type\">Int</span>)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> s = <span class=\"number\">0</span>, e = arr.<span class=\"built_in\">count</span>-<span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> s &lt;= e &#123;</span><br><span class=\"line\">                <span class=\"keyword\">let</span> mid = (s + e) &gt;&gt; <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (mid == <span class=\"number\">0</span> &amp;&amp; new.<span class=\"number\">0</span> &lt;= arr[mid].<span class=\"number\">0</span>) ||</span><br><span class=\"line\">                    (mid &gt; <span class=\"number\">0</span> &amp;&amp; new.<span class=\"number\">0</span> &gt; arr[mid-<span class=\"number\">1</span>].<span class=\"number\">0</span> &amp;&amp; new.<span class=\"number\">0</span> &lt;= arr[mid].<span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    arr.insert(new, at: mid)</span><br><span class=\"line\">                    <span class=\"keyword\">return</span></span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> new.<span class=\"number\">0</span> &gt; arr[mid].<span class=\"number\">0</span> &#123;</span><br><span class=\"line\">                    s = mid + <span class=\"number\">1</span></span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    e = mid - <span class=\"number\">1</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            arr.insert(new, at: arr.<span class=\"built_in\">count</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> arr = [(<span class=\"type\">Int</span>, <span class=\"type\">Int</span>, <span class=\"type\">Int</span>)]()</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> matrix.<span class=\"built_in\">indices</span> &#123;</span><br><span class=\"line\">            arr.append((matrix[i][<span class=\"number\">0</span>], i, <span class=\"number\">0</span>))</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> k = k, i = <span class=\"number\">0</span>, j = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> !arr.isEmpty, k &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">            (<span class=\"number\">_</span>, i, j) = arr.removeFirst()</span><br><span class=\"line\">            <span class=\"keyword\">if</span> j &lt; matrix.first!.<span class=\"built_in\">count</span>-<span class=\"number\">1</span> &#123;</span><br><span class=\"line\">                insert(&amp;arr, (matrix[i][j+<span class=\"number\">1</span>], i, j+<span class=\"number\">1</span>))</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            k -= <span class=\"number\">1</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> matrix[i][j]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">kthSmallest</span><span class=\"params\">(<span class=\"number\">_</span> matrix: [[Int]], <span class=\"number\">_</span> k: Int)</span></span> -&gt; <span class=\"type\">Int</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">guard</span> !matrix.isEmpty <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> n = matrix.<span class=\"built_in\">count</span>-<span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> lo = matrix[<span class=\"number\">0</span>][<span class=\"number\">0</span>], hi = matrix[n][n]</span><br><span class=\"line\">        <span class=\"keyword\">while</span> lo &lt; hi &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> mid = (lo + hi) &gt;&gt; <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">var</span> <span class=\"built_in\">count</span> = <span class=\"number\">0</span>, j = n</span><br><span class=\"line\">            <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"number\">0</span>...n &#123;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> j &gt;= <span class=\"number\">0</span>, matrix[i][j] &gt; mid &#123;</span><br><span class=\"line\">                    j -= <span class=\"number\">1</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"built_in\">count</span> += j + <span class=\"number\">1</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"built_in\">count</span> &lt; k &#123;</span><br><span class=\"line\">                lo = mid + <span class=\"number\">1</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                hi = mid</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> lo</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>From leetCode <a href=\"https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/\" target=\"_blank\" rel=\"noopener\">378. Kth Smallest Element in a Sorted Matrix</a></p>\n<h1 id=\"kth-smallest-number-in-multiplication-table\">Kth Smallest Number in Multiplication Table</h1>\n<p>Nearly every one have used the Multiplication Table. But could you find out the k-th smallest number quickly from the multiplication table?</p>\n<p>Given the height m and the length n of a m * n Multiplication Table, and a positive integer k, you need to return the k-th smallest number in this table.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: m = 3, n = 3, k = 5</span><br><span class=\"line\">Output: </span><br><span class=\"line\">Explanation: </span><br><span class=\"line\">The Multiplication Table:</span><br><span class=\"line\">1\t2\t3</span><br><span class=\"line\">2\t4\t6</span><br><span class=\"line\">3\t6\t9</span><br><span class=\"line\"></span><br><span class=\"line\">The 5-th smallest number is 3 (1, 2, 2, 3, 3).</span><br></pre></td></tr></table></figure>\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: m = 2, n = 3, k = 6</span><br><span class=\"line\">Output: </span><br><span class=\"line\">Explanation: </span><br><span class=\"line\">The Multiplication Table:</span><br><span class=\"line\">1\t2\t3</span><br><span class=\"line\">2\t4\t6</span><br><span class=\"line\"></span><br><span class=\"line\">The 6-th smallest number is 6 (1, 2, 2, 3, 4, 6).</span><br></pre></td></tr></table></figure>\n<p><strong>Note:</strong></p>\n<ol>\n<li>The m and n will be in the range [1, 30000].</li>\n<li>The k will be in the range [1, m * n]</li>\n</ol>\n<p><strong>Algorithm:</strong></p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">findKthNumber</span><span class=\"params\">(<span class=\"number\">_</span> m: Int, <span class=\"number\">_</span> n: Int, <span class=\"number\">_</span> k: Int)</span></span> -&gt; <span class=\"type\">Int</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">guard</span> m &gt; <span class=\"number\">0</span>, n &gt; <span class=\"number\">0</span>, k &gt; <span class=\"number\">0</span> <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> lo = <span class=\"number\">1</span>, hi = m * n</span><br><span class=\"line\">        <span class=\"keyword\">while</span> lo &lt; hi &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> mid = (lo + hi) &gt;&gt; <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">var</span> <span class=\"built_in\">count</span> = <span class=\"number\">0</span>, nN = n</span><br><span class=\"line\">            <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"number\">1</span>...m &#123;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> nN &gt; <span class=\"number\">0</span>, i * nN &gt; mid &#123;</span><br><span class=\"line\">                    nN -= <span class=\"number\">1</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"built_in\">count</span> += nN</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"built_in\">count</span> &lt; k &#123;</span><br><span class=\"line\">                lo = mid + <span class=\"number\">1</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                hi = mid</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> lo</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>From leetCode <a href=\"https://leetcode.com/problems/kth-smallest-number-in-multiplication-table/\" target=\"_blank\" rel=\"noopener\">668. Kth Smallest Number in Multiplication Table</a></p>\n<h1 id=\"find-k-th-smallest-pair-distance\">Find K-th Smallest Pair Distance</h1>\n<p>Given an integer array, return the k-th smallest distance among all the pairs. The distance of a pair (A, B) is defined as the absolute difference between A and B.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input:</span><br><span class=\"line\">nums = [1,3,1]</span><br><span class=\"line\">k = 1</span><br><span class=\"line\">Output: 0 </span><br><span class=\"line\">Explanation:</span><br><span class=\"line\">Here are all the pairs:</span><br><span class=\"line\">(1,3) -&gt; 2</span><br><span class=\"line\">(1,1) -&gt; 0</span><br><span class=\"line\">(3,1) -&gt; 2</span><br><span class=\"line\">Then the 1st smallest distance pair is (1,1), and its distance is 0.</span><br></pre></td></tr></table></figure>\n<p><strong>Note:</strong></p>\n<ol>\n<li>2 &lt;= len(nums) &lt;= 10000.</li>\n<li>0 &lt;= nums[i] &lt; 1000000.</li>\n<li>1 &lt;= k &lt;= len(nums) * (len(nums) - 1) / 2.</li>\n</ol>\n<p><strong>Algorithm:</strong></p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">smallestDistancePair</span><span class=\"params\">(<span class=\"number\">_</span> nums: [Int], <span class=\"number\">_</span> k: Int)</span></span> -&gt; <span class=\"type\">Int</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">guard</span> nums.<span class=\"built_in\">count</span> &gt; <span class=\"number\">1</span> <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> sortedNums = nums.sorted()</span><br><span class=\"line\">        <span class=\"keyword\">var</span> lo = <span class=\"number\">0</span>, hi = sortedNums.last! - sortedNums.first!</span><br><span class=\"line\">        <span class=\"keyword\">while</span> lo &lt; hi &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> mid = (lo + hi) &gt;&gt; <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">var</span> <span class=\"built_in\">count</span> = <span class=\"number\">0</span>, i = <span class=\"number\">0</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"number\">0</span>..&lt;sortedNums.<span class=\"built_in\">count</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> i &lt; sortedNums.<span class=\"built_in\">count</span>, sortedNums[j] - sortedNums[i] &gt; mid &#123;</span><br><span class=\"line\">                    i += <span class=\"number\">1</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"built_in\">count</span> += j-i</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"built_in\">count</span> &lt; k &#123;</span><br><span class=\"line\">                lo = mid + <span class=\"number\">1</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                hi = mid</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> lo</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>From leetCode <a href=\"https://leetcode.com/problems/find-k-th-smallest-pair-distance/\" target=\"_blank\" rel=\"noopener\">719. Find K-th Smallest Pair Distance</a></p>\n<h1 id=\"k-th-smallest-prime-fraction\">K-th Smallest Prime Fraction</h1>\n<p>A sorted list A contains 1, plus some number of primes.  Then, for every p &lt; q in the list, we consider the fraction p/q.</p>\n<p>What is the K-th smallest fraction considered?  Return your answer as an array of ints, where answer[0] = p and answer[1] = q.</p>\n<p><strong>Example:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: A = [1, 2, 3, 5], K = 3</span><br><span class=\"line\">Output: [2, 5]</span><br><span class=\"line\">Explanation:</span><br><span class=\"line\">The fractions to be considered in sorted order are:</span><br><span class=\"line\">1/5, 1/3, 2/5, 1/2, 3/5, 2/3.</span><br><span class=\"line\">The third fraction is 2/5.</span><br><span class=\"line\"></span><br><span class=\"line\">Input: A = [1, 7], K = 1</span><br><span class=\"line\">Output: [1, 7]</span><br></pre></td></tr></table></figure>\n<p><strong>Note:</strong></p>\n<ul>\n<li>A will have length between 2 and 2000.</li>\n<li>Each A[i] will be between 1 and 30000.</li>\n<li>K will be between 1 and A.length * (A.length - 1) / 2.</li>\n</ul>\n<p><strong>Algorithm:</strong></p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">kthSmallestPrimeFraction</span><span class=\"params\">(<span class=\"number\">_</span> A: [Int], <span class=\"number\">_</span> K: Int)</span></span> -&gt; [<span class=\"type\">Int</span>] &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> n = <span class=\"type\">A</span>.<span class=\"built_in\">count</span></span><br><span class=\"line\">        <span class=\"keyword\">guard</span> n &gt; <span class=\"number\">1</span>, <span class=\"type\">K</span> &gt; <span class=\"number\">0</span> <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> []</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> lo = <span class=\"number\">0.0</span>, hi = <span class=\"number\">1.0</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> lo &lt; hi &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> mid = (lo + hi) / <span class=\"number\">2</span></span><br><span class=\"line\">            <span class=\"keyword\">var</span> j = <span class=\"number\">1</span>, <span class=\"built_in\">count</span> = <span class=\"number\">0</span>, maxVal = <span class=\"number\">0.0</span>, res = (<span class=\"number\">0</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"number\">0</span>..&lt;n-<span class=\"number\">1</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> j &lt; n, <span class=\"type\">Double</span>(<span class=\"type\">A</span>[i]) &gt; mid * <span class=\"type\">Double</span>(<span class=\"type\">A</span>[j]) &#123;</span><br><span class=\"line\">                    j += <span class=\"number\">1</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> n == j &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"built_in\">count</span> += n-j</span><br><span class=\"line\">                <span class=\"keyword\">let</span> val = <span class=\"type\">Double</span>(<span class=\"type\">A</span>[i]) / <span class=\"type\">Double</span>(<span class=\"type\">A</span>[j])</span><br><span class=\"line\">                <span class=\"keyword\">if</span> val &gt; maxVal &#123;</span><br><span class=\"line\">                    res = (i, j)</span><br><span class=\"line\">                    maxVal = val</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"built_in\">count</span> &lt; <span class=\"type\">K</span> &#123;</span><br><span class=\"line\">                lo = mid</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> <span class=\"built_in\">count</span> == <span class=\"type\">K</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> [<span class=\"type\">A</span>[res.<span class=\"number\">0</span>], <span class=\"type\">A</span>[res.<span class=\"number\">1</span>]]</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                hi = mid</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> []</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>From leetCode <a href=\"https://leetcode.com/problems/k-th-smallest-prime-fraction/\" target=\"_blank\" rel=\"noopener\">786. K-th Smallest Prime Fraction</a></p>\n<h1 id=\"minimum-cost-to-hire-k-workers\">Minimum Cost to Hire K Workers</h1>\n<p>There are N workers.  The i-th worker has a quality[i] and a minimum wage expectation wage[i].</p>\n<p>Now we want to hire exactly K workers to form a paid group.  When hiring a group of K workers, we must pay them according to the following rules:</p>\n<ol>\n<li>Every worker in the paid group should be paid in the ratio of their quality compared to other workers in the paid group.</li>\n<li>Every worker in the paid group must be paid at least their minimum wage expectation.</li>\n</ol>\n<p>Return the least amount of money needed to form a paid group satisfying the above conditions.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: quality = [10,20,5], wage = [70,50,30], K = 2</span><br><span class=\"line\">Output: 105.00000</span><br><span class=\"line\">Explanation: We pay 70 to 0-th worker and 35 to 2-th worker.</span><br></pre></td></tr></table></figure>\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: quality = [3,1,10,10,1], wage = [4,8,2,2,7], K = 3</span><br><span class=\"line\">Output: 30.66667</span><br><span class=\"line\">Explanation: We pay 4 to 0-th worker, 13.33333 to 2-th and 3-th workers seperately.</span><br></pre></td></tr></table></figure>\n<p><strong>Note:</strong></p>\n<ol>\n<li>1 &lt;= K &lt;= N &lt;= 10000, where N = quality.length = wage.length</li>\n<li>1 &lt;= quality[i] &lt;= 10000</li>\n<li>1 &lt;= wage[i] &lt;= 10000</li>\n<li>Answers within 10^-5 of the correct answer will be considered correct.</li>\n</ol>\n<p><strong>Algorithm:</strong></p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">mincostToHireWorkers</span><span class=\"params\">(<span class=\"number\">_</span> quality: [Int], <span class=\"number\">_</span> wage: [Int], <span class=\"number\">_</span> K: Int)</span></span> -&gt; <span class=\"type\">Double</span> &#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">insert</span>&lt;T: Comparable&gt;<span class=\"params\">(<span class=\"number\">_</span> new: <span class=\"params\">(T, Int)</span></span></span>, <span class=\"number\">_</span> arr: <span class=\"keyword\">inout</span> [(<span class=\"type\">T</span>, <span class=\"type\">Int</span>)]) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> l = <span class=\"number\">0</span>, r = arr.<span class=\"built_in\">count</span>-<span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> l &lt;= r &#123;</span><br><span class=\"line\">                <span class=\"keyword\">let</span> mid = (l+r) &gt;&gt; <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (mid == <span class=\"number\">0</span> &amp;&amp; new.<span class=\"number\">0</span> &lt;= arr[mid].<span class=\"number\">0</span>) ||</span><br><span class=\"line\">                    (mid &gt; <span class=\"number\">0</span> &amp;&amp; new.<span class=\"number\">0</span> &lt;= arr[mid].<span class=\"number\">0</span> &amp;&amp; new.<span class=\"number\">0</span> &gt; arr[mid-<span class=\"number\">1</span>].<span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    arr.insert(new, at: mid)</span><br><span class=\"line\">                    <span class=\"keyword\">return</span></span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> new.<span class=\"number\">0</span> &gt; arr[mid].<span class=\"number\">0</span> &#123;</span><br><span class=\"line\">                    l = mid + <span class=\"number\">1</span></span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    r = mid - <span class=\"number\">1</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            arr.insert(new, at: arr.<span class=\"built_in\">count</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> arr = [(<span class=\"type\">Double</span>, <span class=\"type\">Int</span>)]()</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> quality.<span class=\"built_in\">indices</span> &#123;</span><br><span class=\"line\">            insert((<span class=\"type\">Double</span>(wage[i]) / <span class=\"type\">Double</span>(quality[i]), i), &amp;arr)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> res = pow(<span class=\"number\">10.0</span>, <span class=\"number\">10.0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">var</span> qualities = [(<span class=\"type\">Int</span>, <span class=\"type\">Int</span>)]()</span><br><span class=\"line\">        <span class=\"keyword\">var</span> sump = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"number\">0</span>..&lt;arr.<span class=\"built_in\">count</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> temp = quality[arr[i].<span class=\"number\">1</span>]</span><br><span class=\"line\">            insert((temp, arr[i].<span class=\"number\">1</span>), &amp;qualities)</span><br><span class=\"line\">            sump += temp</span><br><span class=\"line\">            <span class=\"keyword\">if</span> qualities.<span class=\"built_in\">count</span> &gt; <span class=\"type\">K</span> &#123;</span><br><span class=\"line\">                sump -= qualities.popLast()!.<span class=\"number\">0</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> qualities.<span class=\"built_in\">count</span> == <span class=\"type\">K</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">let</span> ratio = arr[i].<span class=\"number\">0</span></span><br><span class=\"line\">                res = <span class=\"built_in\">min</span>(res, <span class=\"type\">Double</span>(sump) * ratio)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>From leetCode <a href=\"https://leetcode.com/problems/minimum-cost-to-hire-k-workers/\" target=\"_blank\" rel=\"noopener\">857. Minimum Cost to Hire K Workers</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1>Introduction</h1>\n<p>Here is the summary about the kth problems in LeetCode.</p>\n<h1>Kth Largest Element in an Array</h1>\n<p>Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: [3,2,1,5,6,4] and k = 2</span><br><span class=\"line\">Output: 5</span><br></pre></td></tr></table></figure>\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: [3,2,3,1,2,4,5,5,6] and k = 4</span><br><span class=\"line\">Output: 4</span><br></pre></td></tr></table></figure>\n<p><strong>Algorithm</strong></p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">findKthLargest</span><span class=\"params\">(<span class=\"number\">_</span> nums: [Int], <span class=\"number\">_</span> k: Int)</span></span> -&gt; <span class=\"type\">Int</span> &#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">quickSort</span><span class=\"params\">(<span class=\"number\">_</span> nums: <span class=\"keyword\">inout</span> [Int], <span class=\"number\">_</span> l: Int, <span class=\"number\">_</span> r: Int)</span></span> -&gt; <span class=\"type\">Int</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> l = l, r = r</span><br><span class=\"line\">            <span class=\"keyword\">let</span> key = nums[l]</span><br><span class=\"line\">            <span class=\"keyword\">while</span> l &lt; r &#123;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> l &lt; r, key &gt;= nums[r] &#123;</span><br><span class=\"line\">                    r -= <span class=\"number\">1</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                nums[l] = nums[r]</span><br><span class=\"line\">                <span class=\"keyword\">while</span> l &lt; r, key &lt;= nums[l] &#123;</span><br><span class=\"line\">                    l += <span class=\"number\">1</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                nums[r] = nums[l]</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            nums[l] = key</span><br><span class=\"line\">            <span class=\"keyword\">return</span> l</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> l = <span class=\"number\">0</span>, r = nums.<span class=\"built_in\">count</span>-<span class=\"number\">1</span>, nums = nums</span><br><span class=\"line\">        <span class=\"keyword\">while</span> l &lt; r &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> index = <span class=\"built_in\">quickSort</span>(&amp;nums, l, r)</span><br><span class=\"line\">            <span class=\"keyword\">switch</span> index &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> k - <span class=\"number\">1</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> nums[index]</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">0</span>..&lt;k-<span class=\"number\">1</span>:</span><br><span class=\"line\">                l = index + <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">            <span class=\"keyword\">default</span>:</span><br><span class=\"line\">                r = index - <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nums[k-<span class=\"number\">1</span>]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>From leetCode <a href=\"https://leetcode.com/problems/kth-largest-element-in-an-array/\" target=\"_blank\" rel=\"noopener\">215. Kth Largest Element in an Array</a></p>\n<h1>Kth Smallest Element in a BST</h1>\n<p>Given a binary search tree, write a function kthSmallest to find the kth smallest element in it.</p>\n<p><strong>Note:</strong></p>\n<p>You may assume k is always valid, 1 ≤ k ≤ BST’s total elements.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: root = [3,1,4,null,2], k = 1</span><br><span class=\"line\">   3</span><br><span class=\"line\">  / \\</span><br><span class=\"line\"> 1   4</span><br><span class=\"line\">  \\</span><br><span class=\"line\">   2</span><br><span class=\"line\">Output: 1</span><br></pre></td></tr></table></figure>\n<p><strong>Exapmle 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: root = [5,3,6,2,4,null,null,1], k = 3</span><br><span class=\"line\">       5</span><br><span class=\"line\">      / \\</span><br><span class=\"line\">     3   6</span><br><span class=\"line\">    / \\</span><br><span class=\"line\">   2   4</span><br><span class=\"line\">  /</span><br><span class=\"line\"> 1</span><br><span class=\"line\">Output: 3</span><br></pre></td></tr></table></figure>\n<p><strong>Algorithm:</strong></p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TreeNode</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">var</span> val: <span class=\"type\">Int</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">var</span> <span class=\"keyword\">left</span>: <span class=\"type\">TreeNode</span>?</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">var</span> <span class=\"keyword\">right</span>: <span class=\"type\">TreeNode</span>?</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">init</span>(<span class=\"number\">_</span> val: <span class=\"type\">Int</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.val = val</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.<span class=\"keyword\">left</span> = <span class=\"literal\">nil</span></span><br><span class=\"line\">        <span class=\"keyword\">self</span>.<span class=\"keyword\">right</span> = <span class=\"literal\">nil</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">kthSmallest</span><span class=\"params\">(<span class=\"number\">_</span> root: TreeNode?, <span class=\"number\">_</span> k: Int)</span></span> -&gt; <span class=\"type\">Int</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> stack = [<span class=\"type\">TreeNode</span>]()</span><br><span class=\"line\">        <span class=\"keyword\">var</span> cur = root</span><br><span class=\"line\">        <span class=\"keyword\">var</span> k = k</span><br><span class=\"line\">        <span class=\"keyword\">while</span> cur != <span class=\"literal\">nil</span> || !stack.isEmpty &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> temp = cur &#123;</span><br><span class=\"line\">                stack.append(temp)</span><br><span class=\"line\">                cur = temp.<span class=\"keyword\">left</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">let</span> last = stack.removeLast()</span><br><span class=\"line\">                k -= <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> k == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> last.val</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                cur = last.<span class=\"keyword\">right</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>From leetCode <a href=\"https://leetcode.com/problems/kth-smallest-element-in-a-bst/\" target=\"_blank\" rel=\"noopener\">230. Kth Smallest Element in a BST</a></p>\n<h1>Find K Pairs with Smallest Sums</h1>\n<p>You are given two integer arrays nums1 and nums2 sorted in ascending order and an integer k.</p>\n<p>Define a pair (u,v) which consists of one element from the first array and one element from the second array.</p>\n<p>Find the k pairs (u1,v1),(u2,v2) …(uk,vk) with the smallest sums.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: nums1 = [1,7,11], nums2 = [2,4,6], k = 3</span><br><span class=\"line\">Output: [[1,2],[1,4],[1,6]] </span><br><span class=\"line\">Explanation: The first 3 pairs are returned from the sequence: </span><br><span class=\"line\">             [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]</span><br></pre></td></tr></table></figure>\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: nums1 = [1,1,2], nums2 = [1,2,3], k = 2</span><br><span class=\"line\">Output: [1,1],[1,1]</span><br><span class=\"line\">Explanation: The first 2 pairs are returned from the sequence: </span><br><span class=\"line\">             [1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]</span><br></pre></td></tr></table></figure>\n<p><strong>Example 3:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: nums1 = [1,2], nums2 = [3], k = 3</span><br><span class=\"line\">Output: [1,3],[2,3]</span><br><span class=\"line\">Explanation: All possible pairs are returned from the sequence: [1,3],[2,3]</span><br></pre></td></tr></table></figure>\n<p><strong>Algorithm:</strong></p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">kSmallestPairs</span><span class=\"params\">(<span class=\"number\">_</span> nums1: [Int], <span class=\"number\">_</span> nums2: [Int], <span class=\"number\">_</span> k: Int)</span></span> -&gt; [[<span class=\"type\">Int</span>]] &#123;</span><br><span class=\"line\">        <span class=\"keyword\">guard</span> !nums1.isEmpty, !nums2.isEmpty, k &gt;= <span class=\"number\">0</span> <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> []</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">insert</span><span class=\"params\">(<span class=\"number\">_</span> arr: <span class=\"keyword\">inout</span> [<span class=\"params\">(Int, Int, Int)</span></span></span>], <span class=\"number\">_</span> new: (<span class=\"type\">Int</span>, <span class=\"type\">Int</span>, <span class=\"type\">Int</span>)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> s = <span class=\"number\">0</span>, e = arr.<span class=\"built_in\">count</span>-<span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> s &lt;= e &#123;</span><br><span class=\"line\">                <span class=\"keyword\">let</span> mid = (s + e) &gt;&gt; <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (mid == <span class=\"number\">0</span> &amp;&amp; new.<span class=\"number\">0</span> &lt;= arr[mid].<span class=\"number\">0</span>) ||</span><br><span class=\"line\">                    (mid &gt; <span class=\"number\">0</span> &amp;&amp; new.<span class=\"number\">0</span> &gt;= arr[mid-<span class=\"number\">1</span>].<span class=\"number\">0</span> &amp;&amp; new.<span class=\"number\">0</span> &lt;= arr[mid].<span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    arr.insert(new, at: mid)</span><br><span class=\"line\">                    <span class=\"keyword\">return</span></span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> new.<span class=\"number\">0</span> &gt; arr[mid].<span class=\"number\">0</span> &#123;</span><br><span class=\"line\">                    s = mid + <span class=\"number\">1</span></span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    e = mid - <span class=\"number\">1</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            arr.insert(new, at: arr.<span class=\"built_in\">count</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> arr = [(<span class=\"type\">Int</span>, <span class=\"type\">Int</span>, <span class=\"type\">Int</span>)]()</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> nums1.<span class=\"built_in\">indices</span> &#123;</span><br><span class=\"line\">            arr.append((nums1[i]+nums2[<span class=\"number\">0</span>], i, <span class=\"number\">0</span>))</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> res = [[<span class=\"type\">Int</span>]]()</span><br><span class=\"line\">        <span class=\"keyword\">while</span> !arr.isEmpty, res.<span class=\"built_in\">count</span> &lt; k &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> (<span class=\"number\">_</span>, i, j) = arr.removeFirst()</span><br><span class=\"line\">            res.append([nums1[i], nums2[j]])</span><br><span class=\"line\">            <span class=\"keyword\">if</span> j &lt; nums2.<span class=\"built_in\">count</span>-<span class=\"number\">1</span> &#123;</span><br><span class=\"line\">                insert(&amp;arr, (nums1[i]+nums2[j+<span class=\"number\">1</span>], i, j+<span class=\"number\">1</span>))</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>Comment:</strong></p>\n<p>Here is a simple example demonstrate how this algorithm works:</p>\n<p><img src=\"/img/article/20191216/1.png\" alt=\"example\"></p>\n<p>From leetCode <a href=\"https://leetcode.com/problems/find-k-pairs-with-smallest-sums/\" target=\"_blank\" rel=\"noopener\">373. Find K Pairs with Smallest Sums</a></p>\n<h1>Kth Smallest Element in a Sorted Matrix</h1>\n<p>Given a n x n matrix where each of the rows and columns are sorted in ascending order, find the kth smallest element in the matrix.</p>\n<p>Note that it is the kth smallest element in the sorted order, not the kth distinct element.</p>\n<p><strong>Example:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">matrix = [</span><br><span class=\"line\">   [ 1,  5,  9],</span><br><span class=\"line\">   [10, 11, 13],</span><br><span class=\"line\">   [12, 13, 15]</span><br><span class=\"line\">],</span><br><span class=\"line\">k = 8,</span><br><span class=\"line\"></span><br><span class=\"line\">return 13.</span><br></pre></td></tr></table></figure>\n<p><strong>Algorithm:</strong></p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">kthSmallest</span><span class=\"params\">(<span class=\"number\">_</span> matrix: [[Int]], <span class=\"number\">_</span> k: Int)</span></span> -&gt; <span class=\"type\">Int</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">guard</span> !matrix.isEmpty, !matrix.first!.isEmpty, k &gt; <span class=\"number\">0</span> <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">insert</span><span class=\"params\">(<span class=\"number\">_</span> arr: <span class=\"keyword\">inout</span> [<span class=\"params\">(Int, Int, Int)</span></span></span>], <span class=\"number\">_</span> new: (<span class=\"type\">Int</span>, <span class=\"type\">Int</span>, <span class=\"type\">Int</span>)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> s = <span class=\"number\">0</span>, e = arr.<span class=\"built_in\">count</span>-<span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> s &lt;= e &#123;</span><br><span class=\"line\">                <span class=\"keyword\">let</span> mid = (s + e) &gt;&gt; <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (mid == <span class=\"number\">0</span> &amp;&amp; new.<span class=\"number\">0</span> &lt;= arr[mid].<span class=\"number\">0</span>) ||</span><br><span class=\"line\">                    (mid &gt; <span class=\"number\">0</span> &amp;&amp; new.<span class=\"number\">0</span> &gt; arr[mid-<span class=\"number\">1</span>].<span class=\"number\">0</span> &amp;&amp; new.<span class=\"number\">0</span> &lt;= arr[mid].<span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    arr.insert(new, at: mid)</span><br><span class=\"line\">                    <span class=\"keyword\">return</span></span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> new.<span class=\"number\">0</span> &gt; arr[mid].<span class=\"number\">0</span> &#123;</span><br><span class=\"line\">                    s = mid + <span class=\"number\">1</span></span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    e = mid - <span class=\"number\">1</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            arr.insert(new, at: arr.<span class=\"built_in\">count</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> arr = [(<span class=\"type\">Int</span>, <span class=\"type\">Int</span>, <span class=\"type\">Int</span>)]()</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> matrix.<span class=\"built_in\">indices</span> &#123;</span><br><span class=\"line\">            arr.append((matrix[i][<span class=\"number\">0</span>], i, <span class=\"number\">0</span>))</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> k = k, i = <span class=\"number\">0</span>, j = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> !arr.isEmpty, k &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">            (<span class=\"number\">_</span>, i, j) = arr.removeFirst()</span><br><span class=\"line\">            <span class=\"keyword\">if</span> j &lt; matrix.first!.<span class=\"built_in\">count</span>-<span class=\"number\">1</span> &#123;</span><br><span class=\"line\">                insert(&amp;arr, (matrix[i][j+<span class=\"number\">1</span>], i, j+<span class=\"number\">1</span>))</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            k -= <span class=\"number\">1</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> matrix[i][j]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">kthSmallest</span><span class=\"params\">(<span class=\"number\">_</span> matrix: [[Int]], <span class=\"number\">_</span> k: Int)</span></span> -&gt; <span class=\"type\">Int</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">guard</span> !matrix.isEmpty <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> n = matrix.<span class=\"built_in\">count</span>-<span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> lo = matrix[<span class=\"number\">0</span>][<span class=\"number\">0</span>], hi = matrix[n][n]</span><br><span class=\"line\">        <span class=\"keyword\">while</span> lo &lt; hi &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> mid = (lo + hi) &gt;&gt; <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">var</span> <span class=\"built_in\">count</span> = <span class=\"number\">0</span>, j = n</span><br><span class=\"line\">            <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"number\">0</span>...n &#123;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> j &gt;= <span class=\"number\">0</span>, matrix[i][j] &gt; mid &#123;</span><br><span class=\"line\">                    j -= <span class=\"number\">1</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"built_in\">count</span> += j + <span class=\"number\">1</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"built_in\">count</span> &lt; k &#123;</span><br><span class=\"line\">                lo = mid + <span class=\"number\">1</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                hi = mid</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> lo</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>From leetCode <a href=\"https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/\" target=\"_blank\" rel=\"noopener\">378. Kth Smallest Element in a Sorted Matrix</a></p>\n<h1>Kth Smallest Number in Multiplication Table</h1>\n<p>Nearly every one have used the Multiplication Table. But could you find out the k-th smallest number quickly from the multiplication table?</p>\n<p>Given the height m and the length n of a m * n Multiplication Table, and a positive integer k, you need to return the k-th smallest number in this table.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: m = 3, n = 3, k = 5</span><br><span class=\"line\">Output: </span><br><span class=\"line\">Explanation: </span><br><span class=\"line\">The Multiplication Table:</span><br><span class=\"line\">1\t2\t3</span><br><span class=\"line\">2\t4\t6</span><br><span class=\"line\">3\t6\t9</span><br><span class=\"line\"></span><br><span class=\"line\">The 5-th smallest number is 3 (1, 2, 2, 3, 3).</span><br></pre></td></tr></table></figure>\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: m = 2, n = 3, k = 6</span><br><span class=\"line\">Output: </span><br><span class=\"line\">Explanation: </span><br><span class=\"line\">The Multiplication Table:</span><br><span class=\"line\">1\t2\t3</span><br><span class=\"line\">2\t4\t6</span><br><span class=\"line\"></span><br><span class=\"line\">The 6-th smallest number is 6 (1, 2, 2, 3, 4, 6).</span><br></pre></td></tr></table></figure>\n<p><strong>Note:</strong></p>\n<ol>\n<li>The m and n will be in the range [1, 30000].</li>\n<li>The k will be in the range [1, m * n]</li>\n</ol>\n<p><strong>Algorithm:</strong></p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">findKthNumber</span><span class=\"params\">(<span class=\"number\">_</span> m: Int, <span class=\"number\">_</span> n: Int, <span class=\"number\">_</span> k: Int)</span></span> -&gt; <span class=\"type\">Int</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">guard</span> m &gt; <span class=\"number\">0</span>, n &gt; <span class=\"number\">0</span>, k &gt; <span class=\"number\">0</span> <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> lo = <span class=\"number\">1</span>, hi = m * n</span><br><span class=\"line\">        <span class=\"keyword\">while</span> lo &lt; hi &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> mid = (lo + hi) &gt;&gt; <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">var</span> <span class=\"built_in\">count</span> = <span class=\"number\">0</span>, nN = n</span><br><span class=\"line\">            <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"number\">1</span>...m &#123;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> nN &gt; <span class=\"number\">0</span>, i * nN &gt; mid &#123;</span><br><span class=\"line\">                    nN -= <span class=\"number\">1</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"built_in\">count</span> += nN</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"built_in\">count</span> &lt; k &#123;</span><br><span class=\"line\">                lo = mid + <span class=\"number\">1</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                hi = mid</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> lo</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>From leetCode <a href=\"https://leetcode.com/problems/kth-smallest-number-in-multiplication-table/\" target=\"_blank\" rel=\"noopener\">668. Kth Smallest Number in Multiplication Table</a></p>\n<h1>Find K-th Smallest Pair Distance</h1>\n<p>Given an integer array, return the k-th smallest distance among all the pairs. The distance of a pair (A, B) is defined as the absolute difference between A and B.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input:</span><br><span class=\"line\">nums = [1,3,1]</span><br><span class=\"line\">k = 1</span><br><span class=\"line\">Output: 0 </span><br><span class=\"line\">Explanation:</span><br><span class=\"line\">Here are all the pairs:</span><br><span class=\"line\">(1,3) -&gt; 2</span><br><span class=\"line\">(1,1) -&gt; 0</span><br><span class=\"line\">(3,1) -&gt; 2</span><br><span class=\"line\">Then the 1st smallest distance pair is (1,1), and its distance is 0.</span><br></pre></td></tr></table></figure>\n<p><strong>Note:</strong></p>\n<ol>\n<li>2 &lt;= len(nums) &lt;= 10000.</li>\n<li>0 &lt;= nums[i] &lt; 1000000.</li>\n<li>1 &lt;= k &lt;= len(nums) * (len(nums) - 1) / 2.</li>\n</ol>\n<p><strong>Algorithm:</strong></p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">smallestDistancePair</span><span class=\"params\">(<span class=\"number\">_</span> nums: [Int], <span class=\"number\">_</span> k: Int)</span></span> -&gt; <span class=\"type\">Int</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">guard</span> nums.<span class=\"built_in\">count</span> &gt; <span class=\"number\">1</span> <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> sortedNums = nums.sorted()</span><br><span class=\"line\">        <span class=\"keyword\">var</span> lo = <span class=\"number\">0</span>, hi = sortedNums.last! - sortedNums.first!</span><br><span class=\"line\">        <span class=\"keyword\">while</span> lo &lt; hi &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> mid = (lo + hi) &gt;&gt; <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">var</span> <span class=\"built_in\">count</span> = <span class=\"number\">0</span>, i = <span class=\"number\">0</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"number\">0</span>..&lt;sortedNums.<span class=\"built_in\">count</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> i &lt; sortedNums.<span class=\"built_in\">count</span>, sortedNums[j] - sortedNums[i] &gt; mid &#123;</span><br><span class=\"line\">                    i += <span class=\"number\">1</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"built_in\">count</span> += j-i</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"built_in\">count</span> &lt; k &#123;</span><br><span class=\"line\">                lo = mid + <span class=\"number\">1</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                hi = mid</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> lo</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>From leetCode <a href=\"https://leetcode.com/problems/find-k-th-smallest-pair-distance/\" target=\"_blank\" rel=\"noopener\">719. Find K-th Smallest Pair Distance</a></p>\n<h1>K-th Smallest Prime Fraction</h1>\n<p>A sorted list A contains 1, plus some number of primes.  Then, for every p &lt; q in the list, we consider the fraction p/q.</p>\n<p>What is the K-th smallest fraction considered?  Return your answer as an array of ints, where answer[0] = p and answer[1] = q.</p>\n<p><strong>Example:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: A = [1, 2, 3, 5], K = 3</span><br><span class=\"line\">Output: [2, 5]</span><br><span class=\"line\">Explanation:</span><br><span class=\"line\">The fractions to be considered in sorted order are:</span><br><span class=\"line\">1/5, 1/3, 2/5, 1/2, 3/5, 2/3.</span><br><span class=\"line\">The third fraction is 2/5.</span><br><span class=\"line\"></span><br><span class=\"line\">Input: A = [1, 7], K = 1</span><br><span class=\"line\">Output: [1, 7]</span><br></pre></td></tr></table></figure>\n<p><strong>Note:</strong></p>\n<ul>\n<li>A will have length between 2 and 2000.</li>\n<li>Each A[i] will be between 1 and 30000.</li>\n<li>K will be between 1 and A.length * (A.length - 1) / 2.</li>\n</ul>\n<p><strong>Algorithm:</strong></p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">kthSmallestPrimeFraction</span><span class=\"params\">(<span class=\"number\">_</span> A: [Int], <span class=\"number\">_</span> K: Int)</span></span> -&gt; [<span class=\"type\">Int</span>] &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> n = <span class=\"type\">A</span>.<span class=\"built_in\">count</span></span><br><span class=\"line\">        <span class=\"keyword\">guard</span> n &gt; <span class=\"number\">1</span>, <span class=\"type\">K</span> &gt; <span class=\"number\">0</span> <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> []</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> lo = <span class=\"number\">0.0</span>, hi = <span class=\"number\">1.0</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> lo &lt; hi &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> mid = (lo + hi) / <span class=\"number\">2</span></span><br><span class=\"line\">            <span class=\"keyword\">var</span> j = <span class=\"number\">1</span>, <span class=\"built_in\">count</span> = <span class=\"number\">0</span>, maxVal = <span class=\"number\">0.0</span>, res = (<span class=\"number\">0</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"number\">0</span>..&lt;n-<span class=\"number\">1</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> j &lt; n, <span class=\"type\">Double</span>(<span class=\"type\">A</span>[i]) &gt; mid * <span class=\"type\">Double</span>(<span class=\"type\">A</span>[j]) &#123;</span><br><span class=\"line\">                    j += <span class=\"number\">1</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> n == j &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"built_in\">count</span> += n-j</span><br><span class=\"line\">                <span class=\"keyword\">let</span> val = <span class=\"type\">Double</span>(<span class=\"type\">A</span>[i]) / <span class=\"type\">Double</span>(<span class=\"type\">A</span>[j])</span><br><span class=\"line\">                <span class=\"keyword\">if</span> val &gt; maxVal &#123;</span><br><span class=\"line\">                    res = (i, j)</span><br><span class=\"line\">                    maxVal = val</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"built_in\">count</span> &lt; <span class=\"type\">K</span> &#123;</span><br><span class=\"line\">                lo = mid</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> <span class=\"built_in\">count</span> == <span class=\"type\">K</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> [<span class=\"type\">A</span>[res.<span class=\"number\">0</span>], <span class=\"type\">A</span>[res.<span class=\"number\">1</span>]]</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                hi = mid</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> []</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>From leetCode <a href=\"https://leetcode.com/problems/k-th-smallest-prime-fraction/\" target=\"_blank\" rel=\"noopener\">786. K-th Smallest Prime Fraction</a></p>\n<h1>Minimum Cost to Hire K Workers</h1>\n<p>There are N workers.  The i-th worker has a quality[i] and a minimum wage expectation wage[i].</p>\n<p>Now we want to hire exactly K workers to form a paid group.  When hiring a group of K workers, we must pay them according to the following rules:</p>\n<ol>\n<li>Every worker in the paid group should be paid in the ratio of their quality compared to other workers in the paid group.</li>\n<li>Every worker in the paid group must be paid at least their minimum wage expectation.</li>\n</ol>\n<p>Return the least amount of money needed to form a paid group satisfying the above conditions.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: quality = [10,20,5], wage = [70,50,30], K = 2</span><br><span class=\"line\">Output: 105.00000</span><br><span class=\"line\">Explanation: We pay 70 to 0-th worker and 35 to 2-th worker.</span><br></pre></td></tr></table></figure>\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: quality = [3,1,10,10,1], wage = [4,8,2,2,7], K = 3</span><br><span class=\"line\">Output: 30.66667</span><br><span class=\"line\">Explanation: We pay 4 to 0-th worker, 13.33333 to 2-th and 3-th workers seperately.</span><br></pre></td></tr></table></figure>\n<p><strong>Note:</strong></p>\n<ol>\n<li>1 &lt;= K &lt;= N &lt;= 10000, where N = quality.length = wage.length</li>\n<li>1 &lt;= quality[i] &lt;= 10000</li>\n<li>1 &lt;= wage[i] &lt;= 10000</li>\n<li>Answers within 10^-5 of the correct answer will be considered correct.</li>\n</ol>\n<p><strong>Algorithm:</strong></p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">mincostToHireWorkers</span><span class=\"params\">(<span class=\"number\">_</span> quality: [Int], <span class=\"number\">_</span> wage: [Int], <span class=\"number\">_</span> K: Int)</span></span> -&gt; <span class=\"type\">Double</span> &#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">insert</span>&lt;T: Comparable&gt;<span class=\"params\">(<span class=\"number\">_</span> new: <span class=\"params\">(T, Int)</span></span></span>, <span class=\"number\">_</span> arr: <span class=\"keyword\">inout</span> [(<span class=\"type\">T</span>, <span class=\"type\">Int</span>)]) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> l = <span class=\"number\">0</span>, r = arr.<span class=\"built_in\">count</span>-<span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> l &lt;= r &#123;</span><br><span class=\"line\">                <span class=\"keyword\">let</span> mid = (l+r) &gt;&gt; <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (mid == <span class=\"number\">0</span> &amp;&amp; new.<span class=\"number\">0</span> &lt;= arr[mid].<span class=\"number\">0</span>) ||</span><br><span class=\"line\">                    (mid &gt; <span class=\"number\">0</span> &amp;&amp; new.<span class=\"number\">0</span> &lt;= arr[mid].<span class=\"number\">0</span> &amp;&amp; new.<span class=\"number\">0</span> &gt; arr[mid-<span class=\"number\">1</span>].<span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    arr.insert(new, at: mid)</span><br><span class=\"line\">                    <span class=\"keyword\">return</span></span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> new.<span class=\"number\">0</span> &gt; arr[mid].<span class=\"number\">0</span> &#123;</span><br><span class=\"line\">                    l = mid + <span class=\"number\">1</span></span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    r = mid - <span class=\"number\">1</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            arr.insert(new, at: arr.<span class=\"built_in\">count</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> arr = [(<span class=\"type\">Double</span>, <span class=\"type\">Int</span>)]()</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> quality.<span class=\"built_in\">indices</span> &#123;</span><br><span class=\"line\">            insert((<span class=\"type\">Double</span>(wage[i]) / <span class=\"type\">Double</span>(quality[i]), i), &amp;arr)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> res = pow(<span class=\"number\">10.0</span>, <span class=\"number\">10.0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">var</span> qualities = [(<span class=\"type\">Int</span>, <span class=\"type\">Int</span>)]()</span><br><span class=\"line\">        <span class=\"keyword\">var</span> sump = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"number\">0</span>..&lt;arr.<span class=\"built_in\">count</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> temp = quality[arr[i].<span class=\"number\">1</span>]</span><br><span class=\"line\">            insert((temp, arr[i].<span class=\"number\">1</span>), &amp;qualities)</span><br><span class=\"line\">            sump += temp</span><br><span class=\"line\">            <span class=\"keyword\">if</span> qualities.<span class=\"built_in\">count</span> &gt; <span class=\"type\">K</span> &#123;</span><br><span class=\"line\">                sump -= qualities.popLast()!.<span class=\"number\">0</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> qualities.<span class=\"built_in\">count</span> == <span class=\"type\">K</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">let</span> ratio = arr[i].<span class=\"number\">0</span></span><br><span class=\"line\">                res = <span class=\"built_in\">min</span>(res, <span class=\"type\">Double</span>(sump) * ratio)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>From leetCode <a href=\"https://leetcode.com/problems/minimum-cost-to-hire-k-workers/\" target=\"_blank\" rel=\"noopener\">857. Minimum Cost to Hire K Workers</a></p>\n"},{"title":"OpenGL ES坐标系统","catalog":true,"toc_nav_num":true,"date":"2019-08-25T08:44:21.000Z","subtitle":"About OpenGL ES","header-img":"/img/article_header/article_header.png","busuanzi":true,"_content":"\n> OpenGL ES希望在每次顶点着色器运行后，我们可见的所有顶点都为标准化设备坐标。也就是说，每个顶点的x，y，z坐标都应该在-1.0到1.0之间，超出这个坐标范围的顶点都将不可见。我们通常会自己设定一个坐标的范围，之后再在顶点着色器中将这些坐标变换为标准化设备坐标。然后将这些标准坐标传入光栅器，将它们变换为屏幕上的二维坐标或像素。\n> 将坐标变换为标准化设备坐标，接着再转化为屏幕坐标的过程通常是分步进行的，也就是类似于流水线那样子。在流水线中，物体的顶点在最终转化为屏幕坐标之前还会被变换到多个坐标系统。将物体的坐标变换到几个过渡坐标系的优点在于，在这些特定的坐标系统中，一些操作或运算更加方便和容易，这一点很快就会变得很明显。对我们来说比较重要的总共有5个不同的坐标系统：\n> - 局部空间（Local Space，或者称为物体空间（Object Space））\n> - 世界空间（World Space）\n> - 观察空间（View Space，或者称为视觉空间（Eye Space））\n> - 裁剪空间（Clip Space）\n> - 屏幕空间（Screen Space）\n>\n> 这就是一个顶点在最终被转化为片段之前需要经历的所有不同状态。\n\n# 概述\n\n为了将坐标从一个坐标系变换到另一个坐标系，我们需要用到几个变换矩阵，最重要的几个分别是模型（Model）、观察（View）、投影（Projection）三个矩阵。我们的顶点坐标起始于局部空间（Local Space），在这里它称为局部坐标（Local Coordinate），它在之后会变为世界坐标（World Coordinate），观察坐标（View Coordinate），裁剪坐标（Clip Coordinate），并最后以屏幕坐标（Screen Coordinate）的形式结束。如下图：\n\n![坐标系统](/img/article/20190825/1.png)\n\n1. 局部坐标是对象相对于局部原点的坐标，也是物体起始的坐标。\n2. 下一步是将局部坐标转换为世界空间坐标，世界空间坐标是处于一个更大的空间范围的。这些坐标相对于世界的全局原点，它们会和其他物体一起相对于世界的原点进行摆放。\n3. 接下来我们将世界坐标转换为观察空间坐标，使得每个坐标都是从摄像机或者说观察者的角度进行观察的。\n4. 坐标到达观察空间之后，我们需要将其投影到裁剪坐标。裁剪坐标会被处理至-1.0到1.0的范围内，并判断哪些顶点将会出现在屏幕上。\n5. 最后，我们将裁剪坐标变换为屏幕坐标，我们将使用一个叫做视口变换（Viewport Transform）的过程。视口变换将位于-1.0到1.0范围的坐标变换到由`glViewport`函数所定义的坐标范围内。最后变换出来的坐标会送到光栅器，并将其转换为片段。\n\n我们之所以将顶点变换到各个不同的空间的原因是有些操作在特定的坐标系统中才有意义且更方便。例如，当需要物体进行修改的时候，在局部空间中来操作会更说得通；如果要对一个物体做出一个相对于其它物体位置的操作时，在世界坐标系中来做这个才更说得通，等等。\n\n# 局部空间\n\n局部空间是指物体所在的坐标空间，即对象最开始所在的地方。想象你在一个建模软件中创建一个立方体。创建的立方体的原点有可能位于(0, 0, 0)，即便它有可能最后在程序中处于完全不同的位置。甚至有可能你创建的所有模型都以(0, 0, 0)为初始位置（然后它们最终出现在世界的不同位置）。所以，模型的所有顶点都是在局部空间中：它们相对于物体来说都是局部的。\n\n# 世界空间\n\n如果我们将我们所有的物体导入到当前程序中，它们有可能会全挤在世界的原点(0, 0, 0)上，这并不是我们想要的结果。我们想为每一个物体定义一个位置，从而能在更大的世界当中放置它们。世界空间中的坐标正如其名：是指顶点相对于世界的坐标。如果我们希望将物体分散在世界上摆放，这就是我们希望物体变换到的空间。物体的坐标将会从局部变换到世界空间；该变换是由模型矩阵（Model Matrix）实现的。\n模型矩阵是一种变换矩阵，它能通过对物体进行位移、缩放、旋转来将它置于它本应该在的位置或朝向。我们可以将它想象为变换一个房子，需要先将它缩小（它在局部空间中太大了），并将其移至郊区的一个小镇，然后在y轴上往左旋转一点以搭配附近的房子。\n\n# 观察空间\n\n观察空间经常被人们称之为OpenGL的摄像机（Camera）(所以有时也称为摄像机空间（Camera Space）或视觉空间（Eye Space）)。观察空间是将世界空间坐标转化为用户视野前方的坐标而产生的结果。因此观察空间就是从摄像机的视角所观察到的空间。而这通常是由一系列的位移和旋转的组合来完成，平移/旋转场景从而使得特定的对象被变换到摄像机的前方。这些组合在一起的变换通常存储在一个观察矩阵（View Matrix）里，它被用来将世界坐标变换到观察空间。\n\n## 摄像机\n\n> OpenGL本身没有摄像机（Camera）的概念，但我们可以通过把场景中的所有物体往相反方向移动的方式来模拟出摄像机，产生一种我们在移动的感觉，而不是场景在移动。\n\n### 摄像机/观察空间\n\n当我们讨论摄像机/观察空间（Camera/View Space）的时候，是在讨论以摄像机的视角作为场景原点时场景中所有的顶点坐标：观察矩阵把所有的世界坐标转换为相对于摄像机位置与方向的观察坐标。要定义一个摄像机，我们需要它在世界空间中的位置、观察的方向、一个指向它右侧的向量以及一个指向它上方的向量（我们实际上创建了一个三个三位轴相互垂直的、以摄像机的位置为原点的坐标系）。\n\n![摄像机/观察空间](/img/article/20190825/6.png)\n\n1. 摄像机位置\n\n获取摄像机位置很简单。摄像机位置简单来说就是世界空间中一个指向摄像机位置的向量：\n\n``` objc\nvec3 cameraPos = vec3(0.0f, 0.0f, 3.0f);\n```\n\n2. 摄像机方向\n\n下一个需要的向量是摄像机的方向，这里指的是摄像机指向哪个方向。现在我们让摄像机指向场景原点：(0, 0, 0)。如果将两个向量相减，我们就能得到这两个向量的差。用场景原点向量减去摄像机位置向量的结果就是摄像机的指向向量。由于我们知道摄像机指向z轴负方向，但我们希望方向向量指向摄像机的z轴正方向。所以我们交换相减的顺序，就可以获得一个指向摄像机正z轴方向的向量：\n\n``` objc\nvec3 cameraTarget = vec3(0.0f, 0.0f, 0.0f);\nvec3 cameraDirection = normalize(cameraPos - cameraTarget);     // normalize 标准化向量，返回一个方向相同但单位向量为1的向量\n```\n\n> 方向向量并不是最好的名字，因为它实际上指向从它到目标向量的相反方向。\n\n3. 右轴\n\n我们需要的另一个向量是一个右向量，它代表摄像机空间的x轴的正方向。为获取右向量我们需要一个小技巧：先定义一个上向量。接下来把上向量和第二步得到的方向向量进行叉乘。两个向量叉乘的结果会同时垂直于两向量，因此我们会得到指向x轴正方向的那个向量（如果我们交换两个向量叉乘的顺序就会得到相反的指向x轴负方向的向量）：\n\n``` objc\nvec3 up = vec3(0.0f, 1.0f, 0.0f);\nvec3 cameraRight = normalize(cross(up, cameraDirection));       // cross 两个向量的向量积\n```\n\n4. 上轴\n\n现在我们已经有了x轴向量和z轴向量，获取一个指向摄像机的正y轴向量就相对简单了：我们把方向向量和右向量进行叉乘：\n\n``` objc\nvec3 cameraUp = cross(cameraDirection, cameraRight);\n```\n\n在叉乘和一些小技巧的帮助下，我们创建了所有构成观察/摄像机空间的向量。使用这些摄像机向量我们就可以创建一个`LookAt`矩阵了，它在创建摄像机的时候非常有用。\n\n### Look At\n\n使用矩阵的好处之一是如果使用3个互相垂直的轴定义了一个坐标空间，我们可以用这3个轴加一个平移向量来创建一个矩阵，并且可以用这个矩阵乘以任何向量来将其变换到那个坐标空间。这正是`LookAt`矩阵所做的，现在我们有了3个互相垂直的轴和一个定义摄像机空间的位置坐标，我们可以创建自己的`LookAt`矩阵了：\n\n![LookAt矩阵](/img/article/20190825/7.png)\n\n其中`R`是右向量，`U`是上向量，`D`是方向向量，`P`是摄像机位置向量。注意，位置向量是相反的，因为我们最终希望把世界平移到我们自身一定的相反方向。把这个`LookAt`矩阵作为观察矩阵可以很高效地把所有世界坐标变换到刚刚定义的观察空间。`LookAt`矩阵就像它的名字表达的那样：它会创建一个看着（Look at）给定目标的观察矩阵。\n\n幸运的是，GLM已经提供了这些支持。我们要做的只是定义一个摄像机位置，一个目标位置和一个表示世界空间中的上向量的向量（我们计算右向量使用的那个上向量）。接着GLM就会创建一个`LookAt`矩阵，我们可以把它当作我们的观察矩阵：\n\n``` objc\n// OpenGL ES 1.1\nGLKMatrix4 view = gluLookAt(0.0f, 0.0f, 3.0f, 0.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f);\n\n// GLKit\nGLKMatrix4 view = GLKMatrix4MakeLookAt(0.0f, 0.0f, 3.0f, 0.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f);\n``\n\n# 裁剪空间\n\n在一个顶点着色器运行的最后，OpenGL期望所有的坐标都能落在一个特定的范围内，且任何在这个范围之外的点都应该被裁剪掉（Clipped）。被裁剪掉的坐标就会被忽略，所以剩下的坐标就将变为屏幕上可见的片段。这也就是裁剪空间（Clip Space）名字的由来。\n因为将所有可见的坐标都指定在-1.0到1.0的范围内不是很直观，所以我们会指定自己的坐标集（Coordinate Set）并将它变换回标准化设备坐标系，就像OpenGL期望的那样。\n为了将顶点坐标从观察变换到裁剪空间，我们需要定义一个投影矩阵（Projection Matrix），它指定了一个范围的坐标，比如每个维度上的-1000到1000.投影矩阵接着会将在这个指定的范围内的坐标变换为标准化设备坐标的范围(-1.0, 1.0)。所有在范围外的坐标不会被映射到在-1.0到1.0的范围之间，所以会被裁剪掉。在上面这个投影矩阵所指定的范围内，坐标(1250, 500, 750)将是不可见的，这是由于它的x坐标超出了范围，它被转化为一个大于1.0的标准化设备坐标，所以被裁剪掉了。\n\n> 如果只是图元，例如三角形的一部分超出了裁剪体积，则OpenGL会重新构建这个三角形为一个或多个三角形让其能够适合这个裁剪范围。\n\n由投影矩阵创建的观察箱（Viewing Box）被称为**平截头体**（Frustum），每个出现在平截头体范围内的坐标都会最终出现在用户的屏幕上。将特定范围内的坐标转化到标准化设备坐标系的过程（而且它很容易被映射到2D观察空间坐标）被称之为投影，因为使用投影矩阵能将3D坐标投影到很容易映射到2D的标准化设备坐标系中。\n一旦所有顶点被变换到裁剪空间，最终的操作--透视除法（Perspective Division）将会执行，在这个过程中我们将位置向量的x，y，z分量分别除以向量的齐次w分量；透视除法是将4D裁剪空间坐标转换为3D标准化设备坐标的过程。这一步会在每一个顶点着色器运行的最后被自动执行。\n在这一阶段之后，最终的坐标将会被映射到屏幕空间中（使用`glViewport`中的设定），并被变换成片段。\n将观察坐标变换为裁剪坐标的投影矩阵可以为两种不同的形式，每种形式都定义了不同的平截头体。我们可以选择创建一个正射投影矩阵（Orthographic Projection Matrix）或一个透视投影矩阵（Perspective Projection Matrix）。\n\n## 正射投影\n\n正射投影矩阵定义了一个类似立方体的平接头箱，它定义了一个裁剪空间，在这空间之外的顶点都会被裁剪掉。创建一个正射投影矩阵需要指定可见平截头体的宽、高和长度。在使用正射投影矩阵变换至裁剪空间之后处于这个平截头体的所有坐标将不会被裁剪掉。它的平截头体看起来像一个容器：\n\n![正射投影](/img/article/20190825/2.png)\n\n上面的平截头体定义了可见的坐标，它由宽、高、近（Near）平面和远（Far）平面所指定。任何出现在近平面之前或远平面之后的坐标都会被裁剪掉。正射平截头体直接将平截头体内部的所有坐标映射为标准化设备坐标，因为每个向量的w分量都没有进行改变；如果w分量等于1.0，透视除法则不会改变这个坐标。\n要创建一个正射投影矩阵，我们可以使用`GLKit`中的方法：\n\n``` objc\nGLKMatrix4MakeOrtho(0.0, 800.0, 0.0, 600, 0.1, 100.0);\n```\n\n或OpenGL ES 1.1中的函数：\n\n``` objc\nglOrthof(0.0, 800.0, 0.0, 600.0, 0.1, 100.0);\n```\n\n前两个参数指定了平截头体的左右坐标，第三和第四参数指定了平截头体的底部和顶部。通过这四个参数我们定义了近平面和远平面的大小，然后第五和第六个参数则定义了近平面和远平面的距离。这个投影矩阵会将处于这些x，y，z值范围内的坐标变换为标准化设备坐标。\n正射投影矩阵直接将坐标映射到2D平面中，即屏幕中，但实际上一个直接的投影矩阵会产生不真实的结果，因为这个投影没有将透视（Perspective）考虑进去。\n\n## 透视投影\n\n我们都曾体验过实际生活中的一个场景，离我们越远的东西看起来更小。这个奇怪的效果称之为透视。透视的效果在我们看一条无限长的高速公路或铁路时尤其明显，正如下面图片显示的那样：\n\n![透视投影](/img/article/20190825/3.png)\n\n正如所看到的那样，由于透视，这两条线在很远的地方看起来会相交。这正是透视投影想要模仿的效果，它是使用透视投影矩阵来完成的。这个投影矩阵将给定的平截头体范围映射到裁剪空间，除此之外还修改了每个顶点的w值，从而使得离观察者越远的顶点坐标w分量越大。被变换到裁剪空间的坐标都会在-w到w的范围之间（任何大于这个范围的坐标都会被裁剪掉）。OpenGL要求所有可见的坐标都落在-1.0到1.0范围内，作为顶点着色器最后的输出，一次，一旦坐标在裁剪空间内之后，透视除法就被会应用到裁剪空间坐标上：\n\n![透视除法](/img/article/20190825/4.png)\n\n顶点坐标的每个分量都会除以它的w分量，距离观察者越远顶点坐标就会越小。这也是w分量非常重要的另一个原因，它能够帮助我们进行透视投影。最后的结果坐标就是处于标准化设备空间中的。\n\n要创建一个透视投影矩阵，我们可以使用`GLKit`中的方法：\n\n``` objc\nGLKMatrix4MakePerspective(GLKMathRadiansToDegrees(45), width/height, 0.1, 100.0);\n```\n\n同样，`GLKMatrix4MakePerspective`所做的其实就是创建了一个定义了可视空间的大平截头体，任何在这个平截头体以外的东西最后都不会出现在裁剪空间体积内，并且将会收到裁剪。一个透视平截头体可以被看作一个不均匀的箱子，在这个箱子内部的每个坐标都会被映射到裁剪空间上的一个点。下面是一张透视平截头体的图片：\n\n![透视平截头体](/img/article/20190825/5.png)\n\n它的第一个参数定义了`fov`的值，它表示的是视野（Field of View），并且设置了观察空间的大小。如果想要一个真实的观察效果，它的值通常设置为45.0f，但想要一个末日风格的结果可以将其设置一个更大的值。第二个参数设置了宽高比，由视口的宽除以高所得。第三和第四个参数设置了平截头体的近和远平面。我们通常设置近距离为0.1f，而远距离设置为100.0f。所有在近平面和远平面且处于平截头体内的顶点都会被渲染。\n\n> 当我们把透视矩阵的`near`值设置太大时（如10.0f），OpenGL会将靠近摄像机的坐标（在0。0f和10.0f之间）都裁剪掉，这会导致一个在游戏中很熟悉的视觉效果：在太过靠近一个物体的时候视线会直接传过去。\n\n# 把它们都组合到一起\n\n我们为上述的每一个步骤都创建了一个变换矩阵：模型矩阵、观察矩阵和投影矩阵。一个顶点坐标将会根据以下过程被变换到裁剪坐标：V<sub>clip</sub> = M<sub>projection</sub>p * M<sub>view</sub> * M<sub>model</sub> * M<sub>local</sub>。\n注意矩阵运算的顺序是相反的。最后的顶点应该被赋值到顶点着色器中的`gl_Position`，OpenGL将会自动进行透视除法和裁剪。\n\n> 然后呢？\n> 顶点着色器的输出要求所有的顶点都在裁剪空间内，这正是我们刚才使用变换矩阵所做的。OpenGL然后对裁剪坐标执行透视除法从而将它们变换到标准化设备坐标。OpenGL会使用`glViewport`内部的参数来标准化设备坐标映射到屏幕坐标，每个坐标都关联了一个屏幕上的点。这个过程称为视口变换。\n\n# 举个例子\n\n我们创建一个立方体，利用摄像机视角对其进行旋转拍摄，主要的矩阵变换代码如下：\n\n``` objc\n- (void)update {\n    NSTimeInterval detalTime = self.timeSinceLastUpdate;\n    self.elapsedTime += detalTime;\n    \n    float varyingFactor = (sin(self.elapsedTime) + 1) / 2.0;\n    float aspect = self.view.frame.size.width / self.view.frame.size.height;\n\n    GLKMatrix4 perspectiveMatrix = GLKMatrix4MakePerspective(GLKMathDegreesToRadians(45), aspect, 0.1, 100.0);  // 投影矩阵\n    GLKMatrix4 cameraMatrix = GLKMatrix4MakeLookAt(0, 0, 5 * (varyingFactor + 1), 0, 0, 0, 0, 1, 0);    // 观察矩阵\n    GLKMatrix4 rotateMatrix = GLKMatrix4MakeRotation(varyingFactor * M_PI * 2, 1, 1, 1);    // 模型矩阵\n    self.projectionMatrix = GLKMatrix4Multiply(cameraMatrix, rotateMatrix);\n    self.projectionMatrix = GLKMatrix4Multiply(perspectiveMatrix, self.projectionMatrix);\n}\n\n- (void)glkView:(GLKView *)view drawInRect:(CGRect)rect {\n    \n    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n    glClearColor(0.0, 0.0, 0.0, 1.0);\n\n    glUniformMatrix4fv(mvpMatrixlocation, 1, 0, self.projectionMatrix.m);\n    \n    glBindVertexArray(vao);\n    glDrawElements(GL_TRIANGLES, 36, GL_UNSIGNED_SHORT, 0);\n}\n```\n\n# 总结\n\n这篇文章主要针对物体根据一系列的坐标系转换，最终转化为屏幕上最终的渲染产物过程中的坐标系转换的学习。\n\n","source":"_posts/2019/opengl-es-coordinated-system-0825.md","raw":"---\ntitle: \"OpenGL ES坐标系统\"\ncatalog: true\ntoc_nav_num: true\ndate: 2019-08-25 16:44:21\nsubtitle: \"About OpenGL ES\"\nheader-img: \"/img/article_header/article_header.png\"\nbusuanzi: true\ntags:\n- iOS\n\n---\n\n> OpenGL ES希望在每次顶点着色器运行后，我们可见的所有顶点都为标准化设备坐标。也就是说，每个顶点的x，y，z坐标都应该在-1.0到1.0之间，超出这个坐标范围的顶点都将不可见。我们通常会自己设定一个坐标的范围，之后再在顶点着色器中将这些坐标变换为标准化设备坐标。然后将这些标准坐标传入光栅器，将它们变换为屏幕上的二维坐标或像素。\n> 将坐标变换为标准化设备坐标，接着再转化为屏幕坐标的过程通常是分步进行的，也就是类似于流水线那样子。在流水线中，物体的顶点在最终转化为屏幕坐标之前还会被变换到多个坐标系统。将物体的坐标变换到几个过渡坐标系的优点在于，在这些特定的坐标系统中，一些操作或运算更加方便和容易，这一点很快就会变得很明显。对我们来说比较重要的总共有5个不同的坐标系统：\n> - 局部空间（Local Space，或者称为物体空间（Object Space））\n> - 世界空间（World Space）\n> - 观察空间（View Space，或者称为视觉空间（Eye Space））\n> - 裁剪空间（Clip Space）\n> - 屏幕空间（Screen Space）\n>\n> 这就是一个顶点在最终被转化为片段之前需要经历的所有不同状态。\n\n# 概述\n\n为了将坐标从一个坐标系变换到另一个坐标系，我们需要用到几个变换矩阵，最重要的几个分别是模型（Model）、观察（View）、投影（Projection）三个矩阵。我们的顶点坐标起始于局部空间（Local Space），在这里它称为局部坐标（Local Coordinate），它在之后会变为世界坐标（World Coordinate），观察坐标（View Coordinate），裁剪坐标（Clip Coordinate），并最后以屏幕坐标（Screen Coordinate）的形式结束。如下图：\n\n![坐标系统](/img/article/20190825/1.png)\n\n1. 局部坐标是对象相对于局部原点的坐标，也是物体起始的坐标。\n2. 下一步是将局部坐标转换为世界空间坐标，世界空间坐标是处于一个更大的空间范围的。这些坐标相对于世界的全局原点，它们会和其他物体一起相对于世界的原点进行摆放。\n3. 接下来我们将世界坐标转换为观察空间坐标，使得每个坐标都是从摄像机或者说观察者的角度进行观察的。\n4. 坐标到达观察空间之后，我们需要将其投影到裁剪坐标。裁剪坐标会被处理至-1.0到1.0的范围内，并判断哪些顶点将会出现在屏幕上。\n5. 最后，我们将裁剪坐标变换为屏幕坐标，我们将使用一个叫做视口变换（Viewport Transform）的过程。视口变换将位于-1.0到1.0范围的坐标变换到由`glViewport`函数所定义的坐标范围内。最后变换出来的坐标会送到光栅器，并将其转换为片段。\n\n我们之所以将顶点变换到各个不同的空间的原因是有些操作在特定的坐标系统中才有意义且更方便。例如，当需要物体进行修改的时候，在局部空间中来操作会更说得通；如果要对一个物体做出一个相对于其它物体位置的操作时，在世界坐标系中来做这个才更说得通，等等。\n\n# 局部空间\n\n局部空间是指物体所在的坐标空间，即对象最开始所在的地方。想象你在一个建模软件中创建一个立方体。创建的立方体的原点有可能位于(0, 0, 0)，即便它有可能最后在程序中处于完全不同的位置。甚至有可能你创建的所有模型都以(0, 0, 0)为初始位置（然后它们最终出现在世界的不同位置）。所以，模型的所有顶点都是在局部空间中：它们相对于物体来说都是局部的。\n\n# 世界空间\n\n如果我们将我们所有的物体导入到当前程序中，它们有可能会全挤在世界的原点(0, 0, 0)上，这并不是我们想要的结果。我们想为每一个物体定义一个位置，从而能在更大的世界当中放置它们。世界空间中的坐标正如其名：是指顶点相对于世界的坐标。如果我们希望将物体分散在世界上摆放，这就是我们希望物体变换到的空间。物体的坐标将会从局部变换到世界空间；该变换是由模型矩阵（Model Matrix）实现的。\n模型矩阵是一种变换矩阵，它能通过对物体进行位移、缩放、旋转来将它置于它本应该在的位置或朝向。我们可以将它想象为变换一个房子，需要先将它缩小（它在局部空间中太大了），并将其移至郊区的一个小镇，然后在y轴上往左旋转一点以搭配附近的房子。\n\n# 观察空间\n\n观察空间经常被人们称之为OpenGL的摄像机（Camera）(所以有时也称为摄像机空间（Camera Space）或视觉空间（Eye Space）)。观察空间是将世界空间坐标转化为用户视野前方的坐标而产生的结果。因此观察空间就是从摄像机的视角所观察到的空间。而这通常是由一系列的位移和旋转的组合来完成，平移/旋转场景从而使得特定的对象被变换到摄像机的前方。这些组合在一起的变换通常存储在一个观察矩阵（View Matrix）里，它被用来将世界坐标变换到观察空间。\n\n## 摄像机\n\n> OpenGL本身没有摄像机（Camera）的概念，但我们可以通过把场景中的所有物体往相反方向移动的方式来模拟出摄像机，产生一种我们在移动的感觉，而不是场景在移动。\n\n### 摄像机/观察空间\n\n当我们讨论摄像机/观察空间（Camera/View Space）的时候，是在讨论以摄像机的视角作为场景原点时场景中所有的顶点坐标：观察矩阵把所有的世界坐标转换为相对于摄像机位置与方向的观察坐标。要定义一个摄像机，我们需要它在世界空间中的位置、观察的方向、一个指向它右侧的向量以及一个指向它上方的向量（我们实际上创建了一个三个三位轴相互垂直的、以摄像机的位置为原点的坐标系）。\n\n![摄像机/观察空间](/img/article/20190825/6.png)\n\n1. 摄像机位置\n\n获取摄像机位置很简单。摄像机位置简单来说就是世界空间中一个指向摄像机位置的向量：\n\n``` objc\nvec3 cameraPos = vec3(0.0f, 0.0f, 3.0f);\n```\n\n2. 摄像机方向\n\n下一个需要的向量是摄像机的方向，这里指的是摄像机指向哪个方向。现在我们让摄像机指向场景原点：(0, 0, 0)。如果将两个向量相减，我们就能得到这两个向量的差。用场景原点向量减去摄像机位置向量的结果就是摄像机的指向向量。由于我们知道摄像机指向z轴负方向，但我们希望方向向量指向摄像机的z轴正方向。所以我们交换相减的顺序，就可以获得一个指向摄像机正z轴方向的向量：\n\n``` objc\nvec3 cameraTarget = vec3(0.0f, 0.0f, 0.0f);\nvec3 cameraDirection = normalize(cameraPos - cameraTarget);     // normalize 标准化向量，返回一个方向相同但单位向量为1的向量\n```\n\n> 方向向量并不是最好的名字，因为它实际上指向从它到目标向量的相反方向。\n\n3. 右轴\n\n我们需要的另一个向量是一个右向量，它代表摄像机空间的x轴的正方向。为获取右向量我们需要一个小技巧：先定义一个上向量。接下来把上向量和第二步得到的方向向量进行叉乘。两个向量叉乘的结果会同时垂直于两向量，因此我们会得到指向x轴正方向的那个向量（如果我们交换两个向量叉乘的顺序就会得到相反的指向x轴负方向的向量）：\n\n``` objc\nvec3 up = vec3(0.0f, 1.0f, 0.0f);\nvec3 cameraRight = normalize(cross(up, cameraDirection));       // cross 两个向量的向量积\n```\n\n4. 上轴\n\n现在我们已经有了x轴向量和z轴向量，获取一个指向摄像机的正y轴向量就相对简单了：我们把方向向量和右向量进行叉乘：\n\n``` objc\nvec3 cameraUp = cross(cameraDirection, cameraRight);\n```\n\n在叉乘和一些小技巧的帮助下，我们创建了所有构成观察/摄像机空间的向量。使用这些摄像机向量我们就可以创建一个`LookAt`矩阵了，它在创建摄像机的时候非常有用。\n\n### Look At\n\n使用矩阵的好处之一是如果使用3个互相垂直的轴定义了一个坐标空间，我们可以用这3个轴加一个平移向量来创建一个矩阵，并且可以用这个矩阵乘以任何向量来将其变换到那个坐标空间。这正是`LookAt`矩阵所做的，现在我们有了3个互相垂直的轴和一个定义摄像机空间的位置坐标，我们可以创建自己的`LookAt`矩阵了：\n\n![LookAt矩阵](/img/article/20190825/7.png)\n\n其中`R`是右向量，`U`是上向量，`D`是方向向量，`P`是摄像机位置向量。注意，位置向量是相反的，因为我们最终希望把世界平移到我们自身一定的相反方向。把这个`LookAt`矩阵作为观察矩阵可以很高效地把所有世界坐标变换到刚刚定义的观察空间。`LookAt`矩阵就像它的名字表达的那样：它会创建一个看着（Look at）给定目标的观察矩阵。\n\n幸运的是，GLM已经提供了这些支持。我们要做的只是定义一个摄像机位置，一个目标位置和一个表示世界空间中的上向量的向量（我们计算右向量使用的那个上向量）。接着GLM就会创建一个`LookAt`矩阵，我们可以把它当作我们的观察矩阵：\n\n``` objc\n// OpenGL ES 1.1\nGLKMatrix4 view = gluLookAt(0.0f, 0.0f, 3.0f, 0.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f);\n\n// GLKit\nGLKMatrix4 view = GLKMatrix4MakeLookAt(0.0f, 0.0f, 3.0f, 0.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f);\n``\n\n# 裁剪空间\n\n在一个顶点着色器运行的最后，OpenGL期望所有的坐标都能落在一个特定的范围内，且任何在这个范围之外的点都应该被裁剪掉（Clipped）。被裁剪掉的坐标就会被忽略，所以剩下的坐标就将变为屏幕上可见的片段。这也就是裁剪空间（Clip Space）名字的由来。\n因为将所有可见的坐标都指定在-1.0到1.0的范围内不是很直观，所以我们会指定自己的坐标集（Coordinate Set）并将它变换回标准化设备坐标系，就像OpenGL期望的那样。\n为了将顶点坐标从观察变换到裁剪空间，我们需要定义一个投影矩阵（Projection Matrix），它指定了一个范围的坐标，比如每个维度上的-1000到1000.投影矩阵接着会将在这个指定的范围内的坐标变换为标准化设备坐标的范围(-1.0, 1.0)。所有在范围外的坐标不会被映射到在-1.0到1.0的范围之间，所以会被裁剪掉。在上面这个投影矩阵所指定的范围内，坐标(1250, 500, 750)将是不可见的，这是由于它的x坐标超出了范围，它被转化为一个大于1.0的标准化设备坐标，所以被裁剪掉了。\n\n> 如果只是图元，例如三角形的一部分超出了裁剪体积，则OpenGL会重新构建这个三角形为一个或多个三角形让其能够适合这个裁剪范围。\n\n由投影矩阵创建的观察箱（Viewing Box）被称为**平截头体**（Frustum），每个出现在平截头体范围内的坐标都会最终出现在用户的屏幕上。将特定范围内的坐标转化到标准化设备坐标系的过程（而且它很容易被映射到2D观察空间坐标）被称之为投影，因为使用投影矩阵能将3D坐标投影到很容易映射到2D的标准化设备坐标系中。\n一旦所有顶点被变换到裁剪空间，最终的操作--透视除法（Perspective Division）将会执行，在这个过程中我们将位置向量的x，y，z分量分别除以向量的齐次w分量；透视除法是将4D裁剪空间坐标转换为3D标准化设备坐标的过程。这一步会在每一个顶点着色器运行的最后被自动执行。\n在这一阶段之后，最终的坐标将会被映射到屏幕空间中（使用`glViewport`中的设定），并被变换成片段。\n将观察坐标变换为裁剪坐标的投影矩阵可以为两种不同的形式，每种形式都定义了不同的平截头体。我们可以选择创建一个正射投影矩阵（Orthographic Projection Matrix）或一个透视投影矩阵（Perspective Projection Matrix）。\n\n## 正射投影\n\n正射投影矩阵定义了一个类似立方体的平接头箱，它定义了一个裁剪空间，在这空间之外的顶点都会被裁剪掉。创建一个正射投影矩阵需要指定可见平截头体的宽、高和长度。在使用正射投影矩阵变换至裁剪空间之后处于这个平截头体的所有坐标将不会被裁剪掉。它的平截头体看起来像一个容器：\n\n![正射投影](/img/article/20190825/2.png)\n\n上面的平截头体定义了可见的坐标，它由宽、高、近（Near）平面和远（Far）平面所指定。任何出现在近平面之前或远平面之后的坐标都会被裁剪掉。正射平截头体直接将平截头体内部的所有坐标映射为标准化设备坐标，因为每个向量的w分量都没有进行改变；如果w分量等于1.0，透视除法则不会改变这个坐标。\n要创建一个正射投影矩阵，我们可以使用`GLKit`中的方法：\n\n``` objc\nGLKMatrix4MakeOrtho(0.0, 800.0, 0.0, 600, 0.1, 100.0);\n```\n\n或OpenGL ES 1.1中的函数：\n\n``` objc\nglOrthof(0.0, 800.0, 0.0, 600.0, 0.1, 100.0);\n```\n\n前两个参数指定了平截头体的左右坐标，第三和第四参数指定了平截头体的底部和顶部。通过这四个参数我们定义了近平面和远平面的大小，然后第五和第六个参数则定义了近平面和远平面的距离。这个投影矩阵会将处于这些x，y，z值范围内的坐标变换为标准化设备坐标。\n正射投影矩阵直接将坐标映射到2D平面中，即屏幕中，但实际上一个直接的投影矩阵会产生不真实的结果，因为这个投影没有将透视（Perspective）考虑进去。\n\n## 透视投影\n\n我们都曾体验过实际生活中的一个场景，离我们越远的东西看起来更小。这个奇怪的效果称之为透视。透视的效果在我们看一条无限长的高速公路或铁路时尤其明显，正如下面图片显示的那样：\n\n![透视投影](/img/article/20190825/3.png)\n\n正如所看到的那样，由于透视，这两条线在很远的地方看起来会相交。这正是透视投影想要模仿的效果，它是使用透视投影矩阵来完成的。这个投影矩阵将给定的平截头体范围映射到裁剪空间，除此之外还修改了每个顶点的w值，从而使得离观察者越远的顶点坐标w分量越大。被变换到裁剪空间的坐标都会在-w到w的范围之间（任何大于这个范围的坐标都会被裁剪掉）。OpenGL要求所有可见的坐标都落在-1.0到1.0范围内，作为顶点着色器最后的输出，一次，一旦坐标在裁剪空间内之后，透视除法就被会应用到裁剪空间坐标上：\n\n![透视除法](/img/article/20190825/4.png)\n\n顶点坐标的每个分量都会除以它的w分量，距离观察者越远顶点坐标就会越小。这也是w分量非常重要的另一个原因，它能够帮助我们进行透视投影。最后的结果坐标就是处于标准化设备空间中的。\n\n要创建一个透视投影矩阵，我们可以使用`GLKit`中的方法：\n\n``` objc\nGLKMatrix4MakePerspective(GLKMathRadiansToDegrees(45), width/height, 0.1, 100.0);\n```\n\n同样，`GLKMatrix4MakePerspective`所做的其实就是创建了一个定义了可视空间的大平截头体，任何在这个平截头体以外的东西最后都不会出现在裁剪空间体积内，并且将会收到裁剪。一个透视平截头体可以被看作一个不均匀的箱子，在这个箱子内部的每个坐标都会被映射到裁剪空间上的一个点。下面是一张透视平截头体的图片：\n\n![透视平截头体](/img/article/20190825/5.png)\n\n它的第一个参数定义了`fov`的值，它表示的是视野（Field of View），并且设置了观察空间的大小。如果想要一个真实的观察效果，它的值通常设置为45.0f，但想要一个末日风格的结果可以将其设置一个更大的值。第二个参数设置了宽高比，由视口的宽除以高所得。第三和第四个参数设置了平截头体的近和远平面。我们通常设置近距离为0.1f，而远距离设置为100.0f。所有在近平面和远平面且处于平截头体内的顶点都会被渲染。\n\n> 当我们把透视矩阵的`near`值设置太大时（如10.0f），OpenGL会将靠近摄像机的坐标（在0。0f和10.0f之间）都裁剪掉，这会导致一个在游戏中很熟悉的视觉效果：在太过靠近一个物体的时候视线会直接传过去。\n\n# 把它们都组合到一起\n\n我们为上述的每一个步骤都创建了一个变换矩阵：模型矩阵、观察矩阵和投影矩阵。一个顶点坐标将会根据以下过程被变换到裁剪坐标：V<sub>clip</sub> = M<sub>projection</sub>p * M<sub>view</sub> * M<sub>model</sub> * M<sub>local</sub>。\n注意矩阵运算的顺序是相反的。最后的顶点应该被赋值到顶点着色器中的`gl_Position`，OpenGL将会自动进行透视除法和裁剪。\n\n> 然后呢？\n> 顶点着色器的输出要求所有的顶点都在裁剪空间内，这正是我们刚才使用变换矩阵所做的。OpenGL然后对裁剪坐标执行透视除法从而将它们变换到标准化设备坐标。OpenGL会使用`glViewport`内部的参数来标准化设备坐标映射到屏幕坐标，每个坐标都关联了一个屏幕上的点。这个过程称为视口变换。\n\n# 举个例子\n\n我们创建一个立方体，利用摄像机视角对其进行旋转拍摄，主要的矩阵变换代码如下：\n\n``` objc\n- (void)update {\n    NSTimeInterval detalTime = self.timeSinceLastUpdate;\n    self.elapsedTime += detalTime;\n    \n    float varyingFactor = (sin(self.elapsedTime) + 1) / 2.0;\n    float aspect = self.view.frame.size.width / self.view.frame.size.height;\n\n    GLKMatrix4 perspectiveMatrix = GLKMatrix4MakePerspective(GLKMathDegreesToRadians(45), aspect, 0.1, 100.0);  // 投影矩阵\n    GLKMatrix4 cameraMatrix = GLKMatrix4MakeLookAt(0, 0, 5 * (varyingFactor + 1), 0, 0, 0, 0, 1, 0);    // 观察矩阵\n    GLKMatrix4 rotateMatrix = GLKMatrix4MakeRotation(varyingFactor * M_PI * 2, 1, 1, 1);    // 模型矩阵\n    self.projectionMatrix = GLKMatrix4Multiply(cameraMatrix, rotateMatrix);\n    self.projectionMatrix = GLKMatrix4Multiply(perspectiveMatrix, self.projectionMatrix);\n}\n\n- (void)glkView:(GLKView *)view drawInRect:(CGRect)rect {\n    \n    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n    glClearColor(0.0, 0.0, 0.0, 1.0);\n\n    glUniformMatrix4fv(mvpMatrixlocation, 1, 0, self.projectionMatrix.m);\n    \n    glBindVertexArray(vao);\n    glDrawElements(GL_TRIANGLES, 36, GL_UNSIGNED_SHORT, 0);\n}\n```\n\n# 总结\n\n这篇文章主要针对物体根据一系列的坐标系转换，最终转化为屏幕上最终的渲染产物过程中的坐标系转换的学习。\n\n","slug":"2019/opengl-es-coordinated-system-0825","published":1,"updated":"2022-01-10T09:04:52.804Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cky8gmc46000kd1qh91whodvy","content":"<blockquote>\n<p>OpenGL ES希望在每次顶点着色器运行后，我们可见的所有顶点都为标准化设备坐标。也就是说，每个顶点的x，y，z坐标都应该在-1.0到1.0之间，超出这个坐标范围的顶点都将不可见。我们通常会自己设定一个坐标的范围，之后再在顶点着色器中将这些坐标变换为标准化设备坐标。然后将这些标准坐标传入光栅器，将它们变换为屏幕上的二维坐标或像素。<br>\n将坐标变换为标准化设备坐标，接着再转化为屏幕坐标的过程通常是分步进行的，也就是类似于流水线那样子。在流水线中，物体的顶点在最终转化为屏幕坐标之前还会被变换到多个坐标系统。将物体的坐标变换到几个过渡坐标系的优点在于，在这些特定的坐标系统中，一些操作或运算更加方便和容易，这一点很快就会变得很明显。对我们来说比较重要的总共有5个不同的坐标系统：</p>\n<ul>\n<li>局部空间（Local Space，或者称为物体空间（Object Space））</li>\n<li>世界空间（World Space）</li>\n<li>观察空间（View Space，或者称为视觉空间（Eye Space））</li>\n<li>裁剪空间（Clip Space）</li>\n<li>屏幕空间（Screen Space）</li>\n</ul>\n<p>这就是一个顶点在最终被转化为片段之前需要经历的所有不同状态。</p>\n</blockquote>\n<h1 id=\"概述\">概述</h1>\n<p>为了将坐标从一个坐标系变换到另一个坐标系，我们需要用到几个变换矩阵，最重要的几个分别是模型（Model）、观察（View）、投影（Projection）三个矩阵。我们的顶点坐标起始于局部空间（Local Space），在这里它称为局部坐标（Local Coordinate），它在之后会变为世界坐标（World Coordinate），观察坐标（View Coordinate），裁剪坐标（Clip Coordinate），并最后以屏幕坐标（Screen Coordinate）的形式结束。如下图：</p>\n<p><img src=\"/img/article/20190825/1.png\" alt=\"坐标系统\"></p>\n<ol>\n<li>局部坐标是对象相对于局部原点的坐标，也是物体起始的坐标。</li>\n<li>下一步是将局部坐标转换为世界空间坐标，世界空间坐标是处于一个更大的空间范围的。这些坐标相对于世界的全局原点，它们会和其他物体一起相对于世界的原点进行摆放。</li>\n<li>接下来我们将世界坐标转换为观察空间坐标，使得每个坐标都是从摄像机或者说观察者的角度进行观察的。</li>\n<li>坐标到达观察空间之后，我们需要将其投影到裁剪坐标。裁剪坐标会被处理至-1.0到1.0的范围内，并判断哪些顶点将会出现在屏幕上。</li>\n<li>最后，我们将裁剪坐标变换为屏幕坐标，我们将使用一个叫做视口变换（Viewport Transform）的过程。视口变换将位于-1.0到1.0范围的坐标变换到由<code>glViewport</code>函数所定义的坐标范围内。最后变换出来的坐标会送到光栅器，并将其转换为片段。</li>\n</ol>\n<p>我们之所以将顶点变换到各个不同的空间的原因是有些操作在特定的坐标系统中才有意义且更方便。例如，当需要物体进行修改的时候，在局部空间中来操作会更说得通；如果要对一个物体做出一个相对于其它物体位置的操作时，在世界坐标系中来做这个才更说得通，等等。</p>\n<h1 id=\"局部空间\">局部空间</h1>\n<p>局部空间是指物体所在的坐标空间，即对象最开始所在的地方。想象你在一个建模软件中创建一个立方体。创建的立方体的原点有可能位于(0, 0, 0)，即便它有可能最后在程序中处于完全不同的位置。甚至有可能你创建的所有模型都以(0, 0, 0)为初始位置（然后它们最终出现在世界的不同位置）。所以，模型的所有顶点都是在局部空间中：它们相对于物体来说都是局部的。</p>\n<h1 id=\"世界空间\">世界空间</h1>\n<p>如果我们将我们所有的物体导入到当前程序中，它们有可能会全挤在世界的原点(0, 0, 0)上，这并不是我们想要的结果。我们想为每一个物体定义一个位置，从而能在更大的世界当中放置它们。世界空间中的坐标正如其名：是指顶点相对于世界的坐标。如果我们希望将物体分散在世界上摆放，这就是我们希望物体变换到的空间。物体的坐标将会从局部变换到世界空间；该变换是由模型矩阵（Model Matrix）实现的。<br>\n模型矩阵是一种变换矩阵，它能通过对物体进行位移、缩放、旋转来将它置于它本应该在的位置或朝向。我们可以将它想象为变换一个房子，需要先将它缩小（它在局部空间中太大了），并将其移至郊区的一个小镇，然后在y轴上往左旋转一点以搭配附近的房子。</p>\n<h1 id=\"观察空间\">观察空间</h1>\n<p>观察空间经常被人们称之为OpenGL的摄像机（Camera）(所以有时也称为摄像机空间（Camera Space）或视觉空间（Eye Space）)。观察空间是将世界空间坐标转化为用户视野前方的坐标而产生的结果。因此观察空间就是从摄像机的视角所观察到的空间。而这通常是由一系列的位移和旋转的组合来完成，平移/旋转场景从而使得特定的对象被变换到摄像机的前方。这些组合在一起的变换通常存储在一个观察矩阵（View Matrix）里，它被用来将世界坐标变换到观察空间。</p>\n<h2 id=\"摄像机\">摄像机</h2>\n<blockquote>\n<p>OpenGL本身没有摄像机（Camera）的概念，但我们可以通过把场景中的所有物体往相反方向移动的方式来模拟出摄像机，产生一种我们在移动的感觉，而不是场景在移动。</p>\n</blockquote>\n<h3 id=\"摄像机观察空间\">摄像机/观察空间</h3>\n<p>当我们讨论摄像机/观察空间（Camera/View Space）的时候，是在讨论以摄像机的视角作为场景原点时场景中所有的顶点坐标：观察矩阵把所有的世界坐标转换为相对于摄像机位置与方向的观察坐标。要定义一个摄像机，我们需要它在世界空间中的位置、观察的方向、一个指向它右侧的向量以及一个指向它上方的向量（我们实际上创建了一个三个三位轴相互垂直的、以摄像机的位置为原点的坐标系）。</p>\n<p><img src=\"/img/article/20190825/6.png\" alt=\"摄像机/观察空间\"></p>\n<ol>\n<li>摄像机位置</li>\n</ol>\n<p>获取摄像机位置很简单。摄像机位置简单来说就是世界空间中一个指向摄像机位置的向量：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vec3 cameraPos = vec3(<span class=\"number\">0.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">3.0</span>f);</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>摄像机方向</li>\n</ol>\n<p>下一个需要的向量是摄像机的方向，这里指的是摄像机指向哪个方向。现在我们让摄像机指向场景原点：(0, 0, 0)。如果将两个向量相减，我们就能得到这两个向量的差。用场景原点向量减去摄像机位置向量的结果就是摄像机的指向向量。由于我们知道摄像机指向z轴负方向，但我们希望方向向量指向摄像机的z轴正方向。所以我们交换相减的顺序，就可以获得一个指向摄像机正z轴方向的向量：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vec3 cameraTarget = vec3(<span class=\"number\">0.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">0.0</span>f);</span><br><span class=\"line\">vec3 cameraDirection = normalize(cameraPos - cameraTarget);     <span class=\"comment\">// normalize 标准化向量，返回一个方向相同但单位向量为1的向量</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>方向向量并不是最好的名字，因为它实际上指向从它到目标向量的相反方向。</p>\n</blockquote>\n<ol start=\"3\">\n<li>右轴</li>\n</ol>\n<p>我们需要的另一个向量是一个右向量，它代表摄像机空间的x轴的正方向。为获取右向量我们需要一个小技巧：先定义一个上向量。接下来把上向量和第二步得到的方向向量进行叉乘。两个向量叉乘的结果会同时垂直于两向量，因此我们会得到指向x轴正方向的那个向量（如果我们交换两个向量叉乘的顺序就会得到相反的指向x轴负方向的向量）：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vec3 up = vec3(<span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f, <span class=\"number\">0.0</span>f);</span><br><span class=\"line\">vec3 cameraRight = normalize(cross(up, cameraDirection));       <span class=\"comment\">// cross 两个向量的向量积</span></span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>上轴</li>\n</ol>\n<p>现在我们已经有了x轴向量和z轴向量，获取一个指向摄像机的正y轴向量就相对简单了：我们把方向向量和右向量进行叉乘：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vec3 cameraUp = cross(cameraDirection, cameraRight);</span><br></pre></td></tr></table></figure>\n<p>在叉乘和一些小技巧的帮助下，我们创建了所有构成观察/摄像机空间的向量。使用这些摄像机向量我们就可以创建一个<code>LookAt</code>矩阵了，它在创建摄像机的时候非常有用。</p>\n<h3 id=\"look-at\">Look At</h3>\n<p>使用矩阵的好处之一是如果使用3个互相垂直的轴定义了一个坐标空间，我们可以用这3个轴加一个平移向量来创建一个矩阵，并且可以用这个矩阵乘以任何向量来将其变换到那个坐标空间。这正是<code>LookAt</code>矩阵所做的，现在我们有了3个互相垂直的轴和一个定义摄像机空间的位置坐标，我们可以创建自己的<code>LookAt</code>矩阵了：</p>\n<p><img src=\"/img/article/20190825/7.png\" alt=\"LookAt矩阵\"></p>\n<p>其中<code>R</code>是右向量，<code>U</code>是上向量，<code>D</code>是方向向量，<code>P</code>是摄像机位置向量。注意，位置向量是相反的，因为我们最终希望把世界平移到我们自身一定的相反方向。把这个<code>LookAt</code>矩阵作为观察矩阵可以很高效地把所有世界坐标变换到刚刚定义的观察空间。<code>LookAt</code>矩阵就像它的名字表达的那样：它会创建一个看着（Look at）给定目标的观察矩阵。</p>\n<p>幸运的是，GLM已经提供了这些支持。我们要做的只是定义一个摄像机位置，一个目标位置和一个表示世界空间中的上向量的向量（我们计算右向量使用的那个上向量）。接着GLM就会创建一个<code>LookAt</code>矩阵，我们可以把它当作我们的观察矩阵：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// OpenGL ES 1.1</span></span><br><span class=\"line\">GLKMatrix4 view = gluLookAt(<span class=\"number\">0.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">3.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f, <span class=\"number\">0.0</span>f);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// GLKit</span></span><br><span class=\"line\">GLKMatrix4 view = GLKMatrix4MakeLookAt(<span class=\"number\">0.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">3.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f, <span class=\"number\">0.0</span>f);</span><br><span class=\"line\">``</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\"># 裁剪空间</span></span><br><span class=\"line\"></span><br><span class=\"line\">在一个顶点着色器运行的最后，OpenGL期望所有的坐标都能落在一个特定的范围内，且任何在这个范围之外的点都应该被裁剪掉（Clipped）。被裁剪掉的坐标就会被忽略，所以剩下的坐标就将变为屏幕上可见的片段。这也就是裁剪空间（Clip Space）名字的由来。</span><br><span class=\"line\">因为将所有可见的坐标都指定在<span class=\"number\">-1.0</span>到<span class=\"number\">1.0</span>的范围内不是很直观，所以我们会指定自己的坐标集（Coordinate Set）并将它变换回标准化设备坐标系，就像OpenGL期望的那样。</span><br><span class=\"line\">为了将顶点坐标从观察变换到裁剪空间，我们需要定义一个投影矩阵（Projection Matrix），它指定了一个范围的坐标，比如每个维度上的<span class=\"number\">-1000</span>到<span class=\"number\">1000.</span>投影矩阵接着会将在这个指定的范围内的坐标变换为标准化设备坐标的范围(<span class=\"number\">-1.0</span>, <span class=\"number\">1.0</span>)。所有在范围外的坐标不会被映射到在<span class=\"number\">-1.0</span>到<span class=\"number\">1.0</span>的范围之间，所以会被裁剪掉。在上面这个投影矩阵所指定的范围内，坐标(<span class=\"number\">1250</span>, <span class=\"number\">500</span>, <span class=\"number\">750</span>)将是不可见的，这是由于它的x坐标超出了范围，它被转化为一个大于<span class=\"number\">1.0</span>的标准化设备坐标，所以被裁剪掉了。</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; 如果只是图元，例如三角形的一部分超出了裁剪体积，则OpenGL会重新构建这个三角形为一个或多个三角形让其能够适合这个裁剪范围。</span><br><span class=\"line\"></span><br><span class=\"line\">由投影矩阵创建的观察箱（Viewing Box）被称为**平截头体**（Frustum），每个出现在平截头体范围内的坐标都会最终出现在用户的屏幕上。将特定范围内的坐标转化到标准化设备坐标系的过程（而且它很容易被映射到<span class=\"number\">2</span>D观察空间坐标）被称之为投影，因为使用投影矩阵能将<span class=\"number\">3</span>D坐标投影到很容易映射到<span class=\"number\">2</span>D的标准化设备坐标系中。</span><br><span class=\"line\">一旦所有顶点被变换到裁剪空间，最终的操作--透视除法（Perspective Division）将会执行，在这个过程中我们将位置向量的x，y，z分量分别除以向量的齐次w分量；透视除法是将<span class=\"number\">4</span>D裁剪空间坐标转换为<span class=\"number\">3</span>D标准化设备坐标的过程。这一步会在每一个顶点着色器运行的最后被自动执行。</span><br><span class=\"line\">在这一阶段之后，最终的坐标将会被映射到屏幕空间中（使用`glViewport`中的设定），并被变换成片段。</span><br><span class=\"line\">将观察坐标变换为裁剪坐标的投影矩阵可以为两种不同的形式，每种形式都定义了不同的平截头体。我们可以选择创建一个正射投影矩阵（Orthographic Projection Matrix）或一个透视投影矩阵（Perspective Projection Matrix）。</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">## 正射投影</span></span><br><span class=\"line\"></span><br><span class=\"line\">正射投影矩阵定义了一个类似立方体的平接头箱，它定义了一个裁剪空间，在这空间之外的顶点都会被裁剪掉。创建一个正射投影矩阵需要指定可见平截头体的宽、高和长度。在使用正射投影矩阵变换至裁剪空间之后处于这个平截头体的所有坐标将不会被裁剪掉。它的平截头体看起来像一个容器：</span><br><span class=\"line\"></span><br><span class=\"line\">![正射投影](/img/article/<span class=\"number\">20190825</span>/<span class=\"number\">2.</span>png)</span><br><span class=\"line\"></span><br><span class=\"line\">上面的平截头体定义了可见的坐标，它由宽、高、近（Near）平面和远（Far）平面所指定。任何出现在近平面之前或远平面之后的坐标都会被裁剪掉。正射平截头体直接将平截头体内部的所有坐标映射为标准化设备坐标，因为每个向量的w分量都没有进行改变；如果w分量等于<span class=\"number\">1.0</span>，透视除法则不会改变这个坐标。</span><br><span class=\"line\">要创建一个正射投影矩阵，我们可以使用`GLKit`中的方法：</span><br><span class=\"line\"></span><br><span class=\"line\">``` objc</span><br><span class=\"line\">GLKMatrix4MakeOrtho(<span class=\"number\">0.0</span>, <span class=\"number\">800.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">600</span>, <span class=\"number\">0.1</span>, <span class=\"number\">100.0</span>);</span><br></pre></td></tr></table></figure>\n<p>或OpenGL ES 1.1中的函数：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">glOrthof(<span class=\"number\">0.0</span>, <span class=\"number\">800.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">600.0</span>, <span class=\"number\">0.1</span>, <span class=\"number\">100.0</span>);</span><br></pre></td></tr></table></figure>\n<p>前两个参数指定了平截头体的左右坐标，第三和第四参数指定了平截头体的底部和顶部。通过这四个参数我们定义了近平面和远平面的大小，然后第五和第六个参数则定义了近平面和远平面的距离。这个投影矩阵会将处于这些x，y，z值范围内的坐标变换为标准化设备坐标。<br>\n正射投影矩阵直接将坐标映射到2D平面中，即屏幕中，但实际上一个直接的投影矩阵会产生不真实的结果，因为这个投影没有将透视（Perspective）考虑进去。</p>\n<h2 id=\"透视投影\">透视投影</h2>\n<p>我们都曾体验过实际生活中的一个场景，离我们越远的东西看起来更小。这个奇怪的效果称之为透视。透视的效果在我们看一条无限长的高速公路或铁路时尤其明显，正如下面图片显示的那样：</p>\n<p><img src=\"/img/article/20190825/3.png\" alt=\"透视投影\"></p>\n<p>正如所看到的那样，由于透视，这两条线在很远的地方看起来会相交。这正是透视投影想要模仿的效果，它是使用透视投影矩阵来完成的。这个投影矩阵将给定的平截头体范围映射到裁剪空间，除此之外还修改了每个顶点的w值，从而使得离观察者越远的顶点坐标w分量越大。被变换到裁剪空间的坐标都会在-w到w的范围之间（任何大于这个范围的坐标都会被裁剪掉）。OpenGL要求所有可见的坐标都落在-1.0到1.0范围内，作为顶点着色器最后的输出，一次，一旦坐标在裁剪空间内之后，透视除法就被会应用到裁剪空间坐标上：</p>\n<p><img src=\"/img/article/20190825/4.png\" alt=\"透视除法\"></p>\n<p>顶点坐标的每个分量都会除以它的w分量，距离观察者越远顶点坐标就会越小。这也是w分量非常重要的另一个原因，它能够帮助我们进行透视投影。最后的结果坐标就是处于标准化设备空间中的。</p>\n<p>要创建一个透视投影矩阵，我们可以使用<code>GLKit</code>中的方法：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GLKMatrix4MakePerspective(GLKMathRadiansToDegrees(<span class=\"number\">45</span>), width/height, <span class=\"number\">0.1</span>, <span class=\"number\">100.0</span>);</span><br></pre></td></tr></table></figure>\n<p>同样，<code>GLKMatrix4MakePerspective</code>所做的其实就是创建了一个定义了可视空间的大平截头体，任何在这个平截头体以外的东西最后都不会出现在裁剪空间体积内，并且将会收到裁剪。一个透视平截头体可以被看作一个不均匀的箱子，在这个箱子内部的每个坐标都会被映射到裁剪空间上的一个点。下面是一张透视平截头体的图片：</p>\n<p><img src=\"/img/article/20190825/5.png\" alt=\"透视平截头体\"></p>\n<p>它的第一个参数定义了<code>fov</code>的值，它表示的是视野（Field of View），并且设置了观察空间的大小。如果想要一个真实的观察效果，它的值通常设置为45.0f，但想要一个末日风格的结果可以将其设置一个更大的值。第二个参数设置了宽高比，由视口的宽除以高所得。第三和第四个参数设置了平截头体的近和远平面。我们通常设置近距离为0.1f，而远距离设置为100.0f。所有在近平面和远平面且处于平截头体内的顶点都会被渲染。</p>\n<blockquote>\n<p>当我们把透视矩阵的<code>near</code>值设置太大时（如10.0f），OpenGL会将靠近摄像机的坐标（在0。0f和10.0f之间）都裁剪掉，这会导致一个在游戏中很熟悉的视觉效果：在太过靠近一个物体的时候视线会直接传过去。</p>\n</blockquote>\n<h1 id=\"把它们都组合到一起\">把它们都组合到一起</h1>\n<p>我们为上述的每一个步骤都创建了一个变换矩阵：模型矩阵、观察矩阵和投影矩阵。一个顶点坐标将会根据以下过程被变换到裁剪坐标：V<sub>clip</sub> = M<sub>projection</sub>p * M<sub>view</sub> * M<sub>model</sub> * M<sub>local</sub>。<br>\n注意矩阵运算的顺序是相反的。最后的顶点应该被赋值到顶点着色器中的<code>gl_Position</code>，OpenGL将会自动进行透视除法和裁剪。</p>\n<blockquote>\n<p>然后呢？<br>\n顶点着色器的输出要求所有的顶点都在裁剪空间内，这正是我们刚才使用变换矩阵所做的。OpenGL然后对裁剪坐标执行透视除法从而将它们变换到标准化设备坐标。OpenGL会使用<code>glViewport</code>内部的参数来标准化设备坐标映射到屏幕坐标，每个坐标都关联了一个屏幕上的点。这个过程称为视口变换。</p>\n</blockquote>\n<h1 id=\"举个例子\">举个例子</h1>\n<p>我们创建一个立方体，利用摄像机视角对其进行旋转拍摄，主要的矩阵变换代码如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)update &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSTimeInterval</span> detalTime = <span class=\"keyword\">self</span>.timeSinceLastUpdate;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.elapsedTime += detalTime;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">float</span> varyingFactor = (sin(<span class=\"keyword\">self</span>.elapsedTime) + <span class=\"number\">1</span>) / <span class=\"number\">2.0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">float</span> aspect = <span class=\"keyword\">self</span>.view.frame.size.width / <span class=\"keyword\">self</span>.view.frame.size.height;</span><br><span class=\"line\"></span><br><span class=\"line\">    GLKMatrix4 perspectiveMatrix = GLKMatrix4MakePerspective(GLKMathDegreesToRadians(<span class=\"number\">45</span>), aspect, <span class=\"number\">0.1</span>, <span class=\"number\">100.0</span>);  <span class=\"comment\">// 投影矩阵</span></span><br><span class=\"line\">    GLKMatrix4 cameraMatrix = GLKMatrix4MakeLookAt(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">5</span> * (varyingFactor + <span class=\"number\">1</span>), <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>);    <span class=\"comment\">// 观察矩阵</span></span><br><span class=\"line\">    GLKMatrix4 rotateMatrix = GLKMatrix4MakeRotation(varyingFactor * M_PI * <span class=\"number\">2</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>);    <span class=\"comment\">// 模型矩阵</span></span><br><span class=\"line\">    <span class=\"keyword\">self</span>.projectionMatrix = GLKMatrix4Multiply(cameraMatrix, rotateMatrix);</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.projectionMatrix = GLKMatrix4Multiply(perspectiveMatrix, <span class=\"keyword\">self</span>.projectionMatrix);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)glkView:(GLKView *)view drawInRect:(<span class=\"built_in\">CGRect</span>)rect &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span><br><span class=\"line\">    glClearColor(<span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    glUniformMatrix4fv(mvpMatrixlocation, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"keyword\">self</span>.projectionMatrix.m);</span><br><span class=\"line\">    </span><br><span class=\"line\">    glBindVertexArray(vao);</span><br><span class=\"line\">    glDrawElements(GL_TRIANGLES, <span class=\"number\">36</span>, GL_UNSIGNED_SHORT, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"总结\">总结</h1>\n<p>这篇文章主要针对物体根据一系列的坐标系转换，最终转化为屏幕上最终的渲染产物过程中的坐标系转换的学习。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>OpenGL ES希望在每次顶点着色器运行后，我们可见的所有顶点都为标准化设备坐标。也就是说，每个顶点的x，y，z坐标都应该在-1.0到1.0之间，超出这个坐标范围的顶点都将不可见。我们通常会自己设定一个坐标的范围，之后再在顶点着色器中将这些坐标变换为标准化设备坐标。然后将这些标准坐标传入光栅器，将它们变换为屏幕上的二维坐标或像素。<br>\n将坐标变换为标准化设备坐标，接着再转化为屏幕坐标的过程通常是分步进行的，也就是类似于流水线那样子。在流水线中，物体的顶点在最终转化为屏幕坐标之前还会被变换到多个坐标系统。将物体的坐标变换到几个过渡坐标系的优点在于，在这些特定的坐标系统中，一些操作或运算更加方便和容易，这一点很快就会变得很明显。对我们来说比较重要的总共有5个不同的坐标系统：</p>\n<ul>\n<li>局部空间（Local Space，或者称为物体空间（Object Space））</li>\n<li>世界空间（World Space）</li>\n<li>观察空间（View Space，或者称为视觉空间（Eye Space））</li>\n<li>裁剪空间（Clip Space）</li>\n<li>屏幕空间（Screen Space）</li>\n</ul>\n<p>这就是一个顶点在最终被转化为片段之前需要经历的所有不同状态。</p>\n</blockquote>\n<h1>概述</h1>\n<p>为了将坐标从一个坐标系变换到另一个坐标系，我们需要用到几个变换矩阵，最重要的几个分别是模型（Model）、观察（View）、投影（Projection）三个矩阵。我们的顶点坐标起始于局部空间（Local Space），在这里它称为局部坐标（Local Coordinate），它在之后会变为世界坐标（World Coordinate），观察坐标（View Coordinate），裁剪坐标（Clip Coordinate），并最后以屏幕坐标（Screen Coordinate）的形式结束。如下图：</p>\n<p><img src=\"/img/article/20190825/1.png\" alt=\"坐标系统\"></p>\n<ol>\n<li>局部坐标是对象相对于局部原点的坐标，也是物体起始的坐标。</li>\n<li>下一步是将局部坐标转换为世界空间坐标，世界空间坐标是处于一个更大的空间范围的。这些坐标相对于世界的全局原点，它们会和其他物体一起相对于世界的原点进行摆放。</li>\n<li>接下来我们将世界坐标转换为观察空间坐标，使得每个坐标都是从摄像机或者说观察者的角度进行观察的。</li>\n<li>坐标到达观察空间之后，我们需要将其投影到裁剪坐标。裁剪坐标会被处理至-1.0到1.0的范围内，并判断哪些顶点将会出现在屏幕上。</li>\n<li>最后，我们将裁剪坐标变换为屏幕坐标，我们将使用一个叫做视口变换（Viewport Transform）的过程。视口变换将位于-1.0到1.0范围的坐标变换到由<code>glViewport</code>函数所定义的坐标范围内。最后变换出来的坐标会送到光栅器，并将其转换为片段。</li>\n</ol>\n<p>我们之所以将顶点变换到各个不同的空间的原因是有些操作在特定的坐标系统中才有意义且更方便。例如，当需要物体进行修改的时候，在局部空间中来操作会更说得通；如果要对一个物体做出一个相对于其它物体位置的操作时，在世界坐标系中来做这个才更说得通，等等。</p>\n<h1>局部空间</h1>\n<p>局部空间是指物体所在的坐标空间，即对象最开始所在的地方。想象你在一个建模软件中创建一个立方体。创建的立方体的原点有可能位于(0, 0, 0)，即便它有可能最后在程序中处于完全不同的位置。甚至有可能你创建的所有模型都以(0, 0, 0)为初始位置（然后它们最终出现在世界的不同位置）。所以，模型的所有顶点都是在局部空间中：它们相对于物体来说都是局部的。</p>\n<h1>世界空间</h1>\n<p>如果我们将我们所有的物体导入到当前程序中，它们有可能会全挤在世界的原点(0, 0, 0)上，这并不是我们想要的结果。我们想为每一个物体定义一个位置，从而能在更大的世界当中放置它们。世界空间中的坐标正如其名：是指顶点相对于世界的坐标。如果我们希望将物体分散在世界上摆放，这就是我们希望物体变换到的空间。物体的坐标将会从局部变换到世界空间；该变换是由模型矩阵（Model Matrix）实现的。<br>\n模型矩阵是一种变换矩阵，它能通过对物体进行位移、缩放、旋转来将它置于它本应该在的位置或朝向。我们可以将它想象为变换一个房子，需要先将它缩小（它在局部空间中太大了），并将其移至郊区的一个小镇，然后在y轴上往左旋转一点以搭配附近的房子。</p>\n<h1>观察空间</h1>\n<p>观察空间经常被人们称之为OpenGL的摄像机（Camera）(所以有时也称为摄像机空间（Camera Space）或视觉空间（Eye Space）)。观察空间是将世界空间坐标转化为用户视野前方的坐标而产生的结果。因此观察空间就是从摄像机的视角所观察到的空间。而这通常是由一系列的位移和旋转的组合来完成，平移/旋转场景从而使得特定的对象被变换到摄像机的前方。这些组合在一起的变换通常存储在一个观察矩阵（View Matrix）里，它被用来将世界坐标变换到观察空间。</p>\n<h2>摄像机</h2>\n<blockquote>\n<p>OpenGL本身没有摄像机（Camera）的概念，但我们可以通过把场景中的所有物体往相反方向移动的方式来模拟出摄像机，产生一种我们在移动的感觉，而不是场景在移动。</p>\n</blockquote>\n<h3>摄像机/观察空间</h3>\n<p>当我们讨论摄像机/观察空间（Camera/View Space）的时候，是在讨论以摄像机的视角作为场景原点时场景中所有的顶点坐标：观察矩阵把所有的世界坐标转换为相对于摄像机位置与方向的观察坐标。要定义一个摄像机，我们需要它在世界空间中的位置、观察的方向、一个指向它右侧的向量以及一个指向它上方的向量（我们实际上创建了一个三个三位轴相互垂直的、以摄像机的位置为原点的坐标系）。</p>\n<p><img src=\"/img/article/20190825/6.png\" alt=\"摄像机/观察空间\"></p>\n<ol>\n<li>摄像机位置</li>\n</ol>\n<p>获取摄像机位置很简单。摄像机位置简单来说就是世界空间中一个指向摄像机位置的向量：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vec3 cameraPos = vec3(<span class=\"number\">0.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">3.0</span>f);</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>摄像机方向</li>\n</ol>\n<p>下一个需要的向量是摄像机的方向，这里指的是摄像机指向哪个方向。现在我们让摄像机指向场景原点：(0, 0, 0)。如果将两个向量相减，我们就能得到这两个向量的差。用场景原点向量减去摄像机位置向量的结果就是摄像机的指向向量。由于我们知道摄像机指向z轴负方向，但我们希望方向向量指向摄像机的z轴正方向。所以我们交换相减的顺序，就可以获得一个指向摄像机正z轴方向的向量：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vec3 cameraTarget = vec3(<span class=\"number\">0.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">0.0</span>f);</span><br><span class=\"line\">vec3 cameraDirection = normalize(cameraPos - cameraTarget);     <span class=\"comment\">// normalize 标准化向量，返回一个方向相同但单位向量为1的向量</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>方向向量并不是最好的名字，因为它实际上指向从它到目标向量的相反方向。</p>\n</blockquote>\n<ol start=\"3\">\n<li>右轴</li>\n</ol>\n<p>我们需要的另一个向量是一个右向量，它代表摄像机空间的x轴的正方向。为获取右向量我们需要一个小技巧：先定义一个上向量。接下来把上向量和第二步得到的方向向量进行叉乘。两个向量叉乘的结果会同时垂直于两向量，因此我们会得到指向x轴正方向的那个向量（如果我们交换两个向量叉乘的顺序就会得到相反的指向x轴负方向的向量）：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vec3 up = vec3(<span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f, <span class=\"number\">0.0</span>f);</span><br><span class=\"line\">vec3 cameraRight = normalize(cross(up, cameraDirection));       <span class=\"comment\">// cross 两个向量的向量积</span></span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>上轴</li>\n</ol>\n<p>现在我们已经有了x轴向量和z轴向量，获取一个指向摄像机的正y轴向量就相对简单了：我们把方向向量和右向量进行叉乘：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vec3 cameraUp = cross(cameraDirection, cameraRight);</span><br></pre></td></tr></table></figure>\n<p>在叉乘和一些小技巧的帮助下，我们创建了所有构成观察/摄像机空间的向量。使用这些摄像机向量我们就可以创建一个<code>LookAt</code>矩阵了，它在创建摄像机的时候非常有用。</p>\n<h3>Look At</h3>\n<p>使用矩阵的好处之一是如果使用3个互相垂直的轴定义了一个坐标空间，我们可以用这3个轴加一个平移向量来创建一个矩阵，并且可以用这个矩阵乘以任何向量来将其变换到那个坐标空间。这正是<code>LookAt</code>矩阵所做的，现在我们有了3个互相垂直的轴和一个定义摄像机空间的位置坐标，我们可以创建自己的<code>LookAt</code>矩阵了：</p>\n<p><img src=\"/img/article/20190825/7.png\" alt=\"LookAt矩阵\"></p>\n<p>其中<code>R</code>是右向量，<code>U</code>是上向量，<code>D</code>是方向向量，<code>P</code>是摄像机位置向量。注意，位置向量是相反的，因为我们最终希望把世界平移到我们自身一定的相反方向。把这个<code>LookAt</code>矩阵作为观察矩阵可以很高效地把所有世界坐标变换到刚刚定义的观察空间。<code>LookAt</code>矩阵就像它的名字表达的那样：它会创建一个看着（Look at）给定目标的观察矩阵。</p>\n<p>幸运的是，GLM已经提供了这些支持。我们要做的只是定义一个摄像机位置，一个目标位置和一个表示世界空间中的上向量的向量（我们计算右向量使用的那个上向量）。接着GLM就会创建一个<code>LookAt</code>矩阵，我们可以把它当作我们的观察矩阵：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// OpenGL ES 1.1</span></span><br><span class=\"line\">GLKMatrix4 view = gluLookAt(<span class=\"number\">0.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">3.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f, <span class=\"number\">0.0</span>f);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// GLKit</span></span><br><span class=\"line\">GLKMatrix4 view = GLKMatrix4MakeLookAt(<span class=\"number\">0.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">3.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f, <span class=\"number\">0.0</span>f);</span><br><span class=\"line\">``</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\"># 裁剪空间</span></span><br><span class=\"line\"></span><br><span class=\"line\">在一个顶点着色器运行的最后，OpenGL期望所有的坐标都能落在一个特定的范围内，且任何在这个范围之外的点都应该被裁剪掉（Clipped）。被裁剪掉的坐标就会被忽略，所以剩下的坐标就将变为屏幕上可见的片段。这也就是裁剪空间（Clip Space）名字的由来。</span><br><span class=\"line\">因为将所有可见的坐标都指定在<span class=\"number\">-1.0</span>到<span class=\"number\">1.0</span>的范围内不是很直观，所以我们会指定自己的坐标集（Coordinate Set）并将它变换回标准化设备坐标系，就像OpenGL期望的那样。</span><br><span class=\"line\">为了将顶点坐标从观察变换到裁剪空间，我们需要定义一个投影矩阵（Projection Matrix），它指定了一个范围的坐标，比如每个维度上的<span class=\"number\">-1000</span>到<span class=\"number\">1000.</span>投影矩阵接着会将在这个指定的范围内的坐标变换为标准化设备坐标的范围(<span class=\"number\">-1.0</span>, <span class=\"number\">1.0</span>)。所有在范围外的坐标不会被映射到在<span class=\"number\">-1.0</span>到<span class=\"number\">1.0</span>的范围之间，所以会被裁剪掉。在上面这个投影矩阵所指定的范围内，坐标(<span class=\"number\">1250</span>, <span class=\"number\">500</span>, <span class=\"number\">750</span>)将是不可见的，这是由于它的x坐标超出了范围，它被转化为一个大于<span class=\"number\">1.0</span>的标准化设备坐标，所以被裁剪掉了。</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; 如果只是图元，例如三角形的一部分超出了裁剪体积，则OpenGL会重新构建这个三角形为一个或多个三角形让其能够适合这个裁剪范围。</span><br><span class=\"line\"></span><br><span class=\"line\">由投影矩阵创建的观察箱（Viewing Box）被称为**平截头体**（Frustum），每个出现在平截头体范围内的坐标都会最终出现在用户的屏幕上。将特定范围内的坐标转化到标准化设备坐标系的过程（而且它很容易被映射到<span class=\"number\">2</span>D观察空间坐标）被称之为投影，因为使用投影矩阵能将<span class=\"number\">3</span>D坐标投影到很容易映射到<span class=\"number\">2</span>D的标准化设备坐标系中。</span><br><span class=\"line\">一旦所有顶点被变换到裁剪空间，最终的操作--透视除法（Perspective Division）将会执行，在这个过程中我们将位置向量的x，y，z分量分别除以向量的齐次w分量；透视除法是将<span class=\"number\">4</span>D裁剪空间坐标转换为<span class=\"number\">3</span>D标准化设备坐标的过程。这一步会在每一个顶点着色器运行的最后被自动执行。</span><br><span class=\"line\">在这一阶段之后，最终的坐标将会被映射到屏幕空间中（使用`glViewport`中的设定），并被变换成片段。</span><br><span class=\"line\">将观察坐标变换为裁剪坐标的投影矩阵可以为两种不同的形式，每种形式都定义了不同的平截头体。我们可以选择创建一个正射投影矩阵（Orthographic Projection Matrix）或一个透视投影矩阵（Perspective Projection Matrix）。</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">## 正射投影</span></span><br><span class=\"line\"></span><br><span class=\"line\">正射投影矩阵定义了一个类似立方体的平接头箱，它定义了一个裁剪空间，在这空间之外的顶点都会被裁剪掉。创建一个正射投影矩阵需要指定可见平截头体的宽、高和长度。在使用正射投影矩阵变换至裁剪空间之后处于这个平截头体的所有坐标将不会被裁剪掉。它的平截头体看起来像一个容器：</span><br><span class=\"line\"></span><br><span class=\"line\">![正射投影](/img/article/<span class=\"number\">20190825</span>/<span class=\"number\">2.</span>png)</span><br><span class=\"line\"></span><br><span class=\"line\">上面的平截头体定义了可见的坐标，它由宽、高、近（Near）平面和远（Far）平面所指定。任何出现在近平面之前或远平面之后的坐标都会被裁剪掉。正射平截头体直接将平截头体内部的所有坐标映射为标准化设备坐标，因为每个向量的w分量都没有进行改变；如果w分量等于<span class=\"number\">1.0</span>，透视除法则不会改变这个坐标。</span><br><span class=\"line\">要创建一个正射投影矩阵，我们可以使用`GLKit`中的方法：</span><br><span class=\"line\"></span><br><span class=\"line\">``` objc</span><br><span class=\"line\">GLKMatrix4MakeOrtho(<span class=\"number\">0.0</span>, <span class=\"number\">800.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">600</span>, <span class=\"number\">0.1</span>, <span class=\"number\">100.0</span>);</span><br></pre></td></tr></table></figure>\n<p>或OpenGL ES 1.1中的函数：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">glOrthof(<span class=\"number\">0.0</span>, <span class=\"number\">800.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">600.0</span>, <span class=\"number\">0.1</span>, <span class=\"number\">100.0</span>);</span><br></pre></td></tr></table></figure>\n<p>前两个参数指定了平截头体的左右坐标，第三和第四参数指定了平截头体的底部和顶部。通过这四个参数我们定义了近平面和远平面的大小，然后第五和第六个参数则定义了近平面和远平面的距离。这个投影矩阵会将处于这些x，y，z值范围内的坐标变换为标准化设备坐标。<br>\n正射投影矩阵直接将坐标映射到2D平面中，即屏幕中，但实际上一个直接的投影矩阵会产生不真实的结果，因为这个投影没有将透视（Perspective）考虑进去。</p>\n<h2>透视投影</h2>\n<p>我们都曾体验过实际生活中的一个场景，离我们越远的东西看起来更小。这个奇怪的效果称之为透视。透视的效果在我们看一条无限长的高速公路或铁路时尤其明显，正如下面图片显示的那样：</p>\n<p><img src=\"/img/article/20190825/3.png\" alt=\"透视投影\"></p>\n<p>正如所看到的那样，由于透视，这两条线在很远的地方看起来会相交。这正是透视投影想要模仿的效果，它是使用透视投影矩阵来完成的。这个投影矩阵将给定的平截头体范围映射到裁剪空间，除此之外还修改了每个顶点的w值，从而使得离观察者越远的顶点坐标w分量越大。被变换到裁剪空间的坐标都会在-w到w的范围之间（任何大于这个范围的坐标都会被裁剪掉）。OpenGL要求所有可见的坐标都落在-1.0到1.0范围内，作为顶点着色器最后的输出，一次，一旦坐标在裁剪空间内之后，透视除法就被会应用到裁剪空间坐标上：</p>\n<p><img src=\"/img/article/20190825/4.png\" alt=\"透视除法\"></p>\n<p>顶点坐标的每个分量都会除以它的w分量，距离观察者越远顶点坐标就会越小。这也是w分量非常重要的另一个原因，它能够帮助我们进行透视投影。最后的结果坐标就是处于标准化设备空间中的。</p>\n<p>要创建一个透视投影矩阵，我们可以使用<code>GLKit</code>中的方法：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GLKMatrix4MakePerspective(GLKMathRadiansToDegrees(<span class=\"number\">45</span>), width/height, <span class=\"number\">0.1</span>, <span class=\"number\">100.0</span>);</span><br></pre></td></tr></table></figure>\n<p>同样，<code>GLKMatrix4MakePerspective</code>所做的其实就是创建了一个定义了可视空间的大平截头体，任何在这个平截头体以外的东西最后都不会出现在裁剪空间体积内，并且将会收到裁剪。一个透视平截头体可以被看作一个不均匀的箱子，在这个箱子内部的每个坐标都会被映射到裁剪空间上的一个点。下面是一张透视平截头体的图片：</p>\n<p><img src=\"/img/article/20190825/5.png\" alt=\"透视平截头体\"></p>\n<p>它的第一个参数定义了<code>fov</code>的值，它表示的是视野（Field of View），并且设置了观察空间的大小。如果想要一个真实的观察效果，它的值通常设置为45.0f，但想要一个末日风格的结果可以将其设置一个更大的值。第二个参数设置了宽高比，由视口的宽除以高所得。第三和第四个参数设置了平截头体的近和远平面。我们通常设置近距离为0.1f，而远距离设置为100.0f。所有在近平面和远平面且处于平截头体内的顶点都会被渲染。</p>\n<blockquote>\n<p>当我们把透视矩阵的<code>near</code>值设置太大时（如10.0f），OpenGL会将靠近摄像机的坐标（在0。0f和10.0f之间）都裁剪掉，这会导致一个在游戏中很熟悉的视觉效果：在太过靠近一个物体的时候视线会直接传过去。</p>\n</blockquote>\n<h1>把它们都组合到一起</h1>\n<p>我们为上述的每一个步骤都创建了一个变换矩阵：模型矩阵、观察矩阵和投影矩阵。一个顶点坐标将会根据以下过程被变换到裁剪坐标：V<sub>clip</sub> = M<sub>projection</sub>p * M<sub>view</sub> * M<sub>model</sub> * M<sub>local</sub>。<br>\n注意矩阵运算的顺序是相反的。最后的顶点应该被赋值到顶点着色器中的<code>gl_Position</code>，OpenGL将会自动进行透视除法和裁剪。</p>\n<blockquote>\n<p>然后呢？<br>\n顶点着色器的输出要求所有的顶点都在裁剪空间内，这正是我们刚才使用变换矩阵所做的。OpenGL然后对裁剪坐标执行透视除法从而将它们变换到标准化设备坐标。OpenGL会使用<code>glViewport</code>内部的参数来标准化设备坐标映射到屏幕坐标，每个坐标都关联了一个屏幕上的点。这个过程称为视口变换。</p>\n</blockquote>\n<h1>举个例子</h1>\n<p>我们创建一个立方体，利用摄像机视角对其进行旋转拍摄，主要的矩阵变换代码如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)update &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSTimeInterval</span> detalTime = <span class=\"keyword\">self</span>.timeSinceLastUpdate;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.elapsedTime += detalTime;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">float</span> varyingFactor = (sin(<span class=\"keyword\">self</span>.elapsedTime) + <span class=\"number\">1</span>) / <span class=\"number\">2.0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">float</span> aspect = <span class=\"keyword\">self</span>.view.frame.size.width / <span class=\"keyword\">self</span>.view.frame.size.height;</span><br><span class=\"line\"></span><br><span class=\"line\">    GLKMatrix4 perspectiveMatrix = GLKMatrix4MakePerspective(GLKMathDegreesToRadians(<span class=\"number\">45</span>), aspect, <span class=\"number\">0.1</span>, <span class=\"number\">100.0</span>);  <span class=\"comment\">// 投影矩阵</span></span><br><span class=\"line\">    GLKMatrix4 cameraMatrix = GLKMatrix4MakeLookAt(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">5</span> * (varyingFactor + <span class=\"number\">1</span>), <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>);    <span class=\"comment\">// 观察矩阵</span></span><br><span class=\"line\">    GLKMatrix4 rotateMatrix = GLKMatrix4MakeRotation(varyingFactor * M_PI * <span class=\"number\">2</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>);    <span class=\"comment\">// 模型矩阵</span></span><br><span class=\"line\">    <span class=\"keyword\">self</span>.projectionMatrix = GLKMatrix4Multiply(cameraMatrix, rotateMatrix);</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.projectionMatrix = GLKMatrix4Multiply(perspectiveMatrix, <span class=\"keyword\">self</span>.projectionMatrix);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)glkView:(GLKView *)view drawInRect:(<span class=\"built_in\">CGRect</span>)rect &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span><br><span class=\"line\">    glClearColor(<span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    glUniformMatrix4fv(mvpMatrixlocation, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"keyword\">self</span>.projectionMatrix.m);</span><br><span class=\"line\">    </span><br><span class=\"line\">    glBindVertexArray(vao);</span><br><span class=\"line\">    glDrawElements(GL_TRIANGLES, <span class=\"number\">36</span>, GL_UNSIGNED_SHORT, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1>总结</h1>\n<p>这篇文章主要针对物体根据一系列的坐标系转换，最终转化为屏幕上最终的渲染产物过程中的坐标系转换的学习。</p>\n"},{"title":"Sliding Window algorithm - substring search problems","catalog":true,"toc_nav_num":true,"date":"2019-10-07T10:39:23.000Z","subtitle":"Leet Code","header-img":"/img/article_header/article_header.png","busuanzi":true,"_content":"\n# Introduction\n\nSliding Window algorithm template to solve almost Leetcode substring search problem.\n\n# Find All Anagrams in a String\n\nGiven a string **s** and a **non-empty** string **p**, find all the start indices of **p**'s anagrams in **s**.\n\nStrings consists of lowercase English letters only and the length of both strings **s** and **p**will not be larger than 20,100.\n\nThe order of output does not matter.\n\n**Example 1:**\n```\nInput:\ns: \"cbaebabacd\" p: \"abc\"\n\nOutput:\n[0, 6]\n\nExplanation:\nThe substring with start index = 0 is \"cba\", which is an anagram of \"abc\".\nThe substring with start index = 6 is \"bac\", which is an anagram of \"abc\".\n```\n\n**Example 2:**\n```\nInput:\ns: \"abab\" p: \"ab\"\n\nOutput:\n[0, 1, 2]\n\nExplanation:\nThe substring with start index = 0 is \"ab\", which is an anagram of \"ab\".\nThe substring with start index = 1 is \"ba\", which is an anagram of \"ab\".\nThe substring with start index = 2 is \"ab\", which is an anagram of \"ab\".\n```\n\n**Algorithm:**\n``` swift\nclass Solution {\n    func findAnagrams(_ s: String, _ p: String) -> [Int] {\n        guard !s.isEmpty, !p.isEmpty, s.count >= p.count else {\n            return []\n        }\n        var map = [Character: Int]()\n        for c in p {\n            map.updateValue(map[c, default: 0] + 1, forKey: c)\n        }\n        var start = 0, end = 0\n        var result = [Int]()\n        var p = Array(p), s = Array(s)\n        var counter = map.count\n        while end < s.count {\n            let sE = s[end]\n            if let mapValue = map[sE] {\n                map.updateValue(mapValue-1, forKey: sE)\n                if mapValue == 1 {\n                    counter -= 1\n                }\n            }\n            end += 1\n            while counter == 0 {\n                let sS = s[start]\n                if let mapValue = map[sS] {\n                    map.updateValue(mapValue+1, forKey: sS)\n                    if mapValue >= 0 {\n                        counter += 1\n                    }\n                }\n                if end-start == p.count {\n                    result.append(start)\n                }\n                start += 1\n            }\n        }\n        return result\n    }\n}\n```\n\nFrom leetCode [438. Find All Anagrams in a String](https://leetcode.com/problems/find-all-anagrams-in-a-string/)\n\n# Minimum Window Substring\n\nGiven a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity **O(n)**.\n\n**Example:**\n```\nInput: S = \"ADOBECODEBANC\", T = \"ABC\"\nOutput: \"BANC\"\n```\n\n**Note:**\n- If there is no such window in S that convers all characters in T, return the empty string \"\".\n- If there is such window, you are guaranteed that there will always be only one unique minimum window in S.\n\n**algorithm:**\n``` swift\nclass Solution {\n    func minWindow(_ s: String, _ t: String) -> String {\n        guard !s.isEmpty, !t.isEmpty, s.count >= t.count else {\n            return \"\"\n        }\n        var map = [Character: Int]()\n        for tS in t {\n            map.updateValue(map[tS, default: 0] + 1, forKey: tS)\n        }\n        var start = 0, end = 0, counter = map.count\n        let sA = Array(s)\n        var result = (-1, s.count+1)\n        while end < sA.count {\n            let sE = sA[end]\n            if let mapValue = map[sE] {\n                map.updateValue(mapValue-1, forKey: sE)\n                if mapValue == 1 {\n                    counter -= 1\n                }\n            }\n            end += 1\n            while counter == 0 {\n                let sS = sA[start]\n                if let mapValue = map[sS] {\n                    map.updateValue(mapValue+1, forKey: sS)\n                    if mapValue >= 0 {\n                        counter += 1\n                    }\n                }\n                if end-start < result.1 {\n                    result = (start, end-start)\n                }\n                start += 1\n            }\n        }\n        return result.0 == -1 ? \"\" : String(s[s.index(s.startIndex, offsetBy: result.0)..<s.index(s.startIndex, offsetBy: result.0+result.1)])\n    }\n}\n```\n\nFrom leetCode [76. Minimum Window Substring](https://leetcode.com/problems/minimum-window-substring/)\n\n# Longest Substring Without Repeating Characters\n\nGiven a string, find the length of the **longest substring** without repeating characters.\n\n**Example 1:**\n```\nInput: \"abcabcbb\"\nOutput: 3 \nExplanation: The answer is \"abc\", with the length of 3. \n```\n\n**Example 2:**\n```\nInput: \"bbbbb\"\nOutput: 1\nExplanation: The answer is \"b\", with the length of 1.\n```\n\n**Example 3:**\n```\nInput: \"pwwkew\"\nOutput: 3\nExplanation: The answer is \"wke\", with the length of 3. \nNote: that the answer must be a substring, \"pwke\" is a subsequence and not a substring.\n```\n\n**Algorithm:**\n``` swift\nclass Solution {\n    func lengthOfLongestSubstring(_ s: String) -> Int {\n        guard !s.isEmpty else {\n            return 0\n        }\n        let sA = Array(s)\n        var map = [Character: Int]()\n        var start = 0, end = 0, counter = 0, result = 0\n        while end < sA.count {\n            let sE = sA[end]\n            if let oldValue = map.updateValue(map[sE, default: 0] + 1, forKey: sE), oldValue > 0 {\n                counter += 1\n            }\n            end += 1\n            while counter > 0 {\n                let sS = sA[start]\n                if let oldValue = map.updateValue(map[sS, default: 0] - 1, forKey: sS), oldValue > 1 {\n                    counter -= 1\n                }\n                start += 1\n            }\n            result = max(result, end-start)\n        }\n        return result\n    }\n}\n```\n\nFrom leetCode [3. Longest Substring Without Repeating Characters](https://leetcode.com/problems/longest-substring-without-repeating-characters/)\n\n# Substring with Concatenation of All Words\n\nYou are given a string, **s**, and a list of words, **words**, that are all of the same length. Find all starting indices of substring(s) in **s** that is a concatenation of each words exactly once and without any intervening characters.\n\n**Example 1:**\n```\nInput:\n  s = \"barfoothefoobarman\",\n  words = [\"foo\",\"bar\"]\nOutput: [0,9]\nExplanation: Substrings starting at index 0 and 9 are \"barfoor\" and \"foobar\" respectively.\nThe output order does not matter, returning [9,0] is fine too.\n```\n\n**Example 2:**\n```\nInput:\n  s = \"wordgoodgoodgoodbestword\",\n  words = [\"word\",\"good\",\"best\",\"word\"]\nOutput: []\n```\n\n**Algorithm:**\n``` swift\nclass Solution {\n    func findSubstring(_ s: String, _ words: [String]) -> [Int] {\n        guard !s.isEmpty, !words.isEmpty, s.count >= words.first!.count else {\n            return []\n        }\n        var map = [String: Int]()\n        for word in words {\n            map.updateValue(map[word, default: 0] + 1, forKey: word)\n        }\n        let sA = Array(s)\n        var curMap = [String: Int]()\n        let wl = words.first!.count\n        var result = [Int]()\n        for i in 0..<wl {\n            var start = i\n            var count = 0\n            for j in stride(from: i, through: s.count-wl, by: wl) {\n                let str = String(sA[j..<j+wl])\n                if let mapValue = map[str] {\n                    curMap.updateValue(curMap[str, default: 0] + 1, forKey: str)\n                    if curMap[str]! <= mapValue {\n                        count += 1\n                    }\n                    \n                    while curMap[str]! > map[str]! {\n                        let tmp = String(sA[start..<start+wl])\n                        curMap.updateValue(curMap[tmp, default: 0] - 1, forKey: tmp)\n                        start += wl\n                        if curMap[tmp]! < map[tmp]! {\n                            count -= 1\n                        }\n                    }\n                    if count == words.count {\n                        result.append(start)\n                        let tmp = String(sA[start..<start+wl])\n                        curMap.updateValue(curMap[tmp, default: 0] - 1, forKey: tmp)\n                        start += wl\n                        count -= 1\n                    }\n                } else {\n                    start = j + wl\n                    count = 0\n                    curMap.removeAll()\n                }\n            }\n            curMap.removeAll()\n        }\n        return result\n    }\n}\n```\n\nFrom leetCode [30. Substring with Concatenation of All Words](https://leetcode.com/problems/substring-with-concatenation-of-all-words/)","source":"_posts/2019/leetcode-substring-search-problems-1007.md","raw":"---\ntitle: \"Sliding Window algorithm - substring search problems\"\ncatalog: true\ntoc_nav_num: true\ndate: 2019-10-07 18:39:23\nsubtitle: \"Leet Code\"\nheader-img: \"/img/article_header/article_header.png\"\nbusuanzi: true\ntags:\n- iOS - Swift\n\n---\n\n# Introduction\n\nSliding Window algorithm template to solve almost Leetcode substring search problem.\n\n# Find All Anagrams in a String\n\nGiven a string **s** and a **non-empty** string **p**, find all the start indices of **p**'s anagrams in **s**.\n\nStrings consists of lowercase English letters only and the length of both strings **s** and **p**will not be larger than 20,100.\n\nThe order of output does not matter.\n\n**Example 1:**\n```\nInput:\ns: \"cbaebabacd\" p: \"abc\"\n\nOutput:\n[0, 6]\n\nExplanation:\nThe substring with start index = 0 is \"cba\", which is an anagram of \"abc\".\nThe substring with start index = 6 is \"bac\", which is an anagram of \"abc\".\n```\n\n**Example 2:**\n```\nInput:\ns: \"abab\" p: \"ab\"\n\nOutput:\n[0, 1, 2]\n\nExplanation:\nThe substring with start index = 0 is \"ab\", which is an anagram of \"ab\".\nThe substring with start index = 1 is \"ba\", which is an anagram of \"ab\".\nThe substring with start index = 2 is \"ab\", which is an anagram of \"ab\".\n```\n\n**Algorithm:**\n``` swift\nclass Solution {\n    func findAnagrams(_ s: String, _ p: String) -> [Int] {\n        guard !s.isEmpty, !p.isEmpty, s.count >= p.count else {\n            return []\n        }\n        var map = [Character: Int]()\n        for c in p {\n            map.updateValue(map[c, default: 0] + 1, forKey: c)\n        }\n        var start = 0, end = 0\n        var result = [Int]()\n        var p = Array(p), s = Array(s)\n        var counter = map.count\n        while end < s.count {\n            let sE = s[end]\n            if let mapValue = map[sE] {\n                map.updateValue(mapValue-1, forKey: sE)\n                if mapValue == 1 {\n                    counter -= 1\n                }\n            }\n            end += 1\n            while counter == 0 {\n                let sS = s[start]\n                if let mapValue = map[sS] {\n                    map.updateValue(mapValue+1, forKey: sS)\n                    if mapValue >= 0 {\n                        counter += 1\n                    }\n                }\n                if end-start == p.count {\n                    result.append(start)\n                }\n                start += 1\n            }\n        }\n        return result\n    }\n}\n```\n\nFrom leetCode [438. Find All Anagrams in a String](https://leetcode.com/problems/find-all-anagrams-in-a-string/)\n\n# Minimum Window Substring\n\nGiven a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity **O(n)**.\n\n**Example:**\n```\nInput: S = \"ADOBECODEBANC\", T = \"ABC\"\nOutput: \"BANC\"\n```\n\n**Note:**\n- If there is no such window in S that convers all characters in T, return the empty string \"\".\n- If there is such window, you are guaranteed that there will always be only one unique minimum window in S.\n\n**algorithm:**\n``` swift\nclass Solution {\n    func minWindow(_ s: String, _ t: String) -> String {\n        guard !s.isEmpty, !t.isEmpty, s.count >= t.count else {\n            return \"\"\n        }\n        var map = [Character: Int]()\n        for tS in t {\n            map.updateValue(map[tS, default: 0] + 1, forKey: tS)\n        }\n        var start = 0, end = 0, counter = map.count\n        let sA = Array(s)\n        var result = (-1, s.count+1)\n        while end < sA.count {\n            let sE = sA[end]\n            if let mapValue = map[sE] {\n                map.updateValue(mapValue-1, forKey: sE)\n                if mapValue == 1 {\n                    counter -= 1\n                }\n            }\n            end += 1\n            while counter == 0 {\n                let sS = sA[start]\n                if let mapValue = map[sS] {\n                    map.updateValue(mapValue+1, forKey: sS)\n                    if mapValue >= 0 {\n                        counter += 1\n                    }\n                }\n                if end-start < result.1 {\n                    result = (start, end-start)\n                }\n                start += 1\n            }\n        }\n        return result.0 == -1 ? \"\" : String(s[s.index(s.startIndex, offsetBy: result.0)..<s.index(s.startIndex, offsetBy: result.0+result.1)])\n    }\n}\n```\n\nFrom leetCode [76. Minimum Window Substring](https://leetcode.com/problems/minimum-window-substring/)\n\n# Longest Substring Without Repeating Characters\n\nGiven a string, find the length of the **longest substring** without repeating characters.\n\n**Example 1:**\n```\nInput: \"abcabcbb\"\nOutput: 3 \nExplanation: The answer is \"abc\", with the length of 3. \n```\n\n**Example 2:**\n```\nInput: \"bbbbb\"\nOutput: 1\nExplanation: The answer is \"b\", with the length of 1.\n```\n\n**Example 3:**\n```\nInput: \"pwwkew\"\nOutput: 3\nExplanation: The answer is \"wke\", with the length of 3. \nNote: that the answer must be a substring, \"pwke\" is a subsequence and not a substring.\n```\n\n**Algorithm:**\n``` swift\nclass Solution {\n    func lengthOfLongestSubstring(_ s: String) -> Int {\n        guard !s.isEmpty else {\n            return 0\n        }\n        let sA = Array(s)\n        var map = [Character: Int]()\n        var start = 0, end = 0, counter = 0, result = 0\n        while end < sA.count {\n            let sE = sA[end]\n            if let oldValue = map.updateValue(map[sE, default: 0] + 1, forKey: sE), oldValue > 0 {\n                counter += 1\n            }\n            end += 1\n            while counter > 0 {\n                let sS = sA[start]\n                if let oldValue = map.updateValue(map[sS, default: 0] - 1, forKey: sS), oldValue > 1 {\n                    counter -= 1\n                }\n                start += 1\n            }\n            result = max(result, end-start)\n        }\n        return result\n    }\n}\n```\n\nFrom leetCode [3. Longest Substring Without Repeating Characters](https://leetcode.com/problems/longest-substring-without-repeating-characters/)\n\n# Substring with Concatenation of All Words\n\nYou are given a string, **s**, and a list of words, **words**, that are all of the same length. Find all starting indices of substring(s) in **s** that is a concatenation of each words exactly once and without any intervening characters.\n\n**Example 1:**\n```\nInput:\n  s = \"barfoothefoobarman\",\n  words = [\"foo\",\"bar\"]\nOutput: [0,9]\nExplanation: Substrings starting at index 0 and 9 are \"barfoor\" and \"foobar\" respectively.\nThe output order does not matter, returning [9,0] is fine too.\n```\n\n**Example 2:**\n```\nInput:\n  s = \"wordgoodgoodgoodbestword\",\n  words = [\"word\",\"good\",\"best\",\"word\"]\nOutput: []\n```\n\n**Algorithm:**\n``` swift\nclass Solution {\n    func findSubstring(_ s: String, _ words: [String]) -> [Int] {\n        guard !s.isEmpty, !words.isEmpty, s.count >= words.first!.count else {\n            return []\n        }\n        var map = [String: Int]()\n        for word in words {\n            map.updateValue(map[word, default: 0] + 1, forKey: word)\n        }\n        let sA = Array(s)\n        var curMap = [String: Int]()\n        let wl = words.first!.count\n        var result = [Int]()\n        for i in 0..<wl {\n            var start = i\n            var count = 0\n            for j in stride(from: i, through: s.count-wl, by: wl) {\n                let str = String(sA[j..<j+wl])\n                if let mapValue = map[str] {\n                    curMap.updateValue(curMap[str, default: 0] + 1, forKey: str)\n                    if curMap[str]! <= mapValue {\n                        count += 1\n                    }\n                    \n                    while curMap[str]! > map[str]! {\n                        let tmp = String(sA[start..<start+wl])\n                        curMap.updateValue(curMap[tmp, default: 0] - 1, forKey: tmp)\n                        start += wl\n                        if curMap[tmp]! < map[tmp]! {\n                            count -= 1\n                        }\n                    }\n                    if count == words.count {\n                        result.append(start)\n                        let tmp = String(sA[start..<start+wl])\n                        curMap.updateValue(curMap[tmp, default: 0] - 1, forKey: tmp)\n                        start += wl\n                        count -= 1\n                    }\n                } else {\n                    start = j + wl\n                    count = 0\n                    curMap.removeAll()\n                }\n            }\n            curMap.removeAll()\n        }\n        return result\n    }\n}\n```\n\nFrom leetCode [30. Substring with Concatenation of All Words](https://leetcode.com/problems/substring-with-concatenation-of-all-words/)","slug":"2019/leetcode-substring-search-problems-1007","published":1,"updated":"2022-01-10T09:04:52.804Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cky8gmc47000md1qh97y7dmwp","content":"<h1 id=\"introduction\">Introduction</h1>\n<p>Sliding Window algorithm template to solve almost Leetcode substring search problem.</p>\n<h1 id=\"find-all-anagrams-in-a-string\">Find All Anagrams in a String</h1>\n<p>Given a string <strong>s</strong> and a <strong>non-empty</strong> string <strong>p</strong>, find all the start indices of <strong>p</strong>’s anagrams in <strong>s</strong>.</p>\n<p>Strings consists of lowercase English letters only and the length of both strings <strong>s</strong> and <strong>p</strong>will not be larger than 20,100.</p>\n<p>The order of output does not matter.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input:</span><br><span class=\"line\">s: &quot;cbaebabacd&quot; p: &quot;abc&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">Output:</span><br><span class=\"line\">[0, 6]</span><br><span class=\"line\"></span><br><span class=\"line\">Explanation:</span><br><span class=\"line\">The substring with start index = 0 is &quot;cba&quot;, which is an anagram of &quot;abc&quot;.</span><br><span class=\"line\">The substring with start index = 6 is &quot;bac&quot;, which is an anagram of &quot;abc&quot;.</span><br></pre></td></tr></table></figure>\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input:</span><br><span class=\"line\">s: &quot;abab&quot; p: &quot;ab&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">Output:</span><br><span class=\"line\">[0, 1, 2]</span><br><span class=\"line\"></span><br><span class=\"line\">Explanation:</span><br><span class=\"line\">The substring with start index = 0 is &quot;ab&quot;, which is an anagram of &quot;ab&quot;.</span><br><span class=\"line\">The substring with start index = 1 is &quot;ba&quot;, which is an anagram of &quot;ab&quot;.</span><br><span class=\"line\">The substring with start index = 2 is &quot;ab&quot;, which is an anagram of &quot;ab&quot;.</span><br></pre></td></tr></table></figure>\n<p><strong>Algorithm:</strong></p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">findAnagrams</span><span class=\"params\">(<span class=\"number\">_</span> s: String, <span class=\"number\">_</span> p: String)</span></span> -&gt; [<span class=\"type\">Int</span>] &#123;</span><br><span class=\"line\">        <span class=\"keyword\">guard</span> !s.isEmpty, !p.isEmpty, s.<span class=\"built_in\">count</span> &gt;= p.<span class=\"built_in\">count</span> <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> []</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> <span class=\"built_in\">map</span> = [<span class=\"type\">Character</span>: <span class=\"type\">Int</span>]()</span><br><span class=\"line\">        <span class=\"keyword\">for</span> <span class=\"built_in\">c</span> <span class=\"keyword\">in</span> p &#123;</span><br><span class=\"line\">            <span class=\"built_in\">map</span>.updateValue(<span class=\"built_in\">map</span>[<span class=\"built_in\">c</span>, <span class=\"keyword\">default</span>: <span class=\"number\">0</span>] + <span class=\"number\">1</span>, forKey: <span class=\"built_in\">c</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> start = <span class=\"number\">0</span>, end = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> result = [<span class=\"type\">Int</span>]()</span><br><span class=\"line\">        <span class=\"keyword\">var</span> p = <span class=\"type\">Array</span>(p), s = <span class=\"type\">Array</span>(s)</span><br><span class=\"line\">        <span class=\"keyword\">var</span> counter = <span class=\"built_in\">map</span>.<span class=\"built_in\">count</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> end &lt; s.<span class=\"built_in\">count</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> sE = s[end]</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> mapValue = <span class=\"built_in\">map</span>[sE] &#123;</span><br><span class=\"line\">                <span class=\"built_in\">map</span>.updateValue(mapValue-<span class=\"number\">1</span>, forKey: sE)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> mapValue == <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">                    counter -= <span class=\"number\">1</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            end += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> counter == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">let</span> sS = s[start]</span><br><span class=\"line\">                <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> mapValue = <span class=\"built_in\">map</span>[sS] &#123;</span><br><span class=\"line\">                    <span class=\"built_in\">map</span>.updateValue(mapValue+<span class=\"number\">1</span>, forKey: sS)</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> mapValue &gt;= <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">                        counter += <span class=\"number\">1</span></span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> end-start == p.<span class=\"built_in\">count</span> &#123;</span><br><span class=\"line\">                    result.append(start)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                start += <span class=\"number\">1</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>From leetCode <a href=\"https://leetcode.com/problems/find-all-anagrams-in-a-string/\" target=\"_blank\" rel=\"noopener\">438. Find All Anagrams in a String</a></p>\n<h1 id=\"minimum-window-substring\">Minimum Window Substring</h1>\n<p>Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity <strong>O(n)</strong>.</p>\n<p><strong>Example:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: S = &quot;ADOBECODEBANC&quot;, T = &quot;ABC&quot;</span><br><span class=\"line\">Output: &quot;BANC&quot;</span><br></pre></td></tr></table></figure>\n<p><strong>Note:</strong></p>\n<ul>\n<li>If there is no such window in S that convers all characters in T, return the empty string “”.</li>\n<li>If there is such window, you are guaranteed that there will always be only one unique minimum window in S.</li>\n</ul>\n<p><strong>algorithm:</strong></p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">minWindow</span><span class=\"params\">(<span class=\"number\">_</span> s: String, <span class=\"number\">_</span> t: String)</span></span> -&gt; <span class=\"type\">String</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">guard</span> !s.isEmpty, !t.isEmpty, s.<span class=\"built_in\">count</span> &gt;= t.<span class=\"built_in\">count</span> <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">\"\"</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> <span class=\"built_in\">map</span> = [<span class=\"type\">Character</span>: <span class=\"type\">Int</span>]()</span><br><span class=\"line\">        <span class=\"keyword\">for</span> tS <span class=\"keyword\">in</span> t &#123;</span><br><span class=\"line\">            <span class=\"built_in\">map</span>.updateValue(<span class=\"built_in\">map</span>[tS, <span class=\"keyword\">default</span>: <span class=\"number\">0</span>] + <span class=\"number\">1</span>, forKey: tS)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> start = <span class=\"number\">0</span>, end = <span class=\"number\">0</span>, counter = <span class=\"built_in\">map</span>.<span class=\"built_in\">count</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> sA = <span class=\"type\">Array</span>(s)</span><br><span class=\"line\">        <span class=\"keyword\">var</span> result = (-<span class=\"number\">1</span>, s.<span class=\"built_in\">count</span>+<span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">while</span> end &lt; sA.<span class=\"built_in\">count</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> sE = sA[end]</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> mapValue = <span class=\"built_in\">map</span>[sE] &#123;</span><br><span class=\"line\">                <span class=\"built_in\">map</span>.updateValue(mapValue-<span class=\"number\">1</span>, forKey: sE)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> mapValue == <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">                    counter -= <span class=\"number\">1</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            end += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> counter == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">let</span> sS = sA[start]</span><br><span class=\"line\">                <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> mapValue = <span class=\"built_in\">map</span>[sS] &#123;</span><br><span class=\"line\">                    <span class=\"built_in\">map</span>.updateValue(mapValue+<span class=\"number\">1</span>, forKey: sS)</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> mapValue &gt;= <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">                        counter += <span class=\"number\">1</span></span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> end-start &lt; result.<span class=\"number\">1</span> &#123;</span><br><span class=\"line\">                    result = (start, end-start)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                start += <span class=\"number\">1</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result.<span class=\"number\">0</span> == -<span class=\"number\">1</span> ? <span class=\"string\">\"\"</span> : <span class=\"type\">String</span>(s[s.index(s.startIndex, offsetBy: result.<span class=\"number\">0</span>)..&lt;s.index(s.startIndex, offsetBy: result.<span class=\"number\">0</span>+result.<span class=\"number\">1</span>)])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>From leetCode <a href=\"https://leetcode.com/problems/minimum-window-substring/\" target=\"_blank\" rel=\"noopener\">76. Minimum Window Substring</a></p>\n<h1 id=\"longest-substring-without-repeating-characters\">Longest Substring Without Repeating Characters</h1>\n<p>Given a string, find the length of the <strong>longest substring</strong> without repeating characters.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: &quot;abcabcbb&quot;</span><br><span class=\"line\">Output: 3 </span><br><span class=\"line\">Explanation: The answer is &quot;abc&quot;, with the length of 3.</span><br></pre></td></tr></table></figure>\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: &quot;bbbbb&quot;</span><br><span class=\"line\">Output: 1</span><br><span class=\"line\">Explanation: The answer is &quot;b&quot;, with the length of 1.</span><br></pre></td></tr></table></figure>\n<p><strong>Example 3:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: &quot;pwwkew&quot;</span><br><span class=\"line\">Output: 3</span><br><span class=\"line\">Explanation: The answer is &quot;wke&quot;, with the length of 3. </span><br><span class=\"line\">Note: that the answer must be a substring, &quot;pwke&quot; is a subsequence and not a substring.</span><br></pre></td></tr></table></figure>\n<p><strong>Algorithm:</strong></p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">lengthOfLongestSubstring</span><span class=\"params\">(<span class=\"number\">_</span> s: String)</span></span> -&gt; <span class=\"type\">Int</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">guard</span> !s.isEmpty <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> sA = <span class=\"type\">Array</span>(s)</span><br><span class=\"line\">        <span class=\"keyword\">var</span> <span class=\"built_in\">map</span> = [<span class=\"type\">Character</span>: <span class=\"type\">Int</span>]()</span><br><span class=\"line\">        <span class=\"keyword\">var</span> start = <span class=\"number\">0</span>, end = <span class=\"number\">0</span>, counter = <span class=\"number\">0</span>, result = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> end &lt; sA.<span class=\"built_in\">count</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> sE = sA[end]</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> oldValue = <span class=\"built_in\">map</span>.updateValue(<span class=\"built_in\">map</span>[sE, <span class=\"keyword\">default</span>: <span class=\"number\">0</span>] + <span class=\"number\">1</span>, forKey: sE), oldValue &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">                counter += <span class=\"number\">1</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            end += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> counter &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">let</span> sS = sA[start]</span><br><span class=\"line\">                <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> oldValue = <span class=\"built_in\">map</span>.updateValue(<span class=\"built_in\">map</span>[sS, <span class=\"keyword\">default</span>: <span class=\"number\">0</span>] - <span class=\"number\">1</span>, forKey: sS), oldValue &gt; <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">                    counter -= <span class=\"number\">1</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                start += <span class=\"number\">1</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            result = <span class=\"built_in\">max</span>(result, end-start)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>From leetCode <a href=\"https://leetcode.com/problems/longest-substring-without-repeating-characters/\" target=\"_blank\" rel=\"noopener\">3. Longest Substring Without Repeating Characters</a></p>\n<h1 id=\"substring-with-concatenation-of-all-words\">Substring with Concatenation of All Words</h1>\n<p>You are given a string, <strong>s</strong>, and a list of words, <strong>words</strong>, that are all of the same length. Find all starting indices of substring(s) in <strong>s</strong> that is a concatenation of each words exactly once and without any intervening characters.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input:</span><br><span class=\"line\">  s = &quot;barfoothefoobarman&quot;,</span><br><span class=\"line\">  words = [&quot;foo&quot;,&quot;bar&quot;]</span><br><span class=\"line\">Output: [0,9]</span><br><span class=\"line\">Explanation: Substrings starting at index 0 and 9 are &quot;barfoor&quot; and &quot;foobar&quot; respectively.</span><br><span class=\"line\">The output order does not matter, returning [9,0] is fine too.</span><br></pre></td></tr></table></figure>\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input:</span><br><span class=\"line\">  s = &quot;wordgoodgoodgoodbestword&quot;,</span><br><span class=\"line\">  words = [&quot;word&quot;,&quot;good&quot;,&quot;best&quot;,&quot;word&quot;]</span><br><span class=\"line\">Output: []</span><br></pre></td></tr></table></figure>\n<p><strong>Algorithm:</strong></p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">findSubstring</span><span class=\"params\">(<span class=\"number\">_</span> s: String, <span class=\"number\">_</span> words: [String])</span></span> -&gt; [<span class=\"type\">Int</span>] &#123;</span><br><span class=\"line\">        <span class=\"keyword\">guard</span> !s.isEmpty, !words.isEmpty, s.<span class=\"built_in\">count</span> &gt;= words.first!.<span class=\"built_in\">count</span> <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> []</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> <span class=\"built_in\">map</span> = [<span class=\"type\">String</span>: <span class=\"type\">Int</span>]()</span><br><span class=\"line\">        <span class=\"keyword\">for</span> word <span class=\"keyword\">in</span> words &#123;</span><br><span class=\"line\">            <span class=\"built_in\">map</span>.updateValue(<span class=\"built_in\">map</span>[word, <span class=\"keyword\">default</span>: <span class=\"number\">0</span>] + <span class=\"number\">1</span>, forKey: word)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> sA = <span class=\"type\">Array</span>(s)</span><br><span class=\"line\">        <span class=\"keyword\">var</span> curMap = [<span class=\"type\">String</span>: <span class=\"type\">Int</span>]()</span><br><span class=\"line\">        <span class=\"keyword\">let</span> wl = words.first!.<span class=\"built_in\">count</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> result = [<span class=\"type\">Int</span>]()</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"number\">0</span>..&lt;wl &#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> start = i</span><br><span class=\"line\">            <span class=\"keyword\">var</span> <span class=\"built_in\">count</span> = <span class=\"number\">0</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"built_in\">stride</span>(from: i, through: s.<span class=\"built_in\">count</span>-wl, by: wl) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">let</span> str = <span class=\"type\">String</span>(sA[j..&lt;j+wl])</span><br><span class=\"line\">                <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> mapValue = <span class=\"built_in\">map</span>[str] &#123;</span><br><span class=\"line\">                    curMap.updateValue(curMap[str, <span class=\"keyword\">default</span>: <span class=\"number\">0</span>] + <span class=\"number\">1</span>, forKey: str)</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> curMap[str]! &lt;= mapValue &#123;</span><br><span class=\"line\">                        <span class=\"built_in\">count</span> += <span class=\"number\">1</span></span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    </span><br><span class=\"line\">                    <span class=\"keyword\">while</span> curMap[str]! &gt; <span class=\"built_in\">map</span>[str]! &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">let</span> tmp = <span class=\"type\">String</span>(sA[start..&lt;start+wl])</span><br><span class=\"line\">                        curMap.updateValue(curMap[tmp, <span class=\"keyword\">default</span>: <span class=\"number\">0</span>] - <span class=\"number\">1</span>, forKey: tmp)</span><br><span class=\"line\">                        start += wl</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> curMap[tmp]! &lt; <span class=\"built_in\">map</span>[tmp]! &#123;</span><br><span class=\"line\">                            <span class=\"built_in\">count</span> -= <span class=\"number\">1</span></span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> <span class=\"built_in\">count</span> == words.<span class=\"built_in\">count</span> &#123;</span><br><span class=\"line\">                        result.append(start)</span><br><span class=\"line\">                        <span class=\"keyword\">let</span> tmp = <span class=\"type\">String</span>(sA[start..&lt;start+wl])</span><br><span class=\"line\">                        curMap.updateValue(curMap[tmp, <span class=\"keyword\">default</span>: <span class=\"number\">0</span>] - <span class=\"number\">1</span>, forKey: tmp)</span><br><span class=\"line\">                        start += wl</span><br><span class=\"line\">                        <span class=\"built_in\">count</span> -= <span class=\"number\">1</span></span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    start = j + wl</span><br><span class=\"line\">                    <span class=\"built_in\">count</span> = <span class=\"number\">0</span></span><br><span class=\"line\">                    curMap.removeAll()</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            curMap.removeAll()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>From leetCode <a href=\"https://leetcode.com/problems/substring-with-concatenation-of-all-words/\" target=\"_blank\" rel=\"noopener\">30. Substring with Concatenation of All Words</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1>Introduction</h1>\n<p>Sliding Window algorithm template to solve almost Leetcode substring search problem.</p>\n<h1>Find All Anagrams in a String</h1>\n<p>Given a string <strong>s</strong> and a <strong>non-empty</strong> string <strong>p</strong>, find all the start indices of <strong>p</strong>’s anagrams in <strong>s</strong>.</p>\n<p>Strings consists of lowercase English letters only and the length of both strings <strong>s</strong> and <strong>p</strong>will not be larger than 20,100.</p>\n<p>The order of output does not matter.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input:</span><br><span class=\"line\">s: &quot;cbaebabacd&quot; p: &quot;abc&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">Output:</span><br><span class=\"line\">[0, 6]</span><br><span class=\"line\"></span><br><span class=\"line\">Explanation:</span><br><span class=\"line\">The substring with start index = 0 is &quot;cba&quot;, which is an anagram of &quot;abc&quot;.</span><br><span class=\"line\">The substring with start index = 6 is &quot;bac&quot;, which is an anagram of &quot;abc&quot;.</span><br></pre></td></tr></table></figure>\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input:</span><br><span class=\"line\">s: &quot;abab&quot; p: &quot;ab&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">Output:</span><br><span class=\"line\">[0, 1, 2]</span><br><span class=\"line\"></span><br><span class=\"line\">Explanation:</span><br><span class=\"line\">The substring with start index = 0 is &quot;ab&quot;, which is an anagram of &quot;ab&quot;.</span><br><span class=\"line\">The substring with start index = 1 is &quot;ba&quot;, which is an anagram of &quot;ab&quot;.</span><br><span class=\"line\">The substring with start index = 2 is &quot;ab&quot;, which is an anagram of &quot;ab&quot;.</span><br></pre></td></tr></table></figure>\n<p><strong>Algorithm:</strong></p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">findAnagrams</span><span class=\"params\">(<span class=\"number\">_</span> s: String, <span class=\"number\">_</span> p: String)</span></span> -&gt; [<span class=\"type\">Int</span>] &#123;</span><br><span class=\"line\">        <span class=\"keyword\">guard</span> !s.isEmpty, !p.isEmpty, s.<span class=\"built_in\">count</span> &gt;= p.<span class=\"built_in\">count</span> <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> []</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> <span class=\"built_in\">map</span> = [<span class=\"type\">Character</span>: <span class=\"type\">Int</span>]()</span><br><span class=\"line\">        <span class=\"keyword\">for</span> <span class=\"built_in\">c</span> <span class=\"keyword\">in</span> p &#123;</span><br><span class=\"line\">            <span class=\"built_in\">map</span>.updateValue(<span class=\"built_in\">map</span>[<span class=\"built_in\">c</span>, <span class=\"keyword\">default</span>: <span class=\"number\">0</span>] + <span class=\"number\">1</span>, forKey: <span class=\"built_in\">c</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> start = <span class=\"number\">0</span>, end = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> result = [<span class=\"type\">Int</span>]()</span><br><span class=\"line\">        <span class=\"keyword\">var</span> p = <span class=\"type\">Array</span>(p), s = <span class=\"type\">Array</span>(s)</span><br><span class=\"line\">        <span class=\"keyword\">var</span> counter = <span class=\"built_in\">map</span>.<span class=\"built_in\">count</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> end &lt; s.<span class=\"built_in\">count</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> sE = s[end]</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> mapValue = <span class=\"built_in\">map</span>[sE] &#123;</span><br><span class=\"line\">                <span class=\"built_in\">map</span>.updateValue(mapValue-<span class=\"number\">1</span>, forKey: sE)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> mapValue == <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">                    counter -= <span class=\"number\">1</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            end += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> counter == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">let</span> sS = s[start]</span><br><span class=\"line\">                <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> mapValue = <span class=\"built_in\">map</span>[sS] &#123;</span><br><span class=\"line\">                    <span class=\"built_in\">map</span>.updateValue(mapValue+<span class=\"number\">1</span>, forKey: sS)</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> mapValue &gt;= <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">                        counter += <span class=\"number\">1</span></span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> end-start == p.<span class=\"built_in\">count</span> &#123;</span><br><span class=\"line\">                    result.append(start)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                start += <span class=\"number\">1</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>From leetCode <a href=\"https://leetcode.com/problems/find-all-anagrams-in-a-string/\" target=\"_blank\" rel=\"noopener\">438. Find All Anagrams in a String</a></p>\n<h1>Minimum Window Substring</h1>\n<p>Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity <strong>O(n)</strong>.</p>\n<p><strong>Example:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: S = &quot;ADOBECODEBANC&quot;, T = &quot;ABC&quot;</span><br><span class=\"line\">Output: &quot;BANC&quot;</span><br></pre></td></tr></table></figure>\n<p><strong>Note:</strong></p>\n<ul>\n<li>If there is no such window in S that convers all characters in T, return the empty string “”.</li>\n<li>If there is such window, you are guaranteed that there will always be only one unique minimum window in S.</li>\n</ul>\n<p><strong>algorithm:</strong></p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">minWindow</span><span class=\"params\">(<span class=\"number\">_</span> s: String, <span class=\"number\">_</span> t: String)</span></span> -&gt; <span class=\"type\">String</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">guard</span> !s.isEmpty, !t.isEmpty, s.<span class=\"built_in\">count</span> &gt;= t.<span class=\"built_in\">count</span> <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">\"\"</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> <span class=\"built_in\">map</span> = [<span class=\"type\">Character</span>: <span class=\"type\">Int</span>]()</span><br><span class=\"line\">        <span class=\"keyword\">for</span> tS <span class=\"keyword\">in</span> t &#123;</span><br><span class=\"line\">            <span class=\"built_in\">map</span>.updateValue(<span class=\"built_in\">map</span>[tS, <span class=\"keyword\">default</span>: <span class=\"number\">0</span>] + <span class=\"number\">1</span>, forKey: tS)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> start = <span class=\"number\">0</span>, end = <span class=\"number\">0</span>, counter = <span class=\"built_in\">map</span>.<span class=\"built_in\">count</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> sA = <span class=\"type\">Array</span>(s)</span><br><span class=\"line\">        <span class=\"keyword\">var</span> result = (-<span class=\"number\">1</span>, s.<span class=\"built_in\">count</span>+<span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">while</span> end &lt; sA.<span class=\"built_in\">count</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> sE = sA[end]</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> mapValue = <span class=\"built_in\">map</span>[sE] &#123;</span><br><span class=\"line\">                <span class=\"built_in\">map</span>.updateValue(mapValue-<span class=\"number\">1</span>, forKey: sE)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> mapValue == <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">                    counter -= <span class=\"number\">1</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            end += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> counter == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">let</span> sS = sA[start]</span><br><span class=\"line\">                <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> mapValue = <span class=\"built_in\">map</span>[sS] &#123;</span><br><span class=\"line\">                    <span class=\"built_in\">map</span>.updateValue(mapValue+<span class=\"number\">1</span>, forKey: sS)</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> mapValue &gt;= <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">                        counter += <span class=\"number\">1</span></span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> end-start &lt; result.<span class=\"number\">1</span> &#123;</span><br><span class=\"line\">                    result = (start, end-start)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                start += <span class=\"number\">1</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result.<span class=\"number\">0</span> == -<span class=\"number\">1</span> ? <span class=\"string\">\"\"</span> : <span class=\"type\">String</span>(s[s.index(s.startIndex, offsetBy: result.<span class=\"number\">0</span>)..&lt;s.index(s.startIndex, offsetBy: result.<span class=\"number\">0</span>+result.<span class=\"number\">1</span>)])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>From leetCode <a href=\"https://leetcode.com/problems/minimum-window-substring/\" target=\"_blank\" rel=\"noopener\">76. Minimum Window Substring</a></p>\n<h1>Longest Substring Without Repeating Characters</h1>\n<p>Given a string, find the length of the <strong>longest substring</strong> without repeating characters.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: &quot;abcabcbb&quot;</span><br><span class=\"line\">Output: 3 </span><br><span class=\"line\">Explanation: The answer is &quot;abc&quot;, with the length of 3.</span><br></pre></td></tr></table></figure>\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: &quot;bbbbb&quot;</span><br><span class=\"line\">Output: 1</span><br><span class=\"line\">Explanation: The answer is &quot;b&quot;, with the length of 1.</span><br></pre></td></tr></table></figure>\n<p><strong>Example 3:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: &quot;pwwkew&quot;</span><br><span class=\"line\">Output: 3</span><br><span class=\"line\">Explanation: The answer is &quot;wke&quot;, with the length of 3. </span><br><span class=\"line\">Note: that the answer must be a substring, &quot;pwke&quot; is a subsequence and not a substring.</span><br></pre></td></tr></table></figure>\n<p><strong>Algorithm:</strong></p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">lengthOfLongestSubstring</span><span class=\"params\">(<span class=\"number\">_</span> s: String)</span></span> -&gt; <span class=\"type\">Int</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">guard</span> !s.isEmpty <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> sA = <span class=\"type\">Array</span>(s)</span><br><span class=\"line\">        <span class=\"keyword\">var</span> <span class=\"built_in\">map</span> = [<span class=\"type\">Character</span>: <span class=\"type\">Int</span>]()</span><br><span class=\"line\">        <span class=\"keyword\">var</span> start = <span class=\"number\">0</span>, end = <span class=\"number\">0</span>, counter = <span class=\"number\">0</span>, result = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> end &lt; sA.<span class=\"built_in\">count</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> sE = sA[end]</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> oldValue = <span class=\"built_in\">map</span>.updateValue(<span class=\"built_in\">map</span>[sE, <span class=\"keyword\">default</span>: <span class=\"number\">0</span>] + <span class=\"number\">1</span>, forKey: sE), oldValue &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">                counter += <span class=\"number\">1</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            end += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> counter &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">let</span> sS = sA[start]</span><br><span class=\"line\">                <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> oldValue = <span class=\"built_in\">map</span>.updateValue(<span class=\"built_in\">map</span>[sS, <span class=\"keyword\">default</span>: <span class=\"number\">0</span>] - <span class=\"number\">1</span>, forKey: sS), oldValue &gt; <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">                    counter -= <span class=\"number\">1</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                start += <span class=\"number\">1</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            result = <span class=\"built_in\">max</span>(result, end-start)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>From leetCode <a href=\"https://leetcode.com/problems/longest-substring-without-repeating-characters/\" target=\"_blank\" rel=\"noopener\">3. Longest Substring Without Repeating Characters</a></p>\n<h1>Substring with Concatenation of All Words</h1>\n<p>You are given a string, <strong>s</strong>, and a list of words, <strong>words</strong>, that are all of the same length. Find all starting indices of substring(s) in <strong>s</strong> that is a concatenation of each words exactly once and without any intervening characters.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input:</span><br><span class=\"line\">  s = &quot;barfoothefoobarman&quot;,</span><br><span class=\"line\">  words = [&quot;foo&quot;,&quot;bar&quot;]</span><br><span class=\"line\">Output: [0,9]</span><br><span class=\"line\">Explanation: Substrings starting at index 0 and 9 are &quot;barfoor&quot; and &quot;foobar&quot; respectively.</span><br><span class=\"line\">The output order does not matter, returning [9,0] is fine too.</span><br></pre></td></tr></table></figure>\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input:</span><br><span class=\"line\">  s = &quot;wordgoodgoodgoodbestword&quot;,</span><br><span class=\"line\">  words = [&quot;word&quot;,&quot;good&quot;,&quot;best&quot;,&quot;word&quot;]</span><br><span class=\"line\">Output: []</span><br></pre></td></tr></table></figure>\n<p><strong>Algorithm:</strong></p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">findSubstring</span><span class=\"params\">(<span class=\"number\">_</span> s: String, <span class=\"number\">_</span> words: [String])</span></span> -&gt; [<span class=\"type\">Int</span>] &#123;</span><br><span class=\"line\">        <span class=\"keyword\">guard</span> !s.isEmpty, !words.isEmpty, s.<span class=\"built_in\">count</span> &gt;= words.first!.<span class=\"built_in\">count</span> <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> []</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> <span class=\"built_in\">map</span> = [<span class=\"type\">String</span>: <span class=\"type\">Int</span>]()</span><br><span class=\"line\">        <span class=\"keyword\">for</span> word <span class=\"keyword\">in</span> words &#123;</span><br><span class=\"line\">            <span class=\"built_in\">map</span>.updateValue(<span class=\"built_in\">map</span>[word, <span class=\"keyword\">default</span>: <span class=\"number\">0</span>] + <span class=\"number\">1</span>, forKey: word)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> sA = <span class=\"type\">Array</span>(s)</span><br><span class=\"line\">        <span class=\"keyword\">var</span> curMap = [<span class=\"type\">String</span>: <span class=\"type\">Int</span>]()</span><br><span class=\"line\">        <span class=\"keyword\">let</span> wl = words.first!.<span class=\"built_in\">count</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> result = [<span class=\"type\">Int</span>]()</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"number\">0</span>..&lt;wl &#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> start = i</span><br><span class=\"line\">            <span class=\"keyword\">var</span> <span class=\"built_in\">count</span> = <span class=\"number\">0</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"built_in\">stride</span>(from: i, through: s.<span class=\"built_in\">count</span>-wl, by: wl) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">let</span> str = <span class=\"type\">String</span>(sA[j..&lt;j+wl])</span><br><span class=\"line\">                <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> mapValue = <span class=\"built_in\">map</span>[str] &#123;</span><br><span class=\"line\">                    curMap.updateValue(curMap[str, <span class=\"keyword\">default</span>: <span class=\"number\">0</span>] + <span class=\"number\">1</span>, forKey: str)</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> curMap[str]! &lt;= mapValue &#123;</span><br><span class=\"line\">                        <span class=\"built_in\">count</span> += <span class=\"number\">1</span></span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    </span><br><span class=\"line\">                    <span class=\"keyword\">while</span> curMap[str]! &gt; <span class=\"built_in\">map</span>[str]! &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">let</span> tmp = <span class=\"type\">String</span>(sA[start..&lt;start+wl])</span><br><span class=\"line\">                        curMap.updateValue(curMap[tmp, <span class=\"keyword\">default</span>: <span class=\"number\">0</span>] - <span class=\"number\">1</span>, forKey: tmp)</span><br><span class=\"line\">                        start += wl</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> curMap[tmp]! &lt; <span class=\"built_in\">map</span>[tmp]! &#123;</span><br><span class=\"line\">                            <span class=\"built_in\">count</span> -= <span class=\"number\">1</span></span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> <span class=\"built_in\">count</span> == words.<span class=\"built_in\">count</span> &#123;</span><br><span class=\"line\">                        result.append(start)</span><br><span class=\"line\">                        <span class=\"keyword\">let</span> tmp = <span class=\"type\">String</span>(sA[start..&lt;start+wl])</span><br><span class=\"line\">                        curMap.updateValue(curMap[tmp, <span class=\"keyword\">default</span>: <span class=\"number\">0</span>] - <span class=\"number\">1</span>, forKey: tmp)</span><br><span class=\"line\">                        start += wl</span><br><span class=\"line\">                        <span class=\"built_in\">count</span> -= <span class=\"number\">1</span></span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    start = j + wl</span><br><span class=\"line\">                    <span class=\"built_in\">count</span> = <span class=\"number\">0</span></span><br><span class=\"line\">                    curMap.removeAll()</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            curMap.removeAll()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>From leetCode <a href=\"https://leetcode.com/problems/substring-with-concatenation-of-all-words/\" target=\"_blank\" rel=\"noopener\">30. Substring with Concatenation of All Words</a></p>\n"},{"title":"使用OpenGL ES绘制三角形","catalog":true,"toc_nav_num":true,"date":"2019-06-06T11:23:02.000Z","subtitle":"About OpenGL ES","header-img":"/img/article_header/article_header.png","busuanzi":true,"_content":"\n# 前言\n\nOpenGL ES的学习，本来是在苹果官方文档上学习，但是该文档是针对基于有一定OpenGL ES基础的人员在iOS和Mac OS平台上的开发时的配置介绍和性能提升，并没有OpenGL ES基础的教学，可以用来后期在有一定知识情况下开发时使用手册。所以，这里从OpenGL ES的最基础开始说起，使用OpenGL ES绘制三角形。\n\n# 自定义着色器绘制三角形\n\n首先我们通过最原始的代码使用OpenGL ES创建一个三角形，这里需要我们自己编写着色器，着色器包含顶点着色器和片段着色器，编写着色器需要用它特有的语言--GLSL，关于GLSL的语法，参见[着色器语言](https://github.com/wshxbqq/GLSL-Card)。\n\n## 着色器的编写\n\n现在我们开始着色器代码的编写，首先我们要创建两个文件，一般顶点着色器使用后缀`.vsh`，片段着色器使用后缀`.fsh`（这边命名可以随意，但是这样命名比较规范）。当然，其实我们也可以不用使用文件声明着色器代码，也可以直接声明一个常量字符串，将代码写入字符串，因为使用文件最终也是读取成字符串形式然后创建着色器，但是使用文件调理更加清晰。\n\n顶点着色器代码：\n``` \n#version 300 es\nlayout(location = 0) in vec4 vPosition;\nvoid main() {\n    gl_Position = vPosition;\n}\n```\n解释：\n1. 第一行代码声明了着色器的版本，V3.00；\n2. 第二行代码`layout(location = 0)`限定符表示这个变量的位置在顶点属性0的位置；`in vec4 vPosition`表示输出的四维向量；\n3. 最后三行就是着色器的main函数，着色器执行的起点；内部就是将输入的四维向量传递给名为`gl_Position`的特殊输出变量，每个顶点着色器必须在`gl_Position`变量中输出一个位置，这个变量定义传递到管线下一个阶段的位置；\n\n片段着色器代码：\n```\n#version 300 es\nprecision mediump float;\nout vec4 fragColor;\nvoid main() {\n    fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n}\n```\n解释：\n1. 第一行代码声明了着色器的版本，V3.00；\n2. 第二行代码声明着色器中浮点变量的默认精度；\n3. 第三行代码声明一个输出变量`fragColor`，同样是四维向量，这个值将被传输到颜色缓冲区；\n4. 最后三行代码就是着色器的man函数，着色器执行的起点；内部就是给定一个默认的思维向量颜色；\n\n## 编译和加载着色器\n\n上面定义了着色器的源代码，这里就可以将着色器加载到OpenGL ES中。这里定义一个`loadShaderWithName:type:`函数编译和加载着色器：\n\n``` objectivec\n- (GLuint)loadShaderWithName:(NSString *)name type:(GLenum)shaderType {\n    \n    // 从文件中读取着色器代码\n    NSString *shaderPath = [[NSBundle mainBundle] pathForResource:name ofType:shaderType == GL_VERTEX_SHADER ? @\"vsh\" : @\"fsh\"];\n    NSError *error;\n    NSString *shaderString = [NSString stringWithContentsOfFile:shaderPath encoding:NSUTF8StringEncoding error:&error];\n    if (!shaderString) {\n        NSAssert(NO, @\"读取Shader失败，%@\", error.localizedDescription);\n        return 0;\n    }\n    \n    // 创建shader对象\n    GLuint shader = glCreateShader(shaderType);\n    if (!shader) {\n        return 0;\n    }\n    \n    // 获取shader内容\n    const GLchar *shaderStringUTF8 = [shaderString UTF8String];\n    glShaderSource(shader, 1, &shaderStringUTF8, NULL);\n    \n    // 编译shader\n    glCompileShader(shader);\n    \n    // 查询shader编译状态\n    GLint compiled;\n    glGetShaderiv(shader, GL_COMPILE_STATUS, &compiled);\n    if (!compiled) {\n        GLint infoLen;\n        glGetShaderiv(shader, GL_INFO_LOG_LENGTH, &infoLen);\n        if (infoLen > 1) {\n            GLchar *infoLog = malloc(sizeof(GLchar) * infoLen);\n            glGetShaderInfoLog(shader, infoLen, NULL, infoLog);\n            NSAssert(NO, @\"编译shader失败，%s\", infoLog);\n            free(infoLog);\n        }\n        glDeleteShader(shader);\n        return 0;\n    }\n    return shader;\n}\n```\n\n## 创建一个程序对象并链接着色器\n\n不同的着色器编译为一个着色器对象之后，必须连接到一个程序对象并一起链接，才能绘制图形。程序对象可以视为最终链接的程序。\n\n``` objectivec\n- (GLuint)createProgram:(NSString *)programName {\n\n    // 获取着色器对象\n    GLuint vertexShader = [self loadShaderWithName:programName type:GL_VERTEX_SHADER];\n    GLuint fragmentShader = [self loadShaderWithName:programName type:GL_FRAGMENT_SHADER];\n    \n    // 创建program对象\n    GLuint program = glCreateProgram();\n    if (!program) {\n        return 0;\n    }\n    \n    // program关联shader\n    glAttachShader(program, vertexShader);\n    glAttachShader(program, fragmentShader);\n    \n    // 链接program\n    glLinkProgram(program);\n    \n    // 查询program状态\n    GLint linked;\n    glGetProgramiv(program, GL_LINK_STATUS, &linked);\n    if (!linked) {\n        GLint infoLen;\n        glGetProgramiv(program, GL_INFO_LOG_LENGTH, &infoLen);\n        if (infoLen > 1) {\n            GLchar *infoLog = malloc(sizeof(GLchar) * infoLen);\n            glGetProgramInfoLog(program, infoLen, NULL, infoLog);\n            NSAssert(NO, @\"program链接失败，%s\", infoLog);\n            free(infoLog);\n        }\n        glDeleteProgram(program);\n        return 0;\n    }\n    return program;\n}\n```\n\n## 创建渲染上下文\n\n现在我们已经有了链接着着色器对象的程序对象，下面就是开始渲染绘制操作。首先创建渲染上下文并设置为当前上下文，这里就直接使用OpenGL ES 3.0：\n\n``` objectivec\nEAGLContext *context = [[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES3];\n[EAGLContext setCurrentContext:context];\n```\n\n## 使用CAEAGLLayer作为渲染目标\n\n在iOS中，我们先用`CAEAGLLayer`作为渲染目标，当然后面也有其他方式，我们先讨论这个方法：\n\n```\n- (void)initialize {\n    // layer的创建，并添加到父layer上\n    CAEAGLLayer *layer = [[CAEAGLLayer alloc] init];\n    layer.frame = self.view.bounds;\n    [self.view.layer addSublayer:layer];\n    \n    // 创建颜色渲染缓冲区，绑定到帧缓冲区，并将layer对象的存储绑定到OpenGL ES的渲染缓冲区对象\n    [self bindRenderLayer:layer context:context];\n}\n\n- (void)bindRenderLayer:(CALayer <EAGLDrawable> *)layer context:(EAGLContext *)context {\n    GLuint renderbuffer;\n    GLuint framebuffer;\n    glGenRenderbuffers(1, &renderbuffer);\n    glBindRenderbuffer(GL_RENDERBUFFER, renderbuffer);\n    [context renderbufferStorage:GL_RENDERBUFFER fromDrawable:layer];\n    \n    glGenFramebuffers(1, &framebuffer);\n    glBindFramebuffer(GL_FRAMEBUFFER, framebuffer);\n    glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_RENDERBUFFER, renderbuffer);\n}\n```\n\n解释：`bindRenderLayer`方法主要是将渲染缓冲区与layer绑定，将layer作为渲染缓冲区的输出层。\n\n## 加载几何形状和绘制图元\n\n指定绘图窗口大小：\n``` objectivec\nglViewport(0, 0, self.drawableWidth, self.drawableHeight);\n\n// 获取渲染缓存宽度\n- (GLint)drawableWidth {\n    GLint backingWidth;\n    glGetRenderbufferParameteriv(GL_RENDERBUFFER, GL_RENDERBUFFER_WIDTH, &backingWidth);\n    \n    return backingWidth;\n}\n\n// 获取渲染缓存高度\n- (GLint)drawableHeight {\n    GLint backingHeight;\n    glGetRenderbufferParameteriv(GL_RENDERBUFFER, GL_RENDERBUFFER_HEIGHT, &backingHeight);\n    \n    return backingHeight;\n}\n```\n\n创建程序对象并使用：\n``` objectivec\nGLuint program = [self createProgram:@\"glsl\"];\nif (!program) {\n    return;\n}\nglUseProgram(program);\n```\n\n清除颜色缓冲区，避免将以前的内容加载到内存中造成高消耗，为确保最佳性能，应该在每次绘图之前调用：\n``` objectivec\nglClearColor(0.0, 0.0, 0.0, 1.0);\nglClear(GL_COLOR_BUFFER_BIT);\n```\n\n指定三角形的几何形状，由(x, y, z)3个坐标点指定：\n\n``` objectivec\nGLfloat vVertices[] = {\n    0.0f, 0.5f, 0.0f,\n    -0.5f, -0.5f, 0.0f,\n    0.5f, -0.5f, 0.0f\n};\n```\n\n绘制图元：\n``` objectivec\n// 启用顶点并设置顶点数据\nglEnableVertexAttribArray(GLKVertexAttribPosition);\nglVertexAttribPointer(GLKVertexAttribPosition, 3, GL_FLOAT, GL_FALSE, 0, vVertices);\n\n// 开始绘制\nglDrawArrays(GL_TRIANGLES, 0, 3);\n```\n\n将渲染结果呈现到屏幕\n``` objectivec\n[context presentRenderbuffer:GL_RENDERBUFFER];\n```\n\n最终，就会在页面上绘画出一个三角形：\n\n![Triangle Picture](/img/article/20190606/1.png)\n\n# 使用GLKit绘制三角形\n\n除了上述使用自定义着色器进行绘制，苹果本身也封装了简易着色器的GLKit供我们实现简单的绘制功能，下面就来介绍使用GLKit绘制三角形。\n\n使用GLKit绘制有两种方式：一种是使用继承`GLKView`并复写`drawRect:`方法进行渲染操作，另一种就是使用`GLKView`的代理方法进行渲染。这两种方法都需要用到`GLKBaseEffect`类，这个类内部就实现了着色器的编译链接过程，简化了整个操作。\n\n## 继承GLKView进行绘制\n\n基础`GLKView`，并复写`drawRect:`方法，创建`GLKBaseEffect`实例并为OpenGL ES渲染准备一个效果，即将编译后的着色器程序绑定到上下文并返回，最后进行顶点设置并绘制：\n\n``` objectivec\n@interface TriangleGLKView ()\n\n@property (nonatomic, strong) GLKBaseEffect *baseEffect;\n\n@end\n\n@implementation TriangleGLKView\n\n- (instancetype)initWithFrame:(CGRect)frame context:(nonnull EAGLContext *)context {\n    self = [super initWithFrame:frame context:context];\n    if (self) {\n        self.baseEffect = [[GLKBaseEffect alloc] init];\n        self.baseEffect.constantColor = GLKVector4Make(0.0, 1.0, 0.0, 1.0);\n    }\n    return self;\n}\n\n\n- (void)drawRect:(CGRect)rect {\n    \n    glClearColor(1.0, 0.0, 0.0, 1.0);\n    glClear(GL_COLOR_BUFFER_BIT);\n    \n    // 准备渲染，将编译后的着色器程序绑定到上下文并返回\n    [self.baseEffect prepareToDraw];\n    \n    GLfloat vVertice[] = {\n        0.0, 0.5, 0.0,\n        -0.5, -0.5, 0.0,\n        0.5, -0.5, 0.0\n    };\n    \n    // 启用顶点并设置顶点数据\n    glEnableVertexAttribArray(GLKVertexAttribPosition);\n    glVertexAttribPointer(GLKVertexAttribPosition, 3, GL_FLOAT, GL_FALSE, 0, vVertice);\n\n    // 开始绘制\n    glDrawArrays(GL_TRIANGLES, 0, 3);\n}\n\n@end\n```\n\n## 使用代理绘制\n\n设置上下文，创建`GLKView`实例并设置代理，实现代理方法，同样使用`GLKBaseEffect`类，与继承方法对比，就是将渲染操作在代理中调用：\n\n``` objectivec\n- (void)initialize {\n    EAGLContext *context = [[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES3];\n    [EAGLContext setCurrentContext:context];\n\n    GLKView *glkView = [[GLKView alloc] initWithFrame:self.view.bounds context:context];\n    glkView.backgroundColor = [UIColor clearColor];\n    glkView.delegate = self;\n    [self.view addSubview:glkView];\n    \n    self.baseEffect = [[GLKBaseEffect alloc] init];\n    self.baseEffect.constantColor = GLKVector4Make(0.0, 1.0, 0.0, 1.0);\n    \n    [glkView display];\n}\n\n\n- (void)glkView:(GLKView *)view drawInRect:(CGRect)rect {\n    glClearColor(1.0, 0.0, 0.0, 1.0);\n    glClear(GL_COLOR_BUFFER_BIT);\n    \n    [self.baseEffect prepareToDraw];\n    \n    GLfloat vVertice[] = {\n        0.0, 0.5, 0.0,\n        -0.5, -0.5, 0.0,\n        0.5, -0.5, 0.0\n    };\n    \n    glEnableVertexAttribArray(GLKVertexAttribPosition);\n    glVertexAttribPointer(GLKVertexAttribPosition, 3, GL_FLOAT, GL_FALSE, 0, vVertice);\n    glDrawArrays(GL_TRIANGLES, 0, 3);\n}\n```\n\n# 结语\n\n简单的三角形绘制就结束了，在理解了整个渲染过程，不管是自定义着色器还是使用封装的GLKit方式渲染，包括后续的Metal渲染，都能够找到丝丝关联，在学习中更加有关联性。[Demo](https://github.com/Quincy-QC/OpenGL-ES-Study)","source":"_posts/2019/opengl-es-draw-triangles-0606.md","raw":"---\ntitle: \"使用OpenGL ES绘制三角形\"\ncatalog: true\ntoc_nav_num: true\ndate: 2019-06-06 19:23:02\nsubtitle: \"About OpenGL ES\"\nheader-img: \"/img/article_header/article_header.png\"\nbusuanzi: true\ntags:\n- iOS\n\n---\n\n# 前言\n\nOpenGL ES的学习，本来是在苹果官方文档上学习，但是该文档是针对基于有一定OpenGL ES基础的人员在iOS和Mac OS平台上的开发时的配置介绍和性能提升，并没有OpenGL ES基础的教学，可以用来后期在有一定知识情况下开发时使用手册。所以，这里从OpenGL ES的最基础开始说起，使用OpenGL ES绘制三角形。\n\n# 自定义着色器绘制三角形\n\n首先我们通过最原始的代码使用OpenGL ES创建一个三角形，这里需要我们自己编写着色器，着色器包含顶点着色器和片段着色器，编写着色器需要用它特有的语言--GLSL，关于GLSL的语法，参见[着色器语言](https://github.com/wshxbqq/GLSL-Card)。\n\n## 着色器的编写\n\n现在我们开始着色器代码的编写，首先我们要创建两个文件，一般顶点着色器使用后缀`.vsh`，片段着色器使用后缀`.fsh`（这边命名可以随意，但是这样命名比较规范）。当然，其实我们也可以不用使用文件声明着色器代码，也可以直接声明一个常量字符串，将代码写入字符串，因为使用文件最终也是读取成字符串形式然后创建着色器，但是使用文件调理更加清晰。\n\n顶点着色器代码：\n``` \n#version 300 es\nlayout(location = 0) in vec4 vPosition;\nvoid main() {\n    gl_Position = vPosition;\n}\n```\n解释：\n1. 第一行代码声明了着色器的版本，V3.00；\n2. 第二行代码`layout(location = 0)`限定符表示这个变量的位置在顶点属性0的位置；`in vec4 vPosition`表示输出的四维向量；\n3. 最后三行就是着色器的main函数，着色器执行的起点；内部就是将输入的四维向量传递给名为`gl_Position`的特殊输出变量，每个顶点着色器必须在`gl_Position`变量中输出一个位置，这个变量定义传递到管线下一个阶段的位置；\n\n片段着色器代码：\n```\n#version 300 es\nprecision mediump float;\nout vec4 fragColor;\nvoid main() {\n    fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n}\n```\n解释：\n1. 第一行代码声明了着色器的版本，V3.00；\n2. 第二行代码声明着色器中浮点变量的默认精度；\n3. 第三行代码声明一个输出变量`fragColor`，同样是四维向量，这个值将被传输到颜色缓冲区；\n4. 最后三行代码就是着色器的man函数，着色器执行的起点；内部就是给定一个默认的思维向量颜色；\n\n## 编译和加载着色器\n\n上面定义了着色器的源代码，这里就可以将着色器加载到OpenGL ES中。这里定义一个`loadShaderWithName:type:`函数编译和加载着色器：\n\n``` objectivec\n- (GLuint)loadShaderWithName:(NSString *)name type:(GLenum)shaderType {\n    \n    // 从文件中读取着色器代码\n    NSString *shaderPath = [[NSBundle mainBundle] pathForResource:name ofType:shaderType == GL_VERTEX_SHADER ? @\"vsh\" : @\"fsh\"];\n    NSError *error;\n    NSString *shaderString = [NSString stringWithContentsOfFile:shaderPath encoding:NSUTF8StringEncoding error:&error];\n    if (!shaderString) {\n        NSAssert(NO, @\"读取Shader失败，%@\", error.localizedDescription);\n        return 0;\n    }\n    \n    // 创建shader对象\n    GLuint shader = glCreateShader(shaderType);\n    if (!shader) {\n        return 0;\n    }\n    \n    // 获取shader内容\n    const GLchar *shaderStringUTF8 = [shaderString UTF8String];\n    glShaderSource(shader, 1, &shaderStringUTF8, NULL);\n    \n    // 编译shader\n    glCompileShader(shader);\n    \n    // 查询shader编译状态\n    GLint compiled;\n    glGetShaderiv(shader, GL_COMPILE_STATUS, &compiled);\n    if (!compiled) {\n        GLint infoLen;\n        glGetShaderiv(shader, GL_INFO_LOG_LENGTH, &infoLen);\n        if (infoLen > 1) {\n            GLchar *infoLog = malloc(sizeof(GLchar) * infoLen);\n            glGetShaderInfoLog(shader, infoLen, NULL, infoLog);\n            NSAssert(NO, @\"编译shader失败，%s\", infoLog);\n            free(infoLog);\n        }\n        glDeleteShader(shader);\n        return 0;\n    }\n    return shader;\n}\n```\n\n## 创建一个程序对象并链接着色器\n\n不同的着色器编译为一个着色器对象之后，必须连接到一个程序对象并一起链接，才能绘制图形。程序对象可以视为最终链接的程序。\n\n``` objectivec\n- (GLuint)createProgram:(NSString *)programName {\n\n    // 获取着色器对象\n    GLuint vertexShader = [self loadShaderWithName:programName type:GL_VERTEX_SHADER];\n    GLuint fragmentShader = [self loadShaderWithName:programName type:GL_FRAGMENT_SHADER];\n    \n    // 创建program对象\n    GLuint program = glCreateProgram();\n    if (!program) {\n        return 0;\n    }\n    \n    // program关联shader\n    glAttachShader(program, vertexShader);\n    glAttachShader(program, fragmentShader);\n    \n    // 链接program\n    glLinkProgram(program);\n    \n    // 查询program状态\n    GLint linked;\n    glGetProgramiv(program, GL_LINK_STATUS, &linked);\n    if (!linked) {\n        GLint infoLen;\n        glGetProgramiv(program, GL_INFO_LOG_LENGTH, &infoLen);\n        if (infoLen > 1) {\n            GLchar *infoLog = malloc(sizeof(GLchar) * infoLen);\n            glGetProgramInfoLog(program, infoLen, NULL, infoLog);\n            NSAssert(NO, @\"program链接失败，%s\", infoLog);\n            free(infoLog);\n        }\n        glDeleteProgram(program);\n        return 0;\n    }\n    return program;\n}\n```\n\n## 创建渲染上下文\n\n现在我们已经有了链接着着色器对象的程序对象，下面就是开始渲染绘制操作。首先创建渲染上下文并设置为当前上下文，这里就直接使用OpenGL ES 3.0：\n\n``` objectivec\nEAGLContext *context = [[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES3];\n[EAGLContext setCurrentContext:context];\n```\n\n## 使用CAEAGLLayer作为渲染目标\n\n在iOS中，我们先用`CAEAGLLayer`作为渲染目标，当然后面也有其他方式，我们先讨论这个方法：\n\n```\n- (void)initialize {\n    // layer的创建，并添加到父layer上\n    CAEAGLLayer *layer = [[CAEAGLLayer alloc] init];\n    layer.frame = self.view.bounds;\n    [self.view.layer addSublayer:layer];\n    \n    // 创建颜色渲染缓冲区，绑定到帧缓冲区，并将layer对象的存储绑定到OpenGL ES的渲染缓冲区对象\n    [self bindRenderLayer:layer context:context];\n}\n\n- (void)bindRenderLayer:(CALayer <EAGLDrawable> *)layer context:(EAGLContext *)context {\n    GLuint renderbuffer;\n    GLuint framebuffer;\n    glGenRenderbuffers(1, &renderbuffer);\n    glBindRenderbuffer(GL_RENDERBUFFER, renderbuffer);\n    [context renderbufferStorage:GL_RENDERBUFFER fromDrawable:layer];\n    \n    glGenFramebuffers(1, &framebuffer);\n    glBindFramebuffer(GL_FRAMEBUFFER, framebuffer);\n    glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_RENDERBUFFER, renderbuffer);\n}\n```\n\n解释：`bindRenderLayer`方法主要是将渲染缓冲区与layer绑定，将layer作为渲染缓冲区的输出层。\n\n## 加载几何形状和绘制图元\n\n指定绘图窗口大小：\n``` objectivec\nglViewport(0, 0, self.drawableWidth, self.drawableHeight);\n\n// 获取渲染缓存宽度\n- (GLint)drawableWidth {\n    GLint backingWidth;\n    glGetRenderbufferParameteriv(GL_RENDERBUFFER, GL_RENDERBUFFER_WIDTH, &backingWidth);\n    \n    return backingWidth;\n}\n\n// 获取渲染缓存高度\n- (GLint)drawableHeight {\n    GLint backingHeight;\n    glGetRenderbufferParameteriv(GL_RENDERBUFFER, GL_RENDERBUFFER_HEIGHT, &backingHeight);\n    \n    return backingHeight;\n}\n```\n\n创建程序对象并使用：\n``` objectivec\nGLuint program = [self createProgram:@\"glsl\"];\nif (!program) {\n    return;\n}\nglUseProgram(program);\n```\n\n清除颜色缓冲区，避免将以前的内容加载到内存中造成高消耗，为确保最佳性能，应该在每次绘图之前调用：\n``` objectivec\nglClearColor(0.0, 0.0, 0.0, 1.0);\nglClear(GL_COLOR_BUFFER_BIT);\n```\n\n指定三角形的几何形状，由(x, y, z)3个坐标点指定：\n\n``` objectivec\nGLfloat vVertices[] = {\n    0.0f, 0.5f, 0.0f,\n    -0.5f, -0.5f, 0.0f,\n    0.5f, -0.5f, 0.0f\n};\n```\n\n绘制图元：\n``` objectivec\n// 启用顶点并设置顶点数据\nglEnableVertexAttribArray(GLKVertexAttribPosition);\nglVertexAttribPointer(GLKVertexAttribPosition, 3, GL_FLOAT, GL_FALSE, 0, vVertices);\n\n// 开始绘制\nglDrawArrays(GL_TRIANGLES, 0, 3);\n```\n\n将渲染结果呈现到屏幕\n``` objectivec\n[context presentRenderbuffer:GL_RENDERBUFFER];\n```\n\n最终，就会在页面上绘画出一个三角形：\n\n![Triangle Picture](/img/article/20190606/1.png)\n\n# 使用GLKit绘制三角形\n\n除了上述使用自定义着色器进行绘制，苹果本身也封装了简易着色器的GLKit供我们实现简单的绘制功能，下面就来介绍使用GLKit绘制三角形。\n\n使用GLKit绘制有两种方式：一种是使用继承`GLKView`并复写`drawRect:`方法进行渲染操作，另一种就是使用`GLKView`的代理方法进行渲染。这两种方法都需要用到`GLKBaseEffect`类，这个类内部就实现了着色器的编译链接过程，简化了整个操作。\n\n## 继承GLKView进行绘制\n\n基础`GLKView`，并复写`drawRect:`方法，创建`GLKBaseEffect`实例并为OpenGL ES渲染准备一个效果，即将编译后的着色器程序绑定到上下文并返回，最后进行顶点设置并绘制：\n\n``` objectivec\n@interface TriangleGLKView ()\n\n@property (nonatomic, strong) GLKBaseEffect *baseEffect;\n\n@end\n\n@implementation TriangleGLKView\n\n- (instancetype)initWithFrame:(CGRect)frame context:(nonnull EAGLContext *)context {\n    self = [super initWithFrame:frame context:context];\n    if (self) {\n        self.baseEffect = [[GLKBaseEffect alloc] init];\n        self.baseEffect.constantColor = GLKVector4Make(0.0, 1.0, 0.0, 1.0);\n    }\n    return self;\n}\n\n\n- (void)drawRect:(CGRect)rect {\n    \n    glClearColor(1.0, 0.0, 0.0, 1.0);\n    glClear(GL_COLOR_BUFFER_BIT);\n    \n    // 准备渲染，将编译后的着色器程序绑定到上下文并返回\n    [self.baseEffect prepareToDraw];\n    \n    GLfloat vVertice[] = {\n        0.0, 0.5, 0.0,\n        -0.5, -0.5, 0.0,\n        0.5, -0.5, 0.0\n    };\n    \n    // 启用顶点并设置顶点数据\n    glEnableVertexAttribArray(GLKVertexAttribPosition);\n    glVertexAttribPointer(GLKVertexAttribPosition, 3, GL_FLOAT, GL_FALSE, 0, vVertice);\n\n    // 开始绘制\n    glDrawArrays(GL_TRIANGLES, 0, 3);\n}\n\n@end\n```\n\n## 使用代理绘制\n\n设置上下文，创建`GLKView`实例并设置代理，实现代理方法，同样使用`GLKBaseEffect`类，与继承方法对比，就是将渲染操作在代理中调用：\n\n``` objectivec\n- (void)initialize {\n    EAGLContext *context = [[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES3];\n    [EAGLContext setCurrentContext:context];\n\n    GLKView *glkView = [[GLKView alloc] initWithFrame:self.view.bounds context:context];\n    glkView.backgroundColor = [UIColor clearColor];\n    glkView.delegate = self;\n    [self.view addSubview:glkView];\n    \n    self.baseEffect = [[GLKBaseEffect alloc] init];\n    self.baseEffect.constantColor = GLKVector4Make(0.0, 1.0, 0.0, 1.0);\n    \n    [glkView display];\n}\n\n\n- (void)glkView:(GLKView *)view drawInRect:(CGRect)rect {\n    glClearColor(1.0, 0.0, 0.0, 1.0);\n    glClear(GL_COLOR_BUFFER_BIT);\n    \n    [self.baseEffect prepareToDraw];\n    \n    GLfloat vVertice[] = {\n        0.0, 0.5, 0.0,\n        -0.5, -0.5, 0.0,\n        0.5, -0.5, 0.0\n    };\n    \n    glEnableVertexAttribArray(GLKVertexAttribPosition);\n    glVertexAttribPointer(GLKVertexAttribPosition, 3, GL_FLOAT, GL_FALSE, 0, vVertice);\n    glDrawArrays(GL_TRIANGLES, 0, 3);\n}\n```\n\n# 结语\n\n简单的三角形绘制就结束了，在理解了整个渲染过程，不管是自定义着色器还是使用封装的GLKit方式渲染，包括后续的Metal渲染，都能够找到丝丝关联，在学习中更加有关联性。[Demo](https://github.com/Quincy-QC/OpenGL-ES-Study)","slug":"2019/opengl-es-draw-triangles-0606","published":1,"updated":"2022-01-10T09:04:52.805Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cky8gmc48000pd1qho9nljqad","content":"<h1 id=\"前言\">前言</h1>\n<p>OpenGL ES的学习，本来是在苹果官方文档上学习，但是该文档是针对基于有一定OpenGL ES基础的人员在iOS和Mac OS平台上的开发时的配置介绍和性能提升，并没有OpenGL ES基础的教学，可以用来后期在有一定知识情况下开发时使用手册。所以，这里从OpenGL ES的最基础开始说起，使用OpenGL ES绘制三角形。</p>\n<h1 id=\"自定义着色器绘制三角形\">自定义着色器绘制三角形</h1>\n<p>首先我们通过最原始的代码使用OpenGL ES创建一个三角形，这里需要我们自己编写着色器，着色器包含顶点着色器和片段着色器，编写着色器需要用它特有的语言–GLSL，关于GLSL的语法，参见<a href=\"https://github.com/wshxbqq/GLSL-Card\" target=\"_blank\" rel=\"noopener\">着色器语言</a>。</p>\n<h2 id=\"着色器的编写\">着色器的编写</h2>\n<p>现在我们开始着色器代码的编写，首先我们要创建两个文件，一般顶点着色器使用后缀<code>.vsh</code>，片段着色器使用后缀<code>.fsh</code>（这边命名可以随意，但是这样命名比较规范）。当然，其实我们也可以不用使用文件声明着色器代码，也可以直接声明一个常量字符串，将代码写入字符串，因为使用文件最终也是读取成字符串形式然后创建着色器，但是使用文件调理更加清晰。</p>\n<p>顶点着色器代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#version 300 es</span><br><span class=\"line\">layout(location = 0) in vec4 vPosition;</span><br><span class=\"line\">void main() &#123;</span><br><span class=\"line\">    gl_Position = vPosition;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>解释：</p>\n<ol>\n<li>第一行代码声明了着色器的版本，V3.00；</li>\n<li>第二行代码<code>layout(location = 0)</code>限定符表示这个变量的位置在顶点属性0的位置；<code>in vec4 vPosition</code>表示输出的四维向量；</li>\n<li>最后三行就是着色器的main函数，着色器执行的起点；内部就是将输入的四维向量传递给名为<code>gl_Position</code>的特殊输出变量，每个顶点着色器必须在<code>gl_Position</code>变量中输出一个位置，这个变量定义传递到管线下一个阶段的位置；</li>\n</ol>\n<p>片段着色器代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#version 300 es</span><br><span class=\"line\">precision mediump float;</span><br><span class=\"line\">out vec4 fragColor;</span><br><span class=\"line\">void main() &#123;</span><br><span class=\"line\">    fragColor = vec4(1.0, 0.0, 0.0, 1.0);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>解释：</p>\n<ol>\n<li>第一行代码声明了着色器的版本，V3.00；</li>\n<li>第二行代码声明着色器中浮点变量的默认精度；</li>\n<li>第三行代码声明一个输出变量<code>fragColor</code>，同样是四维向量，这个值将被传输到颜色缓冲区；</li>\n<li>最后三行代码就是着色器的man函数，着色器执行的起点；内部就是给定一个默认的思维向量颜色；</li>\n</ol>\n<h2 id=\"编译和加载着色器\">编译和加载着色器</h2>\n<p>上面定义了着色器的源代码，这里就可以将着色器加载到OpenGL ES中。这里定义一个<code>loadShaderWithName:type:</code>函数编译和加载着色器：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (GLuint)loadShaderWithName:(<span class=\"built_in\">NSString</span> *)name type:(GLenum)shaderType &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 从文件中读取着色器代码</span></span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> *shaderPath = [[<span class=\"built_in\">NSBundle</span> mainBundle] pathForResource:name ofType:shaderType == GL_VERTEX_SHADER ? <span class=\"string\">@\"vsh\"</span> : <span class=\"string\">@\"fsh\"</span>];</span><br><span class=\"line\">    <span class=\"built_in\">NSError</span> *error;</span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> *shaderString = [<span class=\"built_in\">NSString</span> stringWithContentsOfFile:shaderPath encoding:<span class=\"built_in\">NSUTF8StringEncoding</span> error:&amp;error];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!shaderString) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSAssert</span>(<span class=\"literal\">NO</span>, <span class=\"string\">@\"读取Shader失败，%@\"</span>, error.localizedDescription);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 创建shader对象</span></span><br><span class=\"line\">    GLuint shader = glCreateShader(shaderType);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!shader) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 获取shader内容</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> GLchar *shaderStringUTF8 = [shaderString UTF8String];</span><br><span class=\"line\">    glShaderSource(shader, <span class=\"number\">1</span>, &amp;shaderStringUTF8, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 编译shader</span></span><br><span class=\"line\">    glCompileShader(shader);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 查询shader编译状态</span></span><br><span class=\"line\">    GLint compiled;</span><br><span class=\"line\">    glGetShaderiv(shader, GL_COMPILE_STATUS, &amp;compiled);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!compiled) &#123;</span><br><span class=\"line\">        GLint infoLen;</span><br><span class=\"line\">        glGetShaderiv(shader, GL_INFO_LOG_LENGTH, &amp;infoLen);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (infoLen &gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            GLchar *infoLog = malloc(<span class=\"keyword\">sizeof</span>(GLchar) * infoLen);</span><br><span class=\"line\">            glGetShaderInfoLog(shader, infoLen, <span class=\"literal\">NULL</span>, infoLog);</span><br><span class=\"line\">            <span class=\"built_in\">NSAssert</span>(<span class=\"literal\">NO</span>, <span class=\"string\">@\"编译shader失败，%s\"</span>, infoLog);</span><br><span class=\"line\">            free(infoLog);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        glDeleteShader(shader);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> shader;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"创建一个程序对象并链接着色器\">创建一个程序对象并链接着色器</h2>\n<p>不同的着色器编译为一个着色器对象之后，必须连接到一个程序对象并一起链接，才能绘制图形。程序对象可以视为最终链接的程序。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (GLuint)createProgram:(<span class=\"built_in\">NSString</span> *)programName &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 获取着色器对象</span></span><br><span class=\"line\">    GLuint vertexShader = [<span class=\"keyword\">self</span> loadShaderWithName:programName type:GL_VERTEX_SHADER];</span><br><span class=\"line\">    GLuint fragmentShader = [<span class=\"keyword\">self</span> loadShaderWithName:programName type:GL_FRAGMENT_SHADER];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 创建program对象</span></span><br><span class=\"line\">    GLuint program = glCreateProgram();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!program) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// program关联shader</span></span><br><span class=\"line\">    glAttachShader(program, vertexShader);</span><br><span class=\"line\">    glAttachShader(program, fragmentShader);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 链接program</span></span><br><span class=\"line\">    glLinkProgram(program);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 查询program状态</span></span><br><span class=\"line\">    GLint linked;</span><br><span class=\"line\">    glGetProgramiv(program, GL_LINK_STATUS, &amp;linked);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!linked) &#123;</span><br><span class=\"line\">        GLint infoLen;</span><br><span class=\"line\">        glGetProgramiv(program, GL_INFO_LOG_LENGTH, &amp;infoLen);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (infoLen &gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            GLchar *infoLog = malloc(<span class=\"keyword\">sizeof</span>(GLchar) * infoLen);</span><br><span class=\"line\">            glGetProgramInfoLog(program, infoLen, <span class=\"literal\">NULL</span>, infoLog);</span><br><span class=\"line\">            <span class=\"built_in\">NSAssert</span>(<span class=\"literal\">NO</span>, <span class=\"string\">@\"program链接失败，%s\"</span>, infoLog);</span><br><span class=\"line\">            free(infoLog);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        glDeleteProgram(program);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> program;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"创建渲染上下文\">创建渲染上下文</h2>\n<p>现在我们已经有了链接着着色器对象的程序对象，下面就是开始渲染绘制操作。首先创建渲染上下文并设置为当前上下文，这里就直接使用OpenGL ES 3.0：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EAGLContext *context = [[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES3];</span><br><span class=\"line\">[EAGLContext setCurrentContext:context];</span><br></pre></td></tr></table></figure>\n<h2 id=\"使用caeagllayer作为渲染目标\">使用CAEAGLLayer作为渲染目标</h2>\n<p>在iOS中，我们先用<code>CAEAGLLayer</code>作为渲染目标，当然后面也有其他方式，我们先讨论这个方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)initialize &#123;</span><br><span class=\"line\">    // layer的创建，并添加到父layer上</span><br><span class=\"line\">    CAEAGLLayer *layer = [[CAEAGLLayer alloc] init];</span><br><span class=\"line\">    layer.frame = self.view.bounds;</span><br><span class=\"line\">    [self.view.layer addSublayer:layer];</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 创建颜色渲染缓冲区，绑定到帧缓冲区，并将layer对象的存储绑定到OpenGL ES的渲染缓冲区对象</span><br><span class=\"line\">    [self bindRenderLayer:layer context:context];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)bindRenderLayer:(CALayer &lt;EAGLDrawable&gt; *)layer context:(EAGLContext *)context &#123;</span><br><span class=\"line\">    GLuint renderbuffer;</span><br><span class=\"line\">    GLuint framebuffer;</span><br><span class=\"line\">    glGenRenderbuffers(1, &amp;renderbuffer);</span><br><span class=\"line\">    glBindRenderbuffer(GL_RENDERBUFFER, renderbuffer);</span><br><span class=\"line\">    [context renderbufferStorage:GL_RENDERBUFFER fromDrawable:layer];</span><br><span class=\"line\">    </span><br><span class=\"line\">    glGenFramebuffers(1, &amp;framebuffer);</span><br><span class=\"line\">    glBindFramebuffer(GL_FRAMEBUFFER, framebuffer);</span><br><span class=\"line\">    glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_RENDERBUFFER, renderbuffer);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>解释：<code>bindRenderLayer</code>方法主要是将渲染缓冲区与layer绑定，将layer作为渲染缓冲区的输出层。</p>\n<h2 id=\"加载几何形状和绘制图元\">加载几何形状和绘制图元</h2>\n<p>指定绘图窗口大小：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">glViewport(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"keyword\">self</span>.drawableWidth, <span class=\"keyword\">self</span>.drawableHeight);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取渲染缓存宽度</span></span><br><span class=\"line\">- (GLint)drawableWidth &#123;</span><br><span class=\"line\">    GLint backingWidth;</span><br><span class=\"line\">    glGetRenderbufferParameteriv(GL_RENDERBUFFER, GL_RENDERBUFFER_WIDTH, &amp;backingWidth);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> backingWidth;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取渲染缓存高度</span></span><br><span class=\"line\">- (GLint)drawableHeight &#123;</span><br><span class=\"line\">    GLint backingHeight;</span><br><span class=\"line\">    glGetRenderbufferParameteriv(GL_RENDERBUFFER, GL_RENDERBUFFER_HEIGHT, &amp;backingHeight);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> backingHeight;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>创建程序对象并使用：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GLuint program = [<span class=\"keyword\">self</span> createProgram:<span class=\"string\">@\"glsl\"</span>];</span><br><span class=\"line\"><span class=\"keyword\">if</span> (!program) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">glUseProgram(program);</span><br></pre></td></tr></table></figure>\n<p>清除颜色缓冲区，避免将以前的内容加载到内存中造成高消耗，为确保最佳性能，应该在每次绘图之前调用：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">glClearColor(<span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>);</span><br><span class=\"line\">glClear(GL_COLOR_BUFFER_BIT);</span><br></pre></td></tr></table></figure>\n<p>指定三角形的几何形状，由(x, y, z)3个坐标点指定：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GLfloat vVertices[] = &#123;</span><br><span class=\"line\">    <span class=\"number\">0.0</span>f, <span class=\"number\">0.5</span>f, <span class=\"number\">0.0</span>f,</span><br><span class=\"line\">    <span class=\"number\">-0.5</span>f, <span class=\"number\">-0.5</span>f, <span class=\"number\">0.0</span>f,</span><br><span class=\"line\">    <span class=\"number\">0.5</span>f, <span class=\"number\">-0.5</span>f, <span class=\"number\">0.0</span>f</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>绘制图元：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 启用顶点并设置顶点数据</span></span><br><span class=\"line\">glEnableVertexAttribArray(GLKVertexAttribPosition);</span><br><span class=\"line\">glVertexAttribPointer(GLKVertexAttribPosition, <span class=\"number\">3</span>, GL_FLOAT, GL_FALSE, <span class=\"number\">0</span>, vVertices);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 开始绘制</span></span><br><span class=\"line\">glDrawArrays(GL_TRIANGLES, <span class=\"number\">0</span>, <span class=\"number\">3</span>);</span><br></pre></td></tr></table></figure>\n<p>将渲染结果呈现到屏幕</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[context presentRenderbuffer:GL_RENDERBUFFER];</span><br></pre></td></tr></table></figure>\n<p>最终，就会在页面上绘画出一个三角形：</p>\n<p><img src=\"/img/article/20190606/1.png\" alt=\"Triangle Picture\"></p>\n<h1 id=\"使用glkit绘制三角形\">使用GLKit绘制三角形</h1>\n<p>除了上述使用自定义着色器进行绘制，苹果本身也封装了简易着色器的GLKit供我们实现简单的绘制功能，下面就来介绍使用GLKit绘制三角形。</p>\n<p>使用GLKit绘制有两种方式：一种是使用继承<code>GLKView</code>并复写<code>drawRect:</code>方法进行渲染操作，另一种就是使用<code>GLKView</code>的代理方法进行渲染。这两种方法都需要用到<code>GLKBaseEffect</code>类，这个类内部就实现了着色器的编译链接过程，简化了整个操作。</p>\n<h2 id=\"继承glkview进行绘制\">继承GLKView进行绘制</h2>\n<p>基础<code>GLKView</code>，并复写<code>drawRect:</code>方法，创建<code>GLKBaseEffect</code>实例并为OpenGL ES渲染准备一个效果，即将编译后的着色器程序绑定到上下文并返回，最后进行顶点设置并绘制：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">TriangleGLKView</span> ()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) GLKBaseEffect *baseEffect;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">TriangleGLKView</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">instancetype</span>)initWithFrame:(<span class=\"built_in\">CGRect</span>)frame context:(<span class=\"keyword\">nonnull</span> EAGLContext *)context &#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span> = [<span class=\"keyword\">super</span> initWithFrame:frame context:context];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.baseEffect = [[GLKBaseEffect alloc] init];</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.baseEffect.constantColor = GLKVector4Make(<span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)drawRect:(<span class=\"built_in\">CGRect</span>)rect &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    glClearColor(<span class=\"number\">1.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>);</span><br><span class=\"line\">    glClear(GL_COLOR_BUFFER_BIT);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 准备渲染，将编译后的着色器程序绑定到上下文并返回</span></span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.baseEffect prepareToDraw];</span><br><span class=\"line\">    </span><br><span class=\"line\">    GLfloat vVertice[] = &#123;</span><br><span class=\"line\">        <span class=\"number\">0.0</span>, <span class=\"number\">0.5</span>, <span class=\"number\">0.0</span>,</span><br><span class=\"line\">        <span class=\"number\">-0.5</span>, <span class=\"number\">-0.5</span>, <span class=\"number\">0.0</span>,</span><br><span class=\"line\">        <span class=\"number\">0.5</span>, <span class=\"number\">-0.5</span>, <span class=\"number\">0.0</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 启用顶点并设置顶点数据</span></span><br><span class=\"line\">    glEnableVertexAttribArray(GLKVertexAttribPosition);</span><br><span class=\"line\">    glVertexAttribPointer(GLKVertexAttribPosition, <span class=\"number\">3</span>, GL_FLOAT, GL_FALSE, <span class=\"number\">0</span>, vVertice);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 开始绘制</span></span><br><span class=\"line\">    glDrawArrays(GL_TRIANGLES, <span class=\"number\">0</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"使用代理绘制\">使用代理绘制</h2>\n<p>设置上下文，创建<code>GLKView</code>实例并设置代理，实现代理方法，同样使用<code>GLKBaseEffect</code>类，与继承方法对比，就是将渲染操作在代理中调用：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)initialize &#123;</span><br><span class=\"line\">    EAGLContext *context = [[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES3];</span><br><span class=\"line\">    [EAGLContext setCurrentContext:context];</span><br><span class=\"line\"></span><br><span class=\"line\">    GLKView *glkView = [[GLKView alloc] initWithFrame:<span class=\"keyword\">self</span>.view.bounds context:context];</span><br><span class=\"line\">    glkView.backgroundColor = [<span class=\"built_in\">UIColor</span> clearColor];</span><br><span class=\"line\">    glkView.delegate = <span class=\"keyword\">self</span>;</span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.view addSubview:glkView];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">self</span>.baseEffect = [[GLKBaseEffect alloc] init];</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.baseEffect.constantColor = GLKVector4Make(<span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    [glkView display];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)glkView:(GLKView *)view drawInRect:(<span class=\"built_in\">CGRect</span>)rect &#123;</span><br><span class=\"line\">    glClearColor(<span class=\"number\">1.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>);</span><br><span class=\"line\">    glClear(GL_COLOR_BUFFER_BIT);</span><br><span class=\"line\">    </span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.baseEffect prepareToDraw];</span><br><span class=\"line\">    </span><br><span class=\"line\">    GLfloat vVertice[] = &#123;</span><br><span class=\"line\">        <span class=\"number\">0.0</span>, <span class=\"number\">0.5</span>, <span class=\"number\">0.0</span>,</span><br><span class=\"line\">        <span class=\"number\">-0.5</span>, <span class=\"number\">-0.5</span>, <span class=\"number\">0.0</span>,</span><br><span class=\"line\">        <span class=\"number\">0.5</span>, <span class=\"number\">-0.5</span>, <span class=\"number\">0.0</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    glEnableVertexAttribArray(GLKVertexAttribPosition);</span><br><span class=\"line\">    glVertexAttribPointer(GLKVertexAttribPosition, <span class=\"number\">3</span>, GL_FLOAT, GL_FALSE, <span class=\"number\">0</span>, vVertice);</span><br><span class=\"line\">    glDrawArrays(GL_TRIANGLES, <span class=\"number\">0</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"结语\">结语</h1>\n<p>简单的三角形绘制就结束了，在理解了整个渲染过程，不管是自定义着色器还是使用封装的GLKit方式渲染，包括后续的Metal渲染，都能够找到丝丝关联，在学习中更加有关联性。<a href=\"https://github.com/Quincy-QC/OpenGL-ES-Study\" target=\"_blank\" rel=\"noopener\">Demo</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1>前言</h1>\n<p>OpenGL ES的学习，本来是在苹果官方文档上学习，但是该文档是针对基于有一定OpenGL ES基础的人员在iOS和Mac OS平台上的开发时的配置介绍和性能提升，并没有OpenGL ES基础的教学，可以用来后期在有一定知识情况下开发时使用手册。所以，这里从OpenGL ES的最基础开始说起，使用OpenGL ES绘制三角形。</p>\n<h1>自定义着色器绘制三角形</h1>\n<p>首先我们通过最原始的代码使用OpenGL ES创建一个三角形，这里需要我们自己编写着色器，着色器包含顶点着色器和片段着色器，编写着色器需要用它特有的语言–GLSL，关于GLSL的语法，参见<a href=\"https://github.com/wshxbqq/GLSL-Card\" target=\"_blank\" rel=\"noopener\">着色器语言</a>。</p>\n<h2>着色器的编写</h2>\n<p>现在我们开始着色器代码的编写，首先我们要创建两个文件，一般顶点着色器使用后缀<code>.vsh</code>，片段着色器使用后缀<code>.fsh</code>（这边命名可以随意，但是这样命名比较规范）。当然，其实我们也可以不用使用文件声明着色器代码，也可以直接声明一个常量字符串，将代码写入字符串，因为使用文件最终也是读取成字符串形式然后创建着色器，但是使用文件调理更加清晰。</p>\n<p>顶点着色器代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#version 300 es</span><br><span class=\"line\">layout(location = 0) in vec4 vPosition;</span><br><span class=\"line\">void main() &#123;</span><br><span class=\"line\">    gl_Position = vPosition;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>解释：</p>\n<ol>\n<li>第一行代码声明了着色器的版本，V3.00；</li>\n<li>第二行代码<code>layout(location = 0)</code>限定符表示这个变量的位置在顶点属性0的位置；<code>in vec4 vPosition</code>表示输出的四维向量；</li>\n<li>最后三行就是着色器的main函数，着色器执行的起点；内部就是将输入的四维向量传递给名为<code>gl_Position</code>的特殊输出变量，每个顶点着色器必须在<code>gl_Position</code>变量中输出一个位置，这个变量定义传递到管线下一个阶段的位置；</li>\n</ol>\n<p>片段着色器代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#version 300 es</span><br><span class=\"line\">precision mediump float;</span><br><span class=\"line\">out vec4 fragColor;</span><br><span class=\"line\">void main() &#123;</span><br><span class=\"line\">    fragColor = vec4(1.0, 0.0, 0.0, 1.0);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>解释：</p>\n<ol>\n<li>第一行代码声明了着色器的版本，V3.00；</li>\n<li>第二行代码声明着色器中浮点变量的默认精度；</li>\n<li>第三行代码声明一个输出变量<code>fragColor</code>，同样是四维向量，这个值将被传输到颜色缓冲区；</li>\n<li>最后三行代码就是着色器的man函数，着色器执行的起点；内部就是给定一个默认的思维向量颜色；</li>\n</ol>\n<h2>编译和加载着色器</h2>\n<p>上面定义了着色器的源代码，这里就可以将着色器加载到OpenGL ES中。这里定义一个<code>loadShaderWithName:type:</code>函数编译和加载着色器：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (GLuint)loadShaderWithName:(<span class=\"built_in\">NSString</span> *)name type:(GLenum)shaderType &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 从文件中读取着色器代码</span></span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> *shaderPath = [[<span class=\"built_in\">NSBundle</span> mainBundle] pathForResource:name ofType:shaderType == GL_VERTEX_SHADER ? <span class=\"string\">@\"vsh\"</span> : <span class=\"string\">@\"fsh\"</span>];</span><br><span class=\"line\">    <span class=\"built_in\">NSError</span> *error;</span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> *shaderString = [<span class=\"built_in\">NSString</span> stringWithContentsOfFile:shaderPath encoding:<span class=\"built_in\">NSUTF8StringEncoding</span> error:&amp;error];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!shaderString) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSAssert</span>(<span class=\"literal\">NO</span>, <span class=\"string\">@\"读取Shader失败，%@\"</span>, error.localizedDescription);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 创建shader对象</span></span><br><span class=\"line\">    GLuint shader = glCreateShader(shaderType);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!shader) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 获取shader内容</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> GLchar *shaderStringUTF8 = [shaderString UTF8String];</span><br><span class=\"line\">    glShaderSource(shader, <span class=\"number\">1</span>, &amp;shaderStringUTF8, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 编译shader</span></span><br><span class=\"line\">    glCompileShader(shader);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 查询shader编译状态</span></span><br><span class=\"line\">    GLint compiled;</span><br><span class=\"line\">    glGetShaderiv(shader, GL_COMPILE_STATUS, &amp;compiled);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!compiled) &#123;</span><br><span class=\"line\">        GLint infoLen;</span><br><span class=\"line\">        glGetShaderiv(shader, GL_INFO_LOG_LENGTH, &amp;infoLen);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (infoLen &gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            GLchar *infoLog = malloc(<span class=\"keyword\">sizeof</span>(GLchar) * infoLen);</span><br><span class=\"line\">            glGetShaderInfoLog(shader, infoLen, <span class=\"literal\">NULL</span>, infoLog);</span><br><span class=\"line\">            <span class=\"built_in\">NSAssert</span>(<span class=\"literal\">NO</span>, <span class=\"string\">@\"编译shader失败，%s\"</span>, infoLog);</span><br><span class=\"line\">            free(infoLog);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        glDeleteShader(shader);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> shader;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2>创建一个程序对象并链接着色器</h2>\n<p>不同的着色器编译为一个着色器对象之后，必须连接到一个程序对象并一起链接，才能绘制图形。程序对象可以视为最终链接的程序。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (GLuint)createProgram:(<span class=\"built_in\">NSString</span> *)programName &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 获取着色器对象</span></span><br><span class=\"line\">    GLuint vertexShader = [<span class=\"keyword\">self</span> loadShaderWithName:programName type:GL_VERTEX_SHADER];</span><br><span class=\"line\">    GLuint fragmentShader = [<span class=\"keyword\">self</span> loadShaderWithName:programName type:GL_FRAGMENT_SHADER];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 创建program对象</span></span><br><span class=\"line\">    GLuint program = glCreateProgram();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!program) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// program关联shader</span></span><br><span class=\"line\">    glAttachShader(program, vertexShader);</span><br><span class=\"line\">    glAttachShader(program, fragmentShader);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 链接program</span></span><br><span class=\"line\">    glLinkProgram(program);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 查询program状态</span></span><br><span class=\"line\">    GLint linked;</span><br><span class=\"line\">    glGetProgramiv(program, GL_LINK_STATUS, &amp;linked);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!linked) &#123;</span><br><span class=\"line\">        GLint infoLen;</span><br><span class=\"line\">        glGetProgramiv(program, GL_INFO_LOG_LENGTH, &amp;infoLen);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (infoLen &gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            GLchar *infoLog = malloc(<span class=\"keyword\">sizeof</span>(GLchar) * infoLen);</span><br><span class=\"line\">            glGetProgramInfoLog(program, infoLen, <span class=\"literal\">NULL</span>, infoLog);</span><br><span class=\"line\">            <span class=\"built_in\">NSAssert</span>(<span class=\"literal\">NO</span>, <span class=\"string\">@\"program链接失败，%s\"</span>, infoLog);</span><br><span class=\"line\">            free(infoLog);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        glDeleteProgram(program);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> program;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2>创建渲染上下文</h2>\n<p>现在我们已经有了链接着着色器对象的程序对象，下面就是开始渲染绘制操作。首先创建渲染上下文并设置为当前上下文，这里就直接使用OpenGL ES 3.0：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EAGLContext *context = [[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES3];</span><br><span class=\"line\">[EAGLContext setCurrentContext:context];</span><br></pre></td></tr></table></figure>\n<h2>使用CAEAGLLayer作为渲染目标</h2>\n<p>在iOS中，我们先用<code>CAEAGLLayer</code>作为渲染目标，当然后面也有其他方式，我们先讨论这个方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)initialize &#123;</span><br><span class=\"line\">    // layer的创建，并添加到父layer上</span><br><span class=\"line\">    CAEAGLLayer *layer = [[CAEAGLLayer alloc] init];</span><br><span class=\"line\">    layer.frame = self.view.bounds;</span><br><span class=\"line\">    [self.view.layer addSublayer:layer];</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 创建颜色渲染缓冲区，绑定到帧缓冲区，并将layer对象的存储绑定到OpenGL ES的渲染缓冲区对象</span><br><span class=\"line\">    [self bindRenderLayer:layer context:context];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)bindRenderLayer:(CALayer &lt;EAGLDrawable&gt; *)layer context:(EAGLContext *)context &#123;</span><br><span class=\"line\">    GLuint renderbuffer;</span><br><span class=\"line\">    GLuint framebuffer;</span><br><span class=\"line\">    glGenRenderbuffers(1, &amp;renderbuffer);</span><br><span class=\"line\">    glBindRenderbuffer(GL_RENDERBUFFER, renderbuffer);</span><br><span class=\"line\">    [context renderbufferStorage:GL_RENDERBUFFER fromDrawable:layer];</span><br><span class=\"line\">    </span><br><span class=\"line\">    glGenFramebuffers(1, &amp;framebuffer);</span><br><span class=\"line\">    glBindFramebuffer(GL_FRAMEBUFFER, framebuffer);</span><br><span class=\"line\">    glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_RENDERBUFFER, renderbuffer);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>解释：<code>bindRenderLayer</code>方法主要是将渲染缓冲区与layer绑定，将layer作为渲染缓冲区的输出层。</p>\n<h2>加载几何形状和绘制图元</h2>\n<p>指定绘图窗口大小：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">glViewport(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"keyword\">self</span>.drawableWidth, <span class=\"keyword\">self</span>.drawableHeight);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取渲染缓存宽度</span></span><br><span class=\"line\">- (GLint)drawableWidth &#123;</span><br><span class=\"line\">    GLint backingWidth;</span><br><span class=\"line\">    glGetRenderbufferParameteriv(GL_RENDERBUFFER, GL_RENDERBUFFER_WIDTH, &amp;backingWidth);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> backingWidth;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取渲染缓存高度</span></span><br><span class=\"line\">- (GLint)drawableHeight &#123;</span><br><span class=\"line\">    GLint backingHeight;</span><br><span class=\"line\">    glGetRenderbufferParameteriv(GL_RENDERBUFFER, GL_RENDERBUFFER_HEIGHT, &amp;backingHeight);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> backingHeight;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>创建程序对象并使用：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GLuint program = [<span class=\"keyword\">self</span> createProgram:<span class=\"string\">@\"glsl\"</span>];</span><br><span class=\"line\"><span class=\"keyword\">if</span> (!program) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">glUseProgram(program);</span><br></pre></td></tr></table></figure>\n<p>清除颜色缓冲区，避免将以前的内容加载到内存中造成高消耗，为确保最佳性能，应该在每次绘图之前调用：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">glClearColor(<span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>);</span><br><span class=\"line\">glClear(GL_COLOR_BUFFER_BIT);</span><br></pre></td></tr></table></figure>\n<p>指定三角形的几何形状，由(x, y, z)3个坐标点指定：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GLfloat vVertices[] = &#123;</span><br><span class=\"line\">    <span class=\"number\">0.0</span>f, <span class=\"number\">0.5</span>f, <span class=\"number\">0.0</span>f,</span><br><span class=\"line\">    <span class=\"number\">-0.5</span>f, <span class=\"number\">-0.5</span>f, <span class=\"number\">0.0</span>f,</span><br><span class=\"line\">    <span class=\"number\">0.5</span>f, <span class=\"number\">-0.5</span>f, <span class=\"number\">0.0</span>f</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>绘制图元：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 启用顶点并设置顶点数据</span></span><br><span class=\"line\">glEnableVertexAttribArray(GLKVertexAttribPosition);</span><br><span class=\"line\">glVertexAttribPointer(GLKVertexAttribPosition, <span class=\"number\">3</span>, GL_FLOAT, GL_FALSE, <span class=\"number\">0</span>, vVertices);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 开始绘制</span></span><br><span class=\"line\">glDrawArrays(GL_TRIANGLES, <span class=\"number\">0</span>, <span class=\"number\">3</span>);</span><br></pre></td></tr></table></figure>\n<p>将渲染结果呈现到屏幕</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[context presentRenderbuffer:GL_RENDERBUFFER];</span><br></pre></td></tr></table></figure>\n<p>最终，就会在页面上绘画出一个三角形：</p>\n<p><img src=\"/img/article/20190606/1.png\" alt=\"Triangle Picture\"></p>\n<h1>使用GLKit绘制三角形</h1>\n<p>除了上述使用自定义着色器进行绘制，苹果本身也封装了简易着色器的GLKit供我们实现简单的绘制功能，下面就来介绍使用GLKit绘制三角形。</p>\n<p>使用GLKit绘制有两种方式：一种是使用继承<code>GLKView</code>并复写<code>drawRect:</code>方法进行渲染操作，另一种就是使用<code>GLKView</code>的代理方法进行渲染。这两种方法都需要用到<code>GLKBaseEffect</code>类，这个类内部就实现了着色器的编译链接过程，简化了整个操作。</p>\n<h2>继承GLKView进行绘制</h2>\n<p>基础<code>GLKView</code>，并复写<code>drawRect:</code>方法，创建<code>GLKBaseEffect</code>实例并为OpenGL ES渲染准备一个效果，即将编译后的着色器程序绑定到上下文并返回，最后进行顶点设置并绘制：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">TriangleGLKView</span> ()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) GLKBaseEffect *baseEffect;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">TriangleGLKView</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">instancetype</span>)initWithFrame:(<span class=\"built_in\">CGRect</span>)frame context:(<span class=\"keyword\">nonnull</span> EAGLContext *)context &#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span> = [<span class=\"keyword\">super</span> initWithFrame:frame context:context];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.baseEffect = [[GLKBaseEffect alloc] init];</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.baseEffect.constantColor = GLKVector4Make(<span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)drawRect:(<span class=\"built_in\">CGRect</span>)rect &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    glClearColor(<span class=\"number\">1.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>);</span><br><span class=\"line\">    glClear(GL_COLOR_BUFFER_BIT);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 准备渲染，将编译后的着色器程序绑定到上下文并返回</span></span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.baseEffect prepareToDraw];</span><br><span class=\"line\">    </span><br><span class=\"line\">    GLfloat vVertice[] = &#123;</span><br><span class=\"line\">        <span class=\"number\">0.0</span>, <span class=\"number\">0.5</span>, <span class=\"number\">0.0</span>,</span><br><span class=\"line\">        <span class=\"number\">-0.5</span>, <span class=\"number\">-0.5</span>, <span class=\"number\">0.0</span>,</span><br><span class=\"line\">        <span class=\"number\">0.5</span>, <span class=\"number\">-0.5</span>, <span class=\"number\">0.0</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 启用顶点并设置顶点数据</span></span><br><span class=\"line\">    glEnableVertexAttribArray(GLKVertexAttribPosition);</span><br><span class=\"line\">    glVertexAttribPointer(GLKVertexAttribPosition, <span class=\"number\">3</span>, GL_FLOAT, GL_FALSE, <span class=\"number\">0</span>, vVertice);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 开始绘制</span></span><br><span class=\"line\">    glDrawArrays(GL_TRIANGLES, <span class=\"number\">0</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<h2>使用代理绘制</h2>\n<p>设置上下文，创建<code>GLKView</code>实例并设置代理，实现代理方法，同样使用<code>GLKBaseEffect</code>类，与继承方法对比，就是将渲染操作在代理中调用：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)initialize &#123;</span><br><span class=\"line\">    EAGLContext *context = [[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES3];</span><br><span class=\"line\">    [EAGLContext setCurrentContext:context];</span><br><span class=\"line\"></span><br><span class=\"line\">    GLKView *glkView = [[GLKView alloc] initWithFrame:<span class=\"keyword\">self</span>.view.bounds context:context];</span><br><span class=\"line\">    glkView.backgroundColor = [<span class=\"built_in\">UIColor</span> clearColor];</span><br><span class=\"line\">    glkView.delegate = <span class=\"keyword\">self</span>;</span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.view addSubview:glkView];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">self</span>.baseEffect = [[GLKBaseEffect alloc] init];</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.baseEffect.constantColor = GLKVector4Make(<span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    [glkView display];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)glkView:(GLKView *)view drawInRect:(<span class=\"built_in\">CGRect</span>)rect &#123;</span><br><span class=\"line\">    glClearColor(<span class=\"number\">1.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>);</span><br><span class=\"line\">    glClear(GL_COLOR_BUFFER_BIT);</span><br><span class=\"line\">    </span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.baseEffect prepareToDraw];</span><br><span class=\"line\">    </span><br><span class=\"line\">    GLfloat vVertice[] = &#123;</span><br><span class=\"line\">        <span class=\"number\">0.0</span>, <span class=\"number\">0.5</span>, <span class=\"number\">0.0</span>,</span><br><span class=\"line\">        <span class=\"number\">-0.5</span>, <span class=\"number\">-0.5</span>, <span class=\"number\">0.0</span>,</span><br><span class=\"line\">        <span class=\"number\">0.5</span>, <span class=\"number\">-0.5</span>, <span class=\"number\">0.0</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    glEnableVertexAttribArray(GLKVertexAttribPosition);</span><br><span class=\"line\">    glVertexAttribPointer(GLKVertexAttribPosition, <span class=\"number\">3</span>, GL_FLOAT, GL_FALSE, <span class=\"number\">0</span>, vVertice);</span><br><span class=\"line\">    glDrawArrays(GL_TRIANGLES, <span class=\"number\">0</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1>结语</h1>\n<p>简单的三角形绘制就结束了，在理解了整个渲染过程，不管是自定义着色器还是使用封装的GLKit方式渲染，包括后续的Metal渲染，都能够找到丝丝关联，在学习中更加有关联性。<a href=\"https://github.com/Quincy-QC/OpenGL-ES-Study\" target=\"_blank\" rel=\"noopener\">Demo</a></p>\n"},{"title":"OpenGL ES学习--片段操作","catalog":true,"toc_nav_num":true,"date":"2019-08-16T09:30:01.000Z","subtitle":"About OpenGL ES","header-img":"/img/article_header/article_header.png","busuanzi":true,"_content":"\n> 在OpenGL ES 3.0片段管线中执行片段着色器之后，可能应用到整个帧缓冲区或者单独片段的操作。片段着色器的输出是片段的颜色和深度值。下面的操作在片段着色器执行之后发生，可能影响像素的可见性和最终颜色：\n> - 裁剪区域测试\n> - 模板缓冲区测试\n> - 深度缓冲区测试\n> - 多重采样\n> - 混合\n> - 抖动\n>\n> 片段在前往帧缓冲区途中经历的测试和操作如下图所示。\n> ![着色器后的片段管线](/img/article/20190816/1.png)\n\n# 缓冲区\n\nOpenGL ES支持3中缓冲区，每种缓冲区都保存帧缓冲区中每个像素的不同数据：\n- 颜色缓冲区（由前台和后台颜色缓冲区组成）\n- 深度缓冲区\n- 模板缓冲区\n\n缓冲区的大小常被称作”缓冲区深度“（不要与深度缓冲区混淆），由可用于存储单个像素信息的位数来计量。例如，颜色缓冲区有3个分量，用于存储红、绿和蓝色分量以及可选的Alpha分量存储。颜色缓冲区的深度是所有颜色分量位数的总和。深度和模板缓冲区与此相反，这些缓冲区中用单一值表示像素的位深度。例如，深度缓冲区可能每个像素有16位。缓冲区的总大小是所有分量的位深度的总和。常见的帧缓冲区深度包含16位的RGB缓冲区，红色和蓝色各5位，绿色为6位（人类的视觉系统对绿色比对红色或者蓝色更敏感），对于RGBA缓冲区，32位被平均分配。\n此外，颜色缓冲区可能是双重缓冲，也就是包含两个缓冲区：一个在输出设备（如监控器或者LCD显示器）上显示，称作”前台“缓冲区；另一个缓冲区对观看者隐藏，但是用于构造将要显示的下一个图像，称作”后台“缓冲区。在双缓冲区应用程序中，通过在后台缓冲区中绘制然后切换前后台缓冲区显示新图像来实现动画。缓冲区的切换通常与显示设备的刷新周期同步，这样将产生连续、流程动画的假象。\n虽然每个EGL配置都有一个颜色缓冲区，深度和模板缓冲区是可选的。不过，每个EGL实现必须提供至少一个包含所有3个缓冲区的配置，深度缓冲区至少有16位的深度，模板缓冲区深度至少为8位。\n\n## 清除缓冲区\n\nOpenGL ES是一个交互式渲染系统，它假定在每个帧的开始，要将缓冲区的所有内容初始化为默认值。缓冲区可以通过调用`glClear`函数清除，该函数用一个位掩码表示应该清除为其指定值的各种缓冲区：\n\n``` objc\n/**\n 清除缓冲区\n\n @param mask#> 指定要清除的缓冲区，由如下表示各种OpenGL ES缓冲区的位掩码联合组成：GL_COLOR_BUFFER_BIT， GL_DEPTH_BUFFER_BIT，GL_STENCIL_BUFFER_BIT description#>\n @return void\n */\nglClear(GLbitfield mask);\n```\n\n我们没有要清除每个缓冲区，也没有必要同时清除它们，但是对每个帧仅调用`glClear`一次并同时清除所有需要的缓冲区，可以得到最好的性能。\n当请求清除缓冲区时，每个缓冲区都有一个默认值。对于每个缓冲区，可以用如下函数指定需要的清除值：\n\n``` objc\n/**\n 清除颜色缓冲区指定需要的清除值\n\n @param red，green，blue，alpha#> 当传递给glClear的位掩码中包含GL_COLOR_BUFFER_BIT时，指定颜色缓冲区中所有像素的颜色值（处于[0, 1]区间） description#>\n @return void\n */\nglClearColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);\n\n/**\n 清除深度缓冲区指定需要的清除值\n\n @param depth#> 当传递给glClear的位掩码中包含GL_DEPTH_BUFFER_BIT时，指定深度缓冲区中所有像素的深度值（处于[0, 1]区间） description#>\n @return void\n */\nglClearDepthf(GLclampf depth);\n\n/**\n 清除模板缓冲区指定需要的清除值\n\n @param s#> 当传递给glClear的位掩码中包含GL_DEPTH_BUFFER_BIT时，指定模板缓冲区中所有像素的模板值（处于[0, 2^n-1]区间，其中n是模板缓冲区中可用的位数） description#>\n @return void\n */\nglClearStencil(GLint s);\n```\n\n如果在一个帧缓冲区对象中有多个绘图缓冲区，可以用如下调用清除特定的绘图缓冲区：\n\n``` objc\n/**\n 清除特定的绘图缓冲区\n\n @param buffer#> 指定要清除的缓冲区类型，可能是GL_COLOR、GL_FRONT、GL_BACK、GL_FRONT_AND_BACK、GL_LEFT、GL_RIGHT、GL_DEPTH（仅glClearBufferfv）或GL_STENCIL（仅glClearBufferiv） description#>\n @param drawbuffer#> 指定要清除的绘图缓冲区名称。对于深度或者模板缓冲区，必须为0.对颜色缓冲区必须小于GL_MAX_DRAW_BUFFERS description#>\n @param value#> 指定用于清除缓冲区的一个四元素向量（对于颜色缓冲区）和一个数值（对于深度或者模板缓冲区）的指针 description#>\n @return void\n */\nglClearBufferiv(GLenum buffer, GLint drawbuffer, const GLint *value);\nglClearBufferuiv(GLenum buffer, GLint drawbuffer, const GLuint *value);\nglClearBufferfv(GLenum buffer, GLint drawbuffer, const GLfloat *value);\n```\n\n为了减少函数调用的数量，可以用`glClearBufferfi`同时清除深度和模板缓冲区：\n\n``` objc\n/**\n 同时清除深度和模板缓冲区\n\n @param buffer#> 指定要清除的缓冲区类型；必须是GL_DEPTH_STENCIL description#>\n @param drawbuffer#> 指定要清楚的绘图缓冲区名称；必须为0 description#>\n @param depth#> 指定清除深度缓冲区所用的值 description#>\n @param stencil#> 指定清除模板缓冲区所用的值 description#>\n @return void\n */\nglClearBufferfi(GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil);\n```\n\n## 用掩码控制帧缓冲区的写入\n\n我们也可以通过指定一个缓冲区写入掩码来控制哪些缓冲区或者分量（颜色缓冲区的情况下）可以写入。在像素值被写入缓冲区之前，使用缓冲区掩码验证该缓冲区是否可写入。\n对于颜色缓冲区，`glColorMask`例程指定像素被写入时颜色缓冲区中的哪些分量会被更新。如果特定分量的掩码被设置为`GL_FALSE`，则该分量在写入时不会被更新。默认情况下，所有颜色分量都可以写入：\n\n``` objc\n/**\n 指定颜色分量在写入时是否被更新\n\n @param red，green，blue，alpha#> 指定颜色缓冲区的特定颜色分量在渲染的时候是否可以修改 description#>\n @return void\n */\nglColorMask(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha);\n```\n\n同样，深度缓冲区的写入通过以指定深度缓冲区是否可写入的`GL_TRUE`或`GL_FALSE`为参数的调用`glDepthMask`进行控制。\n在渲染透明物体的时候，深度缓冲区的写入常常被禁用。开始时，启用深度缓冲区的写入（设置为`GL_TRUE`），渲染场景中的所有不透明物体。这能够确保所有不透明物体有正确的深度，而深度缓冲区包含场景的对应深度信息。然后，在渲染透明物体之前，应该调用`glDepthMask`（`GL_FALSE`）来禁用深度缓冲区的写入。在深度缓冲区的写入被禁用时，数值仍然可以从中读出，并用于深度对比。这使得被不透明物体遮盖的透明物体可以正确地缓冲深度，但是不会修改深度缓冲区，从而使不透明的物体被透明物体遮盖：\n\n``` objc\n/**\n 指定深度缓冲区是否可以修改\n\n @param flag#> 指定深度缓冲区是否可以修改 description#>\n @return void\n */\nglDepthMask(GLboolean flag);\n```\n\n最后，可以调用`glStencilMask`来禁用模板缓冲区的写入。与`glColorMask`或`glDepthMask`不同，我们可以提供一个掩码来指定模板缓冲区的哪些位可以写入：\n\n``` objc\n/**\n 指定模板缓冲区的哪些位可以写入\n\n @param mask#> 指定一个说明模板缓冲区中的像素哪些位可以修改的位掩码（在[0, 2^n-1]区间，其中n是模板缓冲区位数），使用得较多的是0x00表示禁止写入，0xFF表示允许任何写入。 description#>\n @return void\n */\nglStencilMask(GLuint mask);\n```\n\n`glStencilMaskSeparate`例程可以根据图元的面顶点顺序（有时候称作”面部特征“）设置模板掩码，这允许对正面和背面的图元使用不同的模板掩码：\n\n``` objc\n/**\n 对正面和背面的图元使用不同的模板掩码来指定缓冲区哪些位可以写入\n\n @param face#> 指定根据渲染图元的面顶点顺序应用的模板掩码。有效值为GL_FRONT，GL_BACK，GL_FRONT_AND_BACK description#>\n @param mask#> 指定一个位掩码（在[0, 2^n-1]区间，其中n是模板缓冲区位数），表示模板缓冲区中像素的哪些位由面指定 description#>\n @return void\n */\nglStencilMaskSeparate(GLenum face, GLuint mask);\n```\n\n# 片段测试和操作\n\n下面几个小节描述可以应用到OpenGL ES片段的各种测试。默认情况下，所有片段测试和操作都被禁用，片段在写入帧缓冲区时按照接收它们的顺序变成像素。通过启用不同的片段，可以应用操作性测试，以选择哪些片段成为像素并影响最终的图像。\n每个片段测试都可以通过调用`glEnable`单独启用，该函数所带的标志参数如下表：\n\nglEnable标志 | 描述\n- | -\nGL_DEPTH_TEST | 控制片段的深度测试\nGL_STENCIL_TEST | 控制片段的模板测试\nGL_BLEND | 控制片段与颜色缓冲区中存储的颜色的混合\nGL_DITHER | 在写入颜色缓冲区前控制片段颜色的抖动\nGL_SAMPLE_COVERAGE | 控制样本范围值的计算\nGL_SAMPLE_ALPHA_TO_COVERAGE | 控制样本范围值计算中样本Alpha的使用\n\n## 使用裁剪测试\n\n裁剪测试通过指定一个矩形区域（进一步限制帧缓冲区中可以写入的像素）提供了额外的裁剪层次。使用裁剪矩形是两步的过程。首先，需用`glScissor`函数指定矩形区域：\n\n``` objc\n/**\n 指定裁剪矩形\n\n @param x，y#> 以视口坐标指定裁剪矩形左下角 description#>\n @param width#> 指定裁剪矩形宽度 description#>\n @param height#> 指定裁剪矩形高度 description#>\n @return void\n */\nglScissor(GLint x, GLint y, GLsizei width, GLsizei height);\n```\n\n指定裁剪矩形之后，需通过调用`glEnable(GL_SCISSOR_TEST)`启用它，以实施更多的裁剪。所有渲染（包括视口清除）都限于裁剪矩形之内。\n一般来说，裁剪矩形是视口中的一个子区域，但是这两个区域不一定真正交叉。当两个区域不交叉时，裁剪操作将在视口区域外渲染的像素上进行。注意，视口的变换发生在片段着色器之前，而裁剪测试发生在片段着色器阶段之后。\n\n## 模板缓冲区测试\n\n应用到片段的下一个操作是模板测试。模板缓冲区是一个逐像素掩码，保存可用于确定某个像素是否应该被更新的值。模板测试由应用程序启用或者禁用。\n模板缓冲区的使用可以看作两步的操作。第一步是逐像素掩码初始化模板缓冲区，这可以通过渲染几何形状并指定模板缓冲区的更新方法来完成。第二步通常是使用这些值控制后续在颜色缓冲区中的渲染。在两种情况下，都指定参数在模板测试中的使用方式。\n模板测试实际上是一个位测试，就像在C程序中使用掩码确定某一位是否置位一样。控制模板测试的运算符和值的模板函数由`glStencilFunc`或`glStencilSeparate`函数控制：\n\n``` objc\n/**\n 控制模板测试的运算符和值的模板函数\n\n @param func#> 指定模板测试的比较函数，有效值为GL_EQUAL、GL_NOTEQUAL、GL_LESS、GL_GREATER、GL_LEQUEAL、GL_GEQUAL、GL_ALWAYS、GL_NEVER description#>\n @param ref#> 指定模板测试的参考值 description#>\n @param mask#> 指定在与参考值与模板缓冲区中各位比较之前进行按位与运算的掩码 description#>\n @return void\n */\nglStencilFunc(GLenum func, GLint ref, GLuint mask);\n\n/**\n 控制模板测试的运算符和值的模板函数\n\n @param face#> 指定与所提供的模板函数相关的面。有效值为GL_FRONT、GL_BACK和GL_FRONT_AND_BACK description#>\n @param func#> 指定模板测试的比较函数，有效值为GL_EQUAL、GL_NOTEQUAL、GL_LESS、GL_GREATER、GL_LEQUEAL、GL_GEQUAL、GL_ALWAYS、GL_NEVER description#>\n @param ref#> 指定模板测试的参考值 description#>\n @param mask#> 指定在与参考值与模板缓冲区中各位比较之前进行按位与运算的掩码 description#>\n @return void\n */\nglStencilFuncSeparate(GLenum face, GLenum func, GLint ref, GLuint mask);\n```\n\n为了更精细地控制模板测试，可以使用一个掩码参数来选择模板值中的哪些位应该参加测试。在选择这些位之后，它们的值用提供的运算符与参考值比较。例如，要指定模板缓冲区最低三位等于2的模板测试，应该调用：\n\n``` objc\nglStencilFunc(GL_EQUAL, 2, 0x7);\n```\n\n并启用模板测试。注意，在二进制格式中，0x7的最后三位为111。\n\n配置了模板测试之后，通常还需要让OpenGL ES 3.0知道模板测试通过时对模板缓冲区中的值进行什么操作。实际上，修改模板缓冲区中的值不仅依赖模板测试，还要加入深度测试的结果。结合模板和深度测试，一个片段可能有3种结果：\n1. 片段无法通过模板测试。如果这样，则不对该片段进行任何进一步的测试（也就是深度测试）。\n2. 片段通过模板测试，但是无法通过深度测试。\n3. 片段既通过模板测试，又通过深度测试。\n\n这些可能的结果都可以用于影响该像素位置的模板缓冲区中的值。`glStencilOp`和`glStencilOpSeparte`函数控制每个测试结果对深度缓冲区进行的操作，模板值上的可能操作如下表：\n\n模板函数 | 描述\n- | -\nGL_ZERO | 将模板值设置为0\nGL_REPLACE | 用`glStencilFunc`或`glStencilFuncSeparate`中指定的参考值代替当前模板值\nGL_INCE, GL_DECR | 递增或递减模板值；模板值被限定在0或2<sup>n</sup>，其中n为模板缓冲区位数\nGL_INCE_WRAP, GL_DECR_WRAP | 递增或者递减模板值，但是如果模板值上溢或者下溢，则”卷绕“该值（最大值递增产生新的模板值0，0值递减产生最大模板值）\nGL_KEEP | 保持当前模板值，实际上没有修改该像素的值\nGL_INVERT | 模板缓冲区中值的按位非\n\n``` objc\n/**\n 更新模板缓冲区中的值\n\n @param fail#> 指定片段不能通过模板测试时应用到模板位的操作。有效值为上表所述 description#>\n @param zfail#> 指定片段通过模板测试但是没有通过深度测试时应用的操作 description#>\n @param zpass#> 指定片段在模板和深度测试中都通过时应用的操作 description#>\n @return void\n */\nglStencilOp(GLenum fail, GLenum zfail, GLenum zpass);\n\n/**\n 更新模板缓冲区中的值\n\n @param face#> 指定与提供的模板函数相关的面。有效值为GL_FRONT、GL_BACK和GL_FRONT_AND_BACK description#>\n @param fail#> 指定片段不能通过模板测试时应用到模板位的操作。有效值为上表所述 description#>\n @param zfail#> 指定片段通过模板测试但是没有通过深度测试时应用的操作 description#>\n @param zpass#> 指定片段在模板和深度测试中都通过时应用的操作 description#>\n @return void\n */\nglStencilOpSeparate(GLenum face, GLenum fail, GLenum zfail, GLenum zpass);\n```\n\n### 深度缓冲测试\n\n深度缓冲区通常用于隐藏表面的消除。传统上，它保存渲染表面上每个像素与视点最近物体的距离值，对于每个新的输入片段，将其与视点的距离和存储值比较。默认情况下，如果输入片段的深度值小于深度缓冲区中保存的值（意味着它离观看者更近），则输入片段的深度值代替保存在深度缓冲区中的值，然后其颜色值代替颜色缓冲区中的颜色值。这是深度缓冲的标准方法--如果这就是我们想做的，那么只需要在创建窗口时请求一个深度缓冲区，然后调用带`GL_DEPTH_TEST`的`glEnable`启用深度测试。如果深度缓冲区与颜色缓冲区关联，则深度测试总是会通过。\n当然，这是使用深度缓冲区的唯一手段。可以通过调用`glDepthFunc`修改深度比较运算符：\n\n``` objc\n/**\n 修改深度比较运算符\n\n @param func#> 指定深度值比较函数，可能是GL_LESS、GL_GREATER、GL_LEQUAL、GL_GEQUAL、GL_EQUAL、GL_NOTEQUAL、GL_ALWAYS或GL_NEVER中的一个 description#>\n @return void\n */\nglDepthFunc(GLenum func);\n```\n\n## 混合\n\n一旦片段通过了所有启用的片段测试，它的颜色将与片段像素位置中已经存在的颜色组合。在两个颜色组合之前，它们与一个比例因子相乘，然后用指定的混合运算符组合。混合方程如下：C<sub>final</sub>=f<sub>source</sub>C<sub>source</sub>opf<sub>destination</sub>C<sub>destination</sub>。\n其中，f<sub>source</sub>和C<sub>source</sub>分别是输入片段的比例因子和颜色。同样，f<sub>destination</sub>和C<sub>destination</sub>是像素的比例因子和颜色，op是组合折算值的数学运算符。\n比例因子通过调用`glBlendFunc`或者`glBlendFuncSeparate`指定：\n\n``` objc\n/**\n 指定混合比例因子\n\n @param sfactor#> 指定输入片段的混合系数 description#>\n @param dfactor#> 指定目标像素的混合系数 description#>\n @return void\n */\nglBlendFunc(GLenum sfactor, GLenum dfactor);\n\n/**\n 指定混合比例因子\n\n @param srcRGB#> 指定输入片段红、绿和蓝色分量的混合系数 description#>\n @param dstRGB#> 指定目标像素红、绿和蓝色分量的混合系数 description#>\n @param srcAlpha#> 指定输入片段Alpha值的混合系数 description#>\n @param dstAlpha#> 指定目标像素Alpha值的混合系数 description#>\n @return void\n */\nglBlendFuncSeparate(GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);\n```\n\n混合系数的取值如下表：\n\n![混合函数](/img/article/20190816/2.png)\n\nC<sub>constant</sub>代表调用`glBlendColor`设置的常量颜色：\n\n``` objc\n/**\n 设置混合常量颜色\n\n @param red，green，blue，alpha#> 指定常量混合颜色的分量值 description#>\n @return void\n */\nglBlendColor(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);\n```\n\n输入片段和像素颜色乘以各自的比例因子后，它们用由`glBlendEquation`或`glBlendEquationSeparate`指定的运算符组合。默认情况下，混合后的颜色用`GL_FUNC_ADD`运算符累加。`GL_FUNC_SUBTRACT`运算符从输入片段值中减去帧缓冲区中的换算值。同样，`GL_FUNC_REVERSE_SUBTRACT`运算符颠倒混合方程式，从当前像素值中减去输入片段颜色：\n\n```\n/**\n 设置混合运算符\n\n @param mode#> 指定混合运算符。有效值是GL_FUNC_ADD、GL_FUNC_SUBTRACT、GL_FUNC_REVERSE_SUBTRACT、GL_MIN、GL_MAX description#>\n @return void\n */\nglBlendEquation(GLenum mode);\n\n/**\n 设置混合运算符\n\n @param modeRGB#> 为红、绿和蓝色分量指定混合运算符 description#>\n @param modeAlpha#> 指定Alpha分量混合运算符 description#>\n @return void\n */\nglBlendEquationSeparate(GLenum modeRGB, GLenum modeAlpha);\n```\n\n# 抖动\n\n在由于帧缓冲区中每个分量的位数导致的帧缓冲区中可用颜色数量有限的系统上，我们可以用抖动（Dithering）模拟更大的色深。抖动算法以某种方式安排颜色，使图像看上去似乎比实际上的可用颜色更多。OpenGL ES 3.0没有规定抖动阶段使用的算法；具体的技术很大程度上依赖于实现。\n应用程序对抖动的唯一控制是它是否应用到最终的像素上。这一决策完全通过带`GL_DITHER`的`glEnable`或`glDisable`控制，它指定了管线中抖动的使用。在初始状态下，启用抖动。\n\n# 多重采样抗锯齿\n\n抗锯齿（Anti-aliasing）是通过尝试减少不同像素渲染中产生的视觉伪像来改进生成图像质量的一种重要技术。OpenGL ES 3.0渲染的几何形状图元在一个网格上进行光栅化，它们的边缘可能在这一过程中变形。绘制跨越显示器的对角线时，几何肯定会发现阶梯效应。\n为了理解什么是多重采样（Multisampling），以及它是如何解决锯齿问题的，我们有必要更加深入地了解OpenGL光栅器的工作方式。\n光栅器是位于最终处理过的顶点之后到片段着色器之前所经过的所有的算法与过程的总和。光栅器会将一个图元的所有顶点作为输入，并将它转换为一系列的片段。顶点坐标理论上可以取任何值，但片段不行，因为它们受限于窗口的分辨率。顶点坐标与片段之间几乎永远也不会有一对一的映射，所以光栅器必须以某种方式来决定每个顶点最终所在的片段/屏幕坐标。\n\n![多重采样三角形](/img/article/20190816/3.png)\n\n这里我们可以看到一个屏幕像素的网格，每个像素的中心包含有一个采样点（Sampler Point），它会被用来决定这个三角形是否遮盖了某个像素。途中红色的采样点被三角形所覆盖，在每一个遮住的像素处都会生成一个片段。虽然三角形边缘的一部分也遮住了某些屏幕像素，但是这些像素的采样点并没有被三角形内部所覆盖，所以它们不会受到片段着色器影响。\n\n现在我们可能已经清楚走样的原因了。完整渲染后的三角形在屏幕上会是这样的：\n\n![多重采样渲染三角形](/img/article/20190816/4.png)\n\n由于屏幕像素总量的限制，有些边缘的像素能够被渲染出来，而有些则不会。结果就是我们使用了不光滑的边缘来渲染图元，导致锯齿边缘。\n\n多重采样所做的正是将单一的采样点变为多个采样点（这也是它名称的由来）。我们不再使用像素中心的是单一采样点，取而代之的是以特定图案排列的4个子采样点（Subsampler）。我们将用这些子采样点来决定像素的遮盖度。当然，这也意味着颜色缓冲的大小会随着子采样点的增加而增加。\n\n![多重采样三角形剖析](/img/article/20190816/5.png)\n\n上图的左侧展示了正常情况下判定三角形是否遮盖的方式。在例子中的这个像素上不会运行片段着色器（所以它会保持空白）。因为它的采样点并未被三角形所覆盖。上图的右侧展示的是实施多重采样之后的版本，每个像素包含有4个采样点。这里，只有两个采样点遮盖了三角形。\n\n> 采样点的数量可以是任意的，更多的采样点能带来更精确的遮盖率。\n\n从这里开始多重采样就变得有趣起来了。我们知道三角形只遮盖了2个子采样点，所以下一步是决定这个像素的颜色。MSAA（Multi-Sampling Anti-Aliasing）真正的工作方式是，无论三角形遮盖了多少个子采样点，（每个图元中）每个像素只允许一次片段着色器。片段着色器所使用的顶点数据会插值到每个像素的中心，所得到的结果颜色会被存储在每个被遮盖住的子采样点中。当颜色缓冲的子样本被图元的所有颜色填满时，所有的这些颜色将会在每个像素内部平均化。因为上图的4个采样点只有2个被遮盖住了，这个像素的颜色将会是三角形颜色与其他两个采样点的颜色（在这里是无色）的平均值，最终形成一种淡蓝色。\n\n这样子做之后，颜色缓冲中所有的图元边缘将会产生一种更平滑的图形：\n\n![多重采样MSAA三角形](/img/article/20190816/6.png)\n\n这里，每个像素包含4个子采样点（不相关的采样点都没有标注），蓝色的采样点被三角形所遮盖，而灰色的则没有。对于三角形的内部的像素，片段着色器只会运行一次，颜色输出会被存储到全部的4个子样本中。而在三角形的边缘，并不是所有的子采样点都被覆盖，所有片段着色器的结果将只会存储到部分的子样本中。根据被遮盖的子样本的数量，最终的像素颜色将由三角形的颜色与其它子样本中所存储的颜色来决定。\n\n简单来说，一个像素中如果有更多的采样点被三角形覆盖，那么这个像素的颜色就会更接近于三角形的颜色。如果我们给上面的三角形填充颜色，就能得到以下效果：\n\n![多重采样渲染三角形](/img/article/20190816/7.png)\n\n对于每个像素来说，越少的子采样点被三角形覆盖，那么它受到三角形的影响越小。三角形的不平滑边缘被稍浅的颜色所包围后，从远处观察时就会显得更加平滑。\n\n不仅仅是颜色值会受到多重采样的影响，深度和模板测试也能够使用多个采样点。对深度测试来说，每个顶点的深度值会在运行深度测试之前被插值到各个子样本中。对模板测试来说，我们对每个子样本，而不是每个像素，存储一个模板值。当然，这也意味着深度和模板缓冲的大小会乘以子采样点的个数。\n\n我们到目前为止讨论的都是多重采样抗锯齿的背后原理，光栅器背后的实际逻辑比目前讨论的要复杂，但现在我们应该已经可以理解多重采样抗锯齿的大体概念和逻辑了。\n\n# 在帧缓冲区读取和写入像素\n\n如果我们想为后代留下渲染过的图像，可以从颜色缓冲区中读回像素值，但是不能从深度或者模板缓冲区中读取。当调用`glReadPixels`时，颜色缓冲区中的像素将从一个前面分配的数组中返回应用程序：\n\n``` objc\n/**\n 从颜色缓冲区中读回像素值\n\n @param x，y#> 指定从颜色缓冲区中要读取的像素矩形左下角的视口坐标 description#>\n @param width，height#> 指定从颜色缓冲区中读取的像素矩形的尺寸 description#>\n @param format#> 指定想要返回的像素格式。有3种可用格式：GL_RGBA、GL_RGBA_INTEGER以及查询GL_IMPLEMENTATION_COLOR_READ_FORMAT返回的值（特定于实现的像素格式） description#>\n @param type#> 指定返回的像素数据类型。有5中可用类型：GL_UNSIGNED_BYTE、GL_UNSIGNED_INT、GL_INT、GL_FLOAT以及查询GL_IMPLEMENTATION_COLOR_READ_TYPE返回的值（特定于实现的像素格式） description#>\n @param pixels#> 一个连续的字节数组，在glReadPixels返回之后包含从颜色缓冲区读取的值 description#>\n @return void\n */\nglReadPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *pixels);\n```\n\n## 像素打包缓冲区对象\n\n当用`glBindBuffer`将一个非零的缓冲区对象绑定到`GL_PIXEL_PACK_BUFFER`时，`glReadPixels`命令将立即返回，并且启动DMA传输，从帧缓冲区读取像素，并将数据写入像素缓冲区对象（PBO）。\n为了保持CPU忙碌，可以在`glReadPixels`调用之后计划一些CPU处理，是CPU计算和DMA传输重叠。根据应用程序的不同，数据可能立即可用；在这种情况下，可以使用多个PBO解决方案，在CPU从一个PBO传输的数据时，可以处理之前从另一个PBO传输的数据。\n\n# 多重渲染目标\n\n多重渲染目标（MRT）允许应用程序一次渲染到多个颜色缓冲区。利用多重渲染目标，片段着色器输出多个颜色（可以用于保存RGBA颜色、发现、深度或者纹理坐标），每个颜色用于一个连接的颜色缓冲区。MRT用于多种高级渲染算法中，例如延迟着色和快速环境遮蔽计算。\n\n下面的步骤说明了设置MRT的方法：\n\n1. 用`glGenFramebuffers`和`glBindFramebuffer`命令初始化帧缓冲区对象（FBO）：\n\n``` objc\nglGenFramebuffers(1, &fbo);\nglBindFramebuffer(GL_FRAMEBUFFER, fbo);\n```\n\n2. 用`glGenTextures`和`glBindTexture`命令初始化纹理：\n\n``` objc\nglBindTexture(GL_TEXTURE_2D, textureId);\nglTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, textureWidth, textureHeight, 0, GL_RGBA, GL_UNSIGNED_BYTE, NULL);\n// Set the filtering mode\nglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);\nglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);\n```\n\n3. 用`glFramebufferTexture2D`或`glFramebufferTextureLayer`命令将相关纹理绑定到FBO：\n\n``` objc\nglFramebufferTexture2D(GL_DRAW_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, textureId, 0);\n```\n\n4. 用`glDrawBuffers`命令为渲染指定颜色附着：\n\n``` objc\n/**\n 为渲染指定颜色附着\n\n @param n#> 指定bufs中的缓冲区数量 description#>\n @param bufs#> 指定一个符号常量数组，这些常量指定了片段颜色或者数据值将要写入的缓冲区 description#>\n @return void\n */\nglDrawBuffers(GLsizei n, const GLenum *bufs);\n\nconst GLenum attachments[4] = { GL_COLOR_ATTACHMENT0, GL_COLOR_ATTACHMENT1, GL_COLOR_ATTACHMENT2, GL_COLOR_ATTACHMENT3 };\nglDrawBuffers(4, attachments);\n```\n\n可以调用以符号常量`GL_MAX_COLOR_ATTACHMENTS`为参数的`glGetIntegerv`查询颜色附着的最大数量。所有OpenGL 3.0实现都支持的颜色附着的最小数量为4.\n\n5. 在片段着色器中声明和使用多个着色器输出。例如，如下的声明将把片段着色器输出`fragData0 ~ fragData3`分别复制到绘图缓冲区0 ~ 3：\n\n``` objc\nlayout(location = 0) out vec4 fragData0;\nlayout(location = 1) out vec4 fragData1;\nlayout(location = 2) out vec4 fragData2;\nlayout(location = 3) out vec4 fragData3;\n```\n\n# 总结\n\n这篇文章介绍了有关片段着色器之后发生的测试和操作的内容。这是OpenGL ES 3.0管线中的最后阶段。","source":"_posts/2019/opengl-es-fragment-operation-0816.md","raw":"---\ntitle: \"OpenGL ES学习--片段操作\"\ncatalog: true\ntoc_nav_num: true\ndate: 2019-08-16 17:30:01\nsubtitle: \"About OpenGL ES\"\nheader-img: \"/img/article_header/article_header.png\"\nbusuanzi: true\ntags:\n- iOS\n\n---\n\n> 在OpenGL ES 3.0片段管线中执行片段着色器之后，可能应用到整个帧缓冲区或者单独片段的操作。片段着色器的输出是片段的颜色和深度值。下面的操作在片段着色器执行之后发生，可能影响像素的可见性和最终颜色：\n> - 裁剪区域测试\n> - 模板缓冲区测试\n> - 深度缓冲区测试\n> - 多重采样\n> - 混合\n> - 抖动\n>\n> 片段在前往帧缓冲区途中经历的测试和操作如下图所示。\n> ![着色器后的片段管线](/img/article/20190816/1.png)\n\n# 缓冲区\n\nOpenGL ES支持3中缓冲区，每种缓冲区都保存帧缓冲区中每个像素的不同数据：\n- 颜色缓冲区（由前台和后台颜色缓冲区组成）\n- 深度缓冲区\n- 模板缓冲区\n\n缓冲区的大小常被称作”缓冲区深度“（不要与深度缓冲区混淆），由可用于存储单个像素信息的位数来计量。例如，颜色缓冲区有3个分量，用于存储红、绿和蓝色分量以及可选的Alpha分量存储。颜色缓冲区的深度是所有颜色分量位数的总和。深度和模板缓冲区与此相反，这些缓冲区中用单一值表示像素的位深度。例如，深度缓冲区可能每个像素有16位。缓冲区的总大小是所有分量的位深度的总和。常见的帧缓冲区深度包含16位的RGB缓冲区，红色和蓝色各5位，绿色为6位（人类的视觉系统对绿色比对红色或者蓝色更敏感），对于RGBA缓冲区，32位被平均分配。\n此外，颜色缓冲区可能是双重缓冲，也就是包含两个缓冲区：一个在输出设备（如监控器或者LCD显示器）上显示，称作”前台“缓冲区；另一个缓冲区对观看者隐藏，但是用于构造将要显示的下一个图像，称作”后台“缓冲区。在双缓冲区应用程序中，通过在后台缓冲区中绘制然后切换前后台缓冲区显示新图像来实现动画。缓冲区的切换通常与显示设备的刷新周期同步，这样将产生连续、流程动画的假象。\n虽然每个EGL配置都有一个颜色缓冲区，深度和模板缓冲区是可选的。不过，每个EGL实现必须提供至少一个包含所有3个缓冲区的配置，深度缓冲区至少有16位的深度，模板缓冲区深度至少为8位。\n\n## 清除缓冲区\n\nOpenGL ES是一个交互式渲染系统，它假定在每个帧的开始，要将缓冲区的所有内容初始化为默认值。缓冲区可以通过调用`glClear`函数清除，该函数用一个位掩码表示应该清除为其指定值的各种缓冲区：\n\n``` objc\n/**\n 清除缓冲区\n\n @param mask#> 指定要清除的缓冲区，由如下表示各种OpenGL ES缓冲区的位掩码联合组成：GL_COLOR_BUFFER_BIT， GL_DEPTH_BUFFER_BIT，GL_STENCIL_BUFFER_BIT description#>\n @return void\n */\nglClear(GLbitfield mask);\n```\n\n我们没有要清除每个缓冲区，也没有必要同时清除它们，但是对每个帧仅调用`glClear`一次并同时清除所有需要的缓冲区，可以得到最好的性能。\n当请求清除缓冲区时，每个缓冲区都有一个默认值。对于每个缓冲区，可以用如下函数指定需要的清除值：\n\n``` objc\n/**\n 清除颜色缓冲区指定需要的清除值\n\n @param red，green，blue，alpha#> 当传递给glClear的位掩码中包含GL_COLOR_BUFFER_BIT时，指定颜色缓冲区中所有像素的颜色值（处于[0, 1]区间） description#>\n @return void\n */\nglClearColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);\n\n/**\n 清除深度缓冲区指定需要的清除值\n\n @param depth#> 当传递给glClear的位掩码中包含GL_DEPTH_BUFFER_BIT时，指定深度缓冲区中所有像素的深度值（处于[0, 1]区间） description#>\n @return void\n */\nglClearDepthf(GLclampf depth);\n\n/**\n 清除模板缓冲区指定需要的清除值\n\n @param s#> 当传递给glClear的位掩码中包含GL_DEPTH_BUFFER_BIT时，指定模板缓冲区中所有像素的模板值（处于[0, 2^n-1]区间，其中n是模板缓冲区中可用的位数） description#>\n @return void\n */\nglClearStencil(GLint s);\n```\n\n如果在一个帧缓冲区对象中有多个绘图缓冲区，可以用如下调用清除特定的绘图缓冲区：\n\n``` objc\n/**\n 清除特定的绘图缓冲区\n\n @param buffer#> 指定要清除的缓冲区类型，可能是GL_COLOR、GL_FRONT、GL_BACK、GL_FRONT_AND_BACK、GL_LEFT、GL_RIGHT、GL_DEPTH（仅glClearBufferfv）或GL_STENCIL（仅glClearBufferiv） description#>\n @param drawbuffer#> 指定要清除的绘图缓冲区名称。对于深度或者模板缓冲区，必须为0.对颜色缓冲区必须小于GL_MAX_DRAW_BUFFERS description#>\n @param value#> 指定用于清除缓冲区的一个四元素向量（对于颜色缓冲区）和一个数值（对于深度或者模板缓冲区）的指针 description#>\n @return void\n */\nglClearBufferiv(GLenum buffer, GLint drawbuffer, const GLint *value);\nglClearBufferuiv(GLenum buffer, GLint drawbuffer, const GLuint *value);\nglClearBufferfv(GLenum buffer, GLint drawbuffer, const GLfloat *value);\n```\n\n为了减少函数调用的数量，可以用`glClearBufferfi`同时清除深度和模板缓冲区：\n\n``` objc\n/**\n 同时清除深度和模板缓冲区\n\n @param buffer#> 指定要清除的缓冲区类型；必须是GL_DEPTH_STENCIL description#>\n @param drawbuffer#> 指定要清楚的绘图缓冲区名称；必须为0 description#>\n @param depth#> 指定清除深度缓冲区所用的值 description#>\n @param stencil#> 指定清除模板缓冲区所用的值 description#>\n @return void\n */\nglClearBufferfi(GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil);\n```\n\n## 用掩码控制帧缓冲区的写入\n\n我们也可以通过指定一个缓冲区写入掩码来控制哪些缓冲区或者分量（颜色缓冲区的情况下）可以写入。在像素值被写入缓冲区之前，使用缓冲区掩码验证该缓冲区是否可写入。\n对于颜色缓冲区，`glColorMask`例程指定像素被写入时颜色缓冲区中的哪些分量会被更新。如果特定分量的掩码被设置为`GL_FALSE`，则该分量在写入时不会被更新。默认情况下，所有颜色分量都可以写入：\n\n``` objc\n/**\n 指定颜色分量在写入时是否被更新\n\n @param red，green，blue，alpha#> 指定颜色缓冲区的特定颜色分量在渲染的时候是否可以修改 description#>\n @return void\n */\nglColorMask(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha);\n```\n\n同样，深度缓冲区的写入通过以指定深度缓冲区是否可写入的`GL_TRUE`或`GL_FALSE`为参数的调用`glDepthMask`进行控制。\n在渲染透明物体的时候，深度缓冲区的写入常常被禁用。开始时，启用深度缓冲区的写入（设置为`GL_TRUE`），渲染场景中的所有不透明物体。这能够确保所有不透明物体有正确的深度，而深度缓冲区包含场景的对应深度信息。然后，在渲染透明物体之前，应该调用`glDepthMask`（`GL_FALSE`）来禁用深度缓冲区的写入。在深度缓冲区的写入被禁用时，数值仍然可以从中读出，并用于深度对比。这使得被不透明物体遮盖的透明物体可以正确地缓冲深度，但是不会修改深度缓冲区，从而使不透明的物体被透明物体遮盖：\n\n``` objc\n/**\n 指定深度缓冲区是否可以修改\n\n @param flag#> 指定深度缓冲区是否可以修改 description#>\n @return void\n */\nglDepthMask(GLboolean flag);\n```\n\n最后，可以调用`glStencilMask`来禁用模板缓冲区的写入。与`glColorMask`或`glDepthMask`不同，我们可以提供一个掩码来指定模板缓冲区的哪些位可以写入：\n\n``` objc\n/**\n 指定模板缓冲区的哪些位可以写入\n\n @param mask#> 指定一个说明模板缓冲区中的像素哪些位可以修改的位掩码（在[0, 2^n-1]区间，其中n是模板缓冲区位数），使用得较多的是0x00表示禁止写入，0xFF表示允许任何写入。 description#>\n @return void\n */\nglStencilMask(GLuint mask);\n```\n\n`glStencilMaskSeparate`例程可以根据图元的面顶点顺序（有时候称作”面部特征“）设置模板掩码，这允许对正面和背面的图元使用不同的模板掩码：\n\n``` objc\n/**\n 对正面和背面的图元使用不同的模板掩码来指定缓冲区哪些位可以写入\n\n @param face#> 指定根据渲染图元的面顶点顺序应用的模板掩码。有效值为GL_FRONT，GL_BACK，GL_FRONT_AND_BACK description#>\n @param mask#> 指定一个位掩码（在[0, 2^n-1]区间，其中n是模板缓冲区位数），表示模板缓冲区中像素的哪些位由面指定 description#>\n @return void\n */\nglStencilMaskSeparate(GLenum face, GLuint mask);\n```\n\n# 片段测试和操作\n\n下面几个小节描述可以应用到OpenGL ES片段的各种测试。默认情况下，所有片段测试和操作都被禁用，片段在写入帧缓冲区时按照接收它们的顺序变成像素。通过启用不同的片段，可以应用操作性测试，以选择哪些片段成为像素并影响最终的图像。\n每个片段测试都可以通过调用`glEnable`单独启用，该函数所带的标志参数如下表：\n\nglEnable标志 | 描述\n- | -\nGL_DEPTH_TEST | 控制片段的深度测试\nGL_STENCIL_TEST | 控制片段的模板测试\nGL_BLEND | 控制片段与颜色缓冲区中存储的颜色的混合\nGL_DITHER | 在写入颜色缓冲区前控制片段颜色的抖动\nGL_SAMPLE_COVERAGE | 控制样本范围值的计算\nGL_SAMPLE_ALPHA_TO_COVERAGE | 控制样本范围值计算中样本Alpha的使用\n\n## 使用裁剪测试\n\n裁剪测试通过指定一个矩形区域（进一步限制帧缓冲区中可以写入的像素）提供了额外的裁剪层次。使用裁剪矩形是两步的过程。首先，需用`glScissor`函数指定矩形区域：\n\n``` objc\n/**\n 指定裁剪矩形\n\n @param x，y#> 以视口坐标指定裁剪矩形左下角 description#>\n @param width#> 指定裁剪矩形宽度 description#>\n @param height#> 指定裁剪矩形高度 description#>\n @return void\n */\nglScissor(GLint x, GLint y, GLsizei width, GLsizei height);\n```\n\n指定裁剪矩形之后，需通过调用`glEnable(GL_SCISSOR_TEST)`启用它，以实施更多的裁剪。所有渲染（包括视口清除）都限于裁剪矩形之内。\n一般来说，裁剪矩形是视口中的一个子区域，但是这两个区域不一定真正交叉。当两个区域不交叉时，裁剪操作将在视口区域外渲染的像素上进行。注意，视口的变换发生在片段着色器之前，而裁剪测试发生在片段着色器阶段之后。\n\n## 模板缓冲区测试\n\n应用到片段的下一个操作是模板测试。模板缓冲区是一个逐像素掩码，保存可用于确定某个像素是否应该被更新的值。模板测试由应用程序启用或者禁用。\n模板缓冲区的使用可以看作两步的操作。第一步是逐像素掩码初始化模板缓冲区，这可以通过渲染几何形状并指定模板缓冲区的更新方法来完成。第二步通常是使用这些值控制后续在颜色缓冲区中的渲染。在两种情况下，都指定参数在模板测试中的使用方式。\n模板测试实际上是一个位测试，就像在C程序中使用掩码确定某一位是否置位一样。控制模板测试的运算符和值的模板函数由`glStencilFunc`或`glStencilSeparate`函数控制：\n\n``` objc\n/**\n 控制模板测试的运算符和值的模板函数\n\n @param func#> 指定模板测试的比较函数，有效值为GL_EQUAL、GL_NOTEQUAL、GL_LESS、GL_GREATER、GL_LEQUEAL、GL_GEQUAL、GL_ALWAYS、GL_NEVER description#>\n @param ref#> 指定模板测试的参考值 description#>\n @param mask#> 指定在与参考值与模板缓冲区中各位比较之前进行按位与运算的掩码 description#>\n @return void\n */\nglStencilFunc(GLenum func, GLint ref, GLuint mask);\n\n/**\n 控制模板测试的运算符和值的模板函数\n\n @param face#> 指定与所提供的模板函数相关的面。有效值为GL_FRONT、GL_BACK和GL_FRONT_AND_BACK description#>\n @param func#> 指定模板测试的比较函数，有效值为GL_EQUAL、GL_NOTEQUAL、GL_LESS、GL_GREATER、GL_LEQUEAL、GL_GEQUAL、GL_ALWAYS、GL_NEVER description#>\n @param ref#> 指定模板测试的参考值 description#>\n @param mask#> 指定在与参考值与模板缓冲区中各位比较之前进行按位与运算的掩码 description#>\n @return void\n */\nglStencilFuncSeparate(GLenum face, GLenum func, GLint ref, GLuint mask);\n```\n\n为了更精细地控制模板测试，可以使用一个掩码参数来选择模板值中的哪些位应该参加测试。在选择这些位之后，它们的值用提供的运算符与参考值比较。例如，要指定模板缓冲区最低三位等于2的模板测试，应该调用：\n\n``` objc\nglStencilFunc(GL_EQUAL, 2, 0x7);\n```\n\n并启用模板测试。注意，在二进制格式中，0x7的最后三位为111。\n\n配置了模板测试之后，通常还需要让OpenGL ES 3.0知道模板测试通过时对模板缓冲区中的值进行什么操作。实际上，修改模板缓冲区中的值不仅依赖模板测试，还要加入深度测试的结果。结合模板和深度测试，一个片段可能有3种结果：\n1. 片段无法通过模板测试。如果这样，则不对该片段进行任何进一步的测试（也就是深度测试）。\n2. 片段通过模板测试，但是无法通过深度测试。\n3. 片段既通过模板测试，又通过深度测试。\n\n这些可能的结果都可以用于影响该像素位置的模板缓冲区中的值。`glStencilOp`和`glStencilOpSeparte`函数控制每个测试结果对深度缓冲区进行的操作，模板值上的可能操作如下表：\n\n模板函数 | 描述\n- | -\nGL_ZERO | 将模板值设置为0\nGL_REPLACE | 用`glStencilFunc`或`glStencilFuncSeparate`中指定的参考值代替当前模板值\nGL_INCE, GL_DECR | 递增或递减模板值；模板值被限定在0或2<sup>n</sup>，其中n为模板缓冲区位数\nGL_INCE_WRAP, GL_DECR_WRAP | 递增或者递减模板值，但是如果模板值上溢或者下溢，则”卷绕“该值（最大值递增产生新的模板值0，0值递减产生最大模板值）\nGL_KEEP | 保持当前模板值，实际上没有修改该像素的值\nGL_INVERT | 模板缓冲区中值的按位非\n\n``` objc\n/**\n 更新模板缓冲区中的值\n\n @param fail#> 指定片段不能通过模板测试时应用到模板位的操作。有效值为上表所述 description#>\n @param zfail#> 指定片段通过模板测试但是没有通过深度测试时应用的操作 description#>\n @param zpass#> 指定片段在模板和深度测试中都通过时应用的操作 description#>\n @return void\n */\nglStencilOp(GLenum fail, GLenum zfail, GLenum zpass);\n\n/**\n 更新模板缓冲区中的值\n\n @param face#> 指定与提供的模板函数相关的面。有效值为GL_FRONT、GL_BACK和GL_FRONT_AND_BACK description#>\n @param fail#> 指定片段不能通过模板测试时应用到模板位的操作。有效值为上表所述 description#>\n @param zfail#> 指定片段通过模板测试但是没有通过深度测试时应用的操作 description#>\n @param zpass#> 指定片段在模板和深度测试中都通过时应用的操作 description#>\n @return void\n */\nglStencilOpSeparate(GLenum face, GLenum fail, GLenum zfail, GLenum zpass);\n```\n\n### 深度缓冲测试\n\n深度缓冲区通常用于隐藏表面的消除。传统上，它保存渲染表面上每个像素与视点最近物体的距离值，对于每个新的输入片段，将其与视点的距离和存储值比较。默认情况下，如果输入片段的深度值小于深度缓冲区中保存的值（意味着它离观看者更近），则输入片段的深度值代替保存在深度缓冲区中的值，然后其颜色值代替颜色缓冲区中的颜色值。这是深度缓冲的标准方法--如果这就是我们想做的，那么只需要在创建窗口时请求一个深度缓冲区，然后调用带`GL_DEPTH_TEST`的`glEnable`启用深度测试。如果深度缓冲区与颜色缓冲区关联，则深度测试总是会通过。\n当然，这是使用深度缓冲区的唯一手段。可以通过调用`glDepthFunc`修改深度比较运算符：\n\n``` objc\n/**\n 修改深度比较运算符\n\n @param func#> 指定深度值比较函数，可能是GL_LESS、GL_GREATER、GL_LEQUAL、GL_GEQUAL、GL_EQUAL、GL_NOTEQUAL、GL_ALWAYS或GL_NEVER中的一个 description#>\n @return void\n */\nglDepthFunc(GLenum func);\n```\n\n## 混合\n\n一旦片段通过了所有启用的片段测试，它的颜色将与片段像素位置中已经存在的颜色组合。在两个颜色组合之前，它们与一个比例因子相乘，然后用指定的混合运算符组合。混合方程如下：C<sub>final</sub>=f<sub>source</sub>C<sub>source</sub>opf<sub>destination</sub>C<sub>destination</sub>。\n其中，f<sub>source</sub>和C<sub>source</sub>分别是输入片段的比例因子和颜色。同样，f<sub>destination</sub>和C<sub>destination</sub>是像素的比例因子和颜色，op是组合折算值的数学运算符。\n比例因子通过调用`glBlendFunc`或者`glBlendFuncSeparate`指定：\n\n``` objc\n/**\n 指定混合比例因子\n\n @param sfactor#> 指定输入片段的混合系数 description#>\n @param dfactor#> 指定目标像素的混合系数 description#>\n @return void\n */\nglBlendFunc(GLenum sfactor, GLenum dfactor);\n\n/**\n 指定混合比例因子\n\n @param srcRGB#> 指定输入片段红、绿和蓝色分量的混合系数 description#>\n @param dstRGB#> 指定目标像素红、绿和蓝色分量的混合系数 description#>\n @param srcAlpha#> 指定输入片段Alpha值的混合系数 description#>\n @param dstAlpha#> 指定目标像素Alpha值的混合系数 description#>\n @return void\n */\nglBlendFuncSeparate(GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);\n```\n\n混合系数的取值如下表：\n\n![混合函数](/img/article/20190816/2.png)\n\nC<sub>constant</sub>代表调用`glBlendColor`设置的常量颜色：\n\n``` objc\n/**\n 设置混合常量颜色\n\n @param red，green，blue，alpha#> 指定常量混合颜色的分量值 description#>\n @return void\n */\nglBlendColor(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);\n```\n\n输入片段和像素颜色乘以各自的比例因子后，它们用由`glBlendEquation`或`glBlendEquationSeparate`指定的运算符组合。默认情况下，混合后的颜色用`GL_FUNC_ADD`运算符累加。`GL_FUNC_SUBTRACT`运算符从输入片段值中减去帧缓冲区中的换算值。同样，`GL_FUNC_REVERSE_SUBTRACT`运算符颠倒混合方程式，从当前像素值中减去输入片段颜色：\n\n```\n/**\n 设置混合运算符\n\n @param mode#> 指定混合运算符。有效值是GL_FUNC_ADD、GL_FUNC_SUBTRACT、GL_FUNC_REVERSE_SUBTRACT、GL_MIN、GL_MAX description#>\n @return void\n */\nglBlendEquation(GLenum mode);\n\n/**\n 设置混合运算符\n\n @param modeRGB#> 为红、绿和蓝色分量指定混合运算符 description#>\n @param modeAlpha#> 指定Alpha分量混合运算符 description#>\n @return void\n */\nglBlendEquationSeparate(GLenum modeRGB, GLenum modeAlpha);\n```\n\n# 抖动\n\n在由于帧缓冲区中每个分量的位数导致的帧缓冲区中可用颜色数量有限的系统上，我们可以用抖动（Dithering）模拟更大的色深。抖动算法以某种方式安排颜色，使图像看上去似乎比实际上的可用颜色更多。OpenGL ES 3.0没有规定抖动阶段使用的算法；具体的技术很大程度上依赖于实现。\n应用程序对抖动的唯一控制是它是否应用到最终的像素上。这一决策完全通过带`GL_DITHER`的`glEnable`或`glDisable`控制，它指定了管线中抖动的使用。在初始状态下，启用抖动。\n\n# 多重采样抗锯齿\n\n抗锯齿（Anti-aliasing）是通过尝试减少不同像素渲染中产生的视觉伪像来改进生成图像质量的一种重要技术。OpenGL ES 3.0渲染的几何形状图元在一个网格上进行光栅化，它们的边缘可能在这一过程中变形。绘制跨越显示器的对角线时，几何肯定会发现阶梯效应。\n为了理解什么是多重采样（Multisampling），以及它是如何解决锯齿问题的，我们有必要更加深入地了解OpenGL光栅器的工作方式。\n光栅器是位于最终处理过的顶点之后到片段着色器之前所经过的所有的算法与过程的总和。光栅器会将一个图元的所有顶点作为输入，并将它转换为一系列的片段。顶点坐标理论上可以取任何值，但片段不行，因为它们受限于窗口的分辨率。顶点坐标与片段之间几乎永远也不会有一对一的映射，所以光栅器必须以某种方式来决定每个顶点最终所在的片段/屏幕坐标。\n\n![多重采样三角形](/img/article/20190816/3.png)\n\n这里我们可以看到一个屏幕像素的网格，每个像素的中心包含有一个采样点（Sampler Point），它会被用来决定这个三角形是否遮盖了某个像素。途中红色的采样点被三角形所覆盖，在每一个遮住的像素处都会生成一个片段。虽然三角形边缘的一部分也遮住了某些屏幕像素，但是这些像素的采样点并没有被三角形内部所覆盖，所以它们不会受到片段着色器影响。\n\n现在我们可能已经清楚走样的原因了。完整渲染后的三角形在屏幕上会是这样的：\n\n![多重采样渲染三角形](/img/article/20190816/4.png)\n\n由于屏幕像素总量的限制，有些边缘的像素能够被渲染出来，而有些则不会。结果就是我们使用了不光滑的边缘来渲染图元，导致锯齿边缘。\n\n多重采样所做的正是将单一的采样点变为多个采样点（这也是它名称的由来）。我们不再使用像素中心的是单一采样点，取而代之的是以特定图案排列的4个子采样点（Subsampler）。我们将用这些子采样点来决定像素的遮盖度。当然，这也意味着颜色缓冲的大小会随着子采样点的增加而增加。\n\n![多重采样三角形剖析](/img/article/20190816/5.png)\n\n上图的左侧展示了正常情况下判定三角形是否遮盖的方式。在例子中的这个像素上不会运行片段着色器（所以它会保持空白）。因为它的采样点并未被三角形所覆盖。上图的右侧展示的是实施多重采样之后的版本，每个像素包含有4个采样点。这里，只有两个采样点遮盖了三角形。\n\n> 采样点的数量可以是任意的，更多的采样点能带来更精确的遮盖率。\n\n从这里开始多重采样就变得有趣起来了。我们知道三角形只遮盖了2个子采样点，所以下一步是决定这个像素的颜色。MSAA（Multi-Sampling Anti-Aliasing）真正的工作方式是，无论三角形遮盖了多少个子采样点，（每个图元中）每个像素只允许一次片段着色器。片段着色器所使用的顶点数据会插值到每个像素的中心，所得到的结果颜色会被存储在每个被遮盖住的子采样点中。当颜色缓冲的子样本被图元的所有颜色填满时，所有的这些颜色将会在每个像素内部平均化。因为上图的4个采样点只有2个被遮盖住了，这个像素的颜色将会是三角形颜色与其他两个采样点的颜色（在这里是无色）的平均值，最终形成一种淡蓝色。\n\n这样子做之后，颜色缓冲中所有的图元边缘将会产生一种更平滑的图形：\n\n![多重采样MSAA三角形](/img/article/20190816/6.png)\n\n这里，每个像素包含4个子采样点（不相关的采样点都没有标注），蓝色的采样点被三角形所遮盖，而灰色的则没有。对于三角形的内部的像素，片段着色器只会运行一次，颜色输出会被存储到全部的4个子样本中。而在三角形的边缘，并不是所有的子采样点都被覆盖，所有片段着色器的结果将只会存储到部分的子样本中。根据被遮盖的子样本的数量，最终的像素颜色将由三角形的颜色与其它子样本中所存储的颜色来决定。\n\n简单来说，一个像素中如果有更多的采样点被三角形覆盖，那么这个像素的颜色就会更接近于三角形的颜色。如果我们给上面的三角形填充颜色，就能得到以下效果：\n\n![多重采样渲染三角形](/img/article/20190816/7.png)\n\n对于每个像素来说，越少的子采样点被三角形覆盖，那么它受到三角形的影响越小。三角形的不平滑边缘被稍浅的颜色所包围后，从远处观察时就会显得更加平滑。\n\n不仅仅是颜色值会受到多重采样的影响，深度和模板测试也能够使用多个采样点。对深度测试来说，每个顶点的深度值会在运行深度测试之前被插值到各个子样本中。对模板测试来说，我们对每个子样本，而不是每个像素，存储一个模板值。当然，这也意味着深度和模板缓冲的大小会乘以子采样点的个数。\n\n我们到目前为止讨论的都是多重采样抗锯齿的背后原理，光栅器背后的实际逻辑比目前讨论的要复杂，但现在我们应该已经可以理解多重采样抗锯齿的大体概念和逻辑了。\n\n# 在帧缓冲区读取和写入像素\n\n如果我们想为后代留下渲染过的图像，可以从颜色缓冲区中读回像素值，但是不能从深度或者模板缓冲区中读取。当调用`glReadPixels`时，颜色缓冲区中的像素将从一个前面分配的数组中返回应用程序：\n\n``` objc\n/**\n 从颜色缓冲区中读回像素值\n\n @param x，y#> 指定从颜色缓冲区中要读取的像素矩形左下角的视口坐标 description#>\n @param width，height#> 指定从颜色缓冲区中读取的像素矩形的尺寸 description#>\n @param format#> 指定想要返回的像素格式。有3种可用格式：GL_RGBA、GL_RGBA_INTEGER以及查询GL_IMPLEMENTATION_COLOR_READ_FORMAT返回的值（特定于实现的像素格式） description#>\n @param type#> 指定返回的像素数据类型。有5中可用类型：GL_UNSIGNED_BYTE、GL_UNSIGNED_INT、GL_INT、GL_FLOAT以及查询GL_IMPLEMENTATION_COLOR_READ_TYPE返回的值（特定于实现的像素格式） description#>\n @param pixels#> 一个连续的字节数组，在glReadPixels返回之后包含从颜色缓冲区读取的值 description#>\n @return void\n */\nglReadPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *pixels);\n```\n\n## 像素打包缓冲区对象\n\n当用`glBindBuffer`将一个非零的缓冲区对象绑定到`GL_PIXEL_PACK_BUFFER`时，`glReadPixels`命令将立即返回，并且启动DMA传输，从帧缓冲区读取像素，并将数据写入像素缓冲区对象（PBO）。\n为了保持CPU忙碌，可以在`glReadPixels`调用之后计划一些CPU处理，是CPU计算和DMA传输重叠。根据应用程序的不同，数据可能立即可用；在这种情况下，可以使用多个PBO解决方案，在CPU从一个PBO传输的数据时，可以处理之前从另一个PBO传输的数据。\n\n# 多重渲染目标\n\n多重渲染目标（MRT）允许应用程序一次渲染到多个颜色缓冲区。利用多重渲染目标，片段着色器输出多个颜色（可以用于保存RGBA颜色、发现、深度或者纹理坐标），每个颜色用于一个连接的颜色缓冲区。MRT用于多种高级渲染算法中，例如延迟着色和快速环境遮蔽计算。\n\n下面的步骤说明了设置MRT的方法：\n\n1. 用`glGenFramebuffers`和`glBindFramebuffer`命令初始化帧缓冲区对象（FBO）：\n\n``` objc\nglGenFramebuffers(1, &fbo);\nglBindFramebuffer(GL_FRAMEBUFFER, fbo);\n```\n\n2. 用`glGenTextures`和`glBindTexture`命令初始化纹理：\n\n``` objc\nglBindTexture(GL_TEXTURE_2D, textureId);\nglTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, textureWidth, textureHeight, 0, GL_RGBA, GL_UNSIGNED_BYTE, NULL);\n// Set the filtering mode\nglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);\nglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);\n```\n\n3. 用`glFramebufferTexture2D`或`glFramebufferTextureLayer`命令将相关纹理绑定到FBO：\n\n``` objc\nglFramebufferTexture2D(GL_DRAW_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, textureId, 0);\n```\n\n4. 用`glDrawBuffers`命令为渲染指定颜色附着：\n\n``` objc\n/**\n 为渲染指定颜色附着\n\n @param n#> 指定bufs中的缓冲区数量 description#>\n @param bufs#> 指定一个符号常量数组，这些常量指定了片段颜色或者数据值将要写入的缓冲区 description#>\n @return void\n */\nglDrawBuffers(GLsizei n, const GLenum *bufs);\n\nconst GLenum attachments[4] = { GL_COLOR_ATTACHMENT0, GL_COLOR_ATTACHMENT1, GL_COLOR_ATTACHMENT2, GL_COLOR_ATTACHMENT3 };\nglDrawBuffers(4, attachments);\n```\n\n可以调用以符号常量`GL_MAX_COLOR_ATTACHMENTS`为参数的`glGetIntegerv`查询颜色附着的最大数量。所有OpenGL 3.0实现都支持的颜色附着的最小数量为4.\n\n5. 在片段着色器中声明和使用多个着色器输出。例如，如下的声明将把片段着色器输出`fragData0 ~ fragData3`分别复制到绘图缓冲区0 ~ 3：\n\n``` objc\nlayout(location = 0) out vec4 fragData0;\nlayout(location = 1) out vec4 fragData1;\nlayout(location = 2) out vec4 fragData2;\nlayout(location = 3) out vec4 fragData3;\n```\n\n# 总结\n\n这篇文章介绍了有关片段着色器之后发生的测试和操作的内容。这是OpenGL ES 3.0管线中的最后阶段。","slug":"2019/opengl-es-fragment-operation-0816","published":1,"updated":"2022-01-10T09:04:52.805Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cky8gmc49000rd1qh4kxsf1vl","content":"<blockquote>\n<p>在OpenGL ES 3.0片段管线中执行片段着色器之后，可能应用到整个帧缓冲区或者单独片段的操作。片段着色器的输出是片段的颜色和深度值。下面的操作在片段着色器执行之后发生，可能影响像素的可见性和最终颜色：</p>\n<ul>\n<li>裁剪区域测试</li>\n<li>模板缓冲区测试</li>\n<li>深度缓冲区测试</li>\n<li>多重采样</li>\n<li>混合</li>\n<li>抖动</li>\n</ul>\n<p>片段在前往帧缓冲区途中经历的测试和操作如下图所示。<br>\n<img src=\"/img/article/20190816/1.png\" alt=\"着色器后的片段管线\"></p>\n</blockquote>\n<h1 id=\"缓冲区\">缓冲区</h1>\n<p>OpenGL ES支持3中缓冲区，每种缓冲区都保存帧缓冲区中每个像素的不同数据：</p>\n<ul>\n<li>颜色缓冲区（由前台和后台颜色缓冲区组成）</li>\n<li>深度缓冲区</li>\n<li>模板缓冲区</li>\n</ul>\n<p>缓冲区的大小常被称作”缓冲区深度“（不要与深度缓冲区混淆），由可用于存储单个像素信息的位数来计量。例如，颜色缓冲区有3个分量，用于存储红、绿和蓝色分量以及可选的Alpha分量存储。颜色缓冲区的深度是所有颜色分量位数的总和。深度和模板缓冲区与此相反，这些缓冲区中用单一值表示像素的位深度。例如，深度缓冲区可能每个像素有16位。缓冲区的总大小是所有分量的位深度的总和。常见的帧缓冲区深度包含16位的RGB缓冲区，红色和蓝色各5位，绿色为6位（人类的视觉系统对绿色比对红色或者蓝色更敏感），对于RGBA缓冲区，32位被平均分配。<br>\n此外，颜色缓冲区可能是双重缓冲，也就是包含两个缓冲区：一个在输出设备（如监控器或者LCD显示器）上显示，称作”前台“缓冲区；另一个缓冲区对观看者隐藏，但是用于构造将要显示的下一个图像，称作”后台“缓冲区。在双缓冲区应用程序中，通过在后台缓冲区中绘制然后切换前后台缓冲区显示新图像来实现动画。缓冲区的切换通常与显示设备的刷新周期同步，这样将产生连续、流程动画的假象。<br>\n虽然每个EGL配置都有一个颜色缓冲区，深度和模板缓冲区是可选的。不过，每个EGL实现必须提供至少一个包含所有3个缓冲区的配置，深度缓冲区至少有16位的深度，模板缓冲区深度至少为8位。</p>\n<h2 id=\"清除缓冲区\">清除缓冲区</h2>\n<p>OpenGL ES是一个交互式渲染系统，它假定在每个帧的开始，要将缓冲区的所有内容初始化为默认值。缓冲区可以通过调用<code>glClear</code>函数清除，该函数用一个位掩码表示应该清除为其指定值的各种缓冲区：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 清除缓冲区</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param mask#&gt; 指定要清除的缓冲区，由如下表示各种OpenGL ES缓冲区的位掩码联合组成：GL_COLOR_BUFFER_BIT， GL_DEPTH_BUFFER_BIT，GL_STENCIL_BUFFER_BIT description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glClear(GLbitfield mask);</span><br></pre></td></tr></table></figure>\n<p>我们没有要清除每个缓冲区，也没有必要同时清除它们，但是对每个帧仅调用<code>glClear</code>一次并同时清除所有需要的缓冲区，可以得到最好的性能。<br>\n当请求清除缓冲区时，每个缓冲区都有一个默认值。对于每个缓冲区，可以用如下函数指定需要的清除值：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 清除颜色缓冲区指定需要的清除值</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param red，green，blue，alpha#&gt; 当传递给glClear的位掩码中包含GL_COLOR_BUFFER_BIT时，指定颜色缓冲区中所有像素的颜色值（处于[0, 1]区间） description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glClearColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 清除深度缓冲区指定需要的清除值</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param depth#&gt; 当传递给glClear的位掩码中包含GL_DEPTH_BUFFER_BIT时，指定深度缓冲区中所有像素的深度值（处于[0, 1]区间） description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glClearDepthf(GLclampf depth);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 清除模板缓冲区指定需要的清除值</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param s#&gt; 当传递给glClear的位掩码中包含GL_DEPTH_BUFFER_BIT时，指定模板缓冲区中所有像素的模板值（处于[0, 2^n-1]区间，其中n是模板缓冲区中可用的位数） description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glClearStencil(GLint s);</span><br></pre></td></tr></table></figure>\n<p>如果在一个帧缓冲区对象中有多个绘图缓冲区，可以用如下调用清除特定的绘图缓冲区：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 清除特定的绘图缓冲区</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param buffer#&gt; 指定要清除的缓冲区类型，可能是GL_COLOR、GL_FRONT、GL_BACK、GL_FRONT_AND_BACK、GL_LEFT、GL_RIGHT、GL_DEPTH（仅glClearBufferfv）或GL_STENCIL（仅glClearBufferiv） description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param drawbuffer#&gt; 指定要清除的绘图缓冲区名称。对于深度或者模板缓冲区，必须为0.对颜色缓冲区必须小于GL_MAX_DRAW_BUFFERS description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param value#&gt; 指定用于清除缓冲区的一个四元素向量（对于颜色缓冲区）和一个数值（对于深度或者模板缓冲区）的指针 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glClearBufferiv(GLenum buffer, GLint drawbuffer, <span class=\"keyword\">const</span> GLint *value);</span><br><span class=\"line\">glClearBufferuiv(GLenum buffer, GLint drawbuffer, <span class=\"keyword\">const</span> GLuint *value);</span><br><span class=\"line\">glClearBufferfv(GLenum buffer, GLint drawbuffer, <span class=\"keyword\">const</span> GLfloat *value);</span><br></pre></td></tr></table></figure>\n<p>为了减少函数调用的数量，可以用<code>glClearBufferfi</code>同时清除深度和模板缓冲区：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 同时清除深度和模板缓冲区</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param buffer#&gt; 指定要清除的缓冲区类型；必须是GL_DEPTH_STENCIL description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param drawbuffer#&gt; 指定要清楚的绘图缓冲区名称；必须为0 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param depth#&gt; 指定清除深度缓冲区所用的值 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param stencil#&gt; 指定清除模板缓冲区所用的值 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glClearBufferfi(GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil);</span><br></pre></td></tr></table></figure>\n<h2 id=\"用掩码控制帧缓冲区的写入\">用掩码控制帧缓冲区的写入</h2>\n<p>我们也可以通过指定一个缓冲区写入掩码来控制哪些缓冲区或者分量（颜色缓冲区的情况下）可以写入。在像素值被写入缓冲区之前，使用缓冲区掩码验证该缓冲区是否可写入。<br>\n对于颜色缓冲区，<code>glColorMask</code>例程指定像素被写入时颜色缓冲区中的哪些分量会被更新。如果特定分量的掩码被设置为<code>GL_FALSE</code>，则该分量在写入时不会被更新。默认情况下，所有颜色分量都可以写入：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 指定颜色分量在写入时是否被更新</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param red，green，blue，alpha#&gt; 指定颜色缓冲区的特定颜色分量在渲染的时候是否可以修改 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glColorMask(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha);</span><br></pre></td></tr></table></figure>\n<p>同样，深度缓冲区的写入通过以指定深度缓冲区是否可写入的<code>GL_TRUE</code>或<code>GL_FALSE</code>为参数的调用<code>glDepthMask</code>进行控制。<br>\n在渲染透明物体的时候，深度缓冲区的写入常常被禁用。开始时，启用深度缓冲区的写入（设置为<code>GL_TRUE</code>），渲染场景中的所有不透明物体。这能够确保所有不透明物体有正确的深度，而深度缓冲区包含场景的对应深度信息。然后，在渲染透明物体之前，应该调用<code>glDepthMask</code>（<code>GL_FALSE</code>）来禁用深度缓冲区的写入。在深度缓冲区的写入被禁用时，数值仍然可以从中读出，并用于深度对比。这使得被不透明物体遮盖的透明物体可以正确地缓冲深度，但是不会修改深度缓冲区，从而使不透明的物体被透明物体遮盖：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 指定深度缓冲区是否可以修改</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param flag#&gt; 指定深度缓冲区是否可以修改 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glDepthMask(GLboolean flag);</span><br></pre></td></tr></table></figure>\n<p>最后，可以调用<code>glStencilMask</code>来禁用模板缓冲区的写入。与<code>glColorMask</code>或<code>glDepthMask</code>不同，我们可以提供一个掩码来指定模板缓冲区的哪些位可以写入：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 指定模板缓冲区的哪些位可以写入</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param mask#&gt; 指定一个说明模板缓冲区中的像素哪些位可以修改的位掩码（在[0, 2^n-1]区间，其中n是模板缓冲区位数），使用得较多的是0x00表示禁止写入，0xFF表示允许任何写入。 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glStencilMask(GLuint mask);</span><br></pre></td></tr></table></figure>\n<p><code>glStencilMaskSeparate</code>例程可以根据图元的面顶点顺序（有时候称作”面部特征“）设置模板掩码，这允许对正面和背面的图元使用不同的模板掩码：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 对正面和背面的图元使用不同的模板掩码来指定缓冲区哪些位可以写入</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param face#&gt; 指定根据渲染图元的面顶点顺序应用的模板掩码。有效值为GL_FRONT，GL_BACK，GL_FRONT_AND_BACK description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param mask#&gt; 指定一个位掩码（在[0, 2^n-1]区间，其中n是模板缓冲区位数），表示模板缓冲区中像素的哪些位由面指定 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glStencilMaskSeparate(GLenum face, GLuint mask);</span><br></pre></td></tr></table></figure>\n<h1 id=\"片段测试和操作\">片段测试和操作</h1>\n<p>下面几个小节描述可以应用到OpenGL ES片段的各种测试。默认情况下，所有片段测试和操作都被禁用，片段在写入帧缓冲区时按照接收它们的顺序变成像素。通过启用不同的片段，可以应用操作性测试，以选择哪些片段成为像素并影响最终的图像。<br>\n每个片段测试都可以通过调用<code>glEnable</code>单独启用，该函数所带的标志参数如下表：</p>\n<table>\n<thead>\n<tr>\n<th>glEnable标志</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>GL_DEPTH_TEST</td>\n<td>控制片段的深度测试</td>\n</tr>\n<tr>\n<td>GL_STENCIL_TEST</td>\n<td>控制片段的模板测试</td>\n</tr>\n<tr>\n<td>GL_BLEND</td>\n<td>控制片段与颜色缓冲区中存储的颜色的混合</td>\n</tr>\n<tr>\n<td>GL_DITHER</td>\n<td>在写入颜色缓冲区前控制片段颜色的抖动</td>\n</tr>\n<tr>\n<td>GL_SAMPLE_COVERAGE</td>\n<td>控制样本范围值的计算</td>\n</tr>\n<tr>\n<td>GL_SAMPLE_ALPHA_TO_COVERAGE</td>\n<td>控制样本范围值计算中样本Alpha的使用</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"使用裁剪测试\">使用裁剪测试</h2>\n<p>裁剪测试通过指定一个矩形区域（进一步限制帧缓冲区中可以写入的像素）提供了额外的裁剪层次。使用裁剪矩形是两步的过程。首先，需用<code>glScissor</code>函数指定矩形区域：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 指定裁剪矩形</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param x，y#&gt; 以视口坐标指定裁剪矩形左下角 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param width#&gt; 指定裁剪矩形宽度 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param height#&gt; 指定裁剪矩形高度 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glScissor(GLint x, GLint y, GLsizei width, GLsizei height);</span><br></pre></td></tr></table></figure>\n<p>指定裁剪矩形之后，需通过调用<code>glEnable(GL_SCISSOR_TEST)</code>启用它，以实施更多的裁剪。所有渲染（包括视口清除）都限于裁剪矩形之内。<br>\n一般来说，裁剪矩形是视口中的一个子区域，但是这两个区域不一定真正交叉。当两个区域不交叉时，裁剪操作将在视口区域外渲染的像素上进行。注意，视口的变换发生在片段着色器之前，而裁剪测试发生在片段着色器阶段之后。</p>\n<h2 id=\"模板缓冲区测试\">模板缓冲区测试</h2>\n<p>应用到片段的下一个操作是模板测试。模板缓冲区是一个逐像素掩码，保存可用于确定某个像素是否应该被更新的值。模板测试由应用程序启用或者禁用。<br>\n模板缓冲区的使用可以看作两步的操作。第一步是逐像素掩码初始化模板缓冲区，这可以通过渲染几何形状并指定模板缓冲区的更新方法来完成。第二步通常是使用这些值控制后续在颜色缓冲区中的渲染。在两种情况下，都指定参数在模板测试中的使用方式。<br>\n模板测试实际上是一个位测试，就像在C程序中使用掩码确定某一位是否置位一样。控制模板测试的运算符和值的模板函数由<code>glStencilFunc</code>或<code>glStencilSeparate</code>函数控制：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 控制模板测试的运算符和值的模板函数</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param func#&gt; 指定模板测试的比较函数，有效值为GL_EQUAL、GL_NOTEQUAL、GL_LESS、GL_GREATER、GL_LEQUEAL、GL_GEQUAL、GL_ALWAYS、GL_NEVER description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param ref#&gt; 指定模板测试的参考值 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param mask#&gt; 指定在与参考值与模板缓冲区中各位比较之前进行按位与运算的掩码 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glStencilFunc(GLenum func, GLint ref, GLuint mask);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 控制模板测试的运算符和值的模板函数</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param face#&gt; 指定与所提供的模板函数相关的面。有效值为GL_FRONT、GL_BACK和GL_FRONT_AND_BACK description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param func#&gt; 指定模板测试的比较函数，有效值为GL_EQUAL、GL_NOTEQUAL、GL_LESS、GL_GREATER、GL_LEQUEAL、GL_GEQUAL、GL_ALWAYS、GL_NEVER description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param ref#&gt; 指定模板测试的参考值 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param mask#&gt; 指定在与参考值与模板缓冲区中各位比较之前进行按位与运算的掩码 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glStencilFuncSeparate(GLenum face, GLenum func, GLint ref, GLuint mask);</span><br></pre></td></tr></table></figure>\n<p>为了更精细地控制模板测试，可以使用一个掩码参数来选择模板值中的哪些位应该参加测试。在选择这些位之后，它们的值用提供的运算符与参考值比较。例如，要指定模板缓冲区最低三位等于2的模板测试，应该调用：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">glStencilFunc(GL_EQUAL, <span class=\"number\">2</span>, <span class=\"number\">0x7</span>);</span><br></pre></td></tr></table></figure>\n<p>并启用模板测试。注意，在二进制格式中，0x7的最后三位为111。</p>\n<p>配置了模板测试之后，通常还需要让OpenGL ES 3.0知道模板测试通过时对模板缓冲区中的值进行什么操作。实际上，修改模板缓冲区中的值不仅依赖模板测试，还要加入深度测试的结果。结合模板和深度测试，一个片段可能有3种结果：</p>\n<ol>\n<li>片段无法通过模板测试。如果这样，则不对该片段进行任何进一步的测试（也就是深度测试）。</li>\n<li>片段通过模板测试，但是无法通过深度测试。</li>\n<li>片段既通过模板测试，又通过深度测试。</li>\n</ol>\n<p>这些可能的结果都可以用于影响该像素位置的模板缓冲区中的值。<code>glStencilOp</code>和<code>glStencilOpSeparte</code>函数控制每个测试结果对深度缓冲区进行的操作，模板值上的可能操作如下表：</p>\n<table>\n<thead>\n<tr>\n<th>模板函数</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>GL_ZERO</td>\n<td>将模板值设置为0</td>\n</tr>\n<tr>\n<td>GL_REPLACE</td>\n<td>用<code>glStencilFunc</code>或<code>glStencilFuncSeparate</code>中指定的参考值代替当前模板值</td>\n</tr>\n<tr>\n<td>GL_INCE, GL_DECR</td>\n<td>递增或递减模板值；模板值被限定在0或2<sup>n</sup>，其中n为模板缓冲区位数</td>\n</tr>\n<tr>\n<td>GL_INCE_WRAP, GL_DECR_WRAP</td>\n<td>递增或者递减模板值，但是如果模板值上溢或者下溢，则”卷绕“该值（最大值递增产生新的模板值0，0值递减产生最大模板值）</td>\n</tr>\n<tr>\n<td>GL_KEEP</td>\n<td>保持当前模板值，实际上没有修改该像素的值</td>\n</tr>\n<tr>\n<td>GL_INVERT</td>\n<td>模板缓冲区中值的按位非</td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 更新模板缓冲区中的值</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param fail#&gt; 指定片段不能通过模板测试时应用到模板位的操作。有效值为上表所述 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param zfail#&gt; 指定片段通过模板测试但是没有通过深度测试时应用的操作 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param zpass#&gt; 指定片段在模板和深度测试中都通过时应用的操作 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glStencilOp(GLenum fail, GLenum zfail, GLenum zpass);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 更新模板缓冲区中的值</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param face#&gt; 指定与提供的模板函数相关的面。有效值为GL_FRONT、GL_BACK和GL_FRONT_AND_BACK description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param fail#&gt; 指定片段不能通过模板测试时应用到模板位的操作。有效值为上表所述 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param zfail#&gt; 指定片段通过模板测试但是没有通过深度测试时应用的操作 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param zpass#&gt; 指定片段在模板和深度测试中都通过时应用的操作 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glStencilOpSeparate(GLenum face, GLenum fail, GLenum zfail, GLenum zpass);</span><br></pre></td></tr></table></figure>\n<h3 id=\"深度缓冲测试\">深度缓冲测试</h3>\n<p>深度缓冲区通常用于隐藏表面的消除。传统上，它保存渲染表面上每个像素与视点最近物体的距离值，对于每个新的输入片段，将其与视点的距离和存储值比较。默认情况下，如果输入片段的深度值小于深度缓冲区中保存的值（意味着它离观看者更近），则输入片段的深度值代替保存在深度缓冲区中的值，然后其颜色值代替颜色缓冲区中的颜色值。这是深度缓冲的标准方法–如果这就是我们想做的，那么只需要在创建窗口时请求一个深度缓冲区，然后调用带<code>GL_DEPTH_TEST</code>的<code>glEnable</code>启用深度测试。如果深度缓冲区与颜色缓冲区关联，则深度测试总是会通过。<br>\n当然，这是使用深度缓冲区的唯一手段。可以通过调用<code>glDepthFunc</code>修改深度比较运算符：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 修改深度比较运算符</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param func#&gt; 指定深度值比较函数，可能是GL_LESS、GL_GREATER、GL_LEQUAL、GL_GEQUAL、GL_EQUAL、GL_NOTEQUAL、GL_ALWAYS或GL_NEVER中的一个 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glDepthFunc(GLenum func);</span><br></pre></td></tr></table></figure>\n<h2 id=\"混合\">混合</h2>\n<p>一旦片段通过了所有启用的片段测试，它的颜色将与片段像素位置中已经存在的颜色组合。在两个颜色组合之前，它们与一个比例因子相乘，然后用指定的混合运算符组合。混合方程如下：C<sub>final</sub>=f<sub>source</sub>C<sub>source</sub>opf<sub>destination</sub>C<sub>destination</sub>。<br>\n其中，f<sub>source</sub>和C<sub>source</sub>分别是输入片段的比例因子和颜色。同样，f<sub>destination</sub>和C<sub>destination</sub>是像素的比例因子和颜色，op是组合折算值的数学运算符。<br>\n比例因子通过调用<code>glBlendFunc</code>或者<code>glBlendFuncSeparate</code>指定：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 指定混合比例因子</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param sfactor#&gt; 指定输入片段的混合系数 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param dfactor#&gt; 指定目标像素的混合系数 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glBlendFunc(GLenum sfactor, GLenum dfactor);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 指定混合比例因子</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param srcRGB#&gt; 指定输入片段红、绿和蓝色分量的混合系数 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param dstRGB#&gt; 指定目标像素红、绿和蓝色分量的混合系数 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param srcAlpha#&gt; 指定输入片段Alpha值的混合系数 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param dstAlpha#&gt; 指定目标像素Alpha值的混合系数 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glBlendFuncSeparate(GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);</span><br></pre></td></tr></table></figure>\n<p>混合系数的取值如下表：</p>\n<p><img src=\"/img/article/20190816/2.png\" alt=\"混合函数\"></p>\n<p>C<sub>constant</sub>代表调用<code>glBlendColor</code>设置的常量颜色：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 设置混合常量颜色</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param red，green，blue，alpha#&gt; 指定常量混合颜色的分量值 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glBlendColor(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);</span><br></pre></td></tr></table></figure>\n<p>输入片段和像素颜色乘以各自的比例因子后，它们用由<code>glBlendEquation</code>或<code>glBlendEquationSeparate</code>指定的运算符组合。默认情况下，混合后的颜色用<code>GL_FUNC_ADD</code>运算符累加。<code>GL_FUNC_SUBTRACT</code>运算符从输入片段值中减去帧缓冲区中的换算值。同样，<code>GL_FUNC_REVERSE_SUBTRACT</code>运算符颠倒混合方程式，从当前像素值中减去输入片段颜色：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> 设置混合运算符</span><br><span class=\"line\"></span><br><span class=\"line\"> @param mode#&gt; 指定混合运算符。有效值是GL_FUNC_ADD、GL_FUNC_SUBTRACT、GL_FUNC_REVERSE_SUBTRACT、GL_MIN、GL_MAX description#&gt;</span><br><span class=\"line\"> @return void</span><br><span class=\"line\"> */</span><br><span class=\"line\">glBlendEquation(GLenum mode);</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> 设置混合运算符</span><br><span class=\"line\"></span><br><span class=\"line\"> @param modeRGB#&gt; 为红、绿和蓝色分量指定混合运算符 description#&gt;</span><br><span class=\"line\"> @param modeAlpha#&gt; 指定Alpha分量混合运算符 description#&gt;</span><br><span class=\"line\"> @return void</span><br><span class=\"line\"> */</span><br><span class=\"line\">glBlendEquationSeparate(GLenum modeRGB, GLenum modeAlpha);</span><br></pre></td></tr></table></figure>\n<h1 id=\"抖动\">抖动</h1>\n<p>在由于帧缓冲区中每个分量的位数导致的帧缓冲区中可用颜色数量有限的系统上，我们可以用抖动（Dithering）模拟更大的色深。抖动算法以某种方式安排颜色，使图像看上去似乎比实际上的可用颜色更多。OpenGL ES 3.0没有规定抖动阶段使用的算法；具体的技术很大程度上依赖于实现。<br>\n应用程序对抖动的唯一控制是它是否应用到最终的像素上。这一决策完全通过带<code>GL_DITHER</code>的<code>glEnable</code>或<code>glDisable</code>控制，它指定了管线中抖动的使用。在初始状态下，启用抖动。</p>\n<h1 id=\"多重采样抗锯齿\">多重采样抗锯齿</h1>\n<p>抗锯齿（Anti-aliasing）是通过尝试减少不同像素渲染中产生的视觉伪像来改进生成图像质量的一种重要技术。OpenGL ES 3.0渲染的几何形状图元在一个网格上进行光栅化，它们的边缘可能在这一过程中变形。绘制跨越显示器的对角线时，几何肯定会发现阶梯效应。<br>\n为了理解什么是多重采样（Multisampling），以及它是如何解决锯齿问题的，我们有必要更加深入地了解OpenGL光栅器的工作方式。<br>\n光栅器是位于最终处理过的顶点之后到片段着色器之前所经过的所有的算法与过程的总和。光栅器会将一个图元的所有顶点作为输入，并将它转换为一系列的片段。顶点坐标理论上可以取任何值，但片段不行，因为它们受限于窗口的分辨率。顶点坐标与片段之间几乎永远也不会有一对一的映射，所以光栅器必须以某种方式来决定每个顶点最终所在的片段/屏幕坐标。</p>\n<p><img src=\"/img/article/20190816/3.png\" alt=\"多重采样三角形\"></p>\n<p>这里我们可以看到一个屏幕像素的网格，每个像素的中心包含有一个采样点（Sampler Point），它会被用来决定这个三角形是否遮盖了某个像素。途中红色的采样点被三角形所覆盖，在每一个遮住的像素处都会生成一个片段。虽然三角形边缘的一部分也遮住了某些屏幕像素，但是这些像素的采样点并没有被三角形内部所覆盖，所以它们不会受到片段着色器影响。</p>\n<p>现在我们可能已经清楚走样的原因了。完整渲染后的三角形在屏幕上会是这样的：</p>\n<p><img src=\"/img/article/20190816/4.png\" alt=\"多重采样渲染三角形\"></p>\n<p>由于屏幕像素总量的限制，有些边缘的像素能够被渲染出来，而有些则不会。结果就是我们使用了不光滑的边缘来渲染图元，导致锯齿边缘。</p>\n<p>多重采样所做的正是将单一的采样点变为多个采样点（这也是它名称的由来）。我们不再使用像素中心的是单一采样点，取而代之的是以特定图案排列的4个子采样点（Subsampler）。我们将用这些子采样点来决定像素的遮盖度。当然，这也意味着颜色缓冲的大小会随着子采样点的增加而增加。</p>\n<p><img src=\"/img/article/20190816/5.png\" alt=\"多重采样三角形剖析\"></p>\n<p>上图的左侧展示了正常情况下判定三角形是否遮盖的方式。在例子中的这个像素上不会运行片段着色器（所以它会保持空白）。因为它的采样点并未被三角形所覆盖。上图的右侧展示的是实施多重采样之后的版本，每个像素包含有4个采样点。这里，只有两个采样点遮盖了三角形。</p>\n<blockquote>\n<p>采样点的数量可以是任意的，更多的采样点能带来更精确的遮盖率。</p>\n</blockquote>\n<p>从这里开始多重采样就变得有趣起来了。我们知道三角形只遮盖了2个子采样点，所以下一步是决定这个像素的颜色。MSAA（Multi-Sampling Anti-Aliasing）真正的工作方式是，无论三角形遮盖了多少个子采样点，（每个图元中）每个像素只允许一次片段着色器。片段着色器所使用的顶点数据会插值到每个像素的中心，所得到的结果颜色会被存储在每个被遮盖住的子采样点中。当颜色缓冲的子样本被图元的所有颜色填满时，所有的这些颜色将会在每个像素内部平均化。因为上图的4个采样点只有2个被遮盖住了，这个像素的颜色将会是三角形颜色与其他两个采样点的颜色（在这里是无色）的平均值，最终形成一种淡蓝色。</p>\n<p>这样子做之后，颜色缓冲中所有的图元边缘将会产生一种更平滑的图形：</p>\n<p><img src=\"/img/article/20190816/6.png\" alt=\"多重采样MSAA三角形\"></p>\n<p>这里，每个像素包含4个子采样点（不相关的采样点都没有标注），蓝色的采样点被三角形所遮盖，而灰色的则没有。对于三角形的内部的像素，片段着色器只会运行一次，颜色输出会被存储到全部的4个子样本中。而在三角形的边缘，并不是所有的子采样点都被覆盖，所有片段着色器的结果将只会存储到部分的子样本中。根据被遮盖的子样本的数量，最终的像素颜色将由三角形的颜色与其它子样本中所存储的颜色来决定。</p>\n<p>简单来说，一个像素中如果有更多的采样点被三角形覆盖，那么这个像素的颜色就会更接近于三角形的颜色。如果我们给上面的三角形填充颜色，就能得到以下效果：</p>\n<p><img src=\"/img/article/20190816/7.png\" alt=\"多重采样渲染三角形\"></p>\n<p>对于每个像素来说，越少的子采样点被三角形覆盖，那么它受到三角形的影响越小。三角形的不平滑边缘被稍浅的颜色所包围后，从远处观察时就会显得更加平滑。</p>\n<p>不仅仅是颜色值会受到多重采样的影响，深度和模板测试也能够使用多个采样点。对深度测试来说，每个顶点的深度值会在运行深度测试之前被插值到各个子样本中。对模板测试来说，我们对每个子样本，而不是每个像素，存储一个模板值。当然，这也意味着深度和模板缓冲的大小会乘以子采样点的个数。</p>\n<p>我们到目前为止讨论的都是多重采样抗锯齿的背后原理，光栅器背后的实际逻辑比目前讨论的要复杂，但现在我们应该已经可以理解多重采样抗锯齿的大体概念和逻辑了。</p>\n<h1 id=\"在帧缓冲区读取和写入像素\">在帧缓冲区读取和写入像素</h1>\n<p>如果我们想为后代留下渲染过的图像，可以从颜色缓冲区中读回像素值，但是不能从深度或者模板缓冲区中读取。当调用<code>glReadPixels</code>时，颜色缓冲区中的像素将从一个前面分配的数组中返回应用程序：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 从颜色缓冲区中读回像素值</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param x，y#&gt; 指定从颜色缓冲区中要读取的像素矩形左下角的视口坐标 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param width，height#&gt; 指定从颜色缓冲区中读取的像素矩形的尺寸 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param format#&gt; 指定想要返回的像素格式。有3种可用格式：GL_RGBA、GL_RGBA_INTEGER以及查询GL_IMPLEMENTATION_COLOR_READ_FORMAT返回的值（特定于实现的像素格式） description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param type#&gt; 指定返回的像素数据类型。有5中可用类型：GL_UNSIGNED_BYTE、GL_UNSIGNED_INT、GL_INT、GL_FLOAT以及查询GL_IMPLEMENTATION_COLOR_READ_TYPE返回的值（特定于实现的像素格式） description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param pixels#&gt; 一个连续的字节数组，在glReadPixels返回之后包含从颜色缓冲区读取的值 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glReadPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *pixels);</span><br></pre></td></tr></table></figure>\n<h2 id=\"像素打包缓冲区对象\">像素打包缓冲区对象</h2>\n<p>当用<code>glBindBuffer</code>将一个非零的缓冲区对象绑定到<code>GL_PIXEL_PACK_BUFFER</code>时，<code>glReadPixels</code>命令将立即返回，并且启动DMA传输，从帧缓冲区读取像素，并将数据写入像素缓冲区对象（PBO）。<br>\n为了保持CPU忙碌，可以在<code>glReadPixels</code>调用之后计划一些CPU处理，是CPU计算和DMA传输重叠。根据应用程序的不同，数据可能立即可用；在这种情况下，可以使用多个PBO解决方案，在CPU从一个PBO传输的数据时，可以处理之前从另一个PBO传输的数据。</p>\n<h1 id=\"多重渲染目标\">多重渲染目标</h1>\n<p>多重渲染目标（MRT）允许应用程序一次渲染到多个颜色缓冲区。利用多重渲染目标，片段着色器输出多个颜色（可以用于保存RGBA颜色、发现、深度或者纹理坐标），每个颜色用于一个连接的颜色缓冲区。MRT用于多种高级渲染算法中，例如延迟着色和快速环境遮蔽计算。</p>\n<p>下面的步骤说明了设置MRT的方法：</p>\n<ol>\n<li>用<code>glGenFramebuffers</code>和<code>glBindFramebuffer</code>命令初始化帧缓冲区对象（FBO）：</li>\n</ol>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">glGenFramebuffers(<span class=\"number\">1</span>, &amp;fbo);</span><br><span class=\"line\">glBindFramebuffer(GL_FRAMEBUFFER, fbo);</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>用<code>glGenTextures</code>和<code>glBindTexture</code>命令初始化纹理：</li>\n</ol>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">glBindTexture(GL_TEXTURE_2D, textureId);</span><br><span class=\"line\">glTexImage2D(GL_TEXTURE_2D, <span class=\"number\">0</span>, GL_RGBA, textureWidth, textureHeight, <span class=\"number\">0</span>, GL_RGBA, GL_UNSIGNED_BYTE, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\"><span class=\"comment\">// Set the filtering mode</span></span><br><span class=\"line\">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);</span><br><span class=\"line\">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>用<code>glFramebufferTexture2D</code>或<code>glFramebufferTextureLayer</code>命令将相关纹理绑定到FBO：</li>\n</ol>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">glFramebufferTexture2D(GL_DRAW_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, textureId, <span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>用<code>glDrawBuffers</code>命令为渲染指定颜色附着：</li>\n</ol>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 为渲染指定颜色附着</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param n#&gt; 指定bufs中的缓冲区数量 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param bufs#&gt; 指定一个符号常量数组，这些常量指定了片段颜色或者数据值将要写入的缓冲区 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glDrawBuffers(GLsizei n, <span class=\"keyword\">const</span> GLenum *bufs);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> GLenum attachments[<span class=\"number\">4</span>] = &#123; GL_COLOR_ATTACHMENT0, GL_COLOR_ATTACHMENT1, GL_COLOR_ATTACHMENT2, GL_COLOR_ATTACHMENT3 &#125;;</span><br><span class=\"line\">glDrawBuffers(<span class=\"number\">4</span>, attachments);</span><br></pre></td></tr></table></figure>\n<p>可以调用以符号常量<code>GL_MAX_COLOR_ATTACHMENTS</code>为参数的<code>glGetIntegerv</code>查询颜色附着的最大数量。所有OpenGL 3.0实现都支持的颜色附着的最小数量为4.</p>\n<ol start=\"5\">\n<li>在片段着色器中声明和使用多个着色器输出。例如，如下的声明将把片段着色器输出<code>fragData0 ~ fragData3</code>分别复制到绘图缓冲区0 ~ 3：</li>\n</ol>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">layout(location = <span class=\"number\">0</span>) <span class=\"keyword\">out</span> vec4 fragData0;</span><br><span class=\"line\">layout(location = <span class=\"number\">1</span>) <span class=\"keyword\">out</span> vec4 fragData1;</span><br><span class=\"line\">layout(location = <span class=\"number\">2</span>) <span class=\"keyword\">out</span> vec4 fragData2;</span><br><span class=\"line\">layout(location = <span class=\"number\">3</span>) <span class=\"keyword\">out</span> vec4 fragData3;</span><br></pre></td></tr></table></figure>\n<h1 id=\"总结\">总结</h1>\n<p>这篇文章介绍了有关片段着色器之后发生的测试和操作的内容。这是OpenGL ES 3.0管线中的最后阶段。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>在OpenGL ES 3.0片段管线中执行片段着色器之后，可能应用到整个帧缓冲区或者单独片段的操作。片段着色器的输出是片段的颜色和深度值。下面的操作在片段着色器执行之后发生，可能影响像素的可见性和最终颜色：</p>\n<ul>\n<li>裁剪区域测试</li>\n<li>模板缓冲区测试</li>\n<li>深度缓冲区测试</li>\n<li>多重采样</li>\n<li>混合</li>\n<li>抖动</li>\n</ul>\n<p>片段在前往帧缓冲区途中经历的测试和操作如下图所示。<br>\n<img src=\"/img/article/20190816/1.png\" alt=\"着色器后的片段管线\"></p>\n</blockquote>\n<h1>缓冲区</h1>\n<p>OpenGL ES支持3中缓冲区，每种缓冲区都保存帧缓冲区中每个像素的不同数据：</p>\n<ul>\n<li>颜色缓冲区（由前台和后台颜色缓冲区组成）</li>\n<li>深度缓冲区</li>\n<li>模板缓冲区</li>\n</ul>\n<p>缓冲区的大小常被称作”缓冲区深度“（不要与深度缓冲区混淆），由可用于存储单个像素信息的位数来计量。例如，颜色缓冲区有3个分量，用于存储红、绿和蓝色分量以及可选的Alpha分量存储。颜色缓冲区的深度是所有颜色分量位数的总和。深度和模板缓冲区与此相反，这些缓冲区中用单一值表示像素的位深度。例如，深度缓冲区可能每个像素有16位。缓冲区的总大小是所有分量的位深度的总和。常见的帧缓冲区深度包含16位的RGB缓冲区，红色和蓝色各5位，绿色为6位（人类的视觉系统对绿色比对红色或者蓝色更敏感），对于RGBA缓冲区，32位被平均分配。<br>\n此外，颜色缓冲区可能是双重缓冲，也就是包含两个缓冲区：一个在输出设备（如监控器或者LCD显示器）上显示，称作”前台“缓冲区；另一个缓冲区对观看者隐藏，但是用于构造将要显示的下一个图像，称作”后台“缓冲区。在双缓冲区应用程序中，通过在后台缓冲区中绘制然后切换前后台缓冲区显示新图像来实现动画。缓冲区的切换通常与显示设备的刷新周期同步，这样将产生连续、流程动画的假象。<br>\n虽然每个EGL配置都有一个颜色缓冲区，深度和模板缓冲区是可选的。不过，每个EGL实现必须提供至少一个包含所有3个缓冲区的配置，深度缓冲区至少有16位的深度，模板缓冲区深度至少为8位。</p>\n<h2>清除缓冲区</h2>\n<p>OpenGL ES是一个交互式渲染系统，它假定在每个帧的开始，要将缓冲区的所有内容初始化为默认值。缓冲区可以通过调用<code>glClear</code>函数清除，该函数用一个位掩码表示应该清除为其指定值的各种缓冲区：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 清除缓冲区</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param mask#&gt; 指定要清除的缓冲区，由如下表示各种OpenGL ES缓冲区的位掩码联合组成：GL_COLOR_BUFFER_BIT， GL_DEPTH_BUFFER_BIT，GL_STENCIL_BUFFER_BIT description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glClear(GLbitfield mask);</span><br></pre></td></tr></table></figure>\n<p>我们没有要清除每个缓冲区，也没有必要同时清除它们，但是对每个帧仅调用<code>glClear</code>一次并同时清除所有需要的缓冲区，可以得到最好的性能。<br>\n当请求清除缓冲区时，每个缓冲区都有一个默认值。对于每个缓冲区，可以用如下函数指定需要的清除值：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 清除颜色缓冲区指定需要的清除值</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param red，green，blue，alpha#&gt; 当传递给glClear的位掩码中包含GL_COLOR_BUFFER_BIT时，指定颜色缓冲区中所有像素的颜色值（处于[0, 1]区间） description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glClearColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 清除深度缓冲区指定需要的清除值</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param depth#&gt; 当传递给glClear的位掩码中包含GL_DEPTH_BUFFER_BIT时，指定深度缓冲区中所有像素的深度值（处于[0, 1]区间） description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glClearDepthf(GLclampf depth);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 清除模板缓冲区指定需要的清除值</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param s#&gt; 当传递给glClear的位掩码中包含GL_DEPTH_BUFFER_BIT时，指定模板缓冲区中所有像素的模板值（处于[0, 2^n-1]区间，其中n是模板缓冲区中可用的位数） description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glClearStencil(GLint s);</span><br></pre></td></tr></table></figure>\n<p>如果在一个帧缓冲区对象中有多个绘图缓冲区，可以用如下调用清除特定的绘图缓冲区：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 清除特定的绘图缓冲区</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param buffer#&gt; 指定要清除的缓冲区类型，可能是GL_COLOR、GL_FRONT、GL_BACK、GL_FRONT_AND_BACK、GL_LEFT、GL_RIGHT、GL_DEPTH（仅glClearBufferfv）或GL_STENCIL（仅glClearBufferiv） description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param drawbuffer#&gt; 指定要清除的绘图缓冲区名称。对于深度或者模板缓冲区，必须为0.对颜色缓冲区必须小于GL_MAX_DRAW_BUFFERS description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param value#&gt; 指定用于清除缓冲区的一个四元素向量（对于颜色缓冲区）和一个数值（对于深度或者模板缓冲区）的指针 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glClearBufferiv(GLenum buffer, GLint drawbuffer, <span class=\"keyword\">const</span> GLint *value);</span><br><span class=\"line\">glClearBufferuiv(GLenum buffer, GLint drawbuffer, <span class=\"keyword\">const</span> GLuint *value);</span><br><span class=\"line\">glClearBufferfv(GLenum buffer, GLint drawbuffer, <span class=\"keyword\">const</span> GLfloat *value);</span><br></pre></td></tr></table></figure>\n<p>为了减少函数调用的数量，可以用<code>glClearBufferfi</code>同时清除深度和模板缓冲区：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 同时清除深度和模板缓冲区</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param buffer#&gt; 指定要清除的缓冲区类型；必须是GL_DEPTH_STENCIL description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param drawbuffer#&gt; 指定要清楚的绘图缓冲区名称；必须为0 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param depth#&gt; 指定清除深度缓冲区所用的值 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param stencil#&gt; 指定清除模板缓冲区所用的值 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glClearBufferfi(GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil);</span><br></pre></td></tr></table></figure>\n<h2>用掩码控制帧缓冲区的写入</h2>\n<p>我们也可以通过指定一个缓冲区写入掩码来控制哪些缓冲区或者分量（颜色缓冲区的情况下）可以写入。在像素值被写入缓冲区之前，使用缓冲区掩码验证该缓冲区是否可写入。<br>\n对于颜色缓冲区，<code>glColorMask</code>例程指定像素被写入时颜色缓冲区中的哪些分量会被更新。如果特定分量的掩码被设置为<code>GL_FALSE</code>，则该分量在写入时不会被更新。默认情况下，所有颜色分量都可以写入：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 指定颜色分量在写入时是否被更新</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param red，green，blue，alpha#&gt; 指定颜色缓冲区的特定颜色分量在渲染的时候是否可以修改 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glColorMask(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha);</span><br></pre></td></tr></table></figure>\n<p>同样，深度缓冲区的写入通过以指定深度缓冲区是否可写入的<code>GL_TRUE</code>或<code>GL_FALSE</code>为参数的调用<code>glDepthMask</code>进行控制。<br>\n在渲染透明物体的时候，深度缓冲区的写入常常被禁用。开始时，启用深度缓冲区的写入（设置为<code>GL_TRUE</code>），渲染场景中的所有不透明物体。这能够确保所有不透明物体有正确的深度，而深度缓冲区包含场景的对应深度信息。然后，在渲染透明物体之前，应该调用<code>glDepthMask</code>（<code>GL_FALSE</code>）来禁用深度缓冲区的写入。在深度缓冲区的写入被禁用时，数值仍然可以从中读出，并用于深度对比。这使得被不透明物体遮盖的透明物体可以正确地缓冲深度，但是不会修改深度缓冲区，从而使不透明的物体被透明物体遮盖：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 指定深度缓冲区是否可以修改</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param flag#&gt; 指定深度缓冲区是否可以修改 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glDepthMask(GLboolean flag);</span><br></pre></td></tr></table></figure>\n<p>最后，可以调用<code>glStencilMask</code>来禁用模板缓冲区的写入。与<code>glColorMask</code>或<code>glDepthMask</code>不同，我们可以提供一个掩码来指定模板缓冲区的哪些位可以写入：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 指定模板缓冲区的哪些位可以写入</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param mask#&gt; 指定一个说明模板缓冲区中的像素哪些位可以修改的位掩码（在[0, 2^n-1]区间，其中n是模板缓冲区位数），使用得较多的是0x00表示禁止写入，0xFF表示允许任何写入。 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glStencilMask(GLuint mask);</span><br></pre></td></tr></table></figure>\n<p><code>glStencilMaskSeparate</code>例程可以根据图元的面顶点顺序（有时候称作”面部特征“）设置模板掩码，这允许对正面和背面的图元使用不同的模板掩码：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 对正面和背面的图元使用不同的模板掩码来指定缓冲区哪些位可以写入</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param face#&gt; 指定根据渲染图元的面顶点顺序应用的模板掩码。有效值为GL_FRONT，GL_BACK，GL_FRONT_AND_BACK description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param mask#&gt; 指定一个位掩码（在[0, 2^n-1]区间，其中n是模板缓冲区位数），表示模板缓冲区中像素的哪些位由面指定 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glStencilMaskSeparate(GLenum face, GLuint mask);</span><br></pre></td></tr></table></figure>\n<h1>片段测试和操作</h1>\n<p>下面几个小节描述可以应用到OpenGL ES片段的各种测试。默认情况下，所有片段测试和操作都被禁用，片段在写入帧缓冲区时按照接收它们的顺序变成像素。通过启用不同的片段，可以应用操作性测试，以选择哪些片段成为像素并影响最终的图像。<br>\n每个片段测试都可以通过调用<code>glEnable</code>单独启用，该函数所带的标志参数如下表：</p>\n<table>\n<thead>\n<tr>\n<th>glEnable标志</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>GL_DEPTH_TEST</td>\n<td>控制片段的深度测试</td>\n</tr>\n<tr>\n<td>GL_STENCIL_TEST</td>\n<td>控制片段的模板测试</td>\n</tr>\n<tr>\n<td>GL_BLEND</td>\n<td>控制片段与颜色缓冲区中存储的颜色的混合</td>\n</tr>\n<tr>\n<td>GL_DITHER</td>\n<td>在写入颜色缓冲区前控制片段颜色的抖动</td>\n</tr>\n<tr>\n<td>GL_SAMPLE_COVERAGE</td>\n<td>控制样本范围值的计算</td>\n</tr>\n<tr>\n<td>GL_SAMPLE_ALPHA_TO_COVERAGE</td>\n<td>控制样本范围值计算中样本Alpha的使用</td>\n</tr>\n</tbody>\n</table>\n<h2>使用裁剪测试</h2>\n<p>裁剪测试通过指定一个矩形区域（进一步限制帧缓冲区中可以写入的像素）提供了额外的裁剪层次。使用裁剪矩形是两步的过程。首先，需用<code>glScissor</code>函数指定矩形区域：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 指定裁剪矩形</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param x，y#&gt; 以视口坐标指定裁剪矩形左下角 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param width#&gt; 指定裁剪矩形宽度 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param height#&gt; 指定裁剪矩形高度 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glScissor(GLint x, GLint y, GLsizei width, GLsizei height);</span><br></pre></td></tr></table></figure>\n<p>指定裁剪矩形之后，需通过调用<code>glEnable(GL_SCISSOR_TEST)</code>启用它，以实施更多的裁剪。所有渲染（包括视口清除）都限于裁剪矩形之内。<br>\n一般来说，裁剪矩形是视口中的一个子区域，但是这两个区域不一定真正交叉。当两个区域不交叉时，裁剪操作将在视口区域外渲染的像素上进行。注意，视口的变换发生在片段着色器之前，而裁剪测试发生在片段着色器阶段之后。</p>\n<h2>模板缓冲区测试</h2>\n<p>应用到片段的下一个操作是模板测试。模板缓冲区是一个逐像素掩码，保存可用于确定某个像素是否应该被更新的值。模板测试由应用程序启用或者禁用。<br>\n模板缓冲区的使用可以看作两步的操作。第一步是逐像素掩码初始化模板缓冲区，这可以通过渲染几何形状并指定模板缓冲区的更新方法来完成。第二步通常是使用这些值控制后续在颜色缓冲区中的渲染。在两种情况下，都指定参数在模板测试中的使用方式。<br>\n模板测试实际上是一个位测试，就像在C程序中使用掩码确定某一位是否置位一样。控制模板测试的运算符和值的模板函数由<code>glStencilFunc</code>或<code>glStencilSeparate</code>函数控制：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 控制模板测试的运算符和值的模板函数</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param func#&gt; 指定模板测试的比较函数，有效值为GL_EQUAL、GL_NOTEQUAL、GL_LESS、GL_GREATER、GL_LEQUEAL、GL_GEQUAL、GL_ALWAYS、GL_NEVER description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param ref#&gt; 指定模板测试的参考值 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param mask#&gt; 指定在与参考值与模板缓冲区中各位比较之前进行按位与运算的掩码 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glStencilFunc(GLenum func, GLint ref, GLuint mask);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 控制模板测试的运算符和值的模板函数</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param face#&gt; 指定与所提供的模板函数相关的面。有效值为GL_FRONT、GL_BACK和GL_FRONT_AND_BACK description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param func#&gt; 指定模板测试的比较函数，有效值为GL_EQUAL、GL_NOTEQUAL、GL_LESS、GL_GREATER、GL_LEQUEAL、GL_GEQUAL、GL_ALWAYS、GL_NEVER description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param ref#&gt; 指定模板测试的参考值 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param mask#&gt; 指定在与参考值与模板缓冲区中各位比较之前进行按位与运算的掩码 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glStencilFuncSeparate(GLenum face, GLenum func, GLint ref, GLuint mask);</span><br></pre></td></tr></table></figure>\n<p>为了更精细地控制模板测试，可以使用一个掩码参数来选择模板值中的哪些位应该参加测试。在选择这些位之后，它们的值用提供的运算符与参考值比较。例如，要指定模板缓冲区最低三位等于2的模板测试，应该调用：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">glStencilFunc(GL_EQUAL, <span class=\"number\">2</span>, <span class=\"number\">0x7</span>);</span><br></pre></td></tr></table></figure>\n<p>并启用模板测试。注意，在二进制格式中，0x7的最后三位为111。</p>\n<p>配置了模板测试之后，通常还需要让OpenGL ES 3.0知道模板测试通过时对模板缓冲区中的值进行什么操作。实际上，修改模板缓冲区中的值不仅依赖模板测试，还要加入深度测试的结果。结合模板和深度测试，一个片段可能有3种结果：</p>\n<ol>\n<li>片段无法通过模板测试。如果这样，则不对该片段进行任何进一步的测试（也就是深度测试）。</li>\n<li>片段通过模板测试，但是无法通过深度测试。</li>\n<li>片段既通过模板测试，又通过深度测试。</li>\n</ol>\n<p>这些可能的结果都可以用于影响该像素位置的模板缓冲区中的值。<code>glStencilOp</code>和<code>glStencilOpSeparte</code>函数控制每个测试结果对深度缓冲区进行的操作，模板值上的可能操作如下表：</p>\n<table>\n<thead>\n<tr>\n<th>模板函数</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>GL_ZERO</td>\n<td>将模板值设置为0</td>\n</tr>\n<tr>\n<td>GL_REPLACE</td>\n<td>用<code>glStencilFunc</code>或<code>glStencilFuncSeparate</code>中指定的参考值代替当前模板值</td>\n</tr>\n<tr>\n<td>GL_INCE, GL_DECR</td>\n<td>递增或递减模板值；模板值被限定在0或2<sup>n</sup>，其中n为模板缓冲区位数</td>\n</tr>\n<tr>\n<td>GL_INCE_WRAP, GL_DECR_WRAP</td>\n<td>递增或者递减模板值，但是如果模板值上溢或者下溢，则”卷绕“该值（最大值递增产生新的模板值0，0值递减产生最大模板值）</td>\n</tr>\n<tr>\n<td>GL_KEEP</td>\n<td>保持当前模板值，实际上没有修改该像素的值</td>\n</tr>\n<tr>\n<td>GL_INVERT</td>\n<td>模板缓冲区中值的按位非</td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 更新模板缓冲区中的值</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param fail#&gt; 指定片段不能通过模板测试时应用到模板位的操作。有效值为上表所述 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param zfail#&gt; 指定片段通过模板测试但是没有通过深度测试时应用的操作 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param zpass#&gt; 指定片段在模板和深度测试中都通过时应用的操作 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glStencilOp(GLenum fail, GLenum zfail, GLenum zpass);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 更新模板缓冲区中的值</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param face#&gt; 指定与提供的模板函数相关的面。有效值为GL_FRONT、GL_BACK和GL_FRONT_AND_BACK description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param fail#&gt; 指定片段不能通过模板测试时应用到模板位的操作。有效值为上表所述 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param zfail#&gt; 指定片段通过模板测试但是没有通过深度测试时应用的操作 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param zpass#&gt; 指定片段在模板和深度测试中都通过时应用的操作 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glStencilOpSeparate(GLenum face, GLenum fail, GLenum zfail, GLenum zpass);</span><br></pre></td></tr></table></figure>\n<h3>深度缓冲测试</h3>\n<p>深度缓冲区通常用于隐藏表面的消除。传统上，它保存渲染表面上每个像素与视点最近物体的距离值，对于每个新的输入片段，将其与视点的距离和存储值比较。默认情况下，如果输入片段的深度值小于深度缓冲区中保存的值（意味着它离观看者更近），则输入片段的深度值代替保存在深度缓冲区中的值，然后其颜色值代替颜色缓冲区中的颜色值。这是深度缓冲的标准方法–如果这就是我们想做的，那么只需要在创建窗口时请求一个深度缓冲区，然后调用带<code>GL_DEPTH_TEST</code>的<code>glEnable</code>启用深度测试。如果深度缓冲区与颜色缓冲区关联，则深度测试总是会通过。<br>\n当然，这是使用深度缓冲区的唯一手段。可以通过调用<code>glDepthFunc</code>修改深度比较运算符：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 修改深度比较运算符</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param func#&gt; 指定深度值比较函数，可能是GL_LESS、GL_GREATER、GL_LEQUAL、GL_GEQUAL、GL_EQUAL、GL_NOTEQUAL、GL_ALWAYS或GL_NEVER中的一个 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glDepthFunc(GLenum func);</span><br></pre></td></tr></table></figure>\n<h2>混合</h2>\n<p>一旦片段通过了所有启用的片段测试，它的颜色将与片段像素位置中已经存在的颜色组合。在两个颜色组合之前，它们与一个比例因子相乘，然后用指定的混合运算符组合。混合方程如下：C<sub>final</sub>=f<sub>source</sub>C<sub>source</sub>opf<sub>destination</sub>C<sub>destination</sub>。<br>\n其中，f<sub>source</sub>和C<sub>source</sub>分别是输入片段的比例因子和颜色。同样，f<sub>destination</sub>和C<sub>destination</sub>是像素的比例因子和颜色，op是组合折算值的数学运算符。<br>\n比例因子通过调用<code>glBlendFunc</code>或者<code>glBlendFuncSeparate</code>指定：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 指定混合比例因子</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param sfactor#&gt; 指定输入片段的混合系数 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param dfactor#&gt; 指定目标像素的混合系数 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glBlendFunc(GLenum sfactor, GLenum dfactor);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 指定混合比例因子</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param srcRGB#&gt; 指定输入片段红、绿和蓝色分量的混合系数 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param dstRGB#&gt; 指定目标像素红、绿和蓝色分量的混合系数 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param srcAlpha#&gt; 指定输入片段Alpha值的混合系数 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param dstAlpha#&gt; 指定目标像素Alpha值的混合系数 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glBlendFuncSeparate(GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);</span><br></pre></td></tr></table></figure>\n<p>混合系数的取值如下表：</p>\n<p><img src=\"/img/article/20190816/2.png\" alt=\"混合函数\"></p>\n<p>C<sub>constant</sub>代表调用<code>glBlendColor</code>设置的常量颜色：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 设置混合常量颜色</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param red，green，blue，alpha#&gt; 指定常量混合颜色的分量值 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glBlendColor(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);</span><br></pre></td></tr></table></figure>\n<p>输入片段和像素颜色乘以各自的比例因子后，它们用由<code>glBlendEquation</code>或<code>glBlendEquationSeparate</code>指定的运算符组合。默认情况下，混合后的颜色用<code>GL_FUNC_ADD</code>运算符累加。<code>GL_FUNC_SUBTRACT</code>运算符从输入片段值中减去帧缓冲区中的换算值。同样，<code>GL_FUNC_REVERSE_SUBTRACT</code>运算符颠倒混合方程式，从当前像素值中减去输入片段颜色：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> 设置混合运算符</span><br><span class=\"line\"></span><br><span class=\"line\"> @param mode#&gt; 指定混合运算符。有效值是GL_FUNC_ADD、GL_FUNC_SUBTRACT、GL_FUNC_REVERSE_SUBTRACT、GL_MIN、GL_MAX description#&gt;</span><br><span class=\"line\"> @return void</span><br><span class=\"line\"> */</span><br><span class=\"line\">glBlendEquation(GLenum mode);</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> 设置混合运算符</span><br><span class=\"line\"></span><br><span class=\"line\"> @param modeRGB#&gt; 为红、绿和蓝色分量指定混合运算符 description#&gt;</span><br><span class=\"line\"> @param modeAlpha#&gt; 指定Alpha分量混合运算符 description#&gt;</span><br><span class=\"line\"> @return void</span><br><span class=\"line\"> */</span><br><span class=\"line\">glBlendEquationSeparate(GLenum modeRGB, GLenum modeAlpha);</span><br></pre></td></tr></table></figure>\n<h1>抖动</h1>\n<p>在由于帧缓冲区中每个分量的位数导致的帧缓冲区中可用颜色数量有限的系统上，我们可以用抖动（Dithering）模拟更大的色深。抖动算法以某种方式安排颜色，使图像看上去似乎比实际上的可用颜色更多。OpenGL ES 3.0没有规定抖动阶段使用的算法；具体的技术很大程度上依赖于实现。<br>\n应用程序对抖动的唯一控制是它是否应用到最终的像素上。这一决策完全通过带<code>GL_DITHER</code>的<code>glEnable</code>或<code>glDisable</code>控制，它指定了管线中抖动的使用。在初始状态下，启用抖动。</p>\n<h1>多重采样抗锯齿</h1>\n<p>抗锯齿（Anti-aliasing）是通过尝试减少不同像素渲染中产生的视觉伪像来改进生成图像质量的一种重要技术。OpenGL ES 3.0渲染的几何形状图元在一个网格上进行光栅化，它们的边缘可能在这一过程中变形。绘制跨越显示器的对角线时，几何肯定会发现阶梯效应。<br>\n为了理解什么是多重采样（Multisampling），以及它是如何解决锯齿问题的，我们有必要更加深入地了解OpenGL光栅器的工作方式。<br>\n光栅器是位于最终处理过的顶点之后到片段着色器之前所经过的所有的算法与过程的总和。光栅器会将一个图元的所有顶点作为输入，并将它转换为一系列的片段。顶点坐标理论上可以取任何值，但片段不行，因为它们受限于窗口的分辨率。顶点坐标与片段之间几乎永远也不会有一对一的映射，所以光栅器必须以某种方式来决定每个顶点最终所在的片段/屏幕坐标。</p>\n<p><img src=\"/img/article/20190816/3.png\" alt=\"多重采样三角形\"></p>\n<p>这里我们可以看到一个屏幕像素的网格，每个像素的中心包含有一个采样点（Sampler Point），它会被用来决定这个三角形是否遮盖了某个像素。途中红色的采样点被三角形所覆盖，在每一个遮住的像素处都会生成一个片段。虽然三角形边缘的一部分也遮住了某些屏幕像素，但是这些像素的采样点并没有被三角形内部所覆盖，所以它们不会受到片段着色器影响。</p>\n<p>现在我们可能已经清楚走样的原因了。完整渲染后的三角形在屏幕上会是这样的：</p>\n<p><img src=\"/img/article/20190816/4.png\" alt=\"多重采样渲染三角形\"></p>\n<p>由于屏幕像素总量的限制，有些边缘的像素能够被渲染出来，而有些则不会。结果就是我们使用了不光滑的边缘来渲染图元，导致锯齿边缘。</p>\n<p>多重采样所做的正是将单一的采样点变为多个采样点（这也是它名称的由来）。我们不再使用像素中心的是单一采样点，取而代之的是以特定图案排列的4个子采样点（Subsampler）。我们将用这些子采样点来决定像素的遮盖度。当然，这也意味着颜色缓冲的大小会随着子采样点的增加而增加。</p>\n<p><img src=\"/img/article/20190816/5.png\" alt=\"多重采样三角形剖析\"></p>\n<p>上图的左侧展示了正常情况下判定三角形是否遮盖的方式。在例子中的这个像素上不会运行片段着色器（所以它会保持空白）。因为它的采样点并未被三角形所覆盖。上图的右侧展示的是实施多重采样之后的版本，每个像素包含有4个采样点。这里，只有两个采样点遮盖了三角形。</p>\n<blockquote>\n<p>采样点的数量可以是任意的，更多的采样点能带来更精确的遮盖率。</p>\n</blockquote>\n<p>从这里开始多重采样就变得有趣起来了。我们知道三角形只遮盖了2个子采样点，所以下一步是决定这个像素的颜色。MSAA（Multi-Sampling Anti-Aliasing）真正的工作方式是，无论三角形遮盖了多少个子采样点，（每个图元中）每个像素只允许一次片段着色器。片段着色器所使用的顶点数据会插值到每个像素的中心，所得到的结果颜色会被存储在每个被遮盖住的子采样点中。当颜色缓冲的子样本被图元的所有颜色填满时，所有的这些颜色将会在每个像素内部平均化。因为上图的4个采样点只有2个被遮盖住了，这个像素的颜色将会是三角形颜色与其他两个采样点的颜色（在这里是无色）的平均值，最终形成一种淡蓝色。</p>\n<p>这样子做之后，颜色缓冲中所有的图元边缘将会产生一种更平滑的图形：</p>\n<p><img src=\"/img/article/20190816/6.png\" alt=\"多重采样MSAA三角形\"></p>\n<p>这里，每个像素包含4个子采样点（不相关的采样点都没有标注），蓝色的采样点被三角形所遮盖，而灰色的则没有。对于三角形的内部的像素，片段着色器只会运行一次，颜色输出会被存储到全部的4个子样本中。而在三角形的边缘，并不是所有的子采样点都被覆盖，所有片段着色器的结果将只会存储到部分的子样本中。根据被遮盖的子样本的数量，最终的像素颜色将由三角形的颜色与其它子样本中所存储的颜色来决定。</p>\n<p>简单来说，一个像素中如果有更多的采样点被三角形覆盖，那么这个像素的颜色就会更接近于三角形的颜色。如果我们给上面的三角形填充颜色，就能得到以下效果：</p>\n<p><img src=\"/img/article/20190816/7.png\" alt=\"多重采样渲染三角形\"></p>\n<p>对于每个像素来说，越少的子采样点被三角形覆盖，那么它受到三角形的影响越小。三角形的不平滑边缘被稍浅的颜色所包围后，从远处观察时就会显得更加平滑。</p>\n<p>不仅仅是颜色值会受到多重采样的影响，深度和模板测试也能够使用多个采样点。对深度测试来说，每个顶点的深度值会在运行深度测试之前被插值到各个子样本中。对模板测试来说，我们对每个子样本，而不是每个像素，存储一个模板值。当然，这也意味着深度和模板缓冲的大小会乘以子采样点的个数。</p>\n<p>我们到目前为止讨论的都是多重采样抗锯齿的背后原理，光栅器背后的实际逻辑比目前讨论的要复杂，但现在我们应该已经可以理解多重采样抗锯齿的大体概念和逻辑了。</p>\n<h1>在帧缓冲区读取和写入像素</h1>\n<p>如果我们想为后代留下渲染过的图像，可以从颜色缓冲区中读回像素值，但是不能从深度或者模板缓冲区中读取。当调用<code>glReadPixels</code>时，颜色缓冲区中的像素将从一个前面分配的数组中返回应用程序：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 从颜色缓冲区中读回像素值</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param x，y#&gt; 指定从颜色缓冲区中要读取的像素矩形左下角的视口坐标 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param width，height#&gt; 指定从颜色缓冲区中读取的像素矩形的尺寸 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param format#&gt; 指定想要返回的像素格式。有3种可用格式：GL_RGBA、GL_RGBA_INTEGER以及查询GL_IMPLEMENTATION_COLOR_READ_FORMAT返回的值（特定于实现的像素格式） description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param type#&gt; 指定返回的像素数据类型。有5中可用类型：GL_UNSIGNED_BYTE、GL_UNSIGNED_INT、GL_INT、GL_FLOAT以及查询GL_IMPLEMENTATION_COLOR_READ_TYPE返回的值（特定于实现的像素格式） description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param pixels#&gt; 一个连续的字节数组，在glReadPixels返回之后包含从颜色缓冲区读取的值 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glReadPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *pixels);</span><br></pre></td></tr></table></figure>\n<h2>像素打包缓冲区对象</h2>\n<p>当用<code>glBindBuffer</code>将一个非零的缓冲区对象绑定到<code>GL_PIXEL_PACK_BUFFER</code>时，<code>glReadPixels</code>命令将立即返回，并且启动DMA传输，从帧缓冲区读取像素，并将数据写入像素缓冲区对象（PBO）。<br>\n为了保持CPU忙碌，可以在<code>glReadPixels</code>调用之后计划一些CPU处理，是CPU计算和DMA传输重叠。根据应用程序的不同，数据可能立即可用；在这种情况下，可以使用多个PBO解决方案，在CPU从一个PBO传输的数据时，可以处理之前从另一个PBO传输的数据。</p>\n<h1>多重渲染目标</h1>\n<p>多重渲染目标（MRT）允许应用程序一次渲染到多个颜色缓冲区。利用多重渲染目标，片段着色器输出多个颜色（可以用于保存RGBA颜色、发现、深度或者纹理坐标），每个颜色用于一个连接的颜色缓冲区。MRT用于多种高级渲染算法中，例如延迟着色和快速环境遮蔽计算。</p>\n<p>下面的步骤说明了设置MRT的方法：</p>\n<ol>\n<li>用<code>glGenFramebuffers</code>和<code>glBindFramebuffer</code>命令初始化帧缓冲区对象（FBO）：</li>\n</ol>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">glGenFramebuffers(<span class=\"number\">1</span>, &amp;fbo);</span><br><span class=\"line\">glBindFramebuffer(GL_FRAMEBUFFER, fbo);</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>用<code>glGenTextures</code>和<code>glBindTexture</code>命令初始化纹理：</li>\n</ol>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">glBindTexture(GL_TEXTURE_2D, textureId);</span><br><span class=\"line\">glTexImage2D(GL_TEXTURE_2D, <span class=\"number\">0</span>, GL_RGBA, textureWidth, textureHeight, <span class=\"number\">0</span>, GL_RGBA, GL_UNSIGNED_BYTE, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\"><span class=\"comment\">// Set the filtering mode</span></span><br><span class=\"line\">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);</span><br><span class=\"line\">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>用<code>glFramebufferTexture2D</code>或<code>glFramebufferTextureLayer</code>命令将相关纹理绑定到FBO：</li>\n</ol>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">glFramebufferTexture2D(GL_DRAW_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, textureId, <span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>用<code>glDrawBuffers</code>命令为渲染指定颜色附着：</li>\n</ol>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 为渲染指定颜色附着</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param n#&gt; 指定bufs中的缓冲区数量 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param bufs#&gt; 指定一个符号常量数组，这些常量指定了片段颜色或者数据值将要写入的缓冲区 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glDrawBuffers(GLsizei n, <span class=\"keyword\">const</span> GLenum *bufs);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> GLenum attachments[<span class=\"number\">4</span>] = &#123; GL_COLOR_ATTACHMENT0, GL_COLOR_ATTACHMENT1, GL_COLOR_ATTACHMENT2, GL_COLOR_ATTACHMENT3 &#125;;</span><br><span class=\"line\">glDrawBuffers(<span class=\"number\">4</span>, attachments);</span><br></pre></td></tr></table></figure>\n<p>可以调用以符号常量<code>GL_MAX_COLOR_ATTACHMENTS</code>为参数的<code>glGetIntegerv</code>查询颜色附着的最大数量。所有OpenGL 3.0实现都支持的颜色附着的最小数量为4.</p>\n<ol start=\"5\">\n<li>在片段着色器中声明和使用多个着色器输出。例如，如下的声明将把片段着色器输出<code>fragData0 ~ fragData3</code>分别复制到绘图缓冲区0 ~ 3：</li>\n</ol>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">layout(location = <span class=\"number\">0</span>) <span class=\"keyword\">out</span> vec4 fragData0;</span><br><span class=\"line\">layout(location = <span class=\"number\">1</span>) <span class=\"keyword\">out</span> vec4 fragData1;</span><br><span class=\"line\">layout(location = <span class=\"number\">2</span>) <span class=\"keyword\">out</span> vec4 fragData2;</span><br><span class=\"line\">layout(location = <span class=\"number\">3</span>) <span class=\"keyword\">out</span> vec4 fragData3;</span><br></pre></td></tr></table></figure>\n<h1>总结</h1>\n<p>这篇文章介绍了有关片段着色器之后发生的测试和操作的内容。这是OpenGL ES 3.0管线中的最后阶段。</p>\n"},{"title":"OpenGL ES学习--片段着色器","catalog":true,"toc_nav_num":true,"date":"2019-08-15T09:20:32.000Z","subtitle":"About OpenGL ES","header-img":"/img/article_header/article_header.png","busuanzi":true,"_content":"\n> 介绍片段着色器编写方面的细节。\n\n# 固定功能片段着色器\n\n在研究片段着色器的细节之前，值得简单地回顾一下老式的固定功能片段管线，这将帮助我们理解老式的固定功能管线映射到片段着色器的方式。在转到更先进的片段编程技术之前，这是很好的起点。\n在OpenGL ES 1.1（以及固定功能桌面OpenGL）中，可以使用一组有限的方程式，确定如何组合片段着色器的不同输入。在固定功能管线中，实际上可以使用3中输入：插值顶点颜色、纹理颜色和常量颜色。顶点颜色通常保存一个预先计算的颜色或者顶点照明计算的结果。纹理颜色来自于使用图元纹理坐标绑定的纹理中读取的值，而常量颜色可以对每个纹理单元设置。\n用于组合这些输入的这一组方程式相当有限，例如，在OpenGL ES 1.1中，可用的方程式在下表中列出。方程式的输入A、B、C可能来自于顶点颜色、纹理颜色或者常量颜色。\n\nRGB组合函数 | 方程式\n- | -\nREPLACE | A\nMODULATE | AxB\nADD | A+B\nADD_SIGNED | A+B-0.5\nINTERPOLATE | AxC+Bx(1-C)\nSUBTRACT | A-B\nDOT3_RGB(and DOT3_RGBA) | 4x((A.r-0.5)x(B.r-0.5)+(A.g-0.5)x(B.g-0.5)+(A.b-0.5)x(B.b-0.5))\n\n即使利用这组有限的方程式，实际上也可以实现大量有趣的特效，但是，这比起可编程还有很大的距离，因为片段管线只能以非常固定的一组方式配置。\n为什么要回顾这段历史呢？因为它能帮助我们理解如何用着色器实现传统的固定功能技术。例如，假定我们已经用一个基本纹理贴图配置了固定功能管线，希望用顶点颜色调制该贴图。在固定功能OpenGL ES（或者OpenGL）中，我们将启用一个纹理单元，选择MODULATE的组合方程式，并且将方程式的输入设置为顶点颜色和纹理颜色。下面提供OpenGL ES 1.1实现以上功能的代码，作为参考：\n\n``` objc\nglTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_COMBINE);\nglTexEnvi(GL_TEXTURE_ENV, GL_COMBINE_RGB, GL_MODULATE);\nglTexEnvi(GL_TEXTURE_ENV, GL_SOURCE0_RGB, GL_PRIMARY_COLOR);\nglTexEnvi(GL_TEXTURE_ENV, GL_SOURCE1_RGB, GL_TEXTURE);\nglTexEnvi(GL_TEXTURE_ENV, GL_COMBINE_ALPHA, GL_MODULATE);\nglTexEnvi(GL_TEXTURE_ENV, GL_SOURCE0_ALPHA, GL_PRIMARY_COLOR);\nglTexEnvi(GL_TEXTURE_ENV, GL_SOURCE1_ALPHA, GL_TEXTURE);\n```\n\n这段代码配置固定功能管线，以执行主颜色（顶点颜色）和纹理颜色之间的调制（AxB）。这些代码在OpenGL ES 3.0中已经不存在了。我们只是试图说明这些功能如何映射到片段着色器。在片段着色器中，同样的调制计算可以用如下代码实现：\n\n``` objc\n#version 300 es\nprecision mediump float;\nuniform sampler2D s_tex0;\nin vec2 v_texCoord;\nin vec4 v_primaryColor;\nlayout(location = 0) out vec4 outColor;\nvoid main()\n{\n    outColor = texture(s_tex0, v_texCoord) * v_primaryColor;\n}\n```\n\n片段着色器执行的操作与固定功能设置执行的操作完全相同。纹理值从一个采样器（绑定到纹理单元0）读取，并用一个2D纹理坐标查找该值。然后，纹理读取的结果和顶点着色器传递的输入值`v_primaryColor`相乘。在这个例子中，顶点着色器已经将颜色传递给片段着色器。\n可以编写一个片段着色器，执行任何固定功能纹理组合设置的等价计算。当然，也可以编写着色器，执行比固定功能复杂得多的不同计算。\n\n# 片段着色器概述\n\n片段着色器为片段操作提供了通用功能的可编程方法。片段着色器的输入由如下部分组成：\n- 输入（或者可变值）--顶点着色器生成的插值数据。顶点着色器输出跨图元进行插值，并作为输入传递给片段着色器。\n- 统一变量--片段着色器使用的状态，这些常量值在每个片段上不会变化。\n- 采样器--用于访问着色器中的纹理图像。\n- 代码--片段着色器源代码或者二进制代码，描述在片段上执行的操作。\n片段着色器的输出时一个或者多个片段颜色，传递到管线的逐片段操作部分（输出颜色的数量取决于使用多少个颜色附着）。片段着色器的输入和输出如下图所示：\n\n![OpenGL ES 3.0片段着色器](/img/article/20190815/1.png)\n\n## 内建特殊变量\n\nOpenGL ES 3.0有内建特殊变量，这些变量由片段着色器输出或者作为片段着色器的输入。片段着色器中可用的内建特殊变量如下所示：\n- `gl_FragCoord`--片段着色器中的一个只读变量。这个变量保存片段的窗口相对坐标(x, y, z, 1/w)。在一些算法中，知道当前片段的窗口坐标是很有用的。例如，可以使用窗口坐标作为某个随机噪声贴图纹理读取的偏移量，噪声贴图的值用于旋转阴影贴图的过滤核心。这种技术用于减少阴影贴图的锯齿失真。\n- `gl_FrontFacing`--片段着色器中的一个只读变量。这个布尔变量在片段是正面图元的一部分时为true，否则为false。\n- `gl_PointCoord`--一个只读变量，可以在渲染点精灵时使用。它保存点精灵的纹理坐标，这个坐标在点光栅化期间自动生成，处于[0, 1]区间内。\n- `gl_FragDepth`--一个只写输出变量，在片段着色器中写入时，覆盖片段的固定功能深度值。这一功能应该谨慎使用（只在必要时），因为它可能禁用许多GPU的深度优化。例如，许多GPU有所谓的”Early-Z“功能，在执行片段着色器之前进行深度测试。使用Early-Z的好处是不能通过深度测试的片段永远不会被着色（从而保护了性能）。但是，使用`gl_FragDepth`时，必须禁用该功能，因为GPU在执行片段着色器之前不知道深度值。\n\n## 内建常量\n\n下面是与片段着色器有关的内建常量：\n\n``` objc\nconst mediump int gl_MaxFragmentInputVectors = 15;\nconst mediump int gl_MaxTextureImageUnits = 16;\nconst mediump int gl_MaxFragmentUniformVectors = 224;\nconst mediump int gl_MaxDrawBuffers = 4;\nconst mediump int gl_MinProgramTexelOffset = -8;\nconst mediump int gl_MaxProgramTexelOffset = 7;\n```\n\n内建常量的描述如下最大项：\n- `gl_MaxFragmentInputVectors`--片段着色器输入（或者可变值）的最大数量。所有ES 3.0实现支持的最小值为15。\n- `gl_MaxTextureImageUnits`--可用纹理图像单元的最大数量。所有ES 3.0实现支持的最小值为15。\n- `gl_MaxFragmentUniformVectors`--片段着色器内可以使用的vec4统一变量项目的最大数量。所有ES 3.0实现支持的最小值为224。开发者实际可以使用的vec4统一变量项目的数量在不同实现以及不同片段着色器中可能不一样。\n- `gl_MaxDrawBuffers`--多重渲染目标（MRT）的最大支持数量。所有ES 3.0实现支持的最小值为4。\n- `gl_MinProgramTexelOffset/gl_MaxProgramTexelOffset`--通过内建ESSL函数texture*Offset()偏移参数支持的最大和最小偏移量。\n每个内建常量所指定的值是所有OpenGL ES 3.0实现必须支持的最小值。不同的实现可能支持大于上述最小值的数值。片段着色器内建数值的实际硬件特定值可以从API代码中查询。下面的代码说明如何查询`gl_MaxTextureImageUnits`和`gl_MaxFragmentUniformVectors`的值。\n\n``` objc\nGLint maxTextureImageUnits, maxFragmentUniformVectors;\nglGetIntegerv(GL_MAX_TEXTURE_IMAGE_UNITS, &maxTextureImageUnits);\nglGetIntegerv(GL_MAX_FRAGMENT_UNIFORM_VECTORS, &maxFragmentUniformVectors);\n```\n\n# 用着色器实现固定功能技术\n\n我们已经对片段着色器进行了概述，现在将演示如何用着色器实现几种固定功能技术。OpenGL ES 1.x和桌面OpenGL中的固定功能管线提供API，可以执行多重纹理、雾化、Alpha测试和用户裁剪平面。尽管这些技术在OpenGL ES 3.0中都没有明确提供，但是都可以用着色器实现。\n\n## 多重纹理\n\n多重纹理，是片段着色器中非常常见的操作，用于组合多个纹理贴图。在顶点着色器中以不同的方式组合纹理很简单，就是采用着色语言中存在的许多运算符和内建函数。使用这些技术，能够轻松地实现OpenGL ES以前版本中的固定功能片段管线所能实现的效果。\n\n下面这个实力加载一个基本纹理贴图和照明贴图纹理：\n\n``` objc\n#version 300 es\nprecision mediump float;\nin vec2 v_texCoord;\nlayout(location = 0) out vec4 outColor;\nuniform sampler2D s_baseMap;\nunifomr sampler2D s_lightMap;\nvoid main()\n{\n    vec4 baseColor;\n    vec4 lightColor;\n    baseColor = texture(s_baseMap, v_texCoord);\n    lightColor = texture(s_lightMap, v_texCoord);\n    // Add a 0.25 ambient light to the texture light color\n    outColor = baseColor * (lightColor + 0.25);\n}\n```\n\n这个片段着色器有两个采样器，每个纹理使用一个。设置纹理单元和采样器的相关代码如下：\n\n``` objc\n// Bind the base map\nglActiveTexture(GL_TEXTURE0);\nglBindTexture(GL_TEXTURE_2D, baseMapTexId);\n// Set the base map sampler to texture unit 0\nglUniformli(baseMapLoc, 0);\n// Bind the light map\nglActiveTexture(GL_TEXTURE1);\nglBindTexture(GL_TEXTURE_2D, lightMapTexId);\n// Set the light map sampler to texture unit 1\nglUniform(lightMapLoc, 1);\n```\n\n可以看到，上述代码将各个纹理对象绑定到纹理单元0和1。为采样器设置数值，将采样器绑定到对应的纹理单元。在这个例子中，使用单一纹理坐标从两个贴图中读取。在典型的照明贴图处理中，基本贴图和照明贴图应该有一组单独的纹理坐标。照明贴图通常混合到单一的大型纹理中，纹理坐标可以使用离线工具生成。\n\n##  雾化\n\n> 待续\n\n## Alpha测试（使用Discard）\n\n3D应用程序中使用的常见特效之一是绘制某些片段中完全透明的图元，这对于渲染链状栅栏等物体很有用。用几何形状表现栅栏要求大量的图元，然而，在纹理中存储一个遮罩值指定哪些纹素应该是透明的是使用几何形状的另一种方法。例如，可以将链状栅栏保存在一个RGBA纹理中，其中RGB值表示栅栏的颜色，A值表示纹理是否透明的遮罩值。这样会很容易地用一个或者两个三角形并且在片段着色器中遮蔽像素来渲染一个栅栏。\n在传统的固定功能渲染中，这种特效用Alpha测试实现。Alpha测试允许你指定一个比较测试，如果片段的Alpha值和参考值的比较失败，该片段将被删除。也就是说，如果一个片段无法通过Alpha测试，该片段便不会被渲染。在OpenGL ES 3.0中没有固定功能Alpha测试，但是在片段着色器中可以使用`discard`关键字实现相同的效果。\n\n``` objc\n#version 300 es\nprecision mediump float;\nuniform sampler2D baseMap;\nin vec2 v_texCoord;\nlayout(location = 0) out vec4 outColor;\nvoid main()\n{\n    vec4 baseColor = texture(baseMap, v_texCoord);\n    // Discard all fragments with alpha value less than 0.25\n    if (baseColor.a < 0.25) {\n        discard;\n    } else {\n        outColor = baseColor;\n    }\n}\n```\n\n在这个片段着色器中，纹理是一个四通道的RGBA纹理。Alpha通道用于Alpha测试。Alpha颜色与0.25比较；如果小于该值，就用`discard`”杀死“片段。\n否则，用纹理颜色绘制片段。这种技术可以用于通过简单地改变对比或者Alpha参考值来实现Alpha测试。\n\n## 用户裁剪平面\n\n> 待续\n\n# 总结\n\n这篇文章介绍了使用片段着色器的多种渲染技术，聚焦于实现OpenGL ES 1.1固定功能部分技术的片段着色器。使用可编程片段着色器时，几乎可以实现无限的着色技术。","source":"_posts/2019/opengl-es-fragment-shader-0815.md","raw":"---\ntitle: \"OpenGL ES学习--片段着色器\"\ncatalog: true\ntoc_nav_num: true\ndate: 2019-08-15 17:20:32\nsubtitle: \"About OpenGL ES\"\nheader-img: \"/img/article_header/article_header.png\"\nbusuanzi: true\ntags:\n- iOS\n\n---\n\n> 介绍片段着色器编写方面的细节。\n\n# 固定功能片段着色器\n\n在研究片段着色器的细节之前，值得简单地回顾一下老式的固定功能片段管线，这将帮助我们理解老式的固定功能管线映射到片段着色器的方式。在转到更先进的片段编程技术之前，这是很好的起点。\n在OpenGL ES 1.1（以及固定功能桌面OpenGL）中，可以使用一组有限的方程式，确定如何组合片段着色器的不同输入。在固定功能管线中，实际上可以使用3中输入：插值顶点颜色、纹理颜色和常量颜色。顶点颜色通常保存一个预先计算的颜色或者顶点照明计算的结果。纹理颜色来自于使用图元纹理坐标绑定的纹理中读取的值，而常量颜色可以对每个纹理单元设置。\n用于组合这些输入的这一组方程式相当有限，例如，在OpenGL ES 1.1中，可用的方程式在下表中列出。方程式的输入A、B、C可能来自于顶点颜色、纹理颜色或者常量颜色。\n\nRGB组合函数 | 方程式\n- | -\nREPLACE | A\nMODULATE | AxB\nADD | A+B\nADD_SIGNED | A+B-0.5\nINTERPOLATE | AxC+Bx(1-C)\nSUBTRACT | A-B\nDOT3_RGB(and DOT3_RGBA) | 4x((A.r-0.5)x(B.r-0.5)+(A.g-0.5)x(B.g-0.5)+(A.b-0.5)x(B.b-0.5))\n\n即使利用这组有限的方程式，实际上也可以实现大量有趣的特效，但是，这比起可编程还有很大的距离，因为片段管线只能以非常固定的一组方式配置。\n为什么要回顾这段历史呢？因为它能帮助我们理解如何用着色器实现传统的固定功能技术。例如，假定我们已经用一个基本纹理贴图配置了固定功能管线，希望用顶点颜色调制该贴图。在固定功能OpenGL ES（或者OpenGL）中，我们将启用一个纹理单元，选择MODULATE的组合方程式，并且将方程式的输入设置为顶点颜色和纹理颜色。下面提供OpenGL ES 1.1实现以上功能的代码，作为参考：\n\n``` objc\nglTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_COMBINE);\nglTexEnvi(GL_TEXTURE_ENV, GL_COMBINE_RGB, GL_MODULATE);\nglTexEnvi(GL_TEXTURE_ENV, GL_SOURCE0_RGB, GL_PRIMARY_COLOR);\nglTexEnvi(GL_TEXTURE_ENV, GL_SOURCE1_RGB, GL_TEXTURE);\nglTexEnvi(GL_TEXTURE_ENV, GL_COMBINE_ALPHA, GL_MODULATE);\nglTexEnvi(GL_TEXTURE_ENV, GL_SOURCE0_ALPHA, GL_PRIMARY_COLOR);\nglTexEnvi(GL_TEXTURE_ENV, GL_SOURCE1_ALPHA, GL_TEXTURE);\n```\n\n这段代码配置固定功能管线，以执行主颜色（顶点颜色）和纹理颜色之间的调制（AxB）。这些代码在OpenGL ES 3.0中已经不存在了。我们只是试图说明这些功能如何映射到片段着色器。在片段着色器中，同样的调制计算可以用如下代码实现：\n\n``` objc\n#version 300 es\nprecision mediump float;\nuniform sampler2D s_tex0;\nin vec2 v_texCoord;\nin vec4 v_primaryColor;\nlayout(location = 0) out vec4 outColor;\nvoid main()\n{\n    outColor = texture(s_tex0, v_texCoord) * v_primaryColor;\n}\n```\n\n片段着色器执行的操作与固定功能设置执行的操作完全相同。纹理值从一个采样器（绑定到纹理单元0）读取，并用一个2D纹理坐标查找该值。然后，纹理读取的结果和顶点着色器传递的输入值`v_primaryColor`相乘。在这个例子中，顶点着色器已经将颜色传递给片段着色器。\n可以编写一个片段着色器，执行任何固定功能纹理组合设置的等价计算。当然，也可以编写着色器，执行比固定功能复杂得多的不同计算。\n\n# 片段着色器概述\n\n片段着色器为片段操作提供了通用功能的可编程方法。片段着色器的输入由如下部分组成：\n- 输入（或者可变值）--顶点着色器生成的插值数据。顶点着色器输出跨图元进行插值，并作为输入传递给片段着色器。\n- 统一变量--片段着色器使用的状态，这些常量值在每个片段上不会变化。\n- 采样器--用于访问着色器中的纹理图像。\n- 代码--片段着色器源代码或者二进制代码，描述在片段上执行的操作。\n片段着色器的输出时一个或者多个片段颜色，传递到管线的逐片段操作部分（输出颜色的数量取决于使用多少个颜色附着）。片段着色器的输入和输出如下图所示：\n\n![OpenGL ES 3.0片段着色器](/img/article/20190815/1.png)\n\n## 内建特殊变量\n\nOpenGL ES 3.0有内建特殊变量，这些变量由片段着色器输出或者作为片段着色器的输入。片段着色器中可用的内建特殊变量如下所示：\n- `gl_FragCoord`--片段着色器中的一个只读变量。这个变量保存片段的窗口相对坐标(x, y, z, 1/w)。在一些算法中，知道当前片段的窗口坐标是很有用的。例如，可以使用窗口坐标作为某个随机噪声贴图纹理读取的偏移量，噪声贴图的值用于旋转阴影贴图的过滤核心。这种技术用于减少阴影贴图的锯齿失真。\n- `gl_FrontFacing`--片段着色器中的一个只读变量。这个布尔变量在片段是正面图元的一部分时为true，否则为false。\n- `gl_PointCoord`--一个只读变量，可以在渲染点精灵时使用。它保存点精灵的纹理坐标，这个坐标在点光栅化期间自动生成，处于[0, 1]区间内。\n- `gl_FragDepth`--一个只写输出变量，在片段着色器中写入时，覆盖片段的固定功能深度值。这一功能应该谨慎使用（只在必要时），因为它可能禁用许多GPU的深度优化。例如，许多GPU有所谓的”Early-Z“功能，在执行片段着色器之前进行深度测试。使用Early-Z的好处是不能通过深度测试的片段永远不会被着色（从而保护了性能）。但是，使用`gl_FragDepth`时，必须禁用该功能，因为GPU在执行片段着色器之前不知道深度值。\n\n## 内建常量\n\n下面是与片段着色器有关的内建常量：\n\n``` objc\nconst mediump int gl_MaxFragmentInputVectors = 15;\nconst mediump int gl_MaxTextureImageUnits = 16;\nconst mediump int gl_MaxFragmentUniformVectors = 224;\nconst mediump int gl_MaxDrawBuffers = 4;\nconst mediump int gl_MinProgramTexelOffset = -8;\nconst mediump int gl_MaxProgramTexelOffset = 7;\n```\n\n内建常量的描述如下最大项：\n- `gl_MaxFragmentInputVectors`--片段着色器输入（或者可变值）的最大数量。所有ES 3.0实现支持的最小值为15。\n- `gl_MaxTextureImageUnits`--可用纹理图像单元的最大数量。所有ES 3.0实现支持的最小值为15。\n- `gl_MaxFragmentUniformVectors`--片段着色器内可以使用的vec4统一变量项目的最大数量。所有ES 3.0实现支持的最小值为224。开发者实际可以使用的vec4统一变量项目的数量在不同实现以及不同片段着色器中可能不一样。\n- `gl_MaxDrawBuffers`--多重渲染目标（MRT）的最大支持数量。所有ES 3.0实现支持的最小值为4。\n- `gl_MinProgramTexelOffset/gl_MaxProgramTexelOffset`--通过内建ESSL函数texture*Offset()偏移参数支持的最大和最小偏移量。\n每个内建常量所指定的值是所有OpenGL ES 3.0实现必须支持的最小值。不同的实现可能支持大于上述最小值的数值。片段着色器内建数值的实际硬件特定值可以从API代码中查询。下面的代码说明如何查询`gl_MaxTextureImageUnits`和`gl_MaxFragmentUniformVectors`的值。\n\n``` objc\nGLint maxTextureImageUnits, maxFragmentUniformVectors;\nglGetIntegerv(GL_MAX_TEXTURE_IMAGE_UNITS, &maxTextureImageUnits);\nglGetIntegerv(GL_MAX_FRAGMENT_UNIFORM_VECTORS, &maxFragmentUniformVectors);\n```\n\n# 用着色器实现固定功能技术\n\n我们已经对片段着色器进行了概述，现在将演示如何用着色器实现几种固定功能技术。OpenGL ES 1.x和桌面OpenGL中的固定功能管线提供API，可以执行多重纹理、雾化、Alpha测试和用户裁剪平面。尽管这些技术在OpenGL ES 3.0中都没有明确提供，但是都可以用着色器实现。\n\n## 多重纹理\n\n多重纹理，是片段着色器中非常常见的操作，用于组合多个纹理贴图。在顶点着色器中以不同的方式组合纹理很简单，就是采用着色语言中存在的许多运算符和内建函数。使用这些技术，能够轻松地实现OpenGL ES以前版本中的固定功能片段管线所能实现的效果。\n\n下面这个实力加载一个基本纹理贴图和照明贴图纹理：\n\n``` objc\n#version 300 es\nprecision mediump float;\nin vec2 v_texCoord;\nlayout(location = 0) out vec4 outColor;\nuniform sampler2D s_baseMap;\nunifomr sampler2D s_lightMap;\nvoid main()\n{\n    vec4 baseColor;\n    vec4 lightColor;\n    baseColor = texture(s_baseMap, v_texCoord);\n    lightColor = texture(s_lightMap, v_texCoord);\n    // Add a 0.25 ambient light to the texture light color\n    outColor = baseColor * (lightColor + 0.25);\n}\n```\n\n这个片段着色器有两个采样器，每个纹理使用一个。设置纹理单元和采样器的相关代码如下：\n\n``` objc\n// Bind the base map\nglActiveTexture(GL_TEXTURE0);\nglBindTexture(GL_TEXTURE_2D, baseMapTexId);\n// Set the base map sampler to texture unit 0\nglUniformli(baseMapLoc, 0);\n// Bind the light map\nglActiveTexture(GL_TEXTURE1);\nglBindTexture(GL_TEXTURE_2D, lightMapTexId);\n// Set the light map sampler to texture unit 1\nglUniform(lightMapLoc, 1);\n```\n\n可以看到，上述代码将各个纹理对象绑定到纹理单元0和1。为采样器设置数值，将采样器绑定到对应的纹理单元。在这个例子中，使用单一纹理坐标从两个贴图中读取。在典型的照明贴图处理中，基本贴图和照明贴图应该有一组单独的纹理坐标。照明贴图通常混合到单一的大型纹理中，纹理坐标可以使用离线工具生成。\n\n##  雾化\n\n> 待续\n\n## Alpha测试（使用Discard）\n\n3D应用程序中使用的常见特效之一是绘制某些片段中完全透明的图元，这对于渲染链状栅栏等物体很有用。用几何形状表现栅栏要求大量的图元，然而，在纹理中存储一个遮罩值指定哪些纹素应该是透明的是使用几何形状的另一种方法。例如，可以将链状栅栏保存在一个RGBA纹理中，其中RGB值表示栅栏的颜色，A值表示纹理是否透明的遮罩值。这样会很容易地用一个或者两个三角形并且在片段着色器中遮蔽像素来渲染一个栅栏。\n在传统的固定功能渲染中，这种特效用Alpha测试实现。Alpha测试允许你指定一个比较测试，如果片段的Alpha值和参考值的比较失败，该片段将被删除。也就是说，如果一个片段无法通过Alpha测试，该片段便不会被渲染。在OpenGL ES 3.0中没有固定功能Alpha测试，但是在片段着色器中可以使用`discard`关键字实现相同的效果。\n\n``` objc\n#version 300 es\nprecision mediump float;\nuniform sampler2D baseMap;\nin vec2 v_texCoord;\nlayout(location = 0) out vec4 outColor;\nvoid main()\n{\n    vec4 baseColor = texture(baseMap, v_texCoord);\n    // Discard all fragments with alpha value less than 0.25\n    if (baseColor.a < 0.25) {\n        discard;\n    } else {\n        outColor = baseColor;\n    }\n}\n```\n\n在这个片段着色器中，纹理是一个四通道的RGBA纹理。Alpha通道用于Alpha测试。Alpha颜色与0.25比较；如果小于该值，就用`discard`”杀死“片段。\n否则，用纹理颜色绘制片段。这种技术可以用于通过简单地改变对比或者Alpha参考值来实现Alpha测试。\n\n## 用户裁剪平面\n\n> 待续\n\n# 总结\n\n这篇文章介绍了使用片段着色器的多种渲染技术，聚焦于实现OpenGL ES 1.1固定功能部分技术的片段着色器。使用可编程片段着色器时，几乎可以实现无限的着色技术。","slug":"2019/opengl-es-fragment-shader-0815","published":1,"updated":"2022-01-10T09:04:52.805Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cky8gmc4a000ud1qhf0c1yfyb","content":"<blockquote>\n<p>介绍片段着色器编写方面的细节。</p>\n</blockquote>\n<h1 id=\"固定功能片段着色器\">固定功能片段着色器</h1>\n<p>在研究片段着色器的细节之前，值得简单地回顾一下老式的固定功能片段管线，这将帮助我们理解老式的固定功能管线映射到片段着色器的方式。在转到更先进的片段编程技术之前，这是很好的起点。<br>\n在OpenGL ES 1.1（以及固定功能桌面OpenGL）中，可以使用一组有限的方程式，确定如何组合片段着色器的不同输入。在固定功能管线中，实际上可以使用3中输入：插值顶点颜色、纹理颜色和常量颜色。顶点颜色通常保存一个预先计算的颜色或者顶点照明计算的结果。纹理颜色来自于使用图元纹理坐标绑定的纹理中读取的值，而常量颜色可以对每个纹理单元设置。<br>\n用于组合这些输入的这一组方程式相当有限，例如，在OpenGL ES 1.1中，可用的方程式在下表中列出。方程式的输入A、B、C可能来自于顶点颜色、纹理颜色或者常量颜色。</p>\n<table>\n<thead>\n<tr>\n<th>RGB组合函数</th>\n<th>方程式</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>REPLACE</td>\n<td>A</td>\n</tr>\n<tr>\n<td>MODULATE</td>\n<td>AxB</td>\n</tr>\n<tr>\n<td>ADD</td>\n<td>A+B</td>\n</tr>\n<tr>\n<td>ADD_SIGNED</td>\n<td>A+B-0.5</td>\n</tr>\n<tr>\n<td>INTERPOLATE</td>\n<td>AxC+Bx(1-C)</td>\n</tr>\n<tr>\n<td>SUBTRACT</td>\n<td>A-B</td>\n</tr>\n<tr>\n<td>DOT3_RGB(and DOT3_RGBA)</td>\n<td>4x((A.r-0.5)x(B.r-0.5)+(A.g-0.5)x(B.g-0.5)+(A.b-0.5)x(B.b-0.5))</td>\n</tr>\n</tbody>\n</table>\n<p>即使利用这组有限的方程式，实际上也可以实现大量有趣的特效，但是，这比起可编程还有很大的距离，因为片段管线只能以非常固定的一组方式配置。<br>\n为什么要回顾这段历史呢？因为它能帮助我们理解如何用着色器实现传统的固定功能技术。例如，假定我们已经用一个基本纹理贴图配置了固定功能管线，希望用顶点颜色调制该贴图。在固定功能OpenGL ES（或者OpenGL）中，我们将启用一个纹理单元，选择MODULATE的组合方程式，并且将方程式的输入设置为顶点颜色和纹理颜色。下面提供OpenGL ES 1.1实现以上功能的代码，作为参考：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_COMBINE);</span><br><span class=\"line\">glTexEnvi(GL_TEXTURE_ENV, GL_COMBINE_RGB, GL_MODULATE);</span><br><span class=\"line\">glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE0_RGB, GL_PRIMARY_COLOR);</span><br><span class=\"line\">glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE1_RGB, GL_TEXTURE);</span><br><span class=\"line\">glTexEnvi(GL_TEXTURE_ENV, GL_COMBINE_ALPHA, GL_MODULATE);</span><br><span class=\"line\">glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE0_ALPHA, GL_PRIMARY_COLOR);</span><br><span class=\"line\">glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE1_ALPHA, GL_TEXTURE);</span><br></pre></td></tr></table></figure>\n<p>这段代码配置固定功能管线，以执行主颜色（顶点颜色）和纹理颜色之间的调制（AxB）。这些代码在OpenGL ES 3.0中已经不存在了。我们只是试图说明这些功能如何映射到片段着色器。在片段着色器中，同样的调制计算可以用如下代码实现：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#version 300 es</span></span><br><span class=\"line\">precision mediump <span class=\"keyword\">float</span>;</span><br><span class=\"line\">uniform sampler2D s_tex0;</span><br><span class=\"line\"><span class=\"keyword\">in</span> vec2 v_texCoord;</span><br><span class=\"line\"><span class=\"keyword\">in</span> vec4 v_primaryColor;</span><br><span class=\"line\">layout(location = <span class=\"number\">0</span>) <span class=\"keyword\">out</span> vec4 outColor;</span><br><span class=\"line\"><span class=\"keyword\">void</span> main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    outColor = texture(s_tex0, v_texCoord) * v_primaryColor;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>片段着色器执行的操作与固定功能设置执行的操作完全相同。纹理值从一个采样器（绑定到纹理单元0）读取，并用一个2D纹理坐标查找该值。然后，纹理读取的结果和顶点着色器传递的输入值<code>v_primaryColor</code>相乘。在这个例子中，顶点着色器已经将颜色传递给片段着色器。<br>\n可以编写一个片段着色器，执行任何固定功能纹理组合设置的等价计算。当然，也可以编写着色器，执行比固定功能复杂得多的不同计算。</p>\n<h1 id=\"片段着色器概述\">片段着色器概述</h1>\n<p>片段着色器为片段操作提供了通用功能的可编程方法。片段着色器的输入由如下部分组成：</p>\n<ul>\n<li>输入（或者可变值）–顶点着色器生成的插值数据。顶点着色器输出跨图元进行插值，并作为输入传递给片段着色器。</li>\n<li>统一变量–片段着色器使用的状态，这些常量值在每个片段上不会变化。</li>\n<li>采样器–用于访问着色器中的纹理图像。</li>\n<li>代码–片段着色器源代码或者二进制代码，描述在片段上执行的操作。<br>\n片段着色器的输出时一个或者多个片段颜色，传递到管线的逐片段操作部分（输出颜色的数量取决于使用多少个颜色附着）。片段着色器的输入和输出如下图所示：</li>\n</ul>\n<p><img src=\"/img/article/20190815/1.png\" alt=\"OpenGL ES 3.0片段着色器\"></p>\n<h2 id=\"内建特殊变量\">内建特殊变量</h2>\n<p>OpenGL ES 3.0有内建特殊变量，这些变量由片段着色器输出或者作为片段着色器的输入。片段着色器中可用的内建特殊变量如下所示：</p>\n<ul>\n<li><code>gl_FragCoord</code>–片段着色器中的一个只读变量。这个变量保存片段的窗口相对坐标(x, y, z, 1/w)。在一些算法中，知道当前片段的窗口坐标是很有用的。例如，可以使用窗口坐标作为某个随机噪声贴图纹理读取的偏移量，噪声贴图的值用于旋转阴影贴图的过滤核心。这种技术用于减少阴影贴图的锯齿失真。</li>\n<li><code>gl_FrontFacing</code>–片段着色器中的一个只读变量。这个布尔变量在片段是正面图元的一部分时为true，否则为false。</li>\n<li><code>gl_PointCoord</code>–一个只读变量，可以在渲染点精灵时使用。它保存点精灵的纹理坐标，这个坐标在点光栅化期间自动生成，处于[0, 1]区间内。</li>\n<li><code>gl_FragDepth</code>–一个只写输出变量，在片段着色器中写入时，覆盖片段的固定功能深度值。这一功能应该谨慎使用（只在必要时），因为它可能禁用许多GPU的深度优化。例如，许多GPU有所谓的”Early-Z“功能，在执行片段着色器之前进行深度测试。使用Early-Z的好处是不能通过深度测试的片段永远不会被着色（从而保护了性能）。但是，使用<code>gl_FragDepth</code>时，必须禁用该功能，因为GPU在执行片段着色器之前不知道深度值。</li>\n</ul>\n<h2 id=\"内建常量\">内建常量</h2>\n<p>下面是与片段着色器有关的内建常量：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> mediump <span class=\"keyword\">int</span> gl_MaxFragmentInputVectors = <span class=\"number\">15</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> mediump <span class=\"keyword\">int</span> gl_MaxTextureImageUnits = <span class=\"number\">16</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> mediump <span class=\"keyword\">int</span> gl_MaxFragmentUniformVectors = <span class=\"number\">224</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> mediump <span class=\"keyword\">int</span> gl_MaxDrawBuffers = <span class=\"number\">4</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> mediump <span class=\"keyword\">int</span> gl_MinProgramTexelOffset = <span class=\"number\">-8</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> mediump <span class=\"keyword\">int</span> gl_MaxProgramTexelOffset = <span class=\"number\">7</span>;</span><br></pre></td></tr></table></figure>\n<p>内建常量的描述如下最大项：</p>\n<ul>\n<li><code>gl_MaxFragmentInputVectors</code>–片段着色器输入（或者可变值）的最大数量。所有ES 3.0实现支持的最小值为15。</li>\n<li><code>gl_MaxTextureImageUnits</code>–可用纹理图像单元的最大数量。所有ES 3.0实现支持的最小值为15。</li>\n<li><code>gl_MaxFragmentUniformVectors</code>–片段着色器内可以使用的vec4统一变量项目的最大数量。所有ES 3.0实现支持的最小值为224。开发者实际可以使用的vec4统一变量项目的数量在不同实现以及不同片段着色器中可能不一样。</li>\n<li><code>gl_MaxDrawBuffers</code>–多重渲染目标（MRT）的最大支持数量。所有ES 3.0实现支持的最小值为4。</li>\n<li><code>gl_MinProgramTexelOffset/gl_MaxProgramTexelOffset</code>–通过内建ESSL函数texture*Offset()偏移参数支持的最大和最小偏移量。<br>\n每个内建常量所指定的值是所有OpenGL ES 3.0实现必须支持的最小值。不同的实现可能支持大于上述最小值的数值。片段着色器内建数值的实际硬件特定值可以从API代码中查询。下面的代码说明如何查询<code>gl_MaxTextureImageUnits</code>和<code>gl_MaxFragmentUniformVectors</code>的值。</li>\n</ul>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GLint maxTextureImageUnits, maxFragmentUniformVectors;</span><br><span class=\"line\">glGetIntegerv(GL_MAX_TEXTURE_IMAGE_UNITS, &amp;maxTextureImageUnits);</span><br><span class=\"line\">glGetIntegerv(GL_MAX_FRAGMENT_UNIFORM_VECTORS, &amp;maxFragmentUniformVectors);</span><br></pre></td></tr></table></figure>\n<h1 id=\"用着色器实现固定功能技术\">用着色器实现固定功能技术</h1>\n<p>我们已经对片段着色器进行了概述，现在将演示如何用着色器实现几种固定功能技术。OpenGL ES 1.x和桌面OpenGL中的固定功能管线提供API，可以执行多重纹理、雾化、Alpha测试和用户裁剪平面。尽管这些技术在OpenGL ES 3.0中都没有明确提供，但是都可以用着色器实现。</p>\n<h2 id=\"多重纹理\">多重纹理</h2>\n<p>多重纹理，是片段着色器中非常常见的操作，用于组合多个纹理贴图。在顶点着色器中以不同的方式组合纹理很简单，就是采用着色语言中存在的许多运算符和内建函数。使用这些技术，能够轻松地实现OpenGL ES以前版本中的固定功能片段管线所能实现的效果。</p>\n<p>下面这个实力加载一个基本纹理贴图和照明贴图纹理：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#version 300 es</span></span><br><span class=\"line\">precision mediump <span class=\"keyword\">float</span>;</span><br><span class=\"line\"><span class=\"keyword\">in</span> vec2 v_texCoord;</span><br><span class=\"line\">layout(location = <span class=\"number\">0</span>) <span class=\"keyword\">out</span> vec4 outColor;</span><br><span class=\"line\">uniform sampler2D s_baseMap;</span><br><span class=\"line\">unifomr sampler2D s_lightMap;</span><br><span class=\"line\"><span class=\"keyword\">void</span> main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    vec4 baseColor;</span><br><span class=\"line\">    vec4 lightColor;</span><br><span class=\"line\">    baseColor = texture(s_baseMap, v_texCoord);</span><br><span class=\"line\">    lightColor = texture(s_lightMap, v_texCoord);</span><br><span class=\"line\">    <span class=\"comment\">// Add a 0.25 ambient light to the texture light color</span></span><br><span class=\"line\">    outColor = baseColor * (lightColor + <span class=\"number\">0.25</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个片段着色器有两个采样器，每个纹理使用一个。设置纹理单元和采样器的相关代码如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Bind the base map</span></span><br><span class=\"line\">glActiveTexture(GL_TEXTURE0);</span><br><span class=\"line\">glBindTexture(GL_TEXTURE_2D, baseMapTexId);</span><br><span class=\"line\"><span class=\"comment\">// Set the base map sampler to texture unit 0</span></span><br><span class=\"line\">glUniformli(baseMapLoc, <span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"comment\">// Bind the light map</span></span><br><span class=\"line\">glActiveTexture(GL_TEXTURE1);</span><br><span class=\"line\">glBindTexture(GL_TEXTURE_2D, lightMapTexId);</span><br><span class=\"line\"><span class=\"comment\">// Set the light map sampler to texture unit 1</span></span><br><span class=\"line\">glUniform(lightMapLoc, <span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure>\n<p>可以看到，上述代码将各个纹理对象绑定到纹理单元0和1。为采样器设置数值，将采样器绑定到对应的纹理单元。在这个例子中，使用单一纹理坐标从两个贴图中读取。在典型的照明贴图处理中，基本贴图和照明贴图应该有一组单独的纹理坐标。照明贴图通常混合到单一的大型纹理中，纹理坐标可以使用离线工具生成。</p>\n<h2 id=\"雾化\">雾化</h2>\n<blockquote>\n<p>待续</p>\n</blockquote>\n<h2 id=\"alpha测试使用discard\">Alpha测试（使用Discard）</h2>\n<p>3D应用程序中使用的常见特效之一是绘制某些片段中完全透明的图元，这对于渲染链状栅栏等物体很有用。用几何形状表现栅栏要求大量的图元，然而，在纹理中存储一个遮罩值指定哪些纹素应该是透明的是使用几何形状的另一种方法。例如，可以将链状栅栏保存在一个RGBA纹理中，其中RGB值表示栅栏的颜色，A值表示纹理是否透明的遮罩值。这样会很容易地用一个或者两个三角形并且在片段着色器中遮蔽像素来渲染一个栅栏。<br>\n在传统的固定功能渲染中，这种特效用Alpha测试实现。Alpha测试允许你指定一个比较测试，如果片段的Alpha值和参考值的比较失败，该片段将被删除。也就是说，如果一个片段无法通过Alpha测试，该片段便不会被渲染。在OpenGL ES 3.0中没有固定功能Alpha测试，但是在片段着色器中可以使用<code>discard</code>关键字实现相同的效果。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#version 300 es</span></span><br><span class=\"line\">precision mediump <span class=\"keyword\">float</span>;</span><br><span class=\"line\">uniform sampler2D baseMap;</span><br><span class=\"line\"><span class=\"keyword\">in</span> vec2 v_texCoord;</span><br><span class=\"line\">layout(location = <span class=\"number\">0</span>) <span class=\"keyword\">out</span> vec4 outColor;</span><br><span class=\"line\"><span class=\"keyword\">void</span> main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    vec4 baseColor = texture(baseMap, v_texCoord);</span><br><span class=\"line\">    <span class=\"comment\">// Discard all fragments with alpha value less than 0.25</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (baseColor.a &lt; <span class=\"number\">0.25</span>) &#123;</span><br><span class=\"line\">        discard;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        outColor = baseColor;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这个片段着色器中，纹理是一个四通道的RGBA纹理。Alpha通道用于Alpha测试。Alpha颜色与0.25比较；如果小于该值，就用<code>discard</code>”杀死“片段。<br>\n否则，用纹理颜色绘制片段。这种技术可以用于通过简单地改变对比或者Alpha参考值来实现Alpha测试。</p>\n<h2 id=\"用户裁剪平面\">用户裁剪平面</h2>\n<blockquote>\n<p>待续</p>\n</blockquote>\n<h1 id=\"总结\">总结</h1>\n<p>这篇文章介绍了使用片段着色器的多种渲染技术，聚焦于实现OpenGL ES 1.1固定功能部分技术的片段着色器。使用可编程片段着色器时，几乎可以实现无限的着色技术。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>介绍片段着色器编写方面的细节。</p>\n</blockquote>\n<h1>固定功能片段着色器</h1>\n<p>在研究片段着色器的细节之前，值得简单地回顾一下老式的固定功能片段管线，这将帮助我们理解老式的固定功能管线映射到片段着色器的方式。在转到更先进的片段编程技术之前，这是很好的起点。<br>\n在OpenGL ES 1.1（以及固定功能桌面OpenGL）中，可以使用一组有限的方程式，确定如何组合片段着色器的不同输入。在固定功能管线中，实际上可以使用3中输入：插值顶点颜色、纹理颜色和常量颜色。顶点颜色通常保存一个预先计算的颜色或者顶点照明计算的结果。纹理颜色来自于使用图元纹理坐标绑定的纹理中读取的值，而常量颜色可以对每个纹理单元设置。<br>\n用于组合这些输入的这一组方程式相当有限，例如，在OpenGL ES 1.1中，可用的方程式在下表中列出。方程式的输入A、B、C可能来自于顶点颜色、纹理颜色或者常量颜色。</p>\n<table>\n<thead>\n<tr>\n<th>RGB组合函数</th>\n<th>方程式</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>REPLACE</td>\n<td>A</td>\n</tr>\n<tr>\n<td>MODULATE</td>\n<td>AxB</td>\n</tr>\n<tr>\n<td>ADD</td>\n<td>A+B</td>\n</tr>\n<tr>\n<td>ADD_SIGNED</td>\n<td>A+B-0.5</td>\n</tr>\n<tr>\n<td>INTERPOLATE</td>\n<td>AxC+Bx(1-C)</td>\n</tr>\n<tr>\n<td>SUBTRACT</td>\n<td>A-B</td>\n</tr>\n<tr>\n<td>DOT3_RGB(and DOT3_RGBA)</td>\n<td>4x((A.r-0.5)x(B.r-0.5)+(A.g-0.5)x(B.g-0.5)+(A.b-0.5)x(B.b-0.5))</td>\n</tr>\n</tbody>\n</table>\n<p>即使利用这组有限的方程式，实际上也可以实现大量有趣的特效，但是，这比起可编程还有很大的距离，因为片段管线只能以非常固定的一组方式配置。<br>\n为什么要回顾这段历史呢？因为它能帮助我们理解如何用着色器实现传统的固定功能技术。例如，假定我们已经用一个基本纹理贴图配置了固定功能管线，希望用顶点颜色调制该贴图。在固定功能OpenGL ES（或者OpenGL）中，我们将启用一个纹理单元，选择MODULATE的组合方程式，并且将方程式的输入设置为顶点颜色和纹理颜色。下面提供OpenGL ES 1.1实现以上功能的代码，作为参考：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_COMBINE);</span><br><span class=\"line\">glTexEnvi(GL_TEXTURE_ENV, GL_COMBINE_RGB, GL_MODULATE);</span><br><span class=\"line\">glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE0_RGB, GL_PRIMARY_COLOR);</span><br><span class=\"line\">glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE1_RGB, GL_TEXTURE);</span><br><span class=\"line\">glTexEnvi(GL_TEXTURE_ENV, GL_COMBINE_ALPHA, GL_MODULATE);</span><br><span class=\"line\">glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE0_ALPHA, GL_PRIMARY_COLOR);</span><br><span class=\"line\">glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE1_ALPHA, GL_TEXTURE);</span><br></pre></td></tr></table></figure>\n<p>这段代码配置固定功能管线，以执行主颜色（顶点颜色）和纹理颜色之间的调制（AxB）。这些代码在OpenGL ES 3.0中已经不存在了。我们只是试图说明这些功能如何映射到片段着色器。在片段着色器中，同样的调制计算可以用如下代码实现：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#version 300 es</span></span><br><span class=\"line\">precision mediump <span class=\"keyword\">float</span>;</span><br><span class=\"line\">uniform sampler2D s_tex0;</span><br><span class=\"line\"><span class=\"keyword\">in</span> vec2 v_texCoord;</span><br><span class=\"line\"><span class=\"keyword\">in</span> vec4 v_primaryColor;</span><br><span class=\"line\">layout(location = <span class=\"number\">0</span>) <span class=\"keyword\">out</span> vec4 outColor;</span><br><span class=\"line\"><span class=\"keyword\">void</span> main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    outColor = texture(s_tex0, v_texCoord) * v_primaryColor;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>片段着色器执行的操作与固定功能设置执行的操作完全相同。纹理值从一个采样器（绑定到纹理单元0）读取，并用一个2D纹理坐标查找该值。然后，纹理读取的结果和顶点着色器传递的输入值<code>v_primaryColor</code>相乘。在这个例子中，顶点着色器已经将颜色传递给片段着色器。<br>\n可以编写一个片段着色器，执行任何固定功能纹理组合设置的等价计算。当然，也可以编写着色器，执行比固定功能复杂得多的不同计算。</p>\n<h1>片段着色器概述</h1>\n<p>片段着色器为片段操作提供了通用功能的可编程方法。片段着色器的输入由如下部分组成：</p>\n<ul>\n<li>输入（或者可变值）–顶点着色器生成的插值数据。顶点着色器输出跨图元进行插值，并作为输入传递给片段着色器。</li>\n<li>统一变量–片段着色器使用的状态，这些常量值在每个片段上不会变化。</li>\n<li>采样器–用于访问着色器中的纹理图像。</li>\n<li>代码–片段着色器源代码或者二进制代码，描述在片段上执行的操作。<br>\n片段着色器的输出时一个或者多个片段颜色，传递到管线的逐片段操作部分（输出颜色的数量取决于使用多少个颜色附着）。片段着色器的输入和输出如下图所示：</li>\n</ul>\n<p><img src=\"/img/article/20190815/1.png\" alt=\"OpenGL ES 3.0片段着色器\"></p>\n<h2>内建特殊变量</h2>\n<p>OpenGL ES 3.0有内建特殊变量，这些变量由片段着色器输出或者作为片段着色器的输入。片段着色器中可用的内建特殊变量如下所示：</p>\n<ul>\n<li><code>gl_FragCoord</code>–片段着色器中的一个只读变量。这个变量保存片段的窗口相对坐标(x, y, z, 1/w)。在一些算法中，知道当前片段的窗口坐标是很有用的。例如，可以使用窗口坐标作为某个随机噪声贴图纹理读取的偏移量，噪声贴图的值用于旋转阴影贴图的过滤核心。这种技术用于减少阴影贴图的锯齿失真。</li>\n<li><code>gl_FrontFacing</code>–片段着色器中的一个只读变量。这个布尔变量在片段是正面图元的一部分时为true，否则为false。</li>\n<li><code>gl_PointCoord</code>–一个只读变量，可以在渲染点精灵时使用。它保存点精灵的纹理坐标，这个坐标在点光栅化期间自动生成，处于[0, 1]区间内。</li>\n<li><code>gl_FragDepth</code>–一个只写输出变量，在片段着色器中写入时，覆盖片段的固定功能深度值。这一功能应该谨慎使用（只在必要时），因为它可能禁用许多GPU的深度优化。例如，许多GPU有所谓的”Early-Z“功能，在执行片段着色器之前进行深度测试。使用Early-Z的好处是不能通过深度测试的片段永远不会被着色（从而保护了性能）。但是，使用<code>gl_FragDepth</code>时，必须禁用该功能，因为GPU在执行片段着色器之前不知道深度值。</li>\n</ul>\n<h2>内建常量</h2>\n<p>下面是与片段着色器有关的内建常量：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> mediump <span class=\"keyword\">int</span> gl_MaxFragmentInputVectors = <span class=\"number\">15</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> mediump <span class=\"keyword\">int</span> gl_MaxTextureImageUnits = <span class=\"number\">16</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> mediump <span class=\"keyword\">int</span> gl_MaxFragmentUniformVectors = <span class=\"number\">224</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> mediump <span class=\"keyword\">int</span> gl_MaxDrawBuffers = <span class=\"number\">4</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> mediump <span class=\"keyword\">int</span> gl_MinProgramTexelOffset = <span class=\"number\">-8</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> mediump <span class=\"keyword\">int</span> gl_MaxProgramTexelOffset = <span class=\"number\">7</span>;</span><br></pre></td></tr></table></figure>\n<p>内建常量的描述如下最大项：</p>\n<ul>\n<li><code>gl_MaxFragmentInputVectors</code>–片段着色器输入（或者可变值）的最大数量。所有ES 3.0实现支持的最小值为15。</li>\n<li><code>gl_MaxTextureImageUnits</code>–可用纹理图像单元的最大数量。所有ES 3.0实现支持的最小值为15。</li>\n<li><code>gl_MaxFragmentUniformVectors</code>–片段着色器内可以使用的vec4统一变量项目的最大数量。所有ES 3.0实现支持的最小值为224。开发者实际可以使用的vec4统一变量项目的数量在不同实现以及不同片段着色器中可能不一样。</li>\n<li><code>gl_MaxDrawBuffers</code>–多重渲染目标（MRT）的最大支持数量。所有ES 3.0实现支持的最小值为4。</li>\n<li><code>gl_MinProgramTexelOffset/gl_MaxProgramTexelOffset</code>–通过内建ESSL函数texture*Offset()偏移参数支持的最大和最小偏移量。<br>\n每个内建常量所指定的值是所有OpenGL ES 3.0实现必须支持的最小值。不同的实现可能支持大于上述最小值的数值。片段着色器内建数值的实际硬件特定值可以从API代码中查询。下面的代码说明如何查询<code>gl_MaxTextureImageUnits</code>和<code>gl_MaxFragmentUniformVectors</code>的值。</li>\n</ul>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GLint maxTextureImageUnits, maxFragmentUniformVectors;</span><br><span class=\"line\">glGetIntegerv(GL_MAX_TEXTURE_IMAGE_UNITS, &amp;maxTextureImageUnits);</span><br><span class=\"line\">glGetIntegerv(GL_MAX_FRAGMENT_UNIFORM_VECTORS, &amp;maxFragmentUniformVectors);</span><br></pre></td></tr></table></figure>\n<h1>用着色器实现固定功能技术</h1>\n<p>我们已经对片段着色器进行了概述，现在将演示如何用着色器实现几种固定功能技术。OpenGL ES 1.x和桌面OpenGL中的固定功能管线提供API，可以执行多重纹理、雾化、Alpha测试和用户裁剪平面。尽管这些技术在OpenGL ES 3.0中都没有明确提供，但是都可以用着色器实现。</p>\n<h2>多重纹理</h2>\n<p>多重纹理，是片段着色器中非常常见的操作，用于组合多个纹理贴图。在顶点着色器中以不同的方式组合纹理很简单，就是采用着色语言中存在的许多运算符和内建函数。使用这些技术，能够轻松地实现OpenGL ES以前版本中的固定功能片段管线所能实现的效果。</p>\n<p>下面这个实力加载一个基本纹理贴图和照明贴图纹理：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#version 300 es</span></span><br><span class=\"line\">precision mediump <span class=\"keyword\">float</span>;</span><br><span class=\"line\"><span class=\"keyword\">in</span> vec2 v_texCoord;</span><br><span class=\"line\">layout(location = <span class=\"number\">0</span>) <span class=\"keyword\">out</span> vec4 outColor;</span><br><span class=\"line\">uniform sampler2D s_baseMap;</span><br><span class=\"line\">unifomr sampler2D s_lightMap;</span><br><span class=\"line\"><span class=\"keyword\">void</span> main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    vec4 baseColor;</span><br><span class=\"line\">    vec4 lightColor;</span><br><span class=\"line\">    baseColor = texture(s_baseMap, v_texCoord);</span><br><span class=\"line\">    lightColor = texture(s_lightMap, v_texCoord);</span><br><span class=\"line\">    <span class=\"comment\">// Add a 0.25 ambient light to the texture light color</span></span><br><span class=\"line\">    outColor = baseColor * (lightColor + <span class=\"number\">0.25</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个片段着色器有两个采样器，每个纹理使用一个。设置纹理单元和采样器的相关代码如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Bind the base map</span></span><br><span class=\"line\">glActiveTexture(GL_TEXTURE0);</span><br><span class=\"line\">glBindTexture(GL_TEXTURE_2D, baseMapTexId);</span><br><span class=\"line\"><span class=\"comment\">// Set the base map sampler to texture unit 0</span></span><br><span class=\"line\">glUniformli(baseMapLoc, <span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"comment\">// Bind the light map</span></span><br><span class=\"line\">glActiveTexture(GL_TEXTURE1);</span><br><span class=\"line\">glBindTexture(GL_TEXTURE_2D, lightMapTexId);</span><br><span class=\"line\"><span class=\"comment\">// Set the light map sampler to texture unit 1</span></span><br><span class=\"line\">glUniform(lightMapLoc, <span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure>\n<p>可以看到，上述代码将各个纹理对象绑定到纹理单元0和1。为采样器设置数值，将采样器绑定到对应的纹理单元。在这个例子中，使用单一纹理坐标从两个贴图中读取。在典型的照明贴图处理中，基本贴图和照明贴图应该有一组单独的纹理坐标。照明贴图通常混合到单一的大型纹理中，纹理坐标可以使用离线工具生成。</p>\n<h2>雾化</h2>\n<blockquote>\n<p>待续</p>\n</blockquote>\n<h2>Alpha测试（使用Discard）</h2>\n<p>3D应用程序中使用的常见特效之一是绘制某些片段中完全透明的图元，这对于渲染链状栅栏等物体很有用。用几何形状表现栅栏要求大量的图元，然而，在纹理中存储一个遮罩值指定哪些纹素应该是透明的是使用几何形状的另一种方法。例如，可以将链状栅栏保存在一个RGBA纹理中，其中RGB值表示栅栏的颜色，A值表示纹理是否透明的遮罩值。这样会很容易地用一个或者两个三角形并且在片段着色器中遮蔽像素来渲染一个栅栏。<br>\n在传统的固定功能渲染中，这种特效用Alpha测试实现。Alpha测试允许你指定一个比较测试，如果片段的Alpha值和参考值的比较失败，该片段将被删除。也就是说，如果一个片段无法通过Alpha测试，该片段便不会被渲染。在OpenGL ES 3.0中没有固定功能Alpha测试，但是在片段着色器中可以使用<code>discard</code>关键字实现相同的效果。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#version 300 es</span></span><br><span class=\"line\">precision mediump <span class=\"keyword\">float</span>;</span><br><span class=\"line\">uniform sampler2D baseMap;</span><br><span class=\"line\"><span class=\"keyword\">in</span> vec2 v_texCoord;</span><br><span class=\"line\">layout(location = <span class=\"number\">0</span>) <span class=\"keyword\">out</span> vec4 outColor;</span><br><span class=\"line\"><span class=\"keyword\">void</span> main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    vec4 baseColor = texture(baseMap, v_texCoord);</span><br><span class=\"line\">    <span class=\"comment\">// Discard all fragments with alpha value less than 0.25</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (baseColor.a &lt; <span class=\"number\">0.25</span>) &#123;</span><br><span class=\"line\">        discard;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        outColor = baseColor;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这个片段着色器中，纹理是一个四通道的RGBA纹理。Alpha通道用于Alpha测试。Alpha颜色与0.25比较；如果小于该值，就用<code>discard</code>”杀死“片段。<br>\n否则，用纹理颜色绘制片段。这种技术可以用于通过简单地改变对比或者Alpha参考值来实现Alpha测试。</p>\n<h2>用户裁剪平面</h2>\n<blockquote>\n<p>待续</p>\n</blockquote>\n<h1>总结</h1>\n<p>这篇文章介绍了使用片段着色器的多种渲染技术，聚焦于实现OpenGL ES 1.1固定功能部分技术的片段着色器。使用可编程片段着色器时，几乎可以实现无限的着色技术。</p>\n"},{"title":"OpenGL ES学习--着色语言","catalog":true,"toc_nav_num":true,"date":"2019-07-15T11:09:32.000Z","subtitle":"About OpenGL ES","header-img":"/img/article_header/article_header.png","busuanzi":true,"_content":"\n> 着色器是OpenGL ES 3.0 API的一个基础核心概念，每个OpenGL ES 3.0程序都需要一个顶点着色器和一个片段着色器，以渲染有意义的图片。所以下面介绍开发着色器的着色语言-GLSL。\n\n# 着色器版本规范\n\nOpenGL ES 3.0顶点着色器和片段着色器的第一行总是声明着色器的版本。在之前的代码中，我是采用如下语法说明着色器使用OpenGL ES着色语言的版本3.0：\n``` objc\n#version 300 es\n```\n没有声明版本号的着色器被认定使用OpenGL ES着色语言1.00版本。着色语言1.00版本用于OpenGL ES 2.0。对于OpenGL ES 3.0，规范的作者决定匹配API和着色语言的版本号，所以版本号直接从1.00跳到3.00的原因。\n\n# 变量和变量类型\n\n在计算机图形中，两个基本数据组成了变换的基础：向量和矩阵。这两种数据类型也是OpenGL ES着色语言中的核心。\n\n变量分类 | 类型 | 描述\n-|-|-\n标量 | float, int, uint, bool | 用于浮点、整数、无符号整数和布尔值的基于标量的数据类型\n浮点向量 | float, vec2, vec3, vec4 | 有1、2、3、4个分量的基于浮点的向量类型\n整数向量 | int, ivec2, ivec3, ivec4 | 有1、2、3、4个分量的基于整数的向量类型\n无符号整数向量 | uint, uvec2, uvec3, uvec4 | 有1、2、3、4个分量的基于无符号整数的向量类型\n布尔向量 | bool, bvec2, bvec3, bvec4 | 有1、2、3、4个分量的基于布尔的向量类型\n矩阵 | mat2, mat3, mat4, max2x3, max3x2 | 2x2, 3x3, 4x4, 2x3, 3x2的基于浮点的矩阵\n\n着色语言中的变量必须以某个类型声明。变量可以在声明时或者声明以后初始化。初始化通过使用构造器进行，构造器也用于类型转换。\n\n# 变量构造器\n\nOpenGL ES 着色语言在类型转换方面有非常严格的规定。变量只能赋值为相同类型的其他变量或者与相同类型的变量进行运算。\n标量：\n``` objc\nfloat myFloat = 1.0;\nbool myBool = true; \n\nmyFloat = Float(myBool);    // bool -> float\nmyBool = bool(myFloat);     // float -> bool\n```\n\n向量：\n``` objc\nvec4 myVec4 = vec4(1.0);        // myVec4 = {1.0, 1.0, 1.0, 1.0}\nvec3 myVec3 = vec3(1.0, 0.0, 0.5);\n\nvec3 temp = vec3(myVec3);\nvec2 myVec2 = vec2(myVec3);     // myVec2 = {myVec3.x, myVec3.y}\n\nmyVec4 = vec4(myVec2, temp);   myVec4 = {myVec2.v, myVec2.y, temp.x, temp.y}\n```\n\n矩阵：\n``` objc\n// 矩阵以列优先顺序存储\nmat3 myMat3 = mat3(1.0, 2.0, 3.0,\n                   4.0, 5.0, 6.0,\n                   7.0, 8.0, 9.0)\n// 生成的矩阵是：\n[1.0 4.0 7.0\n 2.0 5.0 8.0\n 3.0 6.0 9.0]\n```\n\n# 向量和矩阵分量\n\n向量的单独分量可以用两种方式访问：使用“.”运算符或者通过数组下标。根据组成向量的分量数量，每个分量可以通过使用{x, y, z, w}、{r, g, b, a}或者{s, t, p, q}组合访问。三种不同命名方案的原因是向量可以互换地表示数学上的向量、颜色、和纹理坐标。\n\n``` objc\nvec3 myVec3 = vec3(0.0, 1.0, 2.0)\nvec3 temp;\n\ntemp = myVec3.xyz;      // temp = {0.0, 1.0, 2.0}\ntemp = myVec3.xxx;      // temp = {0.0, 0.0, 0.0}\ntemp = myVec3.zyx;      // temp = {2.0, 1.0, 0.0   }\n```\n\n除了使用 \".\" 操作符之外，还可以使用数组下标操作。在使用数组下标操作时，元素 [0] 对应的是 x，元素 [1] 对应 y，以此类推。值得注意的是，在 OpenGL ES 2.0 中的某些情况下，数组下标不支持使用非常数的整型表达式（如使用整型变量索引），这是因为对于向量的动态索引操作，某些硬件设备处理起来很困难。在 OpenGL ES 2.0 中仅对 uniform 类型的变量支持这种动态索引。\n\n矩阵可以看成是由一些向量组成。例如，mat2可以看做是两个vec2，mat3可以看做是3个vec3，等等。对于矩阵，单独的列可以用数组下标运算符“[]”选择，然后每个向量可以通过向量访问行为来访问。\n\n``` objc\nmat4 myMat4 = mat4(1.0);\nvec4 col0 = myMat4[0];      // 矩阵中的向量\nfloat m1_1 = myMat4[1][1];  // 从矩阵[1][1]位置获取元素\n```\n\n# 常量\n\n可以将任何基本类型声明为常数变量。常数变量是着色器中不变的值。声明常量时，在声明中加入const限定符。\n\n``` objc\nconst float zero = 0.0;\nconst vec4 red = vec4(1.0, 0.0, 0.0, 1.0);\n```\n声明为const的变量是只读的，不能在源代码中修改。\n\n# 结构\n\n着色语言也提供了声明结构的语法：\n\n``` objc\nstruct fogStruct {\n    vec4 color;\n    float start;\n    float end;\n} fogVar;\n\nfogVar = fogStruct(vec4(0.0, 1.0, 0.0, 0.0),    // color\n                   0.5,                         // start\n                   2.0);                        // end\n\nvec4 color = fogVar.color;\nfloat start = fogVar.start;\nfloat end = fogVar.end;\n```\n\n# 数组\n\n着色语言同样支持数组：\n\n``` objc\nfloat floatArray[4];\nvec4 vecArray[2];\n\nfloat a[4] = float[](1.0, 2.0, 3.0, 4.0);\nfloat b[4] = float[4](1.0, 2.0, 3.0, 4.0);\nvec2 c[2] = vec[2](vec2(1.0), vec2(1.0));\n```\n\n# 运算符\n\n绝大多数运算符与C语言中一致。运算符只能出现在有相同基本类型的变量之间。像乘这样的运算符可以在浮点、向量和矩阵之间进行运算。\n\n# 函数\n\n函数的声明方法和C语言相同，最明显的不同之处在于函数参数的传递方法。着色语言提供特殊的限定符，定义函数是否可以修改可变参数：\n\n限定符 | 描述\n-|-\nin | 默认限定符，指定参数按值传送，函数不能被修改\ninout | 规定变量按照引用传入函数，如果该值被修改，它将在函数退出后变化\nout | 表示该变量的值不被传入函数，但是在函数返回时被修改\n\n对于着色语言中的函数还需注意一点：函数不能递归。这一限制的原因是，某些实现通过把函数代码真正地内嵌到位GPU生成的最终程序来实施函数调用，着色语言有意地构造为允许这种内嵌式实现，以支持没有堆栈的GPU。\n\n# 插值限定符\n\n顶点着色器的输出和片段着色器的输入，在没有任何限定符时，默认的插值行为是执行平滑着色。也就是说，来自顶点着色器的输出变量在图元中线性插值，片段着色器接收线性插值之后的数值作为输入。我们可以明确请求平滑着色：\n``` objc\n// Vertex shader output\nsmooth out vec3 v_color;\n\n// Fragment shader input\nsmooth in vec3 v_color\n```\n\n还有另一种插值方法--平面着色。在平面着色中，图元中的值没有进行插值，而是将其中一个顶点视为驱动顶点，该顶点的值被用于图元中的所有片段：\n``` objc\n// Vertex shader output\nflat out vec3 v_color;\n\n// Fragment shader input\nflat in vec3 v_color;\n```\n\n最后，可以用`centroid`关键字在插值器中添加另一个限定符，质心采样（centroid sampling）。本质上，使用多重采样渲染时，`centroid`关键字可用于强制插值发生在被渲染图元内部（否则，在图元的边缘可能出现伪像）：\n``` objc\n// Vertex shader output\nsmooth centroid out vec3 v_color;\n\n// Fragment shader input\nsmooth centroid in vec3 v_color;\n```\n\n# 精度限定值\n\n精度限定值使着色器作者可以指定着色器变量的计算精度。变量可以为低、中或者高精度。这些限定符用于提示编译器允许在较低的范围和精度上执行变量计算。在较低的精度上，有些OpenGL ES实现在运行着色器时可能更快，或者电源效率更高。当然，这种效率是以精度为代价的，在没有正确使用精度限定符时可能造成伪像。\n> OpenGL ES规范中没有规定底层硬件必须支持多种精度，所以某个OpenGL ES实现在最高精度上进行所有运算并简单忽略限定符时完全正常的。不过，在某些实现上，使用较低精度可能带来好处。\n精度限定符可以用于指定任何基于浮点或者整数的变量精度。指定精度的关键字是lowp、mediump、highp。\n\n``` objc\nhighp vec4 position;\nvarying lowp vec4 color;\nmediump float specularExp;\n```\n\n除了精度限定符之外，还有默认精度的概念。也就是说，如果变量声明时没有使用精度限定符，它将拥有该类型的默认精度：\n\n``` objc\nprecision highp float;\nprecision mediump int;\n```\n\n在顶点着色器中，如果没有指定默认精度，则int和float的默认精度都为highp。也就是说，顶点着色器中所有没用精度限定符声明的变量都是使用最高精度。片段着色器的规则与此不同。在片段着色器中，浮点值没有默认的精度值：每个着色器必须声明一个默认的float精度，或者为每个float变量指定精度。\n\n# 不变性\n\nOpenGL ES着色语言中引入的`invariant`关键字可以用于任何可变的顶点着色器输出。它的必要性在于：着色器需要编译，而编译器可能进行导致指令重新排序的优化，这种指令重排意味着两个着色器之间的等价计算不能保证产生完全相同的结果。这种不一致性在多遍着色器特效时可能成为问题，在这种情况下，相同的对象用Alpha混合绘制在自身上房。如果用于计算输出位置的数值的精度不完全一样，精度差异就会导致伪像。这个问题通常表现为“深度冲突”（Z fighting），每个像素的Z（深度）精度差异导致不同遍着色相互之间有微小的偏移。\n```\n#version 300 es\nuniform mat4 u_viewProjMatrix;\nlayout(location = 0) in vec4 a_vertex;\ninvariant gl_Position;\nvoid main() {\n    // will be the same value in all shaders with the same viewProjMatrix and vertex\n    gl_Position = u_viewProMatrix * a_vertex;\n}\n```\n也可以用`#pragma STDGL invariant(all)`执行让所有变量全部不变。\n\n> 警告：因为编译器需要保证不变性，所以可能限制它所做的优化。因此，`invariant`限定符应该只在必要时使用；否则可能导致性能下降。由于这个原因，全局启用不变性的`#pragma`指令会应该在不变性对于所有变量都必需的时候使用。还要注意，虽然不变性表示在指定GPU上的计算会得到相同的结果，但是并不意味着计算在任何OpenGL ES实现之间不变。\n\n# 总结\n\n这篇文章主要介绍了OpenGL ES着色语言的一些特性。","source":"_posts/2019/opengl-es-glsl-0715.md","raw":"---\ntitle: \"OpenGL ES学习--着色语言\"\ncatalog: true\ntoc_nav_num: true\ndate: 2019-07-15 19:09:32\nsubtitle: \"About OpenGL ES\"\nheader-img: \"/img/article_header/article_header.png\"\nbusuanzi: true\ntags:\n- iOS\n\n---\n\n> 着色器是OpenGL ES 3.0 API的一个基础核心概念，每个OpenGL ES 3.0程序都需要一个顶点着色器和一个片段着色器，以渲染有意义的图片。所以下面介绍开发着色器的着色语言-GLSL。\n\n# 着色器版本规范\n\nOpenGL ES 3.0顶点着色器和片段着色器的第一行总是声明着色器的版本。在之前的代码中，我是采用如下语法说明着色器使用OpenGL ES着色语言的版本3.0：\n``` objc\n#version 300 es\n```\n没有声明版本号的着色器被认定使用OpenGL ES着色语言1.00版本。着色语言1.00版本用于OpenGL ES 2.0。对于OpenGL ES 3.0，规范的作者决定匹配API和着色语言的版本号，所以版本号直接从1.00跳到3.00的原因。\n\n# 变量和变量类型\n\n在计算机图形中，两个基本数据组成了变换的基础：向量和矩阵。这两种数据类型也是OpenGL ES着色语言中的核心。\n\n变量分类 | 类型 | 描述\n-|-|-\n标量 | float, int, uint, bool | 用于浮点、整数、无符号整数和布尔值的基于标量的数据类型\n浮点向量 | float, vec2, vec3, vec4 | 有1、2、3、4个分量的基于浮点的向量类型\n整数向量 | int, ivec2, ivec3, ivec4 | 有1、2、3、4个分量的基于整数的向量类型\n无符号整数向量 | uint, uvec2, uvec3, uvec4 | 有1、2、3、4个分量的基于无符号整数的向量类型\n布尔向量 | bool, bvec2, bvec3, bvec4 | 有1、2、3、4个分量的基于布尔的向量类型\n矩阵 | mat2, mat3, mat4, max2x3, max3x2 | 2x2, 3x3, 4x4, 2x3, 3x2的基于浮点的矩阵\n\n着色语言中的变量必须以某个类型声明。变量可以在声明时或者声明以后初始化。初始化通过使用构造器进行，构造器也用于类型转换。\n\n# 变量构造器\n\nOpenGL ES 着色语言在类型转换方面有非常严格的规定。变量只能赋值为相同类型的其他变量或者与相同类型的变量进行运算。\n标量：\n``` objc\nfloat myFloat = 1.0;\nbool myBool = true; \n\nmyFloat = Float(myBool);    // bool -> float\nmyBool = bool(myFloat);     // float -> bool\n```\n\n向量：\n``` objc\nvec4 myVec4 = vec4(1.0);        // myVec4 = {1.0, 1.0, 1.0, 1.0}\nvec3 myVec3 = vec3(1.0, 0.0, 0.5);\n\nvec3 temp = vec3(myVec3);\nvec2 myVec2 = vec2(myVec3);     // myVec2 = {myVec3.x, myVec3.y}\n\nmyVec4 = vec4(myVec2, temp);   myVec4 = {myVec2.v, myVec2.y, temp.x, temp.y}\n```\n\n矩阵：\n``` objc\n// 矩阵以列优先顺序存储\nmat3 myMat3 = mat3(1.0, 2.0, 3.0,\n                   4.0, 5.0, 6.0,\n                   7.0, 8.0, 9.0)\n// 生成的矩阵是：\n[1.0 4.0 7.0\n 2.0 5.0 8.0\n 3.0 6.0 9.0]\n```\n\n# 向量和矩阵分量\n\n向量的单独分量可以用两种方式访问：使用“.”运算符或者通过数组下标。根据组成向量的分量数量，每个分量可以通过使用{x, y, z, w}、{r, g, b, a}或者{s, t, p, q}组合访问。三种不同命名方案的原因是向量可以互换地表示数学上的向量、颜色、和纹理坐标。\n\n``` objc\nvec3 myVec3 = vec3(0.0, 1.0, 2.0)\nvec3 temp;\n\ntemp = myVec3.xyz;      // temp = {0.0, 1.0, 2.0}\ntemp = myVec3.xxx;      // temp = {0.0, 0.0, 0.0}\ntemp = myVec3.zyx;      // temp = {2.0, 1.0, 0.0   }\n```\n\n除了使用 \".\" 操作符之外，还可以使用数组下标操作。在使用数组下标操作时，元素 [0] 对应的是 x，元素 [1] 对应 y，以此类推。值得注意的是，在 OpenGL ES 2.0 中的某些情况下，数组下标不支持使用非常数的整型表达式（如使用整型变量索引），这是因为对于向量的动态索引操作，某些硬件设备处理起来很困难。在 OpenGL ES 2.0 中仅对 uniform 类型的变量支持这种动态索引。\n\n矩阵可以看成是由一些向量组成。例如，mat2可以看做是两个vec2，mat3可以看做是3个vec3，等等。对于矩阵，单独的列可以用数组下标运算符“[]”选择，然后每个向量可以通过向量访问行为来访问。\n\n``` objc\nmat4 myMat4 = mat4(1.0);\nvec4 col0 = myMat4[0];      // 矩阵中的向量\nfloat m1_1 = myMat4[1][1];  // 从矩阵[1][1]位置获取元素\n```\n\n# 常量\n\n可以将任何基本类型声明为常数变量。常数变量是着色器中不变的值。声明常量时，在声明中加入const限定符。\n\n``` objc\nconst float zero = 0.0;\nconst vec4 red = vec4(1.0, 0.0, 0.0, 1.0);\n```\n声明为const的变量是只读的，不能在源代码中修改。\n\n# 结构\n\n着色语言也提供了声明结构的语法：\n\n``` objc\nstruct fogStruct {\n    vec4 color;\n    float start;\n    float end;\n} fogVar;\n\nfogVar = fogStruct(vec4(0.0, 1.0, 0.0, 0.0),    // color\n                   0.5,                         // start\n                   2.0);                        // end\n\nvec4 color = fogVar.color;\nfloat start = fogVar.start;\nfloat end = fogVar.end;\n```\n\n# 数组\n\n着色语言同样支持数组：\n\n``` objc\nfloat floatArray[4];\nvec4 vecArray[2];\n\nfloat a[4] = float[](1.0, 2.0, 3.0, 4.0);\nfloat b[4] = float[4](1.0, 2.0, 3.0, 4.0);\nvec2 c[2] = vec[2](vec2(1.0), vec2(1.0));\n```\n\n# 运算符\n\n绝大多数运算符与C语言中一致。运算符只能出现在有相同基本类型的变量之间。像乘这样的运算符可以在浮点、向量和矩阵之间进行运算。\n\n# 函数\n\n函数的声明方法和C语言相同，最明显的不同之处在于函数参数的传递方法。着色语言提供特殊的限定符，定义函数是否可以修改可变参数：\n\n限定符 | 描述\n-|-\nin | 默认限定符，指定参数按值传送，函数不能被修改\ninout | 规定变量按照引用传入函数，如果该值被修改，它将在函数退出后变化\nout | 表示该变量的值不被传入函数，但是在函数返回时被修改\n\n对于着色语言中的函数还需注意一点：函数不能递归。这一限制的原因是，某些实现通过把函数代码真正地内嵌到位GPU生成的最终程序来实施函数调用，着色语言有意地构造为允许这种内嵌式实现，以支持没有堆栈的GPU。\n\n# 插值限定符\n\n顶点着色器的输出和片段着色器的输入，在没有任何限定符时，默认的插值行为是执行平滑着色。也就是说，来自顶点着色器的输出变量在图元中线性插值，片段着色器接收线性插值之后的数值作为输入。我们可以明确请求平滑着色：\n``` objc\n// Vertex shader output\nsmooth out vec3 v_color;\n\n// Fragment shader input\nsmooth in vec3 v_color\n```\n\n还有另一种插值方法--平面着色。在平面着色中，图元中的值没有进行插值，而是将其中一个顶点视为驱动顶点，该顶点的值被用于图元中的所有片段：\n``` objc\n// Vertex shader output\nflat out vec3 v_color;\n\n// Fragment shader input\nflat in vec3 v_color;\n```\n\n最后，可以用`centroid`关键字在插值器中添加另一个限定符，质心采样（centroid sampling）。本质上，使用多重采样渲染时，`centroid`关键字可用于强制插值发生在被渲染图元内部（否则，在图元的边缘可能出现伪像）：\n``` objc\n// Vertex shader output\nsmooth centroid out vec3 v_color;\n\n// Fragment shader input\nsmooth centroid in vec3 v_color;\n```\n\n# 精度限定值\n\n精度限定值使着色器作者可以指定着色器变量的计算精度。变量可以为低、中或者高精度。这些限定符用于提示编译器允许在较低的范围和精度上执行变量计算。在较低的精度上，有些OpenGL ES实现在运行着色器时可能更快，或者电源效率更高。当然，这种效率是以精度为代价的，在没有正确使用精度限定符时可能造成伪像。\n> OpenGL ES规范中没有规定底层硬件必须支持多种精度，所以某个OpenGL ES实现在最高精度上进行所有运算并简单忽略限定符时完全正常的。不过，在某些实现上，使用较低精度可能带来好处。\n精度限定符可以用于指定任何基于浮点或者整数的变量精度。指定精度的关键字是lowp、mediump、highp。\n\n``` objc\nhighp vec4 position;\nvarying lowp vec4 color;\nmediump float specularExp;\n```\n\n除了精度限定符之外，还有默认精度的概念。也就是说，如果变量声明时没有使用精度限定符，它将拥有该类型的默认精度：\n\n``` objc\nprecision highp float;\nprecision mediump int;\n```\n\n在顶点着色器中，如果没有指定默认精度，则int和float的默认精度都为highp。也就是说，顶点着色器中所有没用精度限定符声明的变量都是使用最高精度。片段着色器的规则与此不同。在片段着色器中，浮点值没有默认的精度值：每个着色器必须声明一个默认的float精度，或者为每个float变量指定精度。\n\n# 不变性\n\nOpenGL ES着色语言中引入的`invariant`关键字可以用于任何可变的顶点着色器输出。它的必要性在于：着色器需要编译，而编译器可能进行导致指令重新排序的优化，这种指令重排意味着两个着色器之间的等价计算不能保证产生完全相同的结果。这种不一致性在多遍着色器特效时可能成为问题，在这种情况下，相同的对象用Alpha混合绘制在自身上房。如果用于计算输出位置的数值的精度不完全一样，精度差异就会导致伪像。这个问题通常表现为“深度冲突”（Z fighting），每个像素的Z（深度）精度差异导致不同遍着色相互之间有微小的偏移。\n```\n#version 300 es\nuniform mat4 u_viewProjMatrix;\nlayout(location = 0) in vec4 a_vertex;\ninvariant gl_Position;\nvoid main() {\n    // will be the same value in all shaders with the same viewProjMatrix and vertex\n    gl_Position = u_viewProMatrix * a_vertex;\n}\n```\n也可以用`#pragma STDGL invariant(all)`执行让所有变量全部不变。\n\n> 警告：因为编译器需要保证不变性，所以可能限制它所做的优化。因此，`invariant`限定符应该只在必要时使用；否则可能导致性能下降。由于这个原因，全局启用不变性的`#pragma`指令会应该在不变性对于所有变量都必需的时候使用。还要注意，虽然不变性表示在指定GPU上的计算会得到相同的结果，但是并不意味着计算在任何OpenGL ES实现之间不变。\n\n# 总结\n\n这篇文章主要介绍了OpenGL ES着色语言的一些特性。","slug":"2019/opengl-es-glsl-0715","published":1,"updated":"2022-01-10T09:04:52.806Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cky8gmc4b000wd1qh7b6osuvq","content":"<blockquote>\n<p>着色器是OpenGL ES 3.0 API的一个基础核心概念，每个OpenGL ES 3.0程序都需要一个顶点着色器和一个片段着色器，以渲染有意义的图片。所以下面介绍开发着色器的着色语言-GLSL。</p>\n</blockquote>\n<h1 id=\"着色器版本规范\">着色器版本规范</h1>\n<p>OpenGL ES 3.0顶点着色器和片段着色器的第一行总是声明着色器的版本。在之前的代码中，我是采用如下语法说明着色器使用OpenGL ES着色语言的版本3.0：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#version 300 es</span></span><br></pre></td></tr></table></figure>\n<p>没有声明版本号的着色器被认定使用OpenGL ES着色语言1.00版本。着色语言1.00版本用于OpenGL ES 2.0。对于OpenGL ES 3.0，规范的作者决定匹配API和着色语言的版本号，所以版本号直接从1.00跳到3.00的原因。</p>\n<h1 id=\"变量和变量类型\">变量和变量类型</h1>\n<p>在计算机图形中，两个基本数据组成了变换的基础：向量和矩阵。这两种数据类型也是OpenGL ES着色语言中的核心。</p>\n<table>\n<thead>\n<tr>\n<th>变量分类</th>\n<th>类型</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>标量</td>\n<td>float, int, uint, bool</td>\n<td>用于浮点、整数、无符号整数和布尔值的基于标量的数据类型</td>\n</tr>\n<tr>\n<td>浮点向量</td>\n<td>float, vec2, vec3, vec4</td>\n<td>有1、2、3、4个分量的基于浮点的向量类型</td>\n</tr>\n<tr>\n<td>整数向量</td>\n<td>int, ivec2, ivec3, ivec4</td>\n<td>有1、2、3、4个分量的基于整数的向量类型</td>\n</tr>\n<tr>\n<td>无符号整数向量</td>\n<td>uint, uvec2, uvec3, uvec4</td>\n<td>有1、2、3、4个分量的基于无符号整数的向量类型</td>\n</tr>\n<tr>\n<td>布尔向量</td>\n<td>bool, bvec2, bvec3, bvec4</td>\n<td>有1、2、3、4个分量的基于布尔的向量类型</td>\n</tr>\n<tr>\n<td>矩阵</td>\n<td>mat2, mat3, mat4, max2x3, max3x2</td>\n<td>2x2, 3x3, 4x4, 2x3, 3x2的基于浮点的矩阵</td>\n</tr>\n</tbody>\n</table>\n<p>着色语言中的变量必须以某个类型声明。变量可以在声明时或者声明以后初始化。初始化通过使用构造器进行，构造器也用于类型转换。</p>\n<h1 id=\"变量构造器\">变量构造器</h1>\n<p>OpenGL ES 着色语言在类型转换方面有非常严格的规定。变量只能赋值为相同类型的其他变量或者与相同类型的变量进行运算。<br>\n标量：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">float</span> myFloat = <span class=\"number\">1.0</span>;</span><br><span class=\"line\"><span class=\"keyword\">bool</span> myBool = <span class=\"literal\">true</span>; </span><br><span class=\"line\"></span><br><span class=\"line\">myFloat = Float(myBool);    <span class=\"comment\">// bool -&gt; float</span></span><br><span class=\"line\">myBool = <span class=\"keyword\">bool</span>(myFloat);     <span class=\"comment\">// float -&gt; bool</span></span><br></pre></td></tr></table></figure>\n<p>向量：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vec4 myVec4 = vec4(<span class=\"number\">1.0</span>);        <span class=\"comment\">// myVec4 = &#123;1.0, 1.0, 1.0, 1.0&#125;</span></span><br><span class=\"line\">vec3 myVec3 = vec3(<span class=\"number\">1.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">0.5</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">vec3 temp = vec3(myVec3);</span><br><span class=\"line\">vec2 myVec2 = vec2(myVec3);     <span class=\"comment\">// myVec2 = &#123;myVec3.x, myVec3.y&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">myVec4 = vec4(myVec2, temp);   myVec4 = &#123;myVec2.v, myVec2.y, temp.x, temp.y&#125;</span><br></pre></td></tr></table></figure>\n<p>矩阵：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 矩阵以列优先顺序存储</span></span><br><span class=\"line\">mat3 myMat3 = mat3(<span class=\"number\">1.0</span>, <span class=\"number\">2.0</span>, <span class=\"number\">3.0</span>,</span><br><span class=\"line\">                   <span class=\"number\">4.0</span>, <span class=\"number\">5.0</span>, <span class=\"number\">6.0</span>,</span><br><span class=\"line\">                   <span class=\"number\">7.0</span>, <span class=\"number\">8.0</span>, <span class=\"number\">9.0</span>)</span><br><span class=\"line\"><span class=\"comment\">// 生成的矩阵是：</span></span><br><span class=\"line\">[<span class=\"number\">1.0</span> <span class=\"number\">4.0</span> <span class=\"number\">7.0</span></span><br><span class=\"line\"> <span class=\"number\">2.0</span> <span class=\"number\">5.0</span> <span class=\"number\">8.0</span></span><br><span class=\"line\"> <span class=\"number\">3.0</span> <span class=\"number\">6.0</span> <span class=\"number\">9.0</span>]</span><br></pre></td></tr></table></figure>\n<h1 id=\"向量和矩阵分量\">向量和矩阵分量</h1>\n<p>向量的单独分量可以用两种方式访问：使用“.”运算符或者通过数组下标。根据组成向量的分量数量，每个分量可以通过使用{x, y, z, w}、{r, g, b, a}或者{s, t, p, q}组合访问。三种不同命名方案的原因是向量可以互换地表示数学上的向量、颜色、和纹理坐标。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vec3 myVec3 = vec3(<span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>, <span class=\"number\">2.0</span>)</span><br><span class=\"line\">vec3 temp;</span><br><span class=\"line\"></span><br><span class=\"line\">temp = myVec3.xyz;      <span class=\"comment\">// temp = &#123;0.0, 1.0, 2.0&#125;</span></span><br><span class=\"line\">temp = myVec3.xxx;      <span class=\"comment\">// temp = &#123;0.0, 0.0, 0.0&#125;</span></span><br><span class=\"line\">temp = myVec3.zyx;      <span class=\"comment\">// temp = &#123;2.0, 1.0, 0.0   &#125;</span></span><br></pre></td></tr></table></figure>\n<p>除了使用 “.” 操作符之外，还可以使用数组下标操作。在使用数组下标操作时，元素 [0] 对应的是 x，元素 [1] 对应 y，以此类推。值得注意的是，在 OpenGL ES 2.0 中的某些情况下，数组下标不支持使用非常数的整型表达式（如使用整型变量索引），这是因为对于向量的动态索引操作，某些硬件设备处理起来很困难。在 OpenGL ES 2.0 中仅对 uniform 类型的变量支持这种动态索引。</p>\n<p>矩阵可以看成是由一些向量组成。例如，mat2可以看做是两个vec2，mat3可以看做是3个vec3，等等。对于矩阵，单独的列可以用数组下标运算符“[]”选择，然后每个向量可以通过向量访问行为来访问。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mat4 myMat4 = mat4(<span class=\"number\">1.0</span>);</span><br><span class=\"line\">vec4 col0 = myMat4[<span class=\"number\">0</span>];      <span class=\"comment\">// 矩阵中的向量</span></span><br><span class=\"line\"><span class=\"keyword\">float</span> m1_1 = myMat4[<span class=\"number\">1</span>][<span class=\"number\">1</span>];  <span class=\"comment\">// 从矩阵[1][1]位置获取元素</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"常量\">常量</h1>\n<p>可以将任何基本类型声明为常数变量。常数变量是着色器中不变的值。声明常量时，在声明中加入const限定符。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">float</span> zero = <span class=\"number\">0.0</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> vec4 red = vec4(<span class=\"number\">1.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>);</span><br></pre></td></tr></table></figure>\n<p>声明为const的变量是只读的，不能在源代码中修改。</p>\n<h1 id=\"结构\">结构</h1>\n<p>着色语言也提供了声明结构的语法：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> fogStruct &#123;</span><br><span class=\"line\">    vec4 color;</span><br><span class=\"line\">    <span class=\"keyword\">float</span> start;</span><br><span class=\"line\">    <span class=\"keyword\">float</span> end;</span><br><span class=\"line\">&#125; fogVar;</span><br><span class=\"line\"></span><br><span class=\"line\">fogVar = fogStruct(vec4(<span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>),    <span class=\"comment\">// color</span></span><br><span class=\"line\">                   <span class=\"number\">0.5</span>,                         <span class=\"comment\">// start</span></span><br><span class=\"line\">                   <span class=\"number\">2.0</span>);                        <span class=\"comment\">// end</span></span><br><span class=\"line\"></span><br><span class=\"line\">vec4 color = fogVar.color;</span><br><span class=\"line\"><span class=\"keyword\">float</span> start = fogVar.start;</span><br><span class=\"line\"><span class=\"keyword\">float</span> end = fogVar.end;</span><br></pre></td></tr></table></figure>\n<h1 id=\"数组\">数组</h1>\n<p>着色语言同样支持数组：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">float</span> floatArray[<span class=\"number\">4</span>];</span><br><span class=\"line\">vec4 vecArray[<span class=\"number\">2</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">float</span> a[<span class=\"number\">4</span>] = <span class=\"keyword\">float</span>[](<span class=\"number\">1.0</span>, <span class=\"number\">2.0</span>, <span class=\"number\">3.0</span>, <span class=\"number\">4.0</span>);</span><br><span class=\"line\"><span class=\"keyword\">float</span> b[<span class=\"number\">4</span>] = <span class=\"keyword\">float</span>[<span class=\"number\">4</span>](<span class=\"number\">1.0</span>, <span class=\"number\">2.0</span>, <span class=\"number\">3.0</span>, <span class=\"number\">4.0</span>);</span><br><span class=\"line\">vec2 c[<span class=\"number\">2</span>] = vec[<span class=\"number\">2</span>](vec2(<span class=\"number\">1.0</span>), vec2(<span class=\"number\">1.0</span>));</span><br></pre></td></tr></table></figure>\n<h1 id=\"运算符\">运算符</h1>\n<p>绝大多数运算符与C语言中一致。运算符只能出现在有相同基本类型的变量之间。像乘这样的运算符可以在浮点、向量和矩阵之间进行运算。</p>\n<h1 id=\"函数\">函数</h1>\n<p>函数的声明方法和C语言相同，最明显的不同之处在于函数参数的传递方法。着色语言提供特殊的限定符，定义函数是否可以修改可变参数：</p>\n<table>\n<thead>\n<tr>\n<th>限定符</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>in</td>\n<td>默认限定符，指定参数按值传送，函数不能被修改</td>\n</tr>\n<tr>\n<td>inout</td>\n<td>规定变量按照引用传入函数，如果该值被修改，它将在函数退出后变化</td>\n</tr>\n<tr>\n<td>out</td>\n<td>表示该变量的值不被传入函数，但是在函数返回时被修改</td>\n</tr>\n</tbody>\n</table>\n<p>对于着色语言中的函数还需注意一点：函数不能递归。这一限制的原因是，某些实现通过把函数代码真正地内嵌到位GPU生成的最终程序来实施函数调用，着色语言有意地构造为允许这种内嵌式实现，以支持没有堆栈的GPU。</p>\n<h1 id=\"插值限定符\">插值限定符</h1>\n<p>顶点着色器的输出和片段着色器的输入，在没有任何限定符时，默认的插值行为是执行平滑着色。也就是说，来自顶点着色器的输出变量在图元中线性插值，片段着色器接收线性插值之后的数值作为输入。我们可以明确请求平滑着色：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Vertex shader output</span></span><br><span class=\"line\">smooth <span class=\"keyword\">out</span> vec3 v_color;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Fragment shader input</span></span><br><span class=\"line\">smooth <span class=\"keyword\">in</span> vec3 v_color</span><br></pre></td></tr></table></figure>\n<p>还有另一种插值方法–平面着色。在平面着色中，图元中的值没有进行插值，而是将其中一个顶点视为驱动顶点，该顶点的值被用于图元中的所有片段：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Vertex shader output</span></span><br><span class=\"line\">flat <span class=\"keyword\">out</span> vec3 v_color;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Fragment shader input</span></span><br><span class=\"line\">flat <span class=\"keyword\">in</span> vec3 v_color;</span><br></pre></td></tr></table></figure>\n<p>最后，可以用<code>centroid</code>关键字在插值器中添加另一个限定符，质心采样（centroid sampling）。本质上，使用多重采样渲染时，<code>centroid</code>关键字可用于强制插值发生在被渲染图元内部（否则，在图元的边缘可能出现伪像）：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Vertex shader output</span></span><br><span class=\"line\">smooth centroid <span class=\"keyword\">out</span> vec3 v_color;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Fragment shader input</span></span><br><span class=\"line\">smooth centroid <span class=\"keyword\">in</span> vec3 v_color;</span><br></pre></td></tr></table></figure>\n<h1 id=\"精度限定值\">精度限定值</h1>\n<p>精度限定值使着色器作者可以指定着色器变量的计算精度。变量可以为低、中或者高精度。这些限定符用于提示编译器允许在较低的范围和精度上执行变量计算。在较低的精度上，有些OpenGL ES实现在运行着色器时可能更快，或者电源效率更高。当然，这种效率是以精度为代价的，在没有正确使用精度限定符时可能造成伪像。</p>\n<blockquote>\n<p>OpenGL ES规范中没有规定底层硬件必须支持多种精度，所以某个OpenGL ES实现在最高精度上进行所有运算并简单忽略限定符时完全正常的。不过，在某些实现上，使用较低精度可能带来好处。<br>\n精度限定符可以用于指定任何基于浮点或者整数的变量精度。指定精度的关键字是lowp、mediump、highp。</p>\n</blockquote>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">highp vec4 position;</span><br><span class=\"line\">varying lowp vec4 color;</span><br><span class=\"line\">mediump <span class=\"keyword\">float</span> specularExp;</span><br></pre></td></tr></table></figure>\n<p>除了精度限定符之外，还有默认精度的概念。也就是说，如果变量声明时没有使用精度限定符，它将拥有该类型的默认精度：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">precision highp <span class=\"keyword\">float</span>;</span><br><span class=\"line\">precision mediump <span class=\"keyword\">int</span>;</span><br></pre></td></tr></table></figure>\n<p>在顶点着色器中，如果没有指定默认精度，则int和float的默认精度都为highp。也就是说，顶点着色器中所有没用精度限定符声明的变量都是使用最高精度。片段着色器的规则与此不同。在片段着色器中，浮点值没有默认的精度值：每个着色器必须声明一个默认的float精度，或者为每个float变量指定精度。</p>\n<h1 id=\"不变性\">不变性</h1>\n<p>OpenGL ES着色语言中引入的<code>invariant</code>关键字可以用于任何可变的顶点着色器输出。它的必要性在于：着色器需要编译，而编译器可能进行导致指令重新排序的优化，这种指令重排意味着两个着色器之间的等价计算不能保证产生完全相同的结果。这种不一致性在多遍着色器特效时可能成为问题，在这种情况下，相同的对象用Alpha混合绘制在自身上房。如果用于计算输出位置的数值的精度不完全一样，精度差异就会导致伪像。这个问题通常表现为“深度冲突”（Z fighting），每个像素的Z（深度）精度差异导致不同遍着色相互之间有微小的偏移。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#version 300 es</span><br><span class=\"line\">uniform mat4 u_viewProjMatrix;</span><br><span class=\"line\">layout(location = 0) in vec4 a_vertex;</span><br><span class=\"line\">invariant gl_Position;</span><br><span class=\"line\">void main() &#123;</span><br><span class=\"line\">    // will be the same value in all shaders with the same viewProjMatrix and vertex</span><br><span class=\"line\">    gl_Position = u_viewProMatrix * a_vertex;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>也可以用<code>#pragma STDGL invariant(all)</code>执行让所有变量全部不变。</p>\n<blockquote>\n<p>警告：因为编译器需要保证不变性，所以可能限制它所做的优化。因此，<code>invariant</code>限定符应该只在必要时使用；否则可能导致性能下降。由于这个原因，全局启用不变性的<code>#pragma</code>指令会应该在不变性对于所有变量都必需的时候使用。还要注意，虽然不变性表示在指定GPU上的计算会得到相同的结果，但是并不意味着计算在任何OpenGL ES实现之间不变。</p>\n</blockquote>\n<h1 id=\"总结\">总结</h1>\n<p>这篇文章主要介绍了OpenGL ES着色语言的一些特性。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>着色器是OpenGL ES 3.0 API的一个基础核心概念，每个OpenGL ES 3.0程序都需要一个顶点着色器和一个片段着色器，以渲染有意义的图片。所以下面介绍开发着色器的着色语言-GLSL。</p>\n</blockquote>\n<h1>着色器版本规范</h1>\n<p>OpenGL ES 3.0顶点着色器和片段着色器的第一行总是声明着色器的版本。在之前的代码中，我是采用如下语法说明着色器使用OpenGL ES着色语言的版本3.0：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#version 300 es</span></span><br></pre></td></tr></table></figure>\n<p>没有声明版本号的着色器被认定使用OpenGL ES着色语言1.00版本。着色语言1.00版本用于OpenGL ES 2.0。对于OpenGL ES 3.0，规范的作者决定匹配API和着色语言的版本号，所以版本号直接从1.00跳到3.00的原因。</p>\n<h1>变量和变量类型</h1>\n<p>在计算机图形中，两个基本数据组成了变换的基础：向量和矩阵。这两种数据类型也是OpenGL ES着色语言中的核心。</p>\n<table>\n<thead>\n<tr>\n<th>变量分类</th>\n<th>类型</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>标量</td>\n<td>float, int, uint, bool</td>\n<td>用于浮点、整数、无符号整数和布尔值的基于标量的数据类型</td>\n</tr>\n<tr>\n<td>浮点向量</td>\n<td>float, vec2, vec3, vec4</td>\n<td>有1、2、3、4个分量的基于浮点的向量类型</td>\n</tr>\n<tr>\n<td>整数向量</td>\n<td>int, ivec2, ivec3, ivec4</td>\n<td>有1、2、3、4个分量的基于整数的向量类型</td>\n</tr>\n<tr>\n<td>无符号整数向量</td>\n<td>uint, uvec2, uvec3, uvec4</td>\n<td>有1、2、3、4个分量的基于无符号整数的向量类型</td>\n</tr>\n<tr>\n<td>布尔向量</td>\n<td>bool, bvec2, bvec3, bvec4</td>\n<td>有1、2、3、4个分量的基于布尔的向量类型</td>\n</tr>\n<tr>\n<td>矩阵</td>\n<td>mat2, mat3, mat4, max2x3, max3x2</td>\n<td>2x2, 3x3, 4x4, 2x3, 3x2的基于浮点的矩阵</td>\n</tr>\n</tbody>\n</table>\n<p>着色语言中的变量必须以某个类型声明。变量可以在声明时或者声明以后初始化。初始化通过使用构造器进行，构造器也用于类型转换。</p>\n<h1>变量构造器</h1>\n<p>OpenGL ES 着色语言在类型转换方面有非常严格的规定。变量只能赋值为相同类型的其他变量或者与相同类型的变量进行运算。<br>\n标量：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">float</span> myFloat = <span class=\"number\">1.0</span>;</span><br><span class=\"line\"><span class=\"keyword\">bool</span> myBool = <span class=\"literal\">true</span>; </span><br><span class=\"line\"></span><br><span class=\"line\">myFloat = Float(myBool);    <span class=\"comment\">// bool -&gt; float</span></span><br><span class=\"line\">myBool = <span class=\"keyword\">bool</span>(myFloat);     <span class=\"comment\">// float -&gt; bool</span></span><br></pre></td></tr></table></figure>\n<p>向量：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vec4 myVec4 = vec4(<span class=\"number\">1.0</span>);        <span class=\"comment\">// myVec4 = &#123;1.0, 1.0, 1.0, 1.0&#125;</span></span><br><span class=\"line\">vec3 myVec3 = vec3(<span class=\"number\">1.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">0.5</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">vec3 temp = vec3(myVec3);</span><br><span class=\"line\">vec2 myVec2 = vec2(myVec3);     <span class=\"comment\">// myVec2 = &#123;myVec3.x, myVec3.y&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">myVec4 = vec4(myVec2, temp);   myVec4 = &#123;myVec2.v, myVec2.y, temp.x, temp.y&#125;</span><br></pre></td></tr></table></figure>\n<p>矩阵：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 矩阵以列优先顺序存储</span></span><br><span class=\"line\">mat3 myMat3 = mat3(<span class=\"number\">1.0</span>, <span class=\"number\">2.0</span>, <span class=\"number\">3.0</span>,</span><br><span class=\"line\">                   <span class=\"number\">4.0</span>, <span class=\"number\">5.0</span>, <span class=\"number\">6.0</span>,</span><br><span class=\"line\">                   <span class=\"number\">7.0</span>, <span class=\"number\">8.0</span>, <span class=\"number\">9.0</span>)</span><br><span class=\"line\"><span class=\"comment\">// 生成的矩阵是：</span></span><br><span class=\"line\">[<span class=\"number\">1.0</span> <span class=\"number\">4.0</span> <span class=\"number\">7.0</span></span><br><span class=\"line\"> <span class=\"number\">2.0</span> <span class=\"number\">5.0</span> <span class=\"number\">8.0</span></span><br><span class=\"line\"> <span class=\"number\">3.0</span> <span class=\"number\">6.0</span> <span class=\"number\">9.0</span>]</span><br></pre></td></tr></table></figure>\n<h1>向量和矩阵分量</h1>\n<p>向量的单独分量可以用两种方式访问：使用“.”运算符或者通过数组下标。根据组成向量的分量数量，每个分量可以通过使用{x, y, z, w}、{r, g, b, a}或者{s, t, p, q}组合访问。三种不同命名方案的原因是向量可以互换地表示数学上的向量、颜色、和纹理坐标。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vec3 myVec3 = vec3(<span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>, <span class=\"number\">2.0</span>)</span><br><span class=\"line\">vec3 temp;</span><br><span class=\"line\"></span><br><span class=\"line\">temp = myVec3.xyz;      <span class=\"comment\">// temp = &#123;0.0, 1.0, 2.0&#125;</span></span><br><span class=\"line\">temp = myVec3.xxx;      <span class=\"comment\">// temp = &#123;0.0, 0.0, 0.0&#125;</span></span><br><span class=\"line\">temp = myVec3.zyx;      <span class=\"comment\">// temp = &#123;2.0, 1.0, 0.0   &#125;</span></span><br></pre></td></tr></table></figure>\n<p>除了使用 “.” 操作符之外，还可以使用数组下标操作。在使用数组下标操作时，元素 [0] 对应的是 x，元素 [1] 对应 y，以此类推。值得注意的是，在 OpenGL ES 2.0 中的某些情况下，数组下标不支持使用非常数的整型表达式（如使用整型变量索引），这是因为对于向量的动态索引操作，某些硬件设备处理起来很困难。在 OpenGL ES 2.0 中仅对 uniform 类型的变量支持这种动态索引。</p>\n<p>矩阵可以看成是由一些向量组成。例如，mat2可以看做是两个vec2，mat3可以看做是3个vec3，等等。对于矩阵，单独的列可以用数组下标运算符“[]”选择，然后每个向量可以通过向量访问行为来访问。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mat4 myMat4 = mat4(<span class=\"number\">1.0</span>);</span><br><span class=\"line\">vec4 col0 = myMat4[<span class=\"number\">0</span>];      <span class=\"comment\">// 矩阵中的向量</span></span><br><span class=\"line\"><span class=\"keyword\">float</span> m1_1 = myMat4[<span class=\"number\">1</span>][<span class=\"number\">1</span>];  <span class=\"comment\">// 从矩阵[1][1]位置获取元素</span></span><br></pre></td></tr></table></figure>\n<h1>常量</h1>\n<p>可以将任何基本类型声明为常数变量。常数变量是着色器中不变的值。声明常量时，在声明中加入const限定符。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">float</span> zero = <span class=\"number\">0.0</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> vec4 red = vec4(<span class=\"number\">1.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>);</span><br></pre></td></tr></table></figure>\n<p>声明为const的变量是只读的，不能在源代码中修改。</p>\n<h1>结构</h1>\n<p>着色语言也提供了声明结构的语法：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> fogStruct &#123;</span><br><span class=\"line\">    vec4 color;</span><br><span class=\"line\">    <span class=\"keyword\">float</span> start;</span><br><span class=\"line\">    <span class=\"keyword\">float</span> end;</span><br><span class=\"line\">&#125; fogVar;</span><br><span class=\"line\"></span><br><span class=\"line\">fogVar = fogStruct(vec4(<span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>),    <span class=\"comment\">// color</span></span><br><span class=\"line\">                   <span class=\"number\">0.5</span>,                         <span class=\"comment\">// start</span></span><br><span class=\"line\">                   <span class=\"number\">2.0</span>);                        <span class=\"comment\">// end</span></span><br><span class=\"line\"></span><br><span class=\"line\">vec4 color = fogVar.color;</span><br><span class=\"line\"><span class=\"keyword\">float</span> start = fogVar.start;</span><br><span class=\"line\"><span class=\"keyword\">float</span> end = fogVar.end;</span><br></pre></td></tr></table></figure>\n<h1>数组</h1>\n<p>着色语言同样支持数组：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">float</span> floatArray[<span class=\"number\">4</span>];</span><br><span class=\"line\">vec4 vecArray[<span class=\"number\">2</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">float</span> a[<span class=\"number\">4</span>] = <span class=\"keyword\">float</span>[](<span class=\"number\">1.0</span>, <span class=\"number\">2.0</span>, <span class=\"number\">3.0</span>, <span class=\"number\">4.0</span>);</span><br><span class=\"line\"><span class=\"keyword\">float</span> b[<span class=\"number\">4</span>] = <span class=\"keyword\">float</span>[<span class=\"number\">4</span>](<span class=\"number\">1.0</span>, <span class=\"number\">2.0</span>, <span class=\"number\">3.0</span>, <span class=\"number\">4.0</span>);</span><br><span class=\"line\">vec2 c[<span class=\"number\">2</span>] = vec[<span class=\"number\">2</span>](vec2(<span class=\"number\">1.0</span>), vec2(<span class=\"number\">1.0</span>));</span><br></pre></td></tr></table></figure>\n<h1>运算符</h1>\n<p>绝大多数运算符与C语言中一致。运算符只能出现在有相同基本类型的变量之间。像乘这样的运算符可以在浮点、向量和矩阵之间进行运算。</p>\n<h1>函数</h1>\n<p>函数的声明方法和C语言相同，最明显的不同之处在于函数参数的传递方法。着色语言提供特殊的限定符，定义函数是否可以修改可变参数：</p>\n<table>\n<thead>\n<tr>\n<th>限定符</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>in</td>\n<td>默认限定符，指定参数按值传送，函数不能被修改</td>\n</tr>\n<tr>\n<td>inout</td>\n<td>规定变量按照引用传入函数，如果该值被修改，它将在函数退出后变化</td>\n</tr>\n<tr>\n<td>out</td>\n<td>表示该变量的值不被传入函数，但是在函数返回时被修改</td>\n</tr>\n</tbody>\n</table>\n<p>对于着色语言中的函数还需注意一点：函数不能递归。这一限制的原因是，某些实现通过把函数代码真正地内嵌到位GPU生成的最终程序来实施函数调用，着色语言有意地构造为允许这种内嵌式实现，以支持没有堆栈的GPU。</p>\n<h1>插值限定符</h1>\n<p>顶点着色器的输出和片段着色器的输入，在没有任何限定符时，默认的插值行为是执行平滑着色。也就是说，来自顶点着色器的输出变量在图元中线性插值，片段着色器接收线性插值之后的数值作为输入。我们可以明确请求平滑着色：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Vertex shader output</span></span><br><span class=\"line\">smooth <span class=\"keyword\">out</span> vec3 v_color;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Fragment shader input</span></span><br><span class=\"line\">smooth <span class=\"keyword\">in</span> vec3 v_color</span><br></pre></td></tr></table></figure>\n<p>还有另一种插值方法–平面着色。在平面着色中，图元中的值没有进行插值，而是将其中一个顶点视为驱动顶点，该顶点的值被用于图元中的所有片段：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Vertex shader output</span></span><br><span class=\"line\">flat <span class=\"keyword\">out</span> vec3 v_color;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Fragment shader input</span></span><br><span class=\"line\">flat <span class=\"keyword\">in</span> vec3 v_color;</span><br></pre></td></tr></table></figure>\n<p>最后，可以用<code>centroid</code>关键字在插值器中添加另一个限定符，质心采样（centroid sampling）。本质上，使用多重采样渲染时，<code>centroid</code>关键字可用于强制插值发生在被渲染图元内部（否则，在图元的边缘可能出现伪像）：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Vertex shader output</span></span><br><span class=\"line\">smooth centroid <span class=\"keyword\">out</span> vec3 v_color;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Fragment shader input</span></span><br><span class=\"line\">smooth centroid <span class=\"keyword\">in</span> vec3 v_color;</span><br></pre></td></tr></table></figure>\n<h1>精度限定值</h1>\n<p>精度限定值使着色器作者可以指定着色器变量的计算精度。变量可以为低、中或者高精度。这些限定符用于提示编译器允许在较低的范围和精度上执行变量计算。在较低的精度上，有些OpenGL ES实现在运行着色器时可能更快，或者电源效率更高。当然，这种效率是以精度为代价的，在没有正确使用精度限定符时可能造成伪像。</p>\n<blockquote>\n<p>OpenGL ES规范中没有规定底层硬件必须支持多种精度，所以某个OpenGL ES实现在最高精度上进行所有运算并简单忽略限定符时完全正常的。不过，在某些实现上，使用较低精度可能带来好处。<br>\n精度限定符可以用于指定任何基于浮点或者整数的变量精度。指定精度的关键字是lowp、mediump、highp。</p>\n</blockquote>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">highp vec4 position;</span><br><span class=\"line\">varying lowp vec4 color;</span><br><span class=\"line\">mediump <span class=\"keyword\">float</span> specularExp;</span><br></pre></td></tr></table></figure>\n<p>除了精度限定符之外，还有默认精度的概念。也就是说，如果变量声明时没有使用精度限定符，它将拥有该类型的默认精度：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">precision highp <span class=\"keyword\">float</span>;</span><br><span class=\"line\">precision mediump <span class=\"keyword\">int</span>;</span><br></pre></td></tr></table></figure>\n<p>在顶点着色器中，如果没有指定默认精度，则int和float的默认精度都为highp。也就是说，顶点着色器中所有没用精度限定符声明的变量都是使用最高精度。片段着色器的规则与此不同。在片段着色器中，浮点值没有默认的精度值：每个着色器必须声明一个默认的float精度，或者为每个float变量指定精度。</p>\n<h1>不变性</h1>\n<p>OpenGL ES着色语言中引入的<code>invariant</code>关键字可以用于任何可变的顶点着色器输出。它的必要性在于：着色器需要编译，而编译器可能进行导致指令重新排序的优化，这种指令重排意味着两个着色器之间的等价计算不能保证产生完全相同的结果。这种不一致性在多遍着色器特效时可能成为问题，在这种情况下，相同的对象用Alpha混合绘制在自身上房。如果用于计算输出位置的数值的精度不完全一样，精度差异就会导致伪像。这个问题通常表现为“深度冲突”（Z fighting），每个像素的Z（深度）精度差异导致不同遍着色相互之间有微小的偏移。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#version 300 es</span><br><span class=\"line\">uniform mat4 u_viewProjMatrix;</span><br><span class=\"line\">layout(location = 0) in vec4 a_vertex;</span><br><span class=\"line\">invariant gl_Position;</span><br><span class=\"line\">void main() &#123;</span><br><span class=\"line\">    // will be the same value in all shaders with the same viewProjMatrix and vertex</span><br><span class=\"line\">    gl_Position = u_viewProMatrix * a_vertex;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>也可以用<code>#pragma STDGL invariant(all)</code>执行让所有变量全部不变。</p>\n<blockquote>\n<p>警告：因为编译器需要保证不变性，所以可能限制它所做的优化。因此，<code>invariant</code>限定符应该只在必要时使用；否则可能导致性能下降。由于这个原因，全局启用不变性的<code>#pragma</code>指令会应该在不变性对于所有变量都必需的时候使用。还要注意，虽然不变性表示在指定GPU上的计算会得到相同的结果，但是并不意味着计算在任何OpenGL ES实现之间不变。</p>\n</blockquote>\n<h1>总结</h1>\n<p>这篇文章主要介绍了OpenGL ES着色语言的一些特性。</p>\n"},{"title":"OpenGL ES--光照","catalog":true,"toc_nav_num":true,"date":"2019-09-02T09:30:54.000Z","subtitle":"About OpenGL ES","header-img":"/img/article_header/article_header.png","busuanzi":true,"_content":"\n# 颜色\n\n现实世界中有无数种颜色，每一个物体都有它们自己的颜色。我们需要使用（有限的）数值来模拟真实世界中（无限）的颜色，所以并不是所有现实世界中的颜色都可以用数值来表示的。然而我们仍能通过数值来表现出非常多的颜色，甚至可能都不会注意到与现实的颜色有任何的差异。颜色可以数字化的由红色（Red）、绿色（Green）和蓝色（Blue）三个分量组成，它们通常被缩写为RGB。仅仅用这三个值就可以组合出任意一种颜色。\n我们在显示生活中看到某一物体的颜色并不是这个物体真正拥有的颜色，而是它所反射的（Reflected）颜色。换句话说，那些不能被物体所吸收（Absorb）的颜色（被拒绝的颜色）就是我们能够感知到的物体的颜色。例如，太阳光能被看见的白光其实是由许多不同的颜色组合而成的。如果我们将白光照在一个蓝色的玩具上，这个蓝色的玩具会吸收白光中除了蓝色以外的所有子颜色，不被吸收的蓝色光被反射到我们的眼中，让这个玩具看起来是蓝色的。\n这些颜色反射的定律被直接地运用在图形领域。当我们在OpenGL中创建一个光源时，我们希望给光源一个颜色。我们将光源设置为白色。当我们把光源的颜色与物体的颜色值相乘，所得到的就是这个物体所反射的颜色（也就是我们所感知的颜色）。在图形学中，我们将这两个颜色向量作分量相乘，结果就是最终的颜色向量：\n\n``` objc\nvec3 lightColor = vec3(1.0f, 1.0f, 1.0f);\nvec3 toyColor = vec3(1.0f, 0.5f, 0.3f);\nvec3 result = lightColor * toyColor;    // = (1.0f, 0.5f, 0.3f)\n```\n\n我们可以看到玩具的颜色吸收了白色光源中很大一部分的颜色，但它根据自身的颜色值对红、绿、蓝三个分量都做出了一定的反射。这也表现了现实中颜色的工作原理。由此，我们可以定义物体的颜色为物体从一个光源反射各个颜色分量的大小。如果我们使用绿色光源：\n\n``` objc\nvec3 lightColor = vec3(0.0f, 1.0f, 0.0f);\nvec3 toyColor = vec3(1.0f, 0.5f, 0.3f);\nvec3 result = lightColor * toyColor;    // = (0.0f, 0.5f, 0.0f)\n```\n\n可以看到，并没有红色和蓝色的光让玩具吸收或者反射。这个玩具吸收了光线中一半的绿色值，但仍然反射了一半的绿色值。玩具现在看上去是深绿色的。\n\n# 创建一个光照场景\n\n首先我们需要一个物体来作为被投光的对象--立方体箱子。还有一个立方体箱子来代表光源在3D场景中的位置。这里使用两套着色器，因为灯的颜色不应该受到物体光照计算结果的影响，所以需要将它与物体分离，不受其他颜色变化的影响。\n\n着色器代码：\n\n``` objc\nNSString *objectVertexShaderString = @\" \\\n#version 300 es \\\nlayout(location = 0) in vec3 a_position; \\\nuniform mat4 modelMatrix; \\\nuniform mat4 viewMatrix; \\\nuniform mat4 projectionMatrix; \\\nvoid main() { \\\ngl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(a_position, 1.0); \\\n}\";\nNSString *objectFragmentShaderString = @\"\\\n#version 300 es \\\nprecision mediump float; \\\nuniform vec3 objectColor; \\\nout vec4 fragColor; \\\nvoid main() { \\\nfragColor = vec4(objectColor, 1.0); \\\n}\";\n\nNSString *lightVertexShaderString = @\" \\\n#version 300 es \\\nlayout(location = 0) in vec3 a_position; \\\nuniform mat4 modelMatrix; \\\nuniform mat4 viewMatrix; \\\nuniform mat4 projectionMatrix; \\\nvoid main() { \\\ngl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(a_position, 1.0); \\\n}\";\nNSString *lightFragmentShaderString = @\"\\\n#version 300 es \\\nprecision mediump float; \\\nout vec4 fragColor; \\\nvoid main() { \\\nfragColor = vec4(1.0); \\\n}\";\n```\n\n绘制代码：\n\n``` objc\n- (void)setupVertices {\n    ...\n    顶点配置，设置缓冲\n    ...\n    // 物体顶点数组对象\n    glGenVertexArrays(1, &vao);\n    glBindVertexArray(vao);\n    glEnableVertexAttribArray(0);\n    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, sizeof(GLfloat)*6, 0);\n    glEnableVertexAttribArray(1);\n    glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, sizeof(GLfloat)*6, (GLvoid *)(sizeof(GLfloat)*3));\n    glBindVertexArray(0);\n\n    // 灯顶点数组对象\n    glGenVertexArrays(1, &lightvao);\n    glBindVertexArray(lightvao);\n    glEnableVertexAttribArray(0);\n    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, sizeof(GLfloat)*6, 0);\n    glBindVertexArray(0);\n}\n\n- (void)glkView:(GLKView *)view drawInRect:(CGRect)rect {\n    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n    glClearColor(0.0f, 0.0f, 0.0f, 1.0f);\n    \n    glUseProgram(program1);\n    \n    glBindVertexArray(vao);\n    glDrawArrays(GL_TRIANGLES, 0, 36);\n    \n    float aspect = self.view.frame.size.width / self.view.frame.size.height;\n    GLKMatrix4 modelMatrix = GLKMatrix4MakeTranslation(-0.3f, 0.2f, 1.0f);\n    GLKMatrix4 viewMatrix = GLKMatrix4MakeLookAt(-3.5f, 2.0f, 4.0f, 0.5f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f);\n    GLKMatrix4 projectionMatrx = GLKMatrix4MakePerspective(GLKMathDegreesToRadians(45), aspect, 0.1, 100.0);\n    glUniformMatrix4fv(modelLocation, 1, GL_FALSE, modelMatrix.m);\n    glUniformMatrix4fv(viewLocation, 1, GL_FALSE, viewMatrix.m);\n    glUniformMatrix4fv(projectionLocation, 1, GL_FALSE, projectionMatrx.m);\n    glUniform3f(objectLocation, 1.0f, 0.5f, 0.3f);  // objct color\n    \n    glUseProgram(program2);\n    glBindVertexArray(lightvao);\n    glDrawArrays(GL_TRIANGLES, 0, 36);\n    \n    GLKMatrix4 translateMatrix2 = GLKMatrix4MakeTranslation(3.0f, 6.6f, 2.5f);\n    GLKMatrix4 scaleMatrix2 = GLKMatrix4MakeScale(0.2f, 0.2f, 0.2f);\n    GLKMatrix4 modelMatrix2 = GLKMatrix4Multiply(scaleMatrix2, translateMatrix2);\n    glUniformMatrix4fv(modelLocation2, 1, GL_FALSE, modelMatrix2.m);\n    glUniformMatrix4fv(viewLocation2, 1, GL_FALSE, viewMatrix.m);\n    glUniformMatrix4fv(projectionLocation2, 1, GL_FALSE, projectionMatrx.m);\n}\n```\n\n这样我们就能有一个干净的光照实验场地，如下图：\n\n![干净的光照实验场地](/img/article/20190902/1.png)\n\n# 基础光照\n\n现实世界的光照是极其复杂的，而且会受到诸多因素的影响，这是我们有限的计算能力所无法比拟的。因此OpenGL的光照使用的是简化的模型，对现实的情况进行近似，这样处理起来会更容易一些，而且看起来也差不多一样。这些光照模型都是基于我们对光的物理特性的理解。其中一个模型被称为冯氏光照模型（Phong Lighting Model）。冯氏光照模型的主要结构由3个分量组成：环境（Ambient）、漫反射（Diffuse）和镜面（Specular）光照。\n\n![基础光照](/img/article/20190902/2.png)\n\n- 环境光照（Ambient Lighting）：即使在黑暗的情况下，世界上通常也仍然有一些光亮，所以物体几乎永远不会是完全黑暗的。为了模拟这个，我们会使用一个环境光照常量，它会永远给物体一些颜色。\n- 漫反射光照（Diffuse Lighting）：模拟光源对物体的方向性影响（Directional Impact）。它是冯氏光照模型中视觉上最显著的分量。物体的某一部分越是正对着光源，他就会越亮。\n- 镜面光照（Specular Lighting）：模拟有光泽物体上面出现的亮点。镜面光照的颜色相比于物体的颜色会更倾向于光的颜色。\n\n# 环境光照\n\n光通常都不是来自于同一个光源，而是来自于我们周围分散的很多光源，即使它们可能并不是那么显而易见。光的一个属性是，它可以向很多方向发散并反弹，从而能够到达不是非常直接临近的点。所以，光能够在其它的表面上反射，对一个物体产生间接的影响。考虑到这种情况的算法叫做全局照明（Global Illumination）算法，但是这种算法既开销高昂又及其复杂。\n\n由于我们现在对那种又复杂又开销高昂的算法不是很感兴趣，所以我们将会先使用一个简化的全局照明模型，即环境光照。我们使用一个很小的常量（光照）颜色，添加到物体片段的最终颜色中，这样子的话即使场景中没有直接的光源也能看起来存在有一些发散的光。\n\n把环境光照添加到场景里非常简单。我们用光的颜色乘以一个很小的常量环境因子，再乘以物体的颜色，然后将最终结果作为片段的颜色：\n\n``` objc\nNSString *objectFragmentShaderString = @\"\\\n#version 300 es \\\nprecision mediump float; \\\nuniform vec3 objectColor; \\\nuniform vec3 lightColor; \\\nout vec4 fragColor; \\\nvoid main() { \\\nfloat ambientStrength = 0.1; \\\nvec3 ambient = ambientStrength * lightColor; \\\nvec3 result = ambient * objectColor; \\\nfragColor = vec4(result, 1.0); \\\n}\";\n```\n\n效果如下图，冯氏光照的第一个阶段已经应用到我们的物体上。这个物体非常暗，但由于应用了环境光照（注意光源立方体没受影响是因为我们对它使用了另一个着色器），也不完全是黑的。\n\n![环境光照](/img/article/20190902/3.png)\n\n# 漫反射光照\n\n环境光照本身不能提供最有趣的结果，但是漫反射光照就能开始对物体产生显著的视觉影响了。漫反射光照物体上与光线方向越接近的片段能从光源处获得更多的亮度。\n\n![漫反射光照原理图](/img/article/20190902/4.png)\n\n图左上方有一个光源，它所发出的光线落在物体的一个片段上。我们需要测量这个光线是以什么角度接触到这个片段的。如果光线垂直于物体表面，这束光对物体的影响会最大化（更亮）。为了测量光线和片段的角度，我们使用一个叫做法向量的东西，它是垂直于片段表面的一个向量（黄色箭头），这两个向量之间的角度很容易就能够通过点乘计算出来。\n\n两个单位向量的夹角越小，它们点乘的结果越倾向于1。当两个向量的夹角为90度的时候，点乘会变为0。这同样适用于θ，θ越大，光对片段颜色的影响就越小。\n\n> 为了得到两个向量夹角的余弦值，我们使用的是单位向量（长度为1的向量），所以我们需要确保所有的向量都是标准化的，否则点乘返回的就不仅仅是余弦值了。\n\n点乘返回一个标量，我们可以用它计算光线对片段颜色的影响。不同片段朝向光源的方向的不同，这些片段被照亮的情况也不同。\n\n所以，计算漫反射光照需要：\n- 法向量：一个垂直于顶点表面的向量。\n- 定向的光线：作为光源的位置与片段的位置之间向量差的方向向量。为了计算这个光线，我们需要光的位置向量和片段的位置向量。\n\n# 法向量\n\n法向量是一个垂直于顶点表面的（单位）向量。由于顶点本事并没有表面（它只是空间中一个独立的点），我们利用它周围的顶点来计算出这个顶点的表面。我们能够使用一个小技巧，使用叉乘对立方体所有的顶点计算法向量，但是由于3D立方体不是一个复杂的形状，所以我们可以简单地把发现数据手工添加到顶点数据中。如下：\n\n``` objc\nglFloat vertices[] = {\n    -0.5f, -0.5f, -0.5f,  0.0f,  0.0f, -1.0f,\n    0.5f, -0.5f, -0.5f,  0.0f,  0.0f, -1.0f,\n    0.5f,  0.5f, -0.5f,  0.0f,  0.0f, -1.0f,\n    0.5f,  0.5f, -0.5f,  0.0f,  0.0f, -1.0f,\n    -0.5f,  0.5f, -0.5f,  0.0f,  0.0f, -1.0f,\n    -0.5f, -0.5f, -0.5f,  0.0f,  0.0f, -1.0f,\n    \n    -0.5f, -0.5f,  0.5f,  0.0f,  0.0f, 1.0f,\n    0.5f, -0.5f,  0.5f,  0.0f,  0.0f, 1.0f,\n    0.5f,  0.5f,  0.5f,  0.0f,  0.0f, 1.0f,\n    0.5f,  0.5f,  0.5f,  0.0f,  0.0f, 1.0f,\n    -0.5f,  0.5f,  0.5f,  0.0f,  0.0f, 1.0f,\n    -0.5f, -0.5f,  0.5f,  0.0f,  0.0f, 1.0f,\n    \n    -0.5f,  0.5f,  0.5f, -1.0f,  0.0f,  0.0f,\n    -0.5f,  0.5f, -0.5f, -1.0f,  0.0f,  0.0f,\n    -0.5f, -0.5f, -0.5f, -1.0f,  0.0f,  0.0f,\n    -0.5f, -0.5f, -0.5f, -1.0f,  0.0f,  0.0f,\n    -0.5f, -0.5f,  0.5f, -1.0f,  0.0f,  0.0f,\n    -0.5f,  0.5f,  0.5f, -1.0f,  0.0f,  0.0f,\n    \n    0.5f,  0.5f,  0.5f,  1.0f,  0.0f,  0.0f,\n    0.5f,  0.5f, -0.5f,  1.0f,  0.0f,  0.0f,\n    0.5f, -0.5f, -0.5f,  1.0f,  0.0f,  0.0f,\n    0.5f, -0.5f, -0.5f,  1.0f,  0.0f,  0.0f,\n    0.5f, -0.5f,  0.5f,  1.0f,  0.0f,  0.0f,\n    0.5f,  0.5f,  0.5f,  1.0f,  0.0f,  0.0f,\n    \n    -0.5f, -0.5f, -0.5f,  0.0f, -1.0f,  0.0f,\n    0.5f, -0.5f, -0.5f,  0.0f, -1.0f,  0.0f,\n    0.5f, -0.5f,  0.5f,  0.0f, -1.0f,  0.0f,\n    0.5f, -0.5f,  0.5f,  0.0f, -1.0f,  0.0f,\n    -0.5f, -0.5f,  0.5f,  0.0f, -1.0f,  0.0f,\n    -0.5f, -0.5f, -0.5f,  0.0f, -1.0f,  0.0f,\n    \n    -0.5f,  0.5f, -0.5f,  0.0f,  1.0f,  0.0f,\n    0.5f,  0.5f, -0.5f,  0.0f,  1.0f,  0.0f,\n    0.5f,  0.5f,  0.5f,  0.0f,  1.0f,  0.0f,\n    0.5f,  0.5f,  0.5f,  0.0f,  1.0f,  0.0f,\n    -0.5f,  0.5f,  0.5f,  0.0f,  1.0f,  0.0f,\n    -0.5f,  0.5f, -0.5f,  0.0f,  1.0f,  0.0f\n};\n```\n\n更新后的光照顶点着色器：\n\n``` objc\nNSString *vertexShaderString = @\" \\\n#version 300 es \\\nlayout(location = 0) in vec3 a_position; \\\nlayout(location = 1) in vec3 a_normal; \\\nuniform mat4 modelMatrix; \\\nuniform mat4 viewMatrix; \\\nuniform mat4 projectionMatrix; \\\nout vec3 v_normal; \\\nvoid main() { \\\nv_normal = a_normal; \\\ngl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(a_position, 1.0); \\\n}\";\n```\n\n# 计算漫反射光照\n\n我们现在对每个顶点都有了法向量，但是我们仍需要光源的位置向量和片段的位置向量。由于光源的位置是一个静态变量，我们可以简单地在片段着色器中把它声明为`uniform`：\n\n``` objc\nuniform vec3 lightPos;\n```\n\n最后，我们还需要片段的位置。我们会在世界空间进行所有的光照计算，因此我们需要一个在世界空间中的顶点位置。我们可以通过把顶点位置属性乘以模型矩阵（不是观察和投影矩阵）来把它变换到世界空间坐标。这个在顶点着色器中很容易完成，所以我们声明一个输出变量，来计算它的世界空间坐标：\n\n``` objc\nNSString *vertexShaderString = @\" \\\n#version 300 es \\\nlayout(location = 0) in vec3 a_position; \\\nlayout(location = 1) in vec3 a_normal; \\\nuniform mat4 modelMatrix; \\\nuniform mat4 viewMatrix; \\\nuniform mat4 projectionMatrix; \\\nout vec3 v_normal; \\\nout vec3 FragPos; \\\nvoid main() { \\\nFragPos = vec3(modelMatrix * vec4(a_position, 1.0)); \\\nv_normal = a_normal; \\\ngl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(a_position, 1.0); \\\n}\";\n```\n\n最后，在片段着色器中添加对应的输入变量`FragPos`。\n\n我们需要做的第一件事是计算光源和片段位置之间的方向向量。光的方向向量是光源位置向量与片段位置向量之间的向量差。我们同样希望确保所有相关向量最后都转换为单位向量，所以需要把法线和最终的方向向量都进行标准化：\n\n``` objc\nvec3 norm = normalize(v_normal);\nvec3 lightDir = normalize(lightPos - FragPos);\n```\n\n> 当计算光照时我们通常不关心一个向量的模长或它的位置，只关心它们的方向。所以，几乎所有的计算都使用单位向量完成，因为这简化了大部分的计算（比如点乘）。所以，几乎所有的计算都使用单位向量完成，因为这简化了大部分的计算（比如点乘）。所以当进行光照计算时，确保总是对相关向量进行标准化，来保证它们是真正地单位向量。忘记对向量进行标准化是一个非常常见的错误。\n\n下一步，我们对`norm`和`lightDir`向量进行点乘，计算光源对当前片段实际的漫反射影响。结果值再乘以光的颜色，得到漫反射分量。两个向量之间的角度越大，漫反射分量就会越小：\n\n``` objc\nfloat diff = max(dot(norm, lightDir), 0.0);\nvec3 diffuse = diff * lightColor;\n```\n\n如果两个向量之间的角度大于90度，点乘的结果就会变成负数，这样会导致漫反射分量变为负数。为此，我们使用`max`函数返回两个参数之间较大的参数，从而保证漫反射分量不会变成负数。负数颜色的光照是没有定义的，所以最好避免它。\n\n现在我们有了环境光分量和漫反射分量，我们把它们相加，然后把结果乘以物体的颜色，来获得片段最后的输出颜色：\n\n``` objc\nvec3 result = (ambient + diffuse) * objectColor;\nFragColor = vec4(result, 1.0);\n```\n\n最终的片段着色器代码如下：\n\n``` objc\nNSString *fragmentShaderString = @\"\\\n#version 300 es \\\nprecision mediump float; \\\nuniform vec3 objectColor; \\\nuniform vec3 lightColor; \\\nuniform vec3 lightPos; \\\nin vec3 FragPos; \\\nin vec3 v_normal; \\\nout vec4 fragColor; \\\nvoid main() { \\\nfloat ambientStrength = 0.1; \\\nvec3 ambient = ambientStrength * lightColor; \\\nvec3 norm = normalize(v_normal); \\\nvec3 lightDir = normalize(lightPos - FragPos); \\\nfloat diff = max(dot(norm, lightDir), 0.0); \\\nvec3 diffuse = diff * lightColor; \\\nvec3 result = (ambient + diffuse) * objectColor; \\\nfragColor = vec4(result, 1.0); \\\n}\";\n```\n\n编译之后，效果图如下：\n\n![漫反射光照](/img/article/20190902/5.png)\n\n# 还有...\n\n现在我们已经把法向量从顶点着色器传到了片段着色器。可以，目前片段着色器里的计算都是在世界空间坐标系中进行的。所以，我们应该也需要把法向量转换为世界空间坐标，但这不是简单地把它乘以一个模型矩阵就能搞定的。\n\n首先，法向量只是一个方向向量，不能表达空间中的特定位置。同时，法向量没有齐次坐标（顶点位置中的w分量）。这意味着，位移不应该影响到法向量。一次，如果我们打算把法向量乘以一个模型矩阵，我们就要从矩阵中移除位移部分，只选用模型矩阵左上角3x3的矩阵（注意，我们也可以把法向量的w分量设置为0，再乘以4x4矩阵；这同样可以移除位移）。对于法向量，我们只希望对它实施缩放和旋转变换。\n\n其次，如果模型矩阵执行了不等比缩放，顶点的改变会导致法向量不再垂直于表面了。因此，我们不能用这样的模型矩阵来变换法向量。如下图应用了不等比缩放的模型矩阵对法向量的影响：\n\n![不等比缩放的模型矩阵对法向量的影响](/img/article/20190902/6.png)\n\n每当我们应用一个不等比缩放时（注意，等比缩放不会破坏法线，因为法线的方向没被改变，仅仅改变了法线的长度，而这很容易通过标准化来修复），法向量就不会再垂直于对应的表面了，这样光照就会被破坏。\n\n修复这个行为的诀窍是使用一个为法向量专门定制的模型矩阵。这个矩阵称之为法线矩阵，它使用了一些线性代数的操作来移除对法向量错误缩放的影响。\n\n法线矩阵被定义为「模型矩阵左上角的逆矩阵的转置矩阵」。注意，大部分的资源都会将法线矩阵定义为应用到模型-观察矩阵上的操作，但是由于我们只在世界空间中进行操作（不是在观察空间），我们只使用模型矩阵。\n\n在顶点着色器中，我们可以使用`inverse`和`transpose`函数自己生成这个法线矩阵，这两个函数对所有类型矩阵都有效。注意，我们还要把被处理过的矩阵强制转换为3x3矩阵，来保证它失去了位移属性以及能够乘以`vec3`的法向量：\n\n``` objc\nv_normal = mat3(transpose(inverse(model)))* a_normal;\n```\n\n在漫反射光照部分，光照表现并没有问题，这是因为我们没有对物体本身执行任何缩放操作，所以并不是必须要使用一个发现矩阵，仅仅让模型矩阵乘以法线也可以。可是，如果进行了不等比缩放，使用法线矩阵乘以法向量就是必不可少的了。\n\n> 即使是对于着色器来说，逆矩阵也是一个开销比较大的运算，因此，只要可能就应该避免在着色器中进行逆矩阵运算，它们必须为场景中的每个顶点都进行这样的处理。用作学习目的这样做是可以的，但是对于一个对效率有要求的应用来说，在绘制之前最好用CPU计算出法线矩阵，然后通过uniform把值传递给着色器（像模型矩阵一样）。\n\n# 镜面光照\n\n现在我们还需要把镜面高光加进来，这样冯氏光照才能算完整。\n\n和漫反射光照一样，镜面光照也是根据光的方向向量和物体的法向量来决定的，但是它也依赖于观察方向。镜面光照是基于光的反射特性。如果我们想象物体表面像一面镜子一样，那么无论我们从哪里去看那个表面所反射的光，镜面光照都会达到最大化：\n\n![镜面光照原理图](/img/article/20190902/7.png)\n\n我们通过反射法向量周围光的方向来计算反射向量。然后我们计算反射向量和视线方向的角度差，如果夹角越小，那么镜面光的影响就会越大。它的作用效果就是，当我们去看光被物体所反射的那个方向的时候，我们会看到一个高光。\n\n观察向量是镜面光照附加的一个变量，我们可以使用观察者世界空间位置和片段的位置来计算它。之后，我们计算镜面光强度，用它乘以光源的颜色，再将它加上环境光和漫反射分量。\n\n为了得到观察者的世界空间坐标，我们简单地使用摄像机对象的位置坐标代替（它当然就是观察者）。所以我们把另一个`uniform`添加到片段着色器，把相应的摄像机位置坐标传给片段着色器：\n\n``` objc\nuniform vec3 viewPos;\n```\n\n现在我们已经获得所有需要的变量，可以计算高光强度了。首先，我们定义一个镜面强度变量，给镜面高光一个中等亮度颜色，让它不要产生过度的影响：\n\n``` objc\nfloat specularStrength = 0.5;\n```\n\n如果我们把它设置为1.0f，我们会得到一个非常亮的镜面光分量。下一步，我们计算视线方向向量，和对应的沿着法线轴的反射向量：\n\n``` objc\nvec3 viewDir = normalize(viewPos - FragPos);\nvec3 reflectDir = reflect(-lightDir, norm);\n```\n\n需要注意的是我们对`lightDir`向量进行了取反。`reflect`函数要求第一个向量是从光源指向片段位置的向量，但是`lightDir`刚好与其相反，是从片段指向光源。为了保证我们得到正确的`reflect`向量，我们通过对`lightDir`向量取反来获得相反的方向。第二个参数要求是一个法向量，所以我们提供的是已经标准化的`norm`向量。\n\n剩下要做的是计算镜面分量：\n\n``` objc\nfloat spec = pow(max(dot(viewDir, reflectDir), 0.0), 32.0);\nvec3 specular = specularStrength * spec * lightColor;\n```\n\n我们先计算视线方向与反射方向的点乘（并确保它不是负值），然后取它的32次幂。这个32是高光的反光度。一个物体的反光度越高，反射光的能力越强，散射得越少，高光点就会越小。\n\n![不同反光度的视觉影响](/img/article/20190902/8.png)\n\n剩下的最后一件事是把它加到环境光分量和漫反射分量里，再用结果乘以物体的颜色：\n\n``` objc\nvec3 result = (ambient + diffuse + specular) * objectColor;\nFragColor = vec4(result, 1.0);\n```\n\n最终的片段着色器代码如下：\n\n``` objc\nNSString *fragmentShaderString = @\"\\\n#version 300 es \\\nprecision mediump float; \\\nuniform vec3 objectColor; \\\nuniform vec3 lightColor; \\\nuniform vec3 lightPos; \\\nuniform vec3 viewPos; \\\nin vec3 FragPos; \\\nin vec3 v_normal; \\\nout vec4 fragColor; \\\nvoid main() { \\\nfloat ambientStrength = 0.1; \\\nvec3 ambient = ambientStrength * lightColor; \\\nvec3 norm = normalize(v_normal); \\\nvec3 lightDir = normalize(lightPos - FragPos); \\\nfloat diff = max(dot(norm, lightDir), 0.0); \\\nvec3 diffuse = diff * lightColor; \\\nfloat specularStrength = 0.5; \\\nvec3 viewDir = normalize(viewPos - FragPos); \\\nvec3 reflectDir = reflect(-lightDir, norm); \\\nfloat spec = pow(max(dot(viewDir, reflectDir), 0.0), 32.0); \\\nvec3 specular = specularStrength * spec * lightColor; \\\nvec3 result = (ambient + diffuse + specular) * objectColor; \\\nfragColor = vec4(result, 1.0); \\\n}\";\n```\n\n最终的效果图如下：\n\n![镜面光照](/img/article/20190902/9.png)\n\n> 这里我没做出效果，可能是没有找到对应的观察点。。。\n\n# 总结\n\n这篇文章主要针对颜色、光照进行剖析和示例展示。","source":"_posts/2019/opengl-es-illuminate-0902.md","raw":"---\ntitle: \"OpenGL ES--光照\"\ncatalog: true\ntoc_nav_num: true\ndate: 2019-09-02 17:30:54\nsubtitle: \"About OpenGL ES\"\nheader-img: \"/img/article_header/article_header.png\"\nbusuanzi: true\ntags:\n- iOS\n\n---\n\n# 颜色\n\n现实世界中有无数种颜色，每一个物体都有它们自己的颜色。我们需要使用（有限的）数值来模拟真实世界中（无限）的颜色，所以并不是所有现实世界中的颜色都可以用数值来表示的。然而我们仍能通过数值来表现出非常多的颜色，甚至可能都不会注意到与现实的颜色有任何的差异。颜色可以数字化的由红色（Red）、绿色（Green）和蓝色（Blue）三个分量组成，它们通常被缩写为RGB。仅仅用这三个值就可以组合出任意一种颜色。\n我们在显示生活中看到某一物体的颜色并不是这个物体真正拥有的颜色，而是它所反射的（Reflected）颜色。换句话说，那些不能被物体所吸收（Absorb）的颜色（被拒绝的颜色）就是我们能够感知到的物体的颜色。例如，太阳光能被看见的白光其实是由许多不同的颜色组合而成的。如果我们将白光照在一个蓝色的玩具上，这个蓝色的玩具会吸收白光中除了蓝色以外的所有子颜色，不被吸收的蓝色光被反射到我们的眼中，让这个玩具看起来是蓝色的。\n这些颜色反射的定律被直接地运用在图形领域。当我们在OpenGL中创建一个光源时，我们希望给光源一个颜色。我们将光源设置为白色。当我们把光源的颜色与物体的颜色值相乘，所得到的就是这个物体所反射的颜色（也就是我们所感知的颜色）。在图形学中，我们将这两个颜色向量作分量相乘，结果就是最终的颜色向量：\n\n``` objc\nvec3 lightColor = vec3(1.0f, 1.0f, 1.0f);\nvec3 toyColor = vec3(1.0f, 0.5f, 0.3f);\nvec3 result = lightColor * toyColor;    // = (1.0f, 0.5f, 0.3f)\n```\n\n我们可以看到玩具的颜色吸收了白色光源中很大一部分的颜色，但它根据自身的颜色值对红、绿、蓝三个分量都做出了一定的反射。这也表现了现实中颜色的工作原理。由此，我们可以定义物体的颜色为物体从一个光源反射各个颜色分量的大小。如果我们使用绿色光源：\n\n``` objc\nvec3 lightColor = vec3(0.0f, 1.0f, 0.0f);\nvec3 toyColor = vec3(1.0f, 0.5f, 0.3f);\nvec3 result = lightColor * toyColor;    // = (0.0f, 0.5f, 0.0f)\n```\n\n可以看到，并没有红色和蓝色的光让玩具吸收或者反射。这个玩具吸收了光线中一半的绿色值，但仍然反射了一半的绿色值。玩具现在看上去是深绿色的。\n\n# 创建一个光照场景\n\n首先我们需要一个物体来作为被投光的对象--立方体箱子。还有一个立方体箱子来代表光源在3D场景中的位置。这里使用两套着色器，因为灯的颜色不应该受到物体光照计算结果的影响，所以需要将它与物体分离，不受其他颜色变化的影响。\n\n着色器代码：\n\n``` objc\nNSString *objectVertexShaderString = @\" \\\n#version 300 es \\\nlayout(location = 0) in vec3 a_position; \\\nuniform mat4 modelMatrix; \\\nuniform mat4 viewMatrix; \\\nuniform mat4 projectionMatrix; \\\nvoid main() { \\\ngl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(a_position, 1.0); \\\n}\";\nNSString *objectFragmentShaderString = @\"\\\n#version 300 es \\\nprecision mediump float; \\\nuniform vec3 objectColor; \\\nout vec4 fragColor; \\\nvoid main() { \\\nfragColor = vec4(objectColor, 1.0); \\\n}\";\n\nNSString *lightVertexShaderString = @\" \\\n#version 300 es \\\nlayout(location = 0) in vec3 a_position; \\\nuniform mat4 modelMatrix; \\\nuniform mat4 viewMatrix; \\\nuniform mat4 projectionMatrix; \\\nvoid main() { \\\ngl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(a_position, 1.0); \\\n}\";\nNSString *lightFragmentShaderString = @\"\\\n#version 300 es \\\nprecision mediump float; \\\nout vec4 fragColor; \\\nvoid main() { \\\nfragColor = vec4(1.0); \\\n}\";\n```\n\n绘制代码：\n\n``` objc\n- (void)setupVertices {\n    ...\n    顶点配置，设置缓冲\n    ...\n    // 物体顶点数组对象\n    glGenVertexArrays(1, &vao);\n    glBindVertexArray(vao);\n    glEnableVertexAttribArray(0);\n    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, sizeof(GLfloat)*6, 0);\n    glEnableVertexAttribArray(1);\n    glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, sizeof(GLfloat)*6, (GLvoid *)(sizeof(GLfloat)*3));\n    glBindVertexArray(0);\n\n    // 灯顶点数组对象\n    glGenVertexArrays(1, &lightvao);\n    glBindVertexArray(lightvao);\n    glEnableVertexAttribArray(0);\n    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, sizeof(GLfloat)*6, 0);\n    glBindVertexArray(0);\n}\n\n- (void)glkView:(GLKView *)view drawInRect:(CGRect)rect {\n    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n    glClearColor(0.0f, 0.0f, 0.0f, 1.0f);\n    \n    glUseProgram(program1);\n    \n    glBindVertexArray(vao);\n    glDrawArrays(GL_TRIANGLES, 0, 36);\n    \n    float aspect = self.view.frame.size.width / self.view.frame.size.height;\n    GLKMatrix4 modelMatrix = GLKMatrix4MakeTranslation(-0.3f, 0.2f, 1.0f);\n    GLKMatrix4 viewMatrix = GLKMatrix4MakeLookAt(-3.5f, 2.0f, 4.0f, 0.5f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f);\n    GLKMatrix4 projectionMatrx = GLKMatrix4MakePerspective(GLKMathDegreesToRadians(45), aspect, 0.1, 100.0);\n    glUniformMatrix4fv(modelLocation, 1, GL_FALSE, modelMatrix.m);\n    glUniformMatrix4fv(viewLocation, 1, GL_FALSE, viewMatrix.m);\n    glUniformMatrix4fv(projectionLocation, 1, GL_FALSE, projectionMatrx.m);\n    glUniform3f(objectLocation, 1.0f, 0.5f, 0.3f);  // objct color\n    \n    glUseProgram(program2);\n    glBindVertexArray(lightvao);\n    glDrawArrays(GL_TRIANGLES, 0, 36);\n    \n    GLKMatrix4 translateMatrix2 = GLKMatrix4MakeTranslation(3.0f, 6.6f, 2.5f);\n    GLKMatrix4 scaleMatrix2 = GLKMatrix4MakeScale(0.2f, 0.2f, 0.2f);\n    GLKMatrix4 modelMatrix2 = GLKMatrix4Multiply(scaleMatrix2, translateMatrix2);\n    glUniformMatrix4fv(modelLocation2, 1, GL_FALSE, modelMatrix2.m);\n    glUniformMatrix4fv(viewLocation2, 1, GL_FALSE, viewMatrix.m);\n    glUniformMatrix4fv(projectionLocation2, 1, GL_FALSE, projectionMatrx.m);\n}\n```\n\n这样我们就能有一个干净的光照实验场地，如下图：\n\n![干净的光照实验场地](/img/article/20190902/1.png)\n\n# 基础光照\n\n现实世界的光照是极其复杂的，而且会受到诸多因素的影响，这是我们有限的计算能力所无法比拟的。因此OpenGL的光照使用的是简化的模型，对现实的情况进行近似，这样处理起来会更容易一些，而且看起来也差不多一样。这些光照模型都是基于我们对光的物理特性的理解。其中一个模型被称为冯氏光照模型（Phong Lighting Model）。冯氏光照模型的主要结构由3个分量组成：环境（Ambient）、漫反射（Diffuse）和镜面（Specular）光照。\n\n![基础光照](/img/article/20190902/2.png)\n\n- 环境光照（Ambient Lighting）：即使在黑暗的情况下，世界上通常也仍然有一些光亮，所以物体几乎永远不会是完全黑暗的。为了模拟这个，我们会使用一个环境光照常量，它会永远给物体一些颜色。\n- 漫反射光照（Diffuse Lighting）：模拟光源对物体的方向性影响（Directional Impact）。它是冯氏光照模型中视觉上最显著的分量。物体的某一部分越是正对着光源，他就会越亮。\n- 镜面光照（Specular Lighting）：模拟有光泽物体上面出现的亮点。镜面光照的颜色相比于物体的颜色会更倾向于光的颜色。\n\n# 环境光照\n\n光通常都不是来自于同一个光源，而是来自于我们周围分散的很多光源，即使它们可能并不是那么显而易见。光的一个属性是，它可以向很多方向发散并反弹，从而能够到达不是非常直接临近的点。所以，光能够在其它的表面上反射，对一个物体产生间接的影响。考虑到这种情况的算法叫做全局照明（Global Illumination）算法，但是这种算法既开销高昂又及其复杂。\n\n由于我们现在对那种又复杂又开销高昂的算法不是很感兴趣，所以我们将会先使用一个简化的全局照明模型，即环境光照。我们使用一个很小的常量（光照）颜色，添加到物体片段的最终颜色中，这样子的话即使场景中没有直接的光源也能看起来存在有一些发散的光。\n\n把环境光照添加到场景里非常简单。我们用光的颜色乘以一个很小的常量环境因子，再乘以物体的颜色，然后将最终结果作为片段的颜色：\n\n``` objc\nNSString *objectFragmentShaderString = @\"\\\n#version 300 es \\\nprecision mediump float; \\\nuniform vec3 objectColor; \\\nuniform vec3 lightColor; \\\nout vec4 fragColor; \\\nvoid main() { \\\nfloat ambientStrength = 0.1; \\\nvec3 ambient = ambientStrength * lightColor; \\\nvec3 result = ambient * objectColor; \\\nfragColor = vec4(result, 1.0); \\\n}\";\n```\n\n效果如下图，冯氏光照的第一个阶段已经应用到我们的物体上。这个物体非常暗，但由于应用了环境光照（注意光源立方体没受影响是因为我们对它使用了另一个着色器），也不完全是黑的。\n\n![环境光照](/img/article/20190902/3.png)\n\n# 漫反射光照\n\n环境光照本身不能提供最有趣的结果，但是漫反射光照就能开始对物体产生显著的视觉影响了。漫反射光照物体上与光线方向越接近的片段能从光源处获得更多的亮度。\n\n![漫反射光照原理图](/img/article/20190902/4.png)\n\n图左上方有一个光源，它所发出的光线落在物体的一个片段上。我们需要测量这个光线是以什么角度接触到这个片段的。如果光线垂直于物体表面，这束光对物体的影响会最大化（更亮）。为了测量光线和片段的角度，我们使用一个叫做法向量的东西，它是垂直于片段表面的一个向量（黄色箭头），这两个向量之间的角度很容易就能够通过点乘计算出来。\n\n两个单位向量的夹角越小，它们点乘的结果越倾向于1。当两个向量的夹角为90度的时候，点乘会变为0。这同样适用于θ，θ越大，光对片段颜色的影响就越小。\n\n> 为了得到两个向量夹角的余弦值，我们使用的是单位向量（长度为1的向量），所以我们需要确保所有的向量都是标准化的，否则点乘返回的就不仅仅是余弦值了。\n\n点乘返回一个标量，我们可以用它计算光线对片段颜色的影响。不同片段朝向光源的方向的不同，这些片段被照亮的情况也不同。\n\n所以，计算漫反射光照需要：\n- 法向量：一个垂直于顶点表面的向量。\n- 定向的光线：作为光源的位置与片段的位置之间向量差的方向向量。为了计算这个光线，我们需要光的位置向量和片段的位置向量。\n\n# 法向量\n\n法向量是一个垂直于顶点表面的（单位）向量。由于顶点本事并没有表面（它只是空间中一个独立的点），我们利用它周围的顶点来计算出这个顶点的表面。我们能够使用一个小技巧，使用叉乘对立方体所有的顶点计算法向量，但是由于3D立方体不是一个复杂的形状，所以我们可以简单地把发现数据手工添加到顶点数据中。如下：\n\n``` objc\nglFloat vertices[] = {\n    -0.5f, -0.5f, -0.5f,  0.0f,  0.0f, -1.0f,\n    0.5f, -0.5f, -0.5f,  0.0f,  0.0f, -1.0f,\n    0.5f,  0.5f, -0.5f,  0.0f,  0.0f, -1.0f,\n    0.5f,  0.5f, -0.5f,  0.0f,  0.0f, -1.0f,\n    -0.5f,  0.5f, -0.5f,  0.0f,  0.0f, -1.0f,\n    -0.5f, -0.5f, -0.5f,  0.0f,  0.0f, -1.0f,\n    \n    -0.5f, -0.5f,  0.5f,  0.0f,  0.0f, 1.0f,\n    0.5f, -0.5f,  0.5f,  0.0f,  0.0f, 1.0f,\n    0.5f,  0.5f,  0.5f,  0.0f,  0.0f, 1.0f,\n    0.5f,  0.5f,  0.5f,  0.0f,  0.0f, 1.0f,\n    -0.5f,  0.5f,  0.5f,  0.0f,  0.0f, 1.0f,\n    -0.5f, -0.5f,  0.5f,  0.0f,  0.0f, 1.0f,\n    \n    -0.5f,  0.5f,  0.5f, -1.0f,  0.0f,  0.0f,\n    -0.5f,  0.5f, -0.5f, -1.0f,  0.0f,  0.0f,\n    -0.5f, -0.5f, -0.5f, -1.0f,  0.0f,  0.0f,\n    -0.5f, -0.5f, -0.5f, -1.0f,  0.0f,  0.0f,\n    -0.5f, -0.5f,  0.5f, -1.0f,  0.0f,  0.0f,\n    -0.5f,  0.5f,  0.5f, -1.0f,  0.0f,  0.0f,\n    \n    0.5f,  0.5f,  0.5f,  1.0f,  0.0f,  0.0f,\n    0.5f,  0.5f, -0.5f,  1.0f,  0.0f,  0.0f,\n    0.5f, -0.5f, -0.5f,  1.0f,  0.0f,  0.0f,\n    0.5f, -0.5f, -0.5f,  1.0f,  0.0f,  0.0f,\n    0.5f, -0.5f,  0.5f,  1.0f,  0.0f,  0.0f,\n    0.5f,  0.5f,  0.5f,  1.0f,  0.0f,  0.0f,\n    \n    -0.5f, -0.5f, -0.5f,  0.0f, -1.0f,  0.0f,\n    0.5f, -0.5f, -0.5f,  0.0f, -1.0f,  0.0f,\n    0.5f, -0.5f,  0.5f,  0.0f, -1.0f,  0.0f,\n    0.5f, -0.5f,  0.5f,  0.0f, -1.0f,  0.0f,\n    -0.5f, -0.5f,  0.5f,  0.0f, -1.0f,  0.0f,\n    -0.5f, -0.5f, -0.5f,  0.0f, -1.0f,  0.0f,\n    \n    -0.5f,  0.5f, -0.5f,  0.0f,  1.0f,  0.0f,\n    0.5f,  0.5f, -0.5f,  0.0f,  1.0f,  0.0f,\n    0.5f,  0.5f,  0.5f,  0.0f,  1.0f,  0.0f,\n    0.5f,  0.5f,  0.5f,  0.0f,  1.0f,  0.0f,\n    -0.5f,  0.5f,  0.5f,  0.0f,  1.0f,  0.0f,\n    -0.5f,  0.5f, -0.5f,  0.0f,  1.0f,  0.0f\n};\n```\n\n更新后的光照顶点着色器：\n\n``` objc\nNSString *vertexShaderString = @\" \\\n#version 300 es \\\nlayout(location = 0) in vec3 a_position; \\\nlayout(location = 1) in vec3 a_normal; \\\nuniform mat4 modelMatrix; \\\nuniform mat4 viewMatrix; \\\nuniform mat4 projectionMatrix; \\\nout vec3 v_normal; \\\nvoid main() { \\\nv_normal = a_normal; \\\ngl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(a_position, 1.0); \\\n}\";\n```\n\n# 计算漫反射光照\n\n我们现在对每个顶点都有了法向量，但是我们仍需要光源的位置向量和片段的位置向量。由于光源的位置是一个静态变量，我们可以简单地在片段着色器中把它声明为`uniform`：\n\n``` objc\nuniform vec3 lightPos;\n```\n\n最后，我们还需要片段的位置。我们会在世界空间进行所有的光照计算，因此我们需要一个在世界空间中的顶点位置。我们可以通过把顶点位置属性乘以模型矩阵（不是观察和投影矩阵）来把它变换到世界空间坐标。这个在顶点着色器中很容易完成，所以我们声明一个输出变量，来计算它的世界空间坐标：\n\n``` objc\nNSString *vertexShaderString = @\" \\\n#version 300 es \\\nlayout(location = 0) in vec3 a_position; \\\nlayout(location = 1) in vec3 a_normal; \\\nuniform mat4 modelMatrix; \\\nuniform mat4 viewMatrix; \\\nuniform mat4 projectionMatrix; \\\nout vec3 v_normal; \\\nout vec3 FragPos; \\\nvoid main() { \\\nFragPos = vec3(modelMatrix * vec4(a_position, 1.0)); \\\nv_normal = a_normal; \\\ngl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(a_position, 1.0); \\\n}\";\n```\n\n最后，在片段着色器中添加对应的输入变量`FragPos`。\n\n我们需要做的第一件事是计算光源和片段位置之间的方向向量。光的方向向量是光源位置向量与片段位置向量之间的向量差。我们同样希望确保所有相关向量最后都转换为单位向量，所以需要把法线和最终的方向向量都进行标准化：\n\n``` objc\nvec3 norm = normalize(v_normal);\nvec3 lightDir = normalize(lightPos - FragPos);\n```\n\n> 当计算光照时我们通常不关心一个向量的模长或它的位置，只关心它们的方向。所以，几乎所有的计算都使用单位向量完成，因为这简化了大部分的计算（比如点乘）。所以，几乎所有的计算都使用单位向量完成，因为这简化了大部分的计算（比如点乘）。所以当进行光照计算时，确保总是对相关向量进行标准化，来保证它们是真正地单位向量。忘记对向量进行标准化是一个非常常见的错误。\n\n下一步，我们对`norm`和`lightDir`向量进行点乘，计算光源对当前片段实际的漫反射影响。结果值再乘以光的颜色，得到漫反射分量。两个向量之间的角度越大，漫反射分量就会越小：\n\n``` objc\nfloat diff = max(dot(norm, lightDir), 0.0);\nvec3 diffuse = diff * lightColor;\n```\n\n如果两个向量之间的角度大于90度，点乘的结果就会变成负数，这样会导致漫反射分量变为负数。为此，我们使用`max`函数返回两个参数之间较大的参数，从而保证漫反射分量不会变成负数。负数颜色的光照是没有定义的，所以最好避免它。\n\n现在我们有了环境光分量和漫反射分量，我们把它们相加，然后把结果乘以物体的颜色，来获得片段最后的输出颜色：\n\n``` objc\nvec3 result = (ambient + diffuse) * objectColor;\nFragColor = vec4(result, 1.0);\n```\n\n最终的片段着色器代码如下：\n\n``` objc\nNSString *fragmentShaderString = @\"\\\n#version 300 es \\\nprecision mediump float; \\\nuniform vec3 objectColor; \\\nuniform vec3 lightColor; \\\nuniform vec3 lightPos; \\\nin vec3 FragPos; \\\nin vec3 v_normal; \\\nout vec4 fragColor; \\\nvoid main() { \\\nfloat ambientStrength = 0.1; \\\nvec3 ambient = ambientStrength * lightColor; \\\nvec3 norm = normalize(v_normal); \\\nvec3 lightDir = normalize(lightPos - FragPos); \\\nfloat diff = max(dot(norm, lightDir), 0.0); \\\nvec3 diffuse = diff * lightColor; \\\nvec3 result = (ambient + diffuse) * objectColor; \\\nfragColor = vec4(result, 1.0); \\\n}\";\n```\n\n编译之后，效果图如下：\n\n![漫反射光照](/img/article/20190902/5.png)\n\n# 还有...\n\n现在我们已经把法向量从顶点着色器传到了片段着色器。可以，目前片段着色器里的计算都是在世界空间坐标系中进行的。所以，我们应该也需要把法向量转换为世界空间坐标，但这不是简单地把它乘以一个模型矩阵就能搞定的。\n\n首先，法向量只是一个方向向量，不能表达空间中的特定位置。同时，法向量没有齐次坐标（顶点位置中的w分量）。这意味着，位移不应该影响到法向量。一次，如果我们打算把法向量乘以一个模型矩阵，我们就要从矩阵中移除位移部分，只选用模型矩阵左上角3x3的矩阵（注意，我们也可以把法向量的w分量设置为0，再乘以4x4矩阵；这同样可以移除位移）。对于法向量，我们只希望对它实施缩放和旋转变换。\n\n其次，如果模型矩阵执行了不等比缩放，顶点的改变会导致法向量不再垂直于表面了。因此，我们不能用这样的模型矩阵来变换法向量。如下图应用了不等比缩放的模型矩阵对法向量的影响：\n\n![不等比缩放的模型矩阵对法向量的影响](/img/article/20190902/6.png)\n\n每当我们应用一个不等比缩放时（注意，等比缩放不会破坏法线，因为法线的方向没被改变，仅仅改变了法线的长度，而这很容易通过标准化来修复），法向量就不会再垂直于对应的表面了，这样光照就会被破坏。\n\n修复这个行为的诀窍是使用一个为法向量专门定制的模型矩阵。这个矩阵称之为法线矩阵，它使用了一些线性代数的操作来移除对法向量错误缩放的影响。\n\n法线矩阵被定义为「模型矩阵左上角的逆矩阵的转置矩阵」。注意，大部分的资源都会将法线矩阵定义为应用到模型-观察矩阵上的操作，但是由于我们只在世界空间中进行操作（不是在观察空间），我们只使用模型矩阵。\n\n在顶点着色器中，我们可以使用`inverse`和`transpose`函数自己生成这个法线矩阵，这两个函数对所有类型矩阵都有效。注意，我们还要把被处理过的矩阵强制转换为3x3矩阵，来保证它失去了位移属性以及能够乘以`vec3`的法向量：\n\n``` objc\nv_normal = mat3(transpose(inverse(model)))* a_normal;\n```\n\n在漫反射光照部分，光照表现并没有问题，这是因为我们没有对物体本身执行任何缩放操作，所以并不是必须要使用一个发现矩阵，仅仅让模型矩阵乘以法线也可以。可是，如果进行了不等比缩放，使用法线矩阵乘以法向量就是必不可少的了。\n\n> 即使是对于着色器来说，逆矩阵也是一个开销比较大的运算，因此，只要可能就应该避免在着色器中进行逆矩阵运算，它们必须为场景中的每个顶点都进行这样的处理。用作学习目的这样做是可以的，但是对于一个对效率有要求的应用来说，在绘制之前最好用CPU计算出法线矩阵，然后通过uniform把值传递给着色器（像模型矩阵一样）。\n\n# 镜面光照\n\n现在我们还需要把镜面高光加进来，这样冯氏光照才能算完整。\n\n和漫反射光照一样，镜面光照也是根据光的方向向量和物体的法向量来决定的，但是它也依赖于观察方向。镜面光照是基于光的反射特性。如果我们想象物体表面像一面镜子一样，那么无论我们从哪里去看那个表面所反射的光，镜面光照都会达到最大化：\n\n![镜面光照原理图](/img/article/20190902/7.png)\n\n我们通过反射法向量周围光的方向来计算反射向量。然后我们计算反射向量和视线方向的角度差，如果夹角越小，那么镜面光的影响就会越大。它的作用效果就是，当我们去看光被物体所反射的那个方向的时候，我们会看到一个高光。\n\n观察向量是镜面光照附加的一个变量，我们可以使用观察者世界空间位置和片段的位置来计算它。之后，我们计算镜面光强度，用它乘以光源的颜色，再将它加上环境光和漫反射分量。\n\n为了得到观察者的世界空间坐标，我们简单地使用摄像机对象的位置坐标代替（它当然就是观察者）。所以我们把另一个`uniform`添加到片段着色器，把相应的摄像机位置坐标传给片段着色器：\n\n``` objc\nuniform vec3 viewPos;\n```\n\n现在我们已经获得所有需要的变量，可以计算高光强度了。首先，我们定义一个镜面强度变量，给镜面高光一个中等亮度颜色，让它不要产生过度的影响：\n\n``` objc\nfloat specularStrength = 0.5;\n```\n\n如果我们把它设置为1.0f，我们会得到一个非常亮的镜面光分量。下一步，我们计算视线方向向量，和对应的沿着法线轴的反射向量：\n\n``` objc\nvec3 viewDir = normalize(viewPos - FragPos);\nvec3 reflectDir = reflect(-lightDir, norm);\n```\n\n需要注意的是我们对`lightDir`向量进行了取反。`reflect`函数要求第一个向量是从光源指向片段位置的向量，但是`lightDir`刚好与其相反，是从片段指向光源。为了保证我们得到正确的`reflect`向量，我们通过对`lightDir`向量取反来获得相反的方向。第二个参数要求是一个法向量，所以我们提供的是已经标准化的`norm`向量。\n\n剩下要做的是计算镜面分量：\n\n``` objc\nfloat spec = pow(max(dot(viewDir, reflectDir), 0.0), 32.0);\nvec3 specular = specularStrength * spec * lightColor;\n```\n\n我们先计算视线方向与反射方向的点乘（并确保它不是负值），然后取它的32次幂。这个32是高光的反光度。一个物体的反光度越高，反射光的能力越强，散射得越少，高光点就会越小。\n\n![不同反光度的视觉影响](/img/article/20190902/8.png)\n\n剩下的最后一件事是把它加到环境光分量和漫反射分量里，再用结果乘以物体的颜色：\n\n``` objc\nvec3 result = (ambient + diffuse + specular) * objectColor;\nFragColor = vec4(result, 1.0);\n```\n\n最终的片段着色器代码如下：\n\n``` objc\nNSString *fragmentShaderString = @\"\\\n#version 300 es \\\nprecision mediump float; \\\nuniform vec3 objectColor; \\\nuniform vec3 lightColor; \\\nuniform vec3 lightPos; \\\nuniform vec3 viewPos; \\\nin vec3 FragPos; \\\nin vec3 v_normal; \\\nout vec4 fragColor; \\\nvoid main() { \\\nfloat ambientStrength = 0.1; \\\nvec3 ambient = ambientStrength * lightColor; \\\nvec3 norm = normalize(v_normal); \\\nvec3 lightDir = normalize(lightPos - FragPos); \\\nfloat diff = max(dot(norm, lightDir), 0.0); \\\nvec3 diffuse = diff * lightColor; \\\nfloat specularStrength = 0.5; \\\nvec3 viewDir = normalize(viewPos - FragPos); \\\nvec3 reflectDir = reflect(-lightDir, norm); \\\nfloat spec = pow(max(dot(viewDir, reflectDir), 0.0), 32.0); \\\nvec3 specular = specularStrength * spec * lightColor; \\\nvec3 result = (ambient + diffuse + specular) * objectColor; \\\nfragColor = vec4(result, 1.0); \\\n}\";\n```\n\n最终的效果图如下：\n\n![镜面光照](/img/article/20190902/9.png)\n\n> 这里我没做出效果，可能是没有找到对应的观察点。。。\n\n# 总结\n\n这篇文章主要针对颜色、光照进行剖析和示例展示。","slug":"2019/opengl-es-illuminate-0902","published":1,"updated":"2022-01-10T09:04:52.806Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cky8gmc4b000zd1qha1azfdds","content":"<h1 id=\"颜色\">颜色</h1>\n<p>现实世界中有无数种颜色，每一个物体都有它们自己的颜色。我们需要使用（有限的）数值来模拟真实世界中（无限）的颜色，所以并不是所有现实世界中的颜色都可以用数值来表示的。然而我们仍能通过数值来表现出非常多的颜色，甚至可能都不会注意到与现实的颜色有任何的差异。颜色可以数字化的由红色（Red）、绿色（Green）和蓝色（Blue）三个分量组成，它们通常被缩写为RGB。仅仅用这三个值就可以组合出任意一种颜色。<br>\n我们在显示生活中看到某一物体的颜色并不是这个物体真正拥有的颜色，而是它所反射的（Reflected）颜色。换句话说，那些不能被物体所吸收（Absorb）的颜色（被拒绝的颜色）就是我们能够感知到的物体的颜色。例如，太阳光能被看见的白光其实是由许多不同的颜色组合而成的。如果我们将白光照在一个蓝色的玩具上，这个蓝色的玩具会吸收白光中除了蓝色以外的所有子颜色，不被吸收的蓝色光被反射到我们的眼中，让这个玩具看起来是蓝色的。<br>\n这些颜色反射的定律被直接地运用在图形领域。当我们在OpenGL中创建一个光源时，我们希望给光源一个颜色。我们将光源设置为白色。当我们把光源的颜色与物体的颜色值相乘，所得到的就是这个物体所反射的颜色（也就是我们所感知的颜色）。在图形学中，我们将这两个颜色向量作分量相乘，结果就是最终的颜色向量：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vec3 lightColor = vec3(<span class=\"number\">1.0</span>f, <span class=\"number\">1.0</span>f, <span class=\"number\">1.0</span>f);</span><br><span class=\"line\">vec3 toyColor = vec3(<span class=\"number\">1.0</span>f, <span class=\"number\">0.5</span>f, <span class=\"number\">0.3</span>f);</span><br><span class=\"line\">vec3 result = lightColor * toyColor;    <span class=\"comment\">// = (1.0f, 0.5f, 0.3f)</span></span><br></pre></td></tr></table></figure>\n<p>我们可以看到玩具的颜色吸收了白色光源中很大一部分的颜色，但它根据自身的颜色值对红、绿、蓝三个分量都做出了一定的反射。这也表现了现实中颜色的工作原理。由此，我们可以定义物体的颜色为物体从一个光源反射各个颜色分量的大小。如果我们使用绿色光源：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vec3 lightColor = vec3(<span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f, <span class=\"number\">0.0</span>f);</span><br><span class=\"line\">vec3 toyColor = vec3(<span class=\"number\">1.0</span>f, <span class=\"number\">0.5</span>f, <span class=\"number\">0.3</span>f);</span><br><span class=\"line\">vec3 result = lightColor * toyColor;    <span class=\"comment\">// = (0.0f, 0.5f, 0.0f)</span></span><br></pre></td></tr></table></figure>\n<p>可以看到，并没有红色和蓝色的光让玩具吸收或者反射。这个玩具吸收了光线中一半的绿色值，但仍然反射了一半的绿色值。玩具现在看上去是深绿色的。</p>\n<h1 id=\"创建一个光照场景\">创建一个光照场景</h1>\n<p>首先我们需要一个物体来作为被投光的对象–立方体箱子。还有一个立方体箱子来代表光源在3D场景中的位置。这里使用两套着色器，因为灯的颜色不应该受到物体光照计算结果的影响，所以需要将它与物体分离，不受其他颜色变化的影响。</p>\n<p>着色器代码：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSString</span> *objectVertexShaderString = <span class=\"string\">@\" \\</span></span><br><span class=\"line\"><span class=\"string\">#version 300 es \\</span></span><br><span class=\"line\"><span class=\"string\">layout(location = 0) in vec3 a_position; \\</span></span><br><span class=\"line\"><span class=\"string\">uniform mat4 modelMatrix; \\</span></span><br><span class=\"line\"><span class=\"string\">uniform mat4 viewMatrix; \\</span></span><br><span class=\"line\"><span class=\"string\">uniform mat4 projectionMatrix; \\</span></span><br><span class=\"line\"><span class=\"string\">void main() &#123; \\</span></span><br><span class=\"line\"><span class=\"string\">gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(a_position, 1.0); \\</span></span><br><span class=\"line\"><span class=\"string\">&#125;\"</span>;</span><br><span class=\"line\"><span class=\"built_in\">NSString</span> *objectFragmentShaderString = <span class=\"string\">@\"\\</span></span><br><span class=\"line\"><span class=\"string\">#version 300 es \\</span></span><br><span class=\"line\"><span class=\"string\">precision mediump float; \\</span></span><br><span class=\"line\"><span class=\"string\">uniform vec3 objectColor; \\</span></span><br><span class=\"line\"><span class=\"string\">out vec4 fragColor; \\</span></span><br><span class=\"line\"><span class=\"string\">void main() &#123; \\</span></span><br><span class=\"line\"><span class=\"string\">fragColor = vec4(objectColor, 1.0); \\</span></span><br><span class=\"line\"><span class=\"string\">&#125;\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">NSString</span> *lightVertexShaderString = <span class=\"string\">@\" \\</span></span><br><span class=\"line\"><span class=\"string\">#version 300 es \\</span></span><br><span class=\"line\"><span class=\"string\">layout(location = 0) in vec3 a_position; \\</span></span><br><span class=\"line\"><span class=\"string\">uniform mat4 modelMatrix; \\</span></span><br><span class=\"line\"><span class=\"string\">uniform mat4 viewMatrix; \\</span></span><br><span class=\"line\"><span class=\"string\">uniform mat4 projectionMatrix; \\</span></span><br><span class=\"line\"><span class=\"string\">void main() &#123; \\</span></span><br><span class=\"line\"><span class=\"string\">gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(a_position, 1.0); \\</span></span><br><span class=\"line\"><span class=\"string\">&#125;\"</span>;</span><br><span class=\"line\"><span class=\"built_in\">NSString</span> *lightFragmentShaderString = <span class=\"string\">@\"\\</span></span><br><span class=\"line\"><span class=\"string\">#version 300 es \\</span></span><br><span class=\"line\"><span class=\"string\">precision mediump float; \\</span></span><br><span class=\"line\"><span class=\"string\">out vec4 fragColor; \\</span></span><br><span class=\"line\"><span class=\"string\">void main() &#123; \\</span></span><br><span class=\"line\"><span class=\"string\">fragColor = vec4(1.0); \\</span></span><br><span class=\"line\"><span class=\"string\">&#125;\"</span>;</span><br></pre></td></tr></table></figure>\n<p>绘制代码：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)setupVertices &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    顶点配置，设置缓冲</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\">// 物体顶点数组对象</span></span><br><span class=\"line\">    glGenVertexArrays(<span class=\"number\">1</span>, &amp;vao);</span><br><span class=\"line\">    glBindVertexArray(vao);</span><br><span class=\"line\">    glEnableVertexAttribArray(<span class=\"number\">0</span>);</span><br><span class=\"line\">    glVertexAttribPointer(<span class=\"number\">0</span>, <span class=\"number\">3</span>, GL_FLOAT, GL_FALSE, <span class=\"keyword\">sizeof</span>(GLfloat)*<span class=\"number\">6</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    glEnableVertexAttribArray(<span class=\"number\">1</span>);</span><br><span class=\"line\">    glVertexAttribPointer(<span class=\"number\">1</span>, <span class=\"number\">3</span>, GL_FLOAT, GL_FALSE, <span class=\"keyword\">sizeof</span>(GLfloat)*<span class=\"number\">6</span>, (GLvoid *)(<span class=\"keyword\">sizeof</span>(GLfloat)*<span class=\"number\">3</span>));</span><br><span class=\"line\">    glBindVertexArray(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 灯顶点数组对象</span></span><br><span class=\"line\">    glGenVertexArrays(<span class=\"number\">1</span>, &amp;lightvao);</span><br><span class=\"line\">    glBindVertexArray(lightvao);</span><br><span class=\"line\">    glEnableVertexAttribArray(<span class=\"number\">0</span>);</span><br><span class=\"line\">    glVertexAttribPointer(<span class=\"number\">0</span>, <span class=\"number\">3</span>, GL_FLOAT, GL_FALSE, <span class=\"keyword\">sizeof</span>(GLfloat)*<span class=\"number\">6</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    glBindVertexArray(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)glkView:(GLKView *)view drawInRect:(<span class=\"built_in\">CGRect</span>)rect &#123;</span><br><span class=\"line\">    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span><br><span class=\"line\">    glClearColor(<span class=\"number\">0.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f);</span><br><span class=\"line\">    </span><br><span class=\"line\">    glUseProgram(program1);</span><br><span class=\"line\">    </span><br><span class=\"line\">    glBindVertexArray(vao);</span><br><span class=\"line\">    glDrawArrays(GL_TRIANGLES, <span class=\"number\">0</span>, <span class=\"number\">36</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">float</span> aspect = <span class=\"keyword\">self</span>.view.frame.size.width / <span class=\"keyword\">self</span>.view.frame.size.height;</span><br><span class=\"line\">    GLKMatrix4 modelMatrix = GLKMatrix4MakeTranslation(<span class=\"number\">-0.3</span>f, <span class=\"number\">0.2</span>f, <span class=\"number\">1.0</span>f);</span><br><span class=\"line\">    GLKMatrix4 viewMatrix = GLKMatrix4MakeLookAt(<span class=\"number\">-3.5</span>f, <span class=\"number\">2.0</span>f, <span class=\"number\">4.0</span>f, <span class=\"number\">0.5</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f, <span class=\"number\">0.0</span>f);</span><br><span class=\"line\">    GLKMatrix4 projectionMatrx = GLKMatrix4MakePerspective(GLKMathDegreesToRadians(<span class=\"number\">45</span>), aspect, <span class=\"number\">0.1</span>, <span class=\"number\">100.0</span>);</span><br><span class=\"line\">    glUniformMatrix4fv(modelLocation, <span class=\"number\">1</span>, GL_FALSE, modelMatrix.m);</span><br><span class=\"line\">    glUniformMatrix4fv(viewLocation, <span class=\"number\">1</span>, GL_FALSE, viewMatrix.m);</span><br><span class=\"line\">    glUniformMatrix4fv(projectionLocation, <span class=\"number\">1</span>, GL_FALSE, projectionMatrx.m);</span><br><span class=\"line\">    glUniform3f(objectLocation, <span class=\"number\">1.0</span>f, <span class=\"number\">0.5</span>f, <span class=\"number\">0.3</span>f);  <span class=\"comment\">// objct color</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    glUseProgram(program2);</span><br><span class=\"line\">    glBindVertexArray(lightvao);</span><br><span class=\"line\">    glDrawArrays(GL_TRIANGLES, <span class=\"number\">0</span>, <span class=\"number\">36</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    GLKMatrix4 translateMatrix2 = GLKMatrix4MakeTranslation(<span class=\"number\">3.0</span>f, <span class=\"number\">6.6</span>f, <span class=\"number\">2.5</span>f);</span><br><span class=\"line\">    GLKMatrix4 scaleMatrix2 = GLKMatrix4MakeScale(<span class=\"number\">0.2</span>f, <span class=\"number\">0.2</span>f, <span class=\"number\">0.2</span>f);</span><br><span class=\"line\">    GLKMatrix4 modelMatrix2 = GLKMatrix4Multiply(scaleMatrix2, translateMatrix2);</span><br><span class=\"line\">    glUniformMatrix4fv(modelLocation2, <span class=\"number\">1</span>, GL_FALSE, modelMatrix2.m);</span><br><span class=\"line\">    glUniformMatrix4fv(viewLocation2, <span class=\"number\">1</span>, GL_FALSE, viewMatrix.m);</span><br><span class=\"line\">    glUniformMatrix4fv(projectionLocation2, <span class=\"number\">1</span>, GL_FALSE, projectionMatrx.m);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样我们就能有一个干净的光照实验场地，如下图：</p>\n<p><img src=\"/img/article/20190902/1.png\" alt=\"干净的光照实验场地\"></p>\n<h1 id=\"基础光照\">基础光照</h1>\n<p>现实世界的光照是极其复杂的，而且会受到诸多因素的影响，这是我们有限的计算能力所无法比拟的。因此OpenGL的光照使用的是简化的模型，对现实的情况进行近似，这样处理起来会更容易一些，而且看起来也差不多一样。这些光照模型都是基于我们对光的物理特性的理解。其中一个模型被称为冯氏光照模型（Phong Lighting Model）。冯氏光照模型的主要结构由3个分量组成：环境（Ambient）、漫反射（Diffuse）和镜面（Specular）光照。</p>\n<p><img src=\"/img/article/20190902/2.png\" alt=\"基础光照\"></p>\n<ul>\n<li>环境光照（Ambient Lighting）：即使在黑暗的情况下，世界上通常也仍然有一些光亮，所以物体几乎永远不会是完全黑暗的。为了模拟这个，我们会使用一个环境光照常量，它会永远给物体一些颜色。</li>\n<li>漫反射光照（Diffuse Lighting）：模拟光源对物体的方向性影响（Directional Impact）。它是冯氏光照模型中视觉上最显著的分量。物体的某一部分越是正对着光源，他就会越亮。</li>\n<li>镜面光照（Specular Lighting）：模拟有光泽物体上面出现的亮点。镜面光照的颜色相比于物体的颜色会更倾向于光的颜色。</li>\n</ul>\n<h1 id=\"环境光照\">环境光照</h1>\n<p>光通常都不是来自于同一个光源，而是来自于我们周围分散的很多光源，即使它们可能并不是那么显而易见。光的一个属性是，它可以向很多方向发散并反弹，从而能够到达不是非常直接临近的点。所以，光能够在其它的表面上反射，对一个物体产生间接的影响。考虑到这种情况的算法叫做全局照明（Global Illumination）算法，但是这种算法既开销高昂又及其复杂。</p>\n<p>由于我们现在对那种又复杂又开销高昂的算法不是很感兴趣，所以我们将会先使用一个简化的全局照明模型，即环境光照。我们使用一个很小的常量（光照）颜色，添加到物体片段的最终颜色中，这样子的话即使场景中没有直接的光源也能看起来存在有一些发散的光。</p>\n<p>把环境光照添加到场景里非常简单。我们用光的颜色乘以一个很小的常量环境因子，再乘以物体的颜色，然后将最终结果作为片段的颜色：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSString</span> *objectFragmentShaderString = <span class=\"string\">@\"\\</span></span><br><span class=\"line\"><span class=\"string\">#version 300 es \\</span></span><br><span class=\"line\"><span class=\"string\">precision mediump float; \\</span></span><br><span class=\"line\"><span class=\"string\">uniform vec3 objectColor; \\</span></span><br><span class=\"line\"><span class=\"string\">uniform vec3 lightColor; \\</span></span><br><span class=\"line\"><span class=\"string\">out vec4 fragColor; \\</span></span><br><span class=\"line\"><span class=\"string\">void main() &#123; \\</span></span><br><span class=\"line\"><span class=\"string\">float ambientStrength = 0.1; \\</span></span><br><span class=\"line\"><span class=\"string\">vec3 ambient = ambientStrength * lightColor; \\</span></span><br><span class=\"line\"><span class=\"string\">vec3 result = ambient * objectColor; \\</span></span><br><span class=\"line\"><span class=\"string\">fragColor = vec4(result, 1.0); \\</span></span><br><span class=\"line\"><span class=\"string\">&#125;\"</span>;</span><br></pre></td></tr></table></figure>\n<p>效果如下图，冯氏光照的第一个阶段已经应用到我们的物体上。这个物体非常暗，但由于应用了环境光照（注意光源立方体没受影响是因为我们对它使用了另一个着色器），也不完全是黑的。</p>\n<p><img src=\"/img/article/20190902/3.png\" alt=\"环境光照\"></p>\n<h1 id=\"漫反射光照\">漫反射光照</h1>\n<p>环境光照本身不能提供最有趣的结果，但是漫反射光照就能开始对物体产生显著的视觉影响了。漫反射光照物体上与光线方向越接近的片段能从光源处获得更多的亮度。</p>\n<p><img src=\"/img/article/20190902/4.png\" alt=\"漫反射光照原理图\"></p>\n<p>图左上方有一个光源，它所发出的光线落在物体的一个片段上。我们需要测量这个光线是以什么角度接触到这个片段的。如果光线垂直于物体表面，这束光对物体的影响会最大化（更亮）。为了测量光线和片段的角度，我们使用一个叫做法向量的东西，它是垂直于片段表面的一个向量（黄色箭头），这两个向量之间的角度很容易就能够通过点乘计算出来。</p>\n<p>两个单位向量的夹角越小，它们点乘的结果越倾向于1。当两个向量的夹角为90度的时候，点乘会变为0。这同样适用于θ，θ越大，光对片段颜色的影响就越小。</p>\n<blockquote>\n<p>为了得到两个向量夹角的余弦值，我们使用的是单位向量（长度为1的向量），所以我们需要确保所有的向量都是标准化的，否则点乘返回的就不仅仅是余弦值了。</p>\n</blockquote>\n<p>点乘返回一个标量，我们可以用它计算光线对片段颜色的影响。不同片段朝向光源的方向的不同，这些片段被照亮的情况也不同。</p>\n<p>所以，计算漫反射光照需要：</p>\n<ul>\n<li>法向量：一个垂直于顶点表面的向量。</li>\n<li>定向的光线：作为光源的位置与片段的位置之间向量差的方向向量。为了计算这个光线，我们需要光的位置向量和片段的位置向量。</li>\n</ul>\n<h1 id=\"法向量\">法向量</h1>\n<p>法向量是一个垂直于顶点表面的（单位）向量。由于顶点本事并没有表面（它只是空间中一个独立的点），我们利用它周围的顶点来计算出这个顶点的表面。我们能够使用一个小技巧，使用叉乘对立方体所有的顶点计算法向量，但是由于3D立方体不是一个复杂的形状，所以我们可以简单地把发现数据手工添加到顶点数据中。如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">glFloat vertices[] = &#123;</span><br><span class=\"line\">    <span class=\"number\">-0.5</span>f, <span class=\"number\">-0.5</span>f, <span class=\"number\">-0.5</span>f,  <span class=\"number\">0.0</span>f,  <span class=\"number\">0.0</span>f, <span class=\"number\">-1.0</span>f,</span><br><span class=\"line\">    <span class=\"number\">0.5</span>f, <span class=\"number\">-0.5</span>f, <span class=\"number\">-0.5</span>f,  <span class=\"number\">0.0</span>f,  <span class=\"number\">0.0</span>f, <span class=\"number\">-1.0</span>f,</span><br><span class=\"line\">    <span class=\"number\">0.5</span>f,  <span class=\"number\">0.5</span>f, <span class=\"number\">-0.5</span>f,  <span class=\"number\">0.0</span>f,  <span class=\"number\">0.0</span>f, <span class=\"number\">-1.0</span>f,</span><br><span class=\"line\">    <span class=\"number\">0.5</span>f,  <span class=\"number\">0.5</span>f, <span class=\"number\">-0.5</span>f,  <span class=\"number\">0.0</span>f,  <span class=\"number\">0.0</span>f, <span class=\"number\">-1.0</span>f,</span><br><span class=\"line\">    <span class=\"number\">-0.5</span>f,  <span class=\"number\">0.5</span>f, <span class=\"number\">-0.5</span>f,  <span class=\"number\">0.0</span>f,  <span class=\"number\">0.0</span>f, <span class=\"number\">-1.0</span>f,</span><br><span class=\"line\">    <span class=\"number\">-0.5</span>f, <span class=\"number\">-0.5</span>f, <span class=\"number\">-0.5</span>f,  <span class=\"number\">0.0</span>f,  <span class=\"number\">0.0</span>f, <span class=\"number\">-1.0</span>f,</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"number\">-0.5</span>f, <span class=\"number\">-0.5</span>f,  <span class=\"number\">0.5</span>f,  <span class=\"number\">0.0</span>f,  <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f,</span><br><span class=\"line\">    <span class=\"number\">0.5</span>f, <span class=\"number\">-0.5</span>f,  <span class=\"number\">0.5</span>f,  <span class=\"number\">0.0</span>f,  <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f,</span><br><span class=\"line\">    <span class=\"number\">0.5</span>f,  <span class=\"number\">0.5</span>f,  <span class=\"number\">0.5</span>f,  <span class=\"number\">0.0</span>f,  <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f,</span><br><span class=\"line\">    <span class=\"number\">0.5</span>f,  <span class=\"number\">0.5</span>f,  <span class=\"number\">0.5</span>f,  <span class=\"number\">0.0</span>f,  <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f,</span><br><span class=\"line\">    <span class=\"number\">-0.5</span>f,  <span class=\"number\">0.5</span>f,  <span class=\"number\">0.5</span>f,  <span class=\"number\">0.0</span>f,  <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f,</span><br><span class=\"line\">    <span class=\"number\">-0.5</span>f, <span class=\"number\">-0.5</span>f,  <span class=\"number\">0.5</span>f,  <span class=\"number\">0.0</span>f,  <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f,</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"number\">-0.5</span>f,  <span class=\"number\">0.5</span>f,  <span class=\"number\">0.5</span>f, <span class=\"number\">-1.0</span>f,  <span class=\"number\">0.0</span>f,  <span class=\"number\">0.0</span>f,</span><br><span class=\"line\">    <span class=\"number\">-0.5</span>f,  <span class=\"number\">0.5</span>f, <span class=\"number\">-0.5</span>f, <span class=\"number\">-1.0</span>f,  <span class=\"number\">0.0</span>f,  <span class=\"number\">0.0</span>f,</span><br><span class=\"line\">    <span class=\"number\">-0.5</span>f, <span class=\"number\">-0.5</span>f, <span class=\"number\">-0.5</span>f, <span class=\"number\">-1.0</span>f,  <span class=\"number\">0.0</span>f,  <span class=\"number\">0.0</span>f,</span><br><span class=\"line\">    <span class=\"number\">-0.5</span>f, <span class=\"number\">-0.5</span>f, <span class=\"number\">-0.5</span>f, <span class=\"number\">-1.0</span>f,  <span class=\"number\">0.0</span>f,  <span class=\"number\">0.0</span>f,</span><br><span class=\"line\">    <span class=\"number\">-0.5</span>f, <span class=\"number\">-0.5</span>f,  <span class=\"number\">0.5</span>f, <span class=\"number\">-1.0</span>f,  <span class=\"number\">0.0</span>f,  <span class=\"number\">0.0</span>f,</span><br><span class=\"line\">    <span class=\"number\">-0.5</span>f,  <span class=\"number\">0.5</span>f,  <span class=\"number\">0.5</span>f, <span class=\"number\">-1.0</span>f,  <span class=\"number\">0.0</span>f,  <span class=\"number\">0.0</span>f,</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"number\">0.5</span>f,  <span class=\"number\">0.5</span>f,  <span class=\"number\">0.5</span>f,  <span class=\"number\">1.0</span>f,  <span class=\"number\">0.0</span>f,  <span class=\"number\">0.0</span>f,</span><br><span class=\"line\">    <span class=\"number\">0.5</span>f,  <span class=\"number\">0.5</span>f, <span class=\"number\">-0.5</span>f,  <span class=\"number\">1.0</span>f,  <span class=\"number\">0.0</span>f,  <span class=\"number\">0.0</span>f,</span><br><span class=\"line\">    <span class=\"number\">0.5</span>f, <span class=\"number\">-0.5</span>f, <span class=\"number\">-0.5</span>f,  <span class=\"number\">1.0</span>f,  <span class=\"number\">0.0</span>f,  <span class=\"number\">0.0</span>f,</span><br><span class=\"line\">    <span class=\"number\">0.5</span>f, <span class=\"number\">-0.5</span>f, <span class=\"number\">-0.5</span>f,  <span class=\"number\">1.0</span>f,  <span class=\"number\">0.0</span>f,  <span class=\"number\">0.0</span>f,</span><br><span class=\"line\">    <span class=\"number\">0.5</span>f, <span class=\"number\">-0.5</span>f,  <span class=\"number\">0.5</span>f,  <span class=\"number\">1.0</span>f,  <span class=\"number\">0.0</span>f,  <span class=\"number\">0.0</span>f,</span><br><span class=\"line\">    <span class=\"number\">0.5</span>f,  <span class=\"number\">0.5</span>f,  <span class=\"number\">0.5</span>f,  <span class=\"number\">1.0</span>f,  <span class=\"number\">0.0</span>f,  <span class=\"number\">0.0</span>f,</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"number\">-0.5</span>f, <span class=\"number\">-0.5</span>f, <span class=\"number\">-0.5</span>f,  <span class=\"number\">0.0</span>f, <span class=\"number\">-1.0</span>f,  <span class=\"number\">0.0</span>f,</span><br><span class=\"line\">    <span class=\"number\">0.5</span>f, <span class=\"number\">-0.5</span>f, <span class=\"number\">-0.5</span>f,  <span class=\"number\">0.0</span>f, <span class=\"number\">-1.0</span>f,  <span class=\"number\">0.0</span>f,</span><br><span class=\"line\">    <span class=\"number\">0.5</span>f, <span class=\"number\">-0.5</span>f,  <span class=\"number\">0.5</span>f,  <span class=\"number\">0.0</span>f, <span class=\"number\">-1.0</span>f,  <span class=\"number\">0.0</span>f,</span><br><span class=\"line\">    <span class=\"number\">0.5</span>f, <span class=\"number\">-0.5</span>f,  <span class=\"number\">0.5</span>f,  <span class=\"number\">0.0</span>f, <span class=\"number\">-1.0</span>f,  <span class=\"number\">0.0</span>f,</span><br><span class=\"line\">    <span class=\"number\">-0.5</span>f, <span class=\"number\">-0.5</span>f,  <span class=\"number\">0.5</span>f,  <span class=\"number\">0.0</span>f, <span class=\"number\">-1.0</span>f,  <span class=\"number\">0.0</span>f,</span><br><span class=\"line\">    <span class=\"number\">-0.5</span>f, <span class=\"number\">-0.5</span>f, <span class=\"number\">-0.5</span>f,  <span class=\"number\">0.0</span>f, <span class=\"number\">-1.0</span>f,  <span class=\"number\">0.0</span>f,</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"number\">-0.5</span>f,  <span class=\"number\">0.5</span>f, <span class=\"number\">-0.5</span>f,  <span class=\"number\">0.0</span>f,  <span class=\"number\">1.0</span>f,  <span class=\"number\">0.0</span>f,</span><br><span class=\"line\">    <span class=\"number\">0.5</span>f,  <span class=\"number\">0.5</span>f, <span class=\"number\">-0.5</span>f,  <span class=\"number\">0.0</span>f,  <span class=\"number\">1.0</span>f,  <span class=\"number\">0.0</span>f,</span><br><span class=\"line\">    <span class=\"number\">0.5</span>f,  <span class=\"number\">0.5</span>f,  <span class=\"number\">0.5</span>f,  <span class=\"number\">0.0</span>f,  <span class=\"number\">1.0</span>f,  <span class=\"number\">0.0</span>f,</span><br><span class=\"line\">    <span class=\"number\">0.5</span>f,  <span class=\"number\">0.5</span>f,  <span class=\"number\">0.5</span>f,  <span class=\"number\">0.0</span>f,  <span class=\"number\">1.0</span>f,  <span class=\"number\">0.0</span>f,</span><br><span class=\"line\">    <span class=\"number\">-0.5</span>f,  <span class=\"number\">0.5</span>f,  <span class=\"number\">0.5</span>f,  <span class=\"number\">0.0</span>f,  <span class=\"number\">1.0</span>f,  <span class=\"number\">0.0</span>f,</span><br><span class=\"line\">    <span class=\"number\">-0.5</span>f,  <span class=\"number\">0.5</span>f, <span class=\"number\">-0.5</span>f,  <span class=\"number\">0.0</span>f,  <span class=\"number\">1.0</span>f,  <span class=\"number\">0.0</span>f</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>更新后的光照顶点着色器：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSString</span> *vertexShaderString = <span class=\"string\">@\" \\</span></span><br><span class=\"line\"><span class=\"string\">#version 300 es \\</span></span><br><span class=\"line\"><span class=\"string\">layout(location = 0) in vec3 a_position; \\</span></span><br><span class=\"line\"><span class=\"string\">layout(location = 1) in vec3 a_normal; \\</span></span><br><span class=\"line\"><span class=\"string\">uniform mat4 modelMatrix; \\</span></span><br><span class=\"line\"><span class=\"string\">uniform mat4 viewMatrix; \\</span></span><br><span class=\"line\"><span class=\"string\">uniform mat4 projectionMatrix; \\</span></span><br><span class=\"line\"><span class=\"string\">out vec3 v_normal; \\</span></span><br><span class=\"line\"><span class=\"string\">void main() &#123; \\</span></span><br><span class=\"line\"><span class=\"string\">v_normal = a_normal; \\</span></span><br><span class=\"line\"><span class=\"string\">gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(a_position, 1.0); \\</span></span><br><span class=\"line\"><span class=\"string\">&#125;\"</span>;</span><br></pre></td></tr></table></figure>\n<h1 id=\"计算漫反射光照\">计算漫反射光照</h1>\n<p>我们现在对每个顶点都有了法向量，但是我们仍需要光源的位置向量和片段的位置向量。由于光源的位置是一个静态变量，我们可以简单地在片段着色器中把它声明为<code>uniform</code>：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">uniform vec3 lightPos;</span><br></pre></td></tr></table></figure>\n<p>最后，我们还需要片段的位置。我们会在世界空间进行所有的光照计算，因此我们需要一个在世界空间中的顶点位置。我们可以通过把顶点位置属性乘以模型矩阵（不是观察和投影矩阵）来把它变换到世界空间坐标。这个在顶点着色器中很容易完成，所以我们声明一个输出变量，来计算它的世界空间坐标：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSString</span> *vertexShaderString = <span class=\"string\">@\" \\</span></span><br><span class=\"line\"><span class=\"string\">#version 300 es \\</span></span><br><span class=\"line\"><span class=\"string\">layout(location = 0) in vec3 a_position; \\</span></span><br><span class=\"line\"><span class=\"string\">layout(location = 1) in vec3 a_normal; \\</span></span><br><span class=\"line\"><span class=\"string\">uniform mat4 modelMatrix; \\</span></span><br><span class=\"line\"><span class=\"string\">uniform mat4 viewMatrix; \\</span></span><br><span class=\"line\"><span class=\"string\">uniform mat4 projectionMatrix; \\</span></span><br><span class=\"line\"><span class=\"string\">out vec3 v_normal; \\</span></span><br><span class=\"line\"><span class=\"string\">out vec3 FragPos; \\</span></span><br><span class=\"line\"><span class=\"string\">void main() &#123; \\</span></span><br><span class=\"line\"><span class=\"string\">FragPos = vec3(modelMatrix * vec4(a_position, 1.0)); \\</span></span><br><span class=\"line\"><span class=\"string\">v_normal = a_normal; \\</span></span><br><span class=\"line\"><span class=\"string\">gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(a_position, 1.0); \\</span></span><br><span class=\"line\"><span class=\"string\">&#125;\"</span>;</span><br></pre></td></tr></table></figure>\n<p>最后，在片段着色器中添加对应的输入变量<code>FragPos</code>。</p>\n<p>我们需要做的第一件事是计算光源和片段位置之间的方向向量。光的方向向量是光源位置向量与片段位置向量之间的向量差。我们同样希望确保所有相关向量最后都转换为单位向量，所以需要把法线和最终的方向向量都进行标准化：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vec3 norm = normalize(v_normal);</span><br><span class=\"line\">vec3 lightDir = normalize(lightPos - FragPos);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>当计算光照时我们通常不关心一个向量的模长或它的位置，只关心它们的方向。所以，几乎所有的计算都使用单位向量完成，因为这简化了大部分的计算（比如点乘）。所以，几乎所有的计算都使用单位向量完成，因为这简化了大部分的计算（比如点乘）。所以当进行光照计算时，确保总是对相关向量进行标准化，来保证它们是真正地单位向量。忘记对向量进行标准化是一个非常常见的错误。</p>\n</blockquote>\n<p>下一步，我们对<code>norm</code>和<code>lightDir</code>向量进行点乘，计算光源对当前片段实际的漫反射影响。结果值再乘以光的颜色，得到漫反射分量。两个向量之间的角度越大，漫反射分量就会越小：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">float</span> diff = max(dot(norm, lightDir), <span class=\"number\">0.0</span>);</span><br><span class=\"line\">vec3 diffuse = diff * lightColor;</span><br></pre></td></tr></table></figure>\n<p>如果两个向量之间的角度大于90度，点乘的结果就会变成负数，这样会导致漫反射分量变为负数。为此，我们使用<code>max</code>函数返回两个参数之间较大的参数，从而保证漫反射分量不会变成负数。负数颜色的光照是没有定义的，所以最好避免它。</p>\n<p>现在我们有了环境光分量和漫反射分量，我们把它们相加，然后把结果乘以物体的颜色，来获得片段最后的输出颜色：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vec3 result = (ambient + diffuse) * objectColor;</span><br><span class=\"line\">FragColor = vec4(result, <span class=\"number\">1.0</span>);</span><br></pre></td></tr></table></figure>\n<p>最终的片段着色器代码如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSString</span> *fragmentShaderString = <span class=\"string\">@\"\\</span></span><br><span class=\"line\"><span class=\"string\">#version 300 es \\</span></span><br><span class=\"line\"><span class=\"string\">precision mediump float; \\</span></span><br><span class=\"line\"><span class=\"string\">uniform vec3 objectColor; \\</span></span><br><span class=\"line\"><span class=\"string\">uniform vec3 lightColor; \\</span></span><br><span class=\"line\"><span class=\"string\">uniform vec3 lightPos; \\</span></span><br><span class=\"line\"><span class=\"string\">in vec3 FragPos; \\</span></span><br><span class=\"line\"><span class=\"string\">in vec3 v_normal; \\</span></span><br><span class=\"line\"><span class=\"string\">out vec4 fragColor; \\</span></span><br><span class=\"line\"><span class=\"string\">void main() &#123; \\</span></span><br><span class=\"line\"><span class=\"string\">float ambientStrength = 0.1; \\</span></span><br><span class=\"line\"><span class=\"string\">vec3 ambient = ambientStrength * lightColor; \\</span></span><br><span class=\"line\"><span class=\"string\">vec3 norm = normalize(v_normal); \\</span></span><br><span class=\"line\"><span class=\"string\">vec3 lightDir = normalize(lightPos - FragPos); \\</span></span><br><span class=\"line\"><span class=\"string\">float diff = max(dot(norm, lightDir), 0.0); \\</span></span><br><span class=\"line\"><span class=\"string\">vec3 diffuse = diff * lightColor; \\</span></span><br><span class=\"line\"><span class=\"string\">vec3 result = (ambient + diffuse) * objectColor; \\</span></span><br><span class=\"line\"><span class=\"string\">fragColor = vec4(result, 1.0); \\</span></span><br><span class=\"line\"><span class=\"string\">&#125;\"</span>;</span><br></pre></td></tr></table></figure>\n<p>编译之后，效果图如下：</p>\n<p><img src=\"/img/article/20190902/5.png\" alt=\"漫反射光照\"></p>\n<h1 id=\"还有\">还有…</h1>\n<p>现在我们已经把法向量从顶点着色器传到了片段着色器。可以，目前片段着色器里的计算都是在世界空间坐标系中进行的。所以，我们应该也需要把法向量转换为世界空间坐标，但这不是简单地把它乘以一个模型矩阵就能搞定的。</p>\n<p>首先，法向量只是一个方向向量，不能表达空间中的特定位置。同时，法向量没有齐次坐标（顶点位置中的w分量）。这意味着，位移不应该影响到法向量。一次，如果我们打算把法向量乘以一个模型矩阵，我们就要从矩阵中移除位移部分，只选用模型矩阵左上角3x3的矩阵（注意，我们也可以把法向量的w分量设置为0，再乘以4x4矩阵；这同样可以移除位移）。对于法向量，我们只希望对它实施缩放和旋转变换。</p>\n<p>其次，如果模型矩阵执行了不等比缩放，顶点的改变会导致法向量不再垂直于表面了。因此，我们不能用这样的模型矩阵来变换法向量。如下图应用了不等比缩放的模型矩阵对法向量的影响：</p>\n<p><img src=\"/img/article/20190902/6.png\" alt=\"不等比缩放的模型矩阵对法向量的影响\"></p>\n<p>每当我们应用一个不等比缩放时（注意，等比缩放不会破坏法线，因为法线的方向没被改变，仅仅改变了法线的长度，而这很容易通过标准化来修复），法向量就不会再垂直于对应的表面了，这样光照就会被破坏。</p>\n<p>修复这个行为的诀窍是使用一个为法向量专门定制的模型矩阵。这个矩阵称之为法线矩阵，它使用了一些线性代数的操作来移除对法向量错误缩放的影响。</p>\n<p>法线矩阵被定义为「模型矩阵左上角的逆矩阵的转置矩阵」。注意，大部分的资源都会将法线矩阵定义为应用到模型-观察矩阵上的操作，但是由于我们只在世界空间中进行操作（不是在观察空间），我们只使用模型矩阵。</p>\n<p>在顶点着色器中，我们可以使用<code>inverse</code>和<code>transpose</code>函数自己生成这个法线矩阵，这两个函数对所有类型矩阵都有效。注意，我们还要把被处理过的矩阵强制转换为3x3矩阵，来保证它失去了位移属性以及能够乘以<code>vec3</code>的法向量：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">v_normal = mat3(transpose(inverse(model)))* a_normal;</span><br></pre></td></tr></table></figure>\n<p>在漫反射光照部分，光照表现并没有问题，这是因为我们没有对物体本身执行任何缩放操作，所以并不是必须要使用一个发现矩阵，仅仅让模型矩阵乘以法线也可以。可是，如果进行了不等比缩放，使用法线矩阵乘以法向量就是必不可少的了。</p>\n<blockquote>\n<p>即使是对于着色器来说，逆矩阵也是一个开销比较大的运算，因此，只要可能就应该避免在着色器中进行逆矩阵运算，它们必须为场景中的每个顶点都进行这样的处理。用作学习目的这样做是可以的，但是对于一个对效率有要求的应用来说，在绘制之前最好用CPU计算出法线矩阵，然后通过uniform把值传递给着色器（像模型矩阵一样）。</p>\n</blockquote>\n<h1 id=\"镜面光照\">镜面光照</h1>\n<p>现在我们还需要把镜面高光加进来，这样冯氏光照才能算完整。</p>\n<p>和漫反射光照一样，镜面光照也是根据光的方向向量和物体的法向量来决定的，但是它也依赖于观察方向。镜面光照是基于光的反射特性。如果我们想象物体表面像一面镜子一样，那么无论我们从哪里去看那个表面所反射的光，镜面光照都会达到最大化：</p>\n<p><img src=\"/img/article/20190902/7.png\" alt=\"镜面光照原理图\"></p>\n<p>我们通过反射法向量周围光的方向来计算反射向量。然后我们计算反射向量和视线方向的角度差，如果夹角越小，那么镜面光的影响就会越大。它的作用效果就是，当我们去看光被物体所反射的那个方向的时候，我们会看到一个高光。</p>\n<p>观察向量是镜面光照附加的一个变量，我们可以使用观察者世界空间位置和片段的位置来计算它。之后，我们计算镜面光强度，用它乘以光源的颜色，再将它加上环境光和漫反射分量。</p>\n<p>为了得到观察者的世界空间坐标，我们简单地使用摄像机对象的位置坐标代替（它当然就是观察者）。所以我们把另一个<code>uniform</code>添加到片段着色器，把相应的摄像机位置坐标传给片段着色器：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">uniform vec3 viewPos;</span><br></pre></td></tr></table></figure>\n<p>现在我们已经获得所有需要的变量，可以计算高光强度了。首先，我们定义一个镜面强度变量，给镜面高光一个中等亮度颜色，让它不要产生过度的影响：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">float</span> specularStrength = <span class=\"number\">0.5</span>;</span><br></pre></td></tr></table></figure>\n<p>如果我们把它设置为1.0f，我们会得到一个非常亮的镜面光分量。下一步，我们计算视线方向向量，和对应的沿着法线轴的反射向量：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vec3 viewDir = normalize(viewPos - FragPos);</span><br><span class=\"line\">vec3 reflectDir = reflect(-lightDir, norm);</span><br></pre></td></tr></table></figure>\n<p>需要注意的是我们对<code>lightDir</code>向量进行了取反。<code>reflect</code>函数要求第一个向量是从光源指向片段位置的向量，但是<code>lightDir</code>刚好与其相反，是从片段指向光源。为了保证我们得到正确的<code>reflect</code>向量，我们通过对<code>lightDir</code>向量取反来获得相反的方向。第二个参数要求是一个法向量，所以我们提供的是已经标准化的<code>norm</code>向量。</p>\n<p>剩下要做的是计算镜面分量：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">float</span> spec = pow(max(dot(viewDir, reflectDir), <span class=\"number\">0.0</span>), <span class=\"number\">32.0</span>);</span><br><span class=\"line\">vec3 specular = specularStrength * spec * lightColor;</span><br></pre></td></tr></table></figure>\n<p>我们先计算视线方向与反射方向的点乘（并确保它不是负值），然后取它的32次幂。这个32是高光的反光度。一个物体的反光度越高，反射光的能力越强，散射得越少，高光点就会越小。</p>\n<p><img src=\"/img/article/20190902/8.png\" alt=\"不同反光度的视觉影响\"></p>\n<p>剩下的最后一件事是把它加到环境光分量和漫反射分量里，再用结果乘以物体的颜色：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vec3 result = (ambient + diffuse + specular) * objectColor;</span><br><span class=\"line\">FragColor = vec4(result, <span class=\"number\">1.0</span>);</span><br></pre></td></tr></table></figure>\n<p>最终的片段着色器代码如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSString</span> *fragmentShaderString = <span class=\"string\">@\"\\</span></span><br><span class=\"line\"><span class=\"string\">#version 300 es \\</span></span><br><span class=\"line\"><span class=\"string\">precision mediump float; \\</span></span><br><span class=\"line\"><span class=\"string\">uniform vec3 objectColor; \\</span></span><br><span class=\"line\"><span class=\"string\">uniform vec3 lightColor; \\</span></span><br><span class=\"line\"><span class=\"string\">uniform vec3 lightPos; \\</span></span><br><span class=\"line\"><span class=\"string\">uniform vec3 viewPos; \\</span></span><br><span class=\"line\"><span class=\"string\">in vec3 FragPos; \\</span></span><br><span class=\"line\"><span class=\"string\">in vec3 v_normal; \\</span></span><br><span class=\"line\"><span class=\"string\">out vec4 fragColor; \\</span></span><br><span class=\"line\"><span class=\"string\">void main() &#123; \\</span></span><br><span class=\"line\"><span class=\"string\">float ambientStrength = 0.1; \\</span></span><br><span class=\"line\"><span class=\"string\">vec3 ambient = ambientStrength * lightColor; \\</span></span><br><span class=\"line\"><span class=\"string\">vec3 norm = normalize(v_normal); \\</span></span><br><span class=\"line\"><span class=\"string\">vec3 lightDir = normalize(lightPos - FragPos); \\</span></span><br><span class=\"line\"><span class=\"string\">float diff = max(dot(norm, lightDir), 0.0); \\</span></span><br><span class=\"line\"><span class=\"string\">vec3 diffuse = diff * lightColor; \\</span></span><br><span class=\"line\"><span class=\"string\">float specularStrength = 0.5; \\</span></span><br><span class=\"line\"><span class=\"string\">vec3 viewDir = normalize(viewPos - FragPos); \\</span></span><br><span class=\"line\"><span class=\"string\">vec3 reflectDir = reflect(-lightDir, norm); \\</span></span><br><span class=\"line\"><span class=\"string\">float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32.0); \\</span></span><br><span class=\"line\"><span class=\"string\">vec3 specular = specularStrength * spec * lightColor; \\</span></span><br><span class=\"line\"><span class=\"string\">vec3 result = (ambient + diffuse + specular) * objectColor; \\</span></span><br><span class=\"line\"><span class=\"string\">fragColor = vec4(result, 1.0); \\</span></span><br><span class=\"line\"><span class=\"string\">&#125;\"</span>;</span><br></pre></td></tr></table></figure>\n<p>最终的效果图如下：</p>\n<p><img src=\"/img/article/20190902/9.png\" alt=\"镜面光照\"></p>\n<blockquote>\n<p>这里我没做出效果，可能是没有找到对应的观察点。。。</p>\n</blockquote>\n<h1 id=\"总结\">总结</h1>\n<p>这篇文章主要针对颜色、光照进行剖析和示例展示。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1>颜色</h1>\n<p>现实世界中有无数种颜色，每一个物体都有它们自己的颜色。我们需要使用（有限的）数值来模拟真实世界中（无限）的颜色，所以并不是所有现实世界中的颜色都可以用数值来表示的。然而我们仍能通过数值来表现出非常多的颜色，甚至可能都不会注意到与现实的颜色有任何的差异。颜色可以数字化的由红色（Red）、绿色（Green）和蓝色（Blue）三个分量组成，它们通常被缩写为RGB。仅仅用这三个值就可以组合出任意一种颜色。<br>\n我们在显示生活中看到某一物体的颜色并不是这个物体真正拥有的颜色，而是它所反射的（Reflected）颜色。换句话说，那些不能被物体所吸收（Absorb）的颜色（被拒绝的颜色）就是我们能够感知到的物体的颜色。例如，太阳光能被看见的白光其实是由许多不同的颜色组合而成的。如果我们将白光照在一个蓝色的玩具上，这个蓝色的玩具会吸收白光中除了蓝色以外的所有子颜色，不被吸收的蓝色光被反射到我们的眼中，让这个玩具看起来是蓝色的。<br>\n这些颜色反射的定律被直接地运用在图形领域。当我们在OpenGL中创建一个光源时，我们希望给光源一个颜色。我们将光源设置为白色。当我们把光源的颜色与物体的颜色值相乘，所得到的就是这个物体所反射的颜色（也就是我们所感知的颜色）。在图形学中，我们将这两个颜色向量作分量相乘，结果就是最终的颜色向量：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vec3 lightColor = vec3(<span class=\"number\">1.0</span>f, <span class=\"number\">1.0</span>f, <span class=\"number\">1.0</span>f);</span><br><span class=\"line\">vec3 toyColor = vec3(<span class=\"number\">1.0</span>f, <span class=\"number\">0.5</span>f, <span class=\"number\">0.3</span>f);</span><br><span class=\"line\">vec3 result = lightColor * toyColor;    <span class=\"comment\">// = (1.0f, 0.5f, 0.3f)</span></span><br></pre></td></tr></table></figure>\n<p>我们可以看到玩具的颜色吸收了白色光源中很大一部分的颜色，但它根据自身的颜色值对红、绿、蓝三个分量都做出了一定的反射。这也表现了现实中颜色的工作原理。由此，我们可以定义物体的颜色为物体从一个光源反射各个颜色分量的大小。如果我们使用绿色光源：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vec3 lightColor = vec3(<span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f, <span class=\"number\">0.0</span>f);</span><br><span class=\"line\">vec3 toyColor = vec3(<span class=\"number\">1.0</span>f, <span class=\"number\">0.5</span>f, <span class=\"number\">0.3</span>f);</span><br><span class=\"line\">vec3 result = lightColor * toyColor;    <span class=\"comment\">// = (0.0f, 0.5f, 0.0f)</span></span><br></pre></td></tr></table></figure>\n<p>可以看到，并没有红色和蓝色的光让玩具吸收或者反射。这个玩具吸收了光线中一半的绿色值，但仍然反射了一半的绿色值。玩具现在看上去是深绿色的。</p>\n<h1>创建一个光照场景</h1>\n<p>首先我们需要一个物体来作为被投光的对象–立方体箱子。还有一个立方体箱子来代表光源在3D场景中的位置。这里使用两套着色器，因为灯的颜色不应该受到物体光照计算结果的影响，所以需要将它与物体分离，不受其他颜色变化的影响。</p>\n<p>着色器代码：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSString</span> *objectVertexShaderString = <span class=\"string\">@\" \\</span></span><br><span class=\"line\"><span class=\"string\">#version 300 es \\</span></span><br><span class=\"line\"><span class=\"string\">layout(location = 0) in vec3 a_position; \\</span></span><br><span class=\"line\"><span class=\"string\">uniform mat4 modelMatrix; \\</span></span><br><span class=\"line\"><span class=\"string\">uniform mat4 viewMatrix; \\</span></span><br><span class=\"line\"><span class=\"string\">uniform mat4 projectionMatrix; \\</span></span><br><span class=\"line\"><span class=\"string\">void main() &#123; \\</span></span><br><span class=\"line\"><span class=\"string\">gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(a_position, 1.0); \\</span></span><br><span class=\"line\"><span class=\"string\">&#125;\"</span>;</span><br><span class=\"line\"><span class=\"built_in\">NSString</span> *objectFragmentShaderString = <span class=\"string\">@\"\\</span></span><br><span class=\"line\"><span class=\"string\">#version 300 es \\</span></span><br><span class=\"line\"><span class=\"string\">precision mediump float; \\</span></span><br><span class=\"line\"><span class=\"string\">uniform vec3 objectColor; \\</span></span><br><span class=\"line\"><span class=\"string\">out vec4 fragColor; \\</span></span><br><span class=\"line\"><span class=\"string\">void main() &#123; \\</span></span><br><span class=\"line\"><span class=\"string\">fragColor = vec4(objectColor, 1.0); \\</span></span><br><span class=\"line\"><span class=\"string\">&#125;\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">NSString</span> *lightVertexShaderString = <span class=\"string\">@\" \\</span></span><br><span class=\"line\"><span class=\"string\">#version 300 es \\</span></span><br><span class=\"line\"><span class=\"string\">layout(location = 0) in vec3 a_position; \\</span></span><br><span class=\"line\"><span class=\"string\">uniform mat4 modelMatrix; \\</span></span><br><span class=\"line\"><span class=\"string\">uniform mat4 viewMatrix; \\</span></span><br><span class=\"line\"><span class=\"string\">uniform mat4 projectionMatrix; \\</span></span><br><span class=\"line\"><span class=\"string\">void main() &#123; \\</span></span><br><span class=\"line\"><span class=\"string\">gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(a_position, 1.0); \\</span></span><br><span class=\"line\"><span class=\"string\">&#125;\"</span>;</span><br><span class=\"line\"><span class=\"built_in\">NSString</span> *lightFragmentShaderString = <span class=\"string\">@\"\\</span></span><br><span class=\"line\"><span class=\"string\">#version 300 es \\</span></span><br><span class=\"line\"><span class=\"string\">precision mediump float; \\</span></span><br><span class=\"line\"><span class=\"string\">out vec4 fragColor; \\</span></span><br><span class=\"line\"><span class=\"string\">void main() &#123; \\</span></span><br><span class=\"line\"><span class=\"string\">fragColor = vec4(1.0); \\</span></span><br><span class=\"line\"><span class=\"string\">&#125;\"</span>;</span><br></pre></td></tr></table></figure>\n<p>绘制代码：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)setupVertices &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    顶点配置，设置缓冲</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\">// 物体顶点数组对象</span></span><br><span class=\"line\">    glGenVertexArrays(<span class=\"number\">1</span>, &amp;vao);</span><br><span class=\"line\">    glBindVertexArray(vao);</span><br><span class=\"line\">    glEnableVertexAttribArray(<span class=\"number\">0</span>);</span><br><span class=\"line\">    glVertexAttribPointer(<span class=\"number\">0</span>, <span class=\"number\">3</span>, GL_FLOAT, GL_FALSE, <span class=\"keyword\">sizeof</span>(GLfloat)*<span class=\"number\">6</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    glEnableVertexAttribArray(<span class=\"number\">1</span>);</span><br><span class=\"line\">    glVertexAttribPointer(<span class=\"number\">1</span>, <span class=\"number\">3</span>, GL_FLOAT, GL_FALSE, <span class=\"keyword\">sizeof</span>(GLfloat)*<span class=\"number\">6</span>, (GLvoid *)(<span class=\"keyword\">sizeof</span>(GLfloat)*<span class=\"number\">3</span>));</span><br><span class=\"line\">    glBindVertexArray(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 灯顶点数组对象</span></span><br><span class=\"line\">    glGenVertexArrays(<span class=\"number\">1</span>, &amp;lightvao);</span><br><span class=\"line\">    glBindVertexArray(lightvao);</span><br><span class=\"line\">    glEnableVertexAttribArray(<span class=\"number\">0</span>);</span><br><span class=\"line\">    glVertexAttribPointer(<span class=\"number\">0</span>, <span class=\"number\">3</span>, GL_FLOAT, GL_FALSE, <span class=\"keyword\">sizeof</span>(GLfloat)*<span class=\"number\">6</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    glBindVertexArray(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)glkView:(GLKView *)view drawInRect:(<span class=\"built_in\">CGRect</span>)rect &#123;</span><br><span class=\"line\">    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span><br><span class=\"line\">    glClearColor(<span class=\"number\">0.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f);</span><br><span class=\"line\">    </span><br><span class=\"line\">    glUseProgram(program1);</span><br><span class=\"line\">    </span><br><span class=\"line\">    glBindVertexArray(vao);</span><br><span class=\"line\">    glDrawArrays(GL_TRIANGLES, <span class=\"number\">0</span>, <span class=\"number\">36</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">float</span> aspect = <span class=\"keyword\">self</span>.view.frame.size.width / <span class=\"keyword\">self</span>.view.frame.size.height;</span><br><span class=\"line\">    GLKMatrix4 modelMatrix = GLKMatrix4MakeTranslation(<span class=\"number\">-0.3</span>f, <span class=\"number\">0.2</span>f, <span class=\"number\">1.0</span>f);</span><br><span class=\"line\">    GLKMatrix4 viewMatrix = GLKMatrix4MakeLookAt(<span class=\"number\">-3.5</span>f, <span class=\"number\">2.0</span>f, <span class=\"number\">4.0</span>f, <span class=\"number\">0.5</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f, <span class=\"number\">0.0</span>f);</span><br><span class=\"line\">    GLKMatrix4 projectionMatrx = GLKMatrix4MakePerspective(GLKMathDegreesToRadians(<span class=\"number\">45</span>), aspect, <span class=\"number\">0.1</span>, <span class=\"number\">100.0</span>);</span><br><span class=\"line\">    glUniformMatrix4fv(modelLocation, <span class=\"number\">1</span>, GL_FALSE, modelMatrix.m);</span><br><span class=\"line\">    glUniformMatrix4fv(viewLocation, <span class=\"number\">1</span>, GL_FALSE, viewMatrix.m);</span><br><span class=\"line\">    glUniformMatrix4fv(projectionLocation, <span class=\"number\">1</span>, GL_FALSE, projectionMatrx.m);</span><br><span class=\"line\">    glUniform3f(objectLocation, <span class=\"number\">1.0</span>f, <span class=\"number\">0.5</span>f, <span class=\"number\">0.3</span>f);  <span class=\"comment\">// objct color</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    glUseProgram(program2);</span><br><span class=\"line\">    glBindVertexArray(lightvao);</span><br><span class=\"line\">    glDrawArrays(GL_TRIANGLES, <span class=\"number\">0</span>, <span class=\"number\">36</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    GLKMatrix4 translateMatrix2 = GLKMatrix4MakeTranslation(<span class=\"number\">3.0</span>f, <span class=\"number\">6.6</span>f, <span class=\"number\">2.5</span>f);</span><br><span class=\"line\">    GLKMatrix4 scaleMatrix2 = GLKMatrix4MakeScale(<span class=\"number\">0.2</span>f, <span class=\"number\">0.2</span>f, <span class=\"number\">0.2</span>f);</span><br><span class=\"line\">    GLKMatrix4 modelMatrix2 = GLKMatrix4Multiply(scaleMatrix2, translateMatrix2);</span><br><span class=\"line\">    glUniformMatrix4fv(modelLocation2, <span class=\"number\">1</span>, GL_FALSE, modelMatrix2.m);</span><br><span class=\"line\">    glUniformMatrix4fv(viewLocation2, <span class=\"number\">1</span>, GL_FALSE, viewMatrix.m);</span><br><span class=\"line\">    glUniformMatrix4fv(projectionLocation2, <span class=\"number\">1</span>, GL_FALSE, projectionMatrx.m);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样我们就能有一个干净的光照实验场地，如下图：</p>\n<p><img src=\"/img/article/20190902/1.png\" alt=\"干净的光照实验场地\"></p>\n<h1>基础光照</h1>\n<p>现实世界的光照是极其复杂的，而且会受到诸多因素的影响，这是我们有限的计算能力所无法比拟的。因此OpenGL的光照使用的是简化的模型，对现实的情况进行近似，这样处理起来会更容易一些，而且看起来也差不多一样。这些光照模型都是基于我们对光的物理特性的理解。其中一个模型被称为冯氏光照模型（Phong Lighting Model）。冯氏光照模型的主要结构由3个分量组成：环境（Ambient）、漫反射（Diffuse）和镜面（Specular）光照。</p>\n<p><img src=\"/img/article/20190902/2.png\" alt=\"基础光照\"></p>\n<ul>\n<li>环境光照（Ambient Lighting）：即使在黑暗的情况下，世界上通常也仍然有一些光亮，所以物体几乎永远不会是完全黑暗的。为了模拟这个，我们会使用一个环境光照常量，它会永远给物体一些颜色。</li>\n<li>漫反射光照（Diffuse Lighting）：模拟光源对物体的方向性影响（Directional Impact）。它是冯氏光照模型中视觉上最显著的分量。物体的某一部分越是正对着光源，他就会越亮。</li>\n<li>镜面光照（Specular Lighting）：模拟有光泽物体上面出现的亮点。镜面光照的颜色相比于物体的颜色会更倾向于光的颜色。</li>\n</ul>\n<h1>环境光照</h1>\n<p>光通常都不是来自于同一个光源，而是来自于我们周围分散的很多光源，即使它们可能并不是那么显而易见。光的一个属性是，它可以向很多方向发散并反弹，从而能够到达不是非常直接临近的点。所以，光能够在其它的表面上反射，对一个物体产生间接的影响。考虑到这种情况的算法叫做全局照明（Global Illumination）算法，但是这种算法既开销高昂又及其复杂。</p>\n<p>由于我们现在对那种又复杂又开销高昂的算法不是很感兴趣，所以我们将会先使用一个简化的全局照明模型，即环境光照。我们使用一个很小的常量（光照）颜色，添加到物体片段的最终颜色中，这样子的话即使场景中没有直接的光源也能看起来存在有一些发散的光。</p>\n<p>把环境光照添加到场景里非常简单。我们用光的颜色乘以一个很小的常量环境因子，再乘以物体的颜色，然后将最终结果作为片段的颜色：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSString</span> *objectFragmentShaderString = <span class=\"string\">@\"\\</span></span><br><span class=\"line\"><span class=\"string\">#version 300 es \\</span></span><br><span class=\"line\"><span class=\"string\">precision mediump float; \\</span></span><br><span class=\"line\"><span class=\"string\">uniform vec3 objectColor; \\</span></span><br><span class=\"line\"><span class=\"string\">uniform vec3 lightColor; \\</span></span><br><span class=\"line\"><span class=\"string\">out vec4 fragColor; \\</span></span><br><span class=\"line\"><span class=\"string\">void main() &#123; \\</span></span><br><span class=\"line\"><span class=\"string\">float ambientStrength = 0.1; \\</span></span><br><span class=\"line\"><span class=\"string\">vec3 ambient = ambientStrength * lightColor; \\</span></span><br><span class=\"line\"><span class=\"string\">vec3 result = ambient * objectColor; \\</span></span><br><span class=\"line\"><span class=\"string\">fragColor = vec4(result, 1.0); \\</span></span><br><span class=\"line\"><span class=\"string\">&#125;\"</span>;</span><br></pre></td></tr></table></figure>\n<p>效果如下图，冯氏光照的第一个阶段已经应用到我们的物体上。这个物体非常暗，但由于应用了环境光照（注意光源立方体没受影响是因为我们对它使用了另一个着色器），也不完全是黑的。</p>\n<p><img src=\"/img/article/20190902/3.png\" alt=\"环境光照\"></p>\n<h1>漫反射光照</h1>\n<p>环境光照本身不能提供最有趣的结果，但是漫反射光照就能开始对物体产生显著的视觉影响了。漫反射光照物体上与光线方向越接近的片段能从光源处获得更多的亮度。</p>\n<p><img src=\"/img/article/20190902/4.png\" alt=\"漫反射光照原理图\"></p>\n<p>图左上方有一个光源，它所发出的光线落在物体的一个片段上。我们需要测量这个光线是以什么角度接触到这个片段的。如果光线垂直于物体表面，这束光对物体的影响会最大化（更亮）。为了测量光线和片段的角度，我们使用一个叫做法向量的东西，它是垂直于片段表面的一个向量（黄色箭头），这两个向量之间的角度很容易就能够通过点乘计算出来。</p>\n<p>两个单位向量的夹角越小，它们点乘的结果越倾向于1。当两个向量的夹角为90度的时候，点乘会变为0。这同样适用于θ，θ越大，光对片段颜色的影响就越小。</p>\n<blockquote>\n<p>为了得到两个向量夹角的余弦值，我们使用的是单位向量（长度为1的向量），所以我们需要确保所有的向量都是标准化的，否则点乘返回的就不仅仅是余弦值了。</p>\n</blockquote>\n<p>点乘返回一个标量，我们可以用它计算光线对片段颜色的影响。不同片段朝向光源的方向的不同，这些片段被照亮的情况也不同。</p>\n<p>所以，计算漫反射光照需要：</p>\n<ul>\n<li>法向量：一个垂直于顶点表面的向量。</li>\n<li>定向的光线：作为光源的位置与片段的位置之间向量差的方向向量。为了计算这个光线，我们需要光的位置向量和片段的位置向量。</li>\n</ul>\n<h1>法向量</h1>\n<p>法向量是一个垂直于顶点表面的（单位）向量。由于顶点本事并没有表面（它只是空间中一个独立的点），我们利用它周围的顶点来计算出这个顶点的表面。我们能够使用一个小技巧，使用叉乘对立方体所有的顶点计算法向量，但是由于3D立方体不是一个复杂的形状，所以我们可以简单地把发现数据手工添加到顶点数据中。如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">glFloat vertices[] = &#123;</span><br><span class=\"line\">    <span class=\"number\">-0.5</span>f, <span class=\"number\">-0.5</span>f, <span class=\"number\">-0.5</span>f,  <span class=\"number\">0.0</span>f,  <span class=\"number\">0.0</span>f, <span class=\"number\">-1.0</span>f,</span><br><span class=\"line\">    <span class=\"number\">0.5</span>f, <span class=\"number\">-0.5</span>f, <span class=\"number\">-0.5</span>f,  <span class=\"number\">0.0</span>f,  <span class=\"number\">0.0</span>f, <span class=\"number\">-1.0</span>f,</span><br><span class=\"line\">    <span class=\"number\">0.5</span>f,  <span class=\"number\">0.5</span>f, <span class=\"number\">-0.5</span>f,  <span class=\"number\">0.0</span>f,  <span class=\"number\">0.0</span>f, <span class=\"number\">-1.0</span>f,</span><br><span class=\"line\">    <span class=\"number\">0.5</span>f,  <span class=\"number\">0.5</span>f, <span class=\"number\">-0.5</span>f,  <span class=\"number\">0.0</span>f,  <span class=\"number\">0.0</span>f, <span class=\"number\">-1.0</span>f,</span><br><span class=\"line\">    <span class=\"number\">-0.5</span>f,  <span class=\"number\">0.5</span>f, <span class=\"number\">-0.5</span>f,  <span class=\"number\">0.0</span>f,  <span class=\"number\">0.0</span>f, <span class=\"number\">-1.0</span>f,</span><br><span class=\"line\">    <span class=\"number\">-0.5</span>f, <span class=\"number\">-0.5</span>f, <span class=\"number\">-0.5</span>f,  <span class=\"number\">0.0</span>f,  <span class=\"number\">0.0</span>f, <span class=\"number\">-1.0</span>f,</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"number\">-0.5</span>f, <span class=\"number\">-0.5</span>f,  <span class=\"number\">0.5</span>f,  <span class=\"number\">0.0</span>f,  <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f,</span><br><span class=\"line\">    <span class=\"number\">0.5</span>f, <span class=\"number\">-0.5</span>f,  <span class=\"number\">0.5</span>f,  <span class=\"number\">0.0</span>f,  <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f,</span><br><span class=\"line\">    <span class=\"number\">0.5</span>f,  <span class=\"number\">0.5</span>f,  <span class=\"number\">0.5</span>f,  <span class=\"number\">0.0</span>f,  <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f,</span><br><span class=\"line\">    <span class=\"number\">0.5</span>f,  <span class=\"number\">0.5</span>f,  <span class=\"number\">0.5</span>f,  <span class=\"number\">0.0</span>f,  <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f,</span><br><span class=\"line\">    <span class=\"number\">-0.5</span>f,  <span class=\"number\">0.5</span>f,  <span class=\"number\">0.5</span>f,  <span class=\"number\">0.0</span>f,  <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f,</span><br><span class=\"line\">    <span class=\"number\">-0.5</span>f, <span class=\"number\">-0.5</span>f,  <span class=\"number\">0.5</span>f,  <span class=\"number\">0.0</span>f,  <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f,</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"number\">-0.5</span>f,  <span class=\"number\">0.5</span>f,  <span class=\"number\">0.5</span>f, <span class=\"number\">-1.0</span>f,  <span class=\"number\">0.0</span>f,  <span class=\"number\">0.0</span>f,</span><br><span class=\"line\">    <span class=\"number\">-0.5</span>f,  <span class=\"number\">0.5</span>f, <span class=\"number\">-0.5</span>f, <span class=\"number\">-1.0</span>f,  <span class=\"number\">0.0</span>f,  <span class=\"number\">0.0</span>f,</span><br><span class=\"line\">    <span class=\"number\">-0.5</span>f, <span class=\"number\">-0.5</span>f, <span class=\"number\">-0.5</span>f, <span class=\"number\">-1.0</span>f,  <span class=\"number\">0.0</span>f,  <span class=\"number\">0.0</span>f,</span><br><span class=\"line\">    <span class=\"number\">-0.5</span>f, <span class=\"number\">-0.5</span>f, <span class=\"number\">-0.5</span>f, <span class=\"number\">-1.0</span>f,  <span class=\"number\">0.0</span>f,  <span class=\"number\">0.0</span>f,</span><br><span class=\"line\">    <span class=\"number\">-0.5</span>f, <span class=\"number\">-0.5</span>f,  <span class=\"number\">0.5</span>f, <span class=\"number\">-1.0</span>f,  <span class=\"number\">0.0</span>f,  <span class=\"number\">0.0</span>f,</span><br><span class=\"line\">    <span class=\"number\">-0.5</span>f,  <span class=\"number\">0.5</span>f,  <span class=\"number\">0.5</span>f, <span class=\"number\">-1.0</span>f,  <span class=\"number\">0.0</span>f,  <span class=\"number\">0.0</span>f,</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"number\">0.5</span>f,  <span class=\"number\">0.5</span>f,  <span class=\"number\">0.5</span>f,  <span class=\"number\">1.0</span>f,  <span class=\"number\">0.0</span>f,  <span class=\"number\">0.0</span>f,</span><br><span class=\"line\">    <span class=\"number\">0.5</span>f,  <span class=\"number\">0.5</span>f, <span class=\"number\">-0.5</span>f,  <span class=\"number\">1.0</span>f,  <span class=\"number\">0.0</span>f,  <span class=\"number\">0.0</span>f,</span><br><span class=\"line\">    <span class=\"number\">0.5</span>f, <span class=\"number\">-0.5</span>f, <span class=\"number\">-0.5</span>f,  <span class=\"number\">1.0</span>f,  <span class=\"number\">0.0</span>f,  <span class=\"number\">0.0</span>f,</span><br><span class=\"line\">    <span class=\"number\">0.5</span>f, <span class=\"number\">-0.5</span>f, <span class=\"number\">-0.5</span>f,  <span class=\"number\">1.0</span>f,  <span class=\"number\">0.0</span>f,  <span class=\"number\">0.0</span>f,</span><br><span class=\"line\">    <span class=\"number\">0.5</span>f, <span class=\"number\">-0.5</span>f,  <span class=\"number\">0.5</span>f,  <span class=\"number\">1.0</span>f,  <span class=\"number\">0.0</span>f,  <span class=\"number\">0.0</span>f,</span><br><span class=\"line\">    <span class=\"number\">0.5</span>f,  <span class=\"number\">0.5</span>f,  <span class=\"number\">0.5</span>f,  <span class=\"number\">1.0</span>f,  <span class=\"number\">0.0</span>f,  <span class=\"number\">0.0</span>f,</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"number\">-0.5</span>f, <span class=\"number\">-0.5</span>f, <span class=\"number\">-0.5</span>f,  <span class=\"number\">0.0</span>f, <span class=\"number\">-1.0</span>f,  <span class=\"number\">0.0</span>f,</span><br><span class=\"line\">    <span class=\"number\">0.5</span>f, <span class=\"number\">-0.5</span>f, <span class=\"number\">-0.5</span>f,  <span class=\"number\">0.0</span>f, <span class=\"number\">-1.0</span>f,  <span class=\"number\">0.0</span>f,</span><br><span class=\"line\">    <span class=\"number\">0.5</span>f, <span class=\"number\">-0.5</span>f,  <span class=\"number\">0.5</span>f,  <span class=\"number\">0.0</span>f, <span class=\"number\">-1.0</span>f,  <span class=\"number\">0.0</span>f,</span><br><span class=\"line\">    <span class=\"number\">0.5</span>f, <span class=\"number\">-0.5</span>f,  <span class=\"number\">0.5</span>f,  <span class=\"number\">0.0</span>f, <span class=\"number\">-1.0</span>f,  <span class=\"number\">0.0</span>f,</span><br><span class=\"line\">    <span class=\"number\">-0.5</span>f, <span class=\"number\">-0.5</span>f,  <span class=\"number\">0.5</span>f,  <span class=\"number\">0.0</span>f, <span class=\"number\">-1.0</span>f,  <span class=\"number\">0.0</span>f,</span><br><span class=\"line\">    <span class=\"number\">-0.5</span>f, <span class=\"number\">-0.5</span>f, <span class=\"number\">-0.5</span>f,  <span class=\"number\">0.0</span>f, <span class=\"number\">-1.0</span>f,  <span class=\"number\">0.0</span>f,</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"number\">-0.5</span>f,  <span class=\"number\">0.5</span>f, <span class=\"number\">-0.5</span>f,  <span class=\"number\">0.0</span>f,  <span class=\"number\">1.0</span>f,  <span class=\"number\">0.0</span>f,</span><br><span class=\"line\">    <span class=\"number\">0.5</span>f,  <span class=\"number\">0.5</span>f, <span class=\"number\">-0.5</span>f,  <span class=\"number\">0.0</span>f,  <span class=\"number\">1.0</span>f,  <span class=\"number\">0.0</span>f,</span><br><span class=\"line\">    <span class=\"number\">0.5</span>f,  <span class=\"number\">0.5</span>f,  <span class=\"number\">0.5</span>f,  <span class=\"number\">0.0</span>f,  <span class=\"number\">1.0</span>f,  <span class=\"number\">0.0</span>f,</span><br><span class=\"line\">    <span class=\"number\">0.5</span>f,  <span class=\"number\">0.5</span>f,  <span class=\"number\">0.5</span>f,  <span class=\"number\">0.0</span>f,  <span class=\"number\">1.0</span>f,  <span class=\"number\">0.0</span>f,</span><br><span class=\"line\">    <span class=\"number\">-0.5</span>f,  <span class=\"number\">0.5</span>f,  <span class=\"number\">0.5</span>f,  <span class=\"number\">0.0</span>f,  <span class=\"number\">1.0</span>f,  <span class=\"number\">0.0</span>f,</span><br><span class=\"line\">    <span class=\"number\">-0.5</span>f,  <span class=\"number\">0.5</span>f, <span class=\"number\">-0.5</span>f,  <span class=\"number\">0.0</span>f,  <span class=\"number\">1.0</span>f,  <span class=\"number\">0.0</span>f</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>更新后的光照顶点着色器：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSString</span> *vertexShaderString = <span class=\"string\">@\" \\</span></span><br><span class=\"line\"><span class=\"string\">#version 300 es \\</span></span><br><span class=\"line\"><span class=\"string\">layout(location = 0) in vec3 a_position; \\</span></span><br><span class=\"line\"><span class=\"string\">layout(location = 1) in vec3 a_normal; \\</span></span><br><span class=\"line\"><span class=\"string\">uniform mat4 modelMatrix; \\</span></span><br><span class=\"line\"><span class=\"string\">uniform mat4 viewMatrix; \\</span></span><br><span class=\"line\"><span class=\"string\">uniform mat4 projectionMatrix; \\</span></span><br><span class=\"line\"><span class=\"string\">out vec3 v_normal; \\</span></span><br><span class=\"line\"><span class=\"string\">void main() &#123; \\</span></span><br><span class=\"line\"><span class=\"string\">v_normal = a_normal; \\</span></span><br><span class=\"line\"><span class=\"string\">gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(a_position, 1.0); \\</span></span><br><span class=\"line\"><span class=\"string\">&#125;\"</span>;</span><br></pre></td></tr></table></figure>\n<h1>计算漫反射光照</h1>\n<p>我们现在对每个顶点都有了法向量，但是我们仍需要光源的位置向量和片段的位置向量。由于光源的位置是一个静态变量，我们可以简单地在片段着色器中把它声明为<code>uniform</code>：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">uniform vec3 lightPos;</span><br></pre></td></tr></table></figure>\n<p>最后，我们还需要片段的位置。我们会在世界空间进行所有的光照计算，因此我们需要一个在世界空间中的顶点位置。我们可以通过把顶点位置属性乘以模型矩阵（不是观察和投影矩阵）来把它变换到世界空间坐标。这个在顶点着色器中很容易完成，所以我们声明一个输出变量，来计算它的世界空间坐标：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSString</span> *vertexShaderString = <span class=\"string\">@\" \\</span></span><br><span class=\"line\"><span class=\"string\">#version 300 es \\</span></span><br><span class=\"line\"><span class=\"string\">layout(location = 0) in vec3 a_position; \\</span></span><br><span class=\"line\"><span class=\"string\">layout(location = 1) in vec3 a_normal; \\</span></span><br><span class=\"line\"><span class=\"string\">uniform mat4 modelMatrix; \\</span></span><br><span class=\"line\"><span class=\"string\">uniform mat4 viewMatrix; \\</span></span><br><span class=\"line\"><span class=\"string\">uniform mat4 projectionMatrix; \\</span></span><br><span class=\"line\"><span class=\"string\">out vec3 v_normal; \\</span></span><br><span class=\"line\"><span class=\"string\">out vec3 FragPos; \\</span></span><br><span class=\"line\"><span class=\"string\">void main() &#123; \\</span></span><br><span class=\"line\"><span class=\"string\">FragPos = vec3(modelMatrix * vec4(a_position, 1.0)); \\</span></span><br><span class=\"line\"><span class=\"string\">v_normal = a_normal; \\</span></span><br><span class=\"line\"><span class=\"string\">gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(a_position, 1.0); \\</span></span><br><span class=\"line\"><span class=\"string\">&#125;\"</span>;</span><br></pre></td></tr></table></figure>\n<p>最后，在片段着色器中添加对应的输入变量<code>FragPos</code>。</p>\n<p>我们需要做的第一件事是计算光源和片段位置之间的方向向量。光的方向向量是光源位置向量与片段位置向量之间的向量差。我们同样希望确保所有相关向量最后都转换为单位向量，所以需要把法线和最终的方向向量都进行标准化：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vec3 norm = normalize(v_normal);</span><br><span class=\"line\">vec3 lightDir = normalize(lightPos - FragPos);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>当计算光照时我们通常不关心一个向量的模长或它的位置，只关心它们的方向。所以，几乎所有的计算都使用单位向量完成，因为这简化了大部分的计算（比如点乘）。所以，几乎所有的计算都使用单位向量完成，因为这简化了大部分的计算（比如点乘）。所以当进行光照计算时，确保总是对相关向量进行标准化，来保证它们是真正地单位向量。忘记对向量进行标准化是一个非常常见的错误。</p>\n</blockquote>\n<p>下一步，我们对<code>norm</code>和<code>lightDir</code>向量进行点乘，计算光源对当前片段实际的漫反射影响。结果值再乘以光的颜色，得到漫反射分量。两个向量之间的角度越大，漫反射分量就会越小：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">float</span> diff = max(dot(norm, lightDir), <span class=\"number\">0.0</span>);</span><br><span class=\"line\">vec3 diffuse = diff * lightColor;</span><br></pre></td></tr></table></figure>\n<p>如果两个向量之间的角度大于90度，点乘的结果就会变成负数，这样会导致漫反射分量变为负数。为此，我们使用<code>max</code>函数返回两个参数之间较大的参数，从而保证漫反射分量不会变成负数。负数颜色的光照是没有定义的，所以最好避免它。</p>\n<p>现在我们有了环境光分量和漫反射分量，我们把它们相加，然后把结果乘以物体的颜色，来获得片段最后的输出颜色：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vec3 result = (ambient + diffuse) * objectColor;</span><br><span class=\"line\">FragColor = vec4(result, <span class=\"number\">1.0</span>);</span><br></pre></td></tr></table></figure>\n<p>最终的片段着色器代码如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSString</span> *fragmentShaderString = <span class=\"string\">@\"\\</span></span><br><span class=\"line\"><span class=\"string\">#version 300 es \\</span></span><br><span class=\"line\"><span class=\"string\">precision mediump float; \\</span></span><br><span class=\"line\"><span class=\"string\">uniform vec3 objectColor; \\</span></span><br><span class=\"line\"><span class=\"string\">uniform vec3 lightColor; \\</span></span><br><span class=\"line\"><span class=\"string\">uniform vec3 lightPos; \\</span></span><br><span class=\"line\"><span class=\"string\">in vec3 FragPos; \\</span></span><br><span class=\"line\"><span class=\"string\">in vec3 v_normal; \\</span></span><br><span class=\"line\"><span class=\"string\">out vec4 fragColor; \\</span></span><br><span class=\"line\"><span class=\"string\">void main() &#123; \\</span></span><br><span class=\"line\"><span class=\"string\">float ambientStrength = 0.1; \\</span></span><br><span class=\"line\"><span class=\"string\">vec3 ambient = ambientStrength * lightColor; \\</span></span><br><span class=\"line\"><span class=\"string\">vec3 norm = normalize(v_normal); \\</span></span><br><span class=\"line\"><span class=\"string\">vec3 lightDir = normalize(lightPos - FragPos); \\</span></span><br><span class=\"line\"><span class=\"string\">float diff = max(dot(norm, lightDir), 0.0); \\</span></span><br><span class=\"line\"><span class=\"string\">vec3 diffuse = diff * lightColor; \\</span></span><br><span class=\"line\"><span class=\"string\">vec3 result = (ambient + diffuse) * objectColor; \\</span></span><br><span class=\"line\"><span class=\"string\">fragColor = vec4(result, 1.0); \\</span></span><br><span class=\"line\"><span class=\"string\">&#125;\"</span>;</span><br></pre></td></tr></table></figure>\n<p>编译之后，效果图如下：</p>\n<p><img src=\"/img/article/20190902/5.png\" alt=\"漫反射光照\"></p>\n<h1>还有…</h1>\n<p>现在我们已经把法向量从顶点着色器传到了片段着色器。可以，目前片段着色器里的计算都是在世界空间坐标系中进行的。所以，我们应该也需要把法向量转换为世界空间坐标，但这不是简单地把它乘以一个模型矩阵就能搞定的。</p>\n<p>首先，法向量只是一个方向向量，不能表达空间中的特定位置。同时，法向量没有齐次坐标（顶点位置中的w分量）。这意味着，位移不应该影响到法向量。一次，如果我们打算把法向量乘以一个模型矩阵，我们就要从矩阵中移除位移部分，只选用模型矩阵左上角3x3的矩阵（注意，我们也可以把法向量的w分量设置为0，再乘以4x4矩阵；这同样可以移除位移）。对于法向量，我们只希望对它实施缩放和旋转变换。</p>\n<p>其次，如果模型矩阵执行了不等比缩放，顶点的改变会导致法向量不再垂直于表面了。因此，我们不能用这样的模型矩阵来变换法向量。如下图应用了不等比缩放的模型矩阵对法向量的影响：</p>\n<p><img src=\"/img/article/20190902/6.png\" alt=\"不等比缩放的模型矩阵对法向量的影响\"></p>\n<p>每当我们应用一个不等比缩放时（注意，等比缩放不会破坏法线，因为法线的方向没被改变，仅仅改变了法线的长度，而这很容易通过标准化来修复），法向量就不会再垂直于对应的表面了，这样光照就会被破坏。</p>\n<p>修复这个行为的诀窍是使用一个为法向量专门定制的模型矩阵。这个矩阵称之为法线矩阵，它使用了一些线性代数的操作来移除对法向量错误缩放的影响。</p>\n<p>法线矩阵被定义为「模型矩阵左上角的逆矩阵的转置矩阵」。注意，大部分的资源都会将法线矩阵定义为应用到模型-观察矩阵上的操作，但是由于我们只在世界空间中进行操作（不是在观察空间），我们只使用模型矩阵。</p>\n<p>在顶点着色器中，我们可以使用<code>inverse</code>和<code>transpose</code>函数自己生成这个法线矩阵，这两个函数对所有类型矩阵都有效。注意，我们还要把被处理过的矩阵强制转换为3x3矩阵，来保证它失去了位移属性以及能够乘以<code>vec3</code>的法向量：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">v_normal = mat3(transpose(inverse(model)))* a_normal;</span><br></pre></td></tr></table></figure>\n<p>在漫反射光照部分，光照表现并没有问题，这是因为我们没有对物体本身执行任何缩放操作，所以并不是必须要使用一个发现矩阵，仅仅让模型矩阵乘以法线也可以。可是，如果进行了不等比缩放，使用法线矩阵乘以法向量就是必不可少的了。</p>\n<blockquote>\n<p>即使是对于着色器来说，逆矩阵也是一个开销比较大的运算，因此，只要可能就应该避免在着色器中进行逆矩阵运算，它们必须为场景中的每个顶点都进行这样的处理。用作学习目的这样做是可以的，但是对于一个对效率有要求的应用来说，在绘制之前最好用CPU计算出法线矩阵，然后通过uniform把值传递给着色器（像模型矩阵一样）。</p>\n</blockquote>\n<h1>镜面光照</h1>\n<p>现在我们还需要把镜面高光加进来，这样冯氏光照才能算完整。</p>\n<p>和漫反射光照一样，镜面光照也是根据光的方向向量和物体的法向量来决定的，但是它也依赖于观察方向。镜面光照是基于光的反射特性。如果我们想象物体表面像一面镜子一样，那么无论我们从哪里去看那个表面所反射的光，镜面光照都会达到最大化：</p>\n<p><img src=\"/img/article/20190902/7.png\" alt=\"镜面光照原理图\"></p>\n<p>我们通过反射法向量周围光的方向来计算反射向量。然后我们计算反射向量和视线方向的角度差，如果夹角越小，那么镜面光的影响就会越大。它的作用效果就是，当我们去看光被物体所反射的那个方向的时候，我们会看到一个高光。</p>\n<p>观察向量是镜面光照附加的一个变量，我们可以使用观察者世界空间位置和片段的位置来计算它。之后，我们计算镜面光强度，用它乘以光源的颜色，再将它加上环境光和漫反射分量。</p>\n<p>为了得到观察者的世界空间坐标，我们简单地使用摄像机对象的位置坐标代替（它当然就是观察者）。所以我们把另一个<code>uniform</code>添加到片段着色器，把相应的摄像机位置坐标传给片段着色器：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">uniform vec3 viewPos;</span><br></pre></td></tr></table></figure>\n<p>现在我们已经获得所有需要的变量，可以计算高光强度了。首先，我们定义一个镜面强度变量，给镜面高光一个中等亮度颜色，让它不要产生过度的影响：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">float</span> specularStrength = <span class=\"number\">0.5</span>;</span><br></pre></td></tr></table></figure>\n<p>如果我们把它设置为1.0f，我们会得到一个非常亮的镜面光分量。下一步，我们计算视线方向向量，和对应的沿着法线轴的反射向量：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vec3 viewDir = normalize(viewPos - FragPos);</span><br><span class=\"line\">vec3 reflectDir = reflect(-lightDir, norm);</span><br></pre></td></tr></table></figure>\n<p>需要注意的是我们对<code>lightDir</code>向量进行了取反。<code>reflect</code>函数要求第一个向量是从光源指向片段位置的向量，但是<code>lightDir</code>刚好与其相反，是从片段指向光源。为了保证我们得到正确的<code>reflect</code>向量，我们通过对<code>lightDir</code>向量取反来获得相反的方向。第二个参数要求是一个法向量，所以我们提供的是已经标准化的<code>norm</code>向量。</p>\n<p>剩下要做的是计算镜面分量：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">float</span> spec = pow(max(dot(viewDir, reflectDir), <span class=\"number\">0.0</span>), <span class=\"number\">32.0</span>);</span><br><span class=\"line\">vec3 specular = specularStrength * spec * lightColor;</span><br></pre></td></tr></table></figure>\n<p>我们先计算视线方向与反射方向的点乘（并确保它不是负值），然后取它的32次幂。这个32是高光的反光度。一个物体的反光度越高，反射光的能力越强，散射得越少，高光点就会越小。</p>\n<p><img src=\"/img/article/20190902/8.png\" alt=\"不同反光度的视觉影响\"></p>\n<p>剩下的最后一件事是把它加到环境光分量和漫反射分量里，再用结果乘以物体的颜色：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vec3 result = (ambient + diffuse + specular) * objectColor;</span><br><span class=\"line\">FragColor = vec4(result, <span class=\"number\">1.0</span>);</span><br></pre></td></tr></table></figure>\n<p>最终的片段着色器代码如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSString</span> *fragmentShaderString = <span class=\"string\">@\"\\</span></span><br><span class=\"line\"><span class=\"string\">#version 300 es \\</span></span><br><span class=\"line\"><span class=\"string\">precision mediump float; \\</span></span><br><span class=\"line\"><span class=\"string\">uniform vec3 objectColor; \\</span></span><br><span class=\"line\"><span class=\"string\">uniform vec3 lightColor; \\</span></span><br><span class=\"line\"><span class=\"string\">uniform vec3 lightPos; \\</span></span><br><span class=\"line\"><span class=\"string\">uniform vec3 viewPos; \\</span></span><br><span class=\"line\"><span class=\"string\">in vec3 FragPos; \\</span></span><br><span class=\"line\"><span class=\"string\">in vec3 v_normal; \\</span></span><br><span class=\"line\"><span class=\"string\">out vec4 fragColor; \\</span></span><br><span class=\"line\"><span class=\"string\">void main() &#123; \\</span></span><br><span class=\"line\"><span class=\"string\">float ambientStrength = 0.1; \\</span></span><br><span class=\"line\"><span class=\"string\">vec3 ambient = ambientStrength * lightColor; \\</span></span><br><span class=\"line\"><span class=\"string\">vec3 norm = normalize(v_normal); \\</span></span><br><span class=\"line\"><span class=\"string\">vec3 lightDir = normalize(lightPos - FragPos); \\</span></span><br><span class=\"line\"><span class=\"string\">float diff = max(dot(norm, lightDir), 0.0); \\</span></span><br><span class=\"line\"><span class=\"string\">vec3 diffuse = diff * lightColor; \\</span></span><br><span class=\"line\"><span class=\"string\">float specularStrength = 0.5; \\</span></span><br><span class=\"line\"><span class=\"string\">vec3 viewDir = normalize(viewPos - FragPos); \\</span></span><br><span class=\"line\"><span class=\"string\">vec3 reflectDir = reflect(-lightDir, norm); \\</span></span><br><span class=\"line\"><span class=\"string\">float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32.0); \\</span></span><br><span class=\"line\"><span class=\"string\">vec3 specular = specularStrength * spec * lightColor; \\</span></span><br><span class=\"line\"><span class=\"string\">vec3 result = (ambient + diffuse + specular) * objectColor; \\</span></span><br><span class=\"line\"><span class=\"string\">fragColor = vec4(result, 1.0); \\</span></span><br><span class=\"line\"><span class=\"string\">&#125;\"</span>;</span><br></pre></td></tr></table></figure>\n<p>最终的效果图如下：</p>\n<p><img src=\"/img/article/20190902/9.png\" alt=\"镜面光照\"></p>\n<blockquote>\n<p>这里我没做出效果，可能是没有找到对应的观察点。。。</p>\n</blockquote>\n<h1>总结</h1>\n<p>这篇文章主要针对颜色、光照进行剖析和示例展示。</p>\n"},{"title":"OpenGL ES学习--图元装配和光栅化","catalog":true,"toc_nav_num":true,"date":"2019-08-01T11:09:32.000Z","subtitle":"About OpenGL ES","header-img":"/img/article_header/article_header.png","busuanzi":true,"_content":"\n> 本章描述OpenGL ES支持的图元和几何形状对象的类型，并说明绘制它们的方法。然后描述发生在顶点着色器处理图元顶点之后的图元装配阶段。在这一阶段，执行裁剪、透视分割和视口变换操作，对这些操作将作详细的讨论。本章以光栅化阶段的描述作为结束。光栅化是将图元转换为一组二维片段的过程，这些片段由片段着色器处理，代表可以在屏幕上绘制的像素。\n\n# 图元\n\n图元是可以用OpenGL ES中的`glDrawArrays`、`glDrawElements`、`glDrawRangeElements`、`glDrawArraysInstanced`、`glDrawElementsInstanced`命令绘制的几何形状对象。图元由一组表示顶点位置的顶点描述。其他如颜色、纹理坐标和几何法线等信息也作为通用属性与每个顶点关联。\n\nOpenGL ES 3.0可以绘制如下图元：\n- 三角形\n- 直线\n- 点精灵\n\n## 三角形\n\n三角形代表着描述由3D应用程序渲染的几何形状对象时最常用的方法。OpenGL ES支持的三角形图元有`GL_TRIANGLES`、`GL_TRIANGLE_STRIP`和`GL_TRIANGLE_FAN`。\n\n![三角形图元类型](/img/article/20190801/1.png)\n\n`GL_TRIANGLES`绘制一系列单独的三角形。如上图所示，绘制了顶点为(v<sup>0</sup>, v<sup>1</sup>, v<sup>2</sup>)和(v<sup>3</sup>, v<sup>4</sup>, v<sup>5</sup>)的两个三角形。总共绘制了n/3个三角形，其中n为`glDraw*`函数中的`count`指定的索引。\n\n`GL_TRIANGLE_STRIP`绘制一系列相互连接的三角形。如上图所示，绘制了4个顶点为(v<sup>0</sup>, v<sup>1</sup>, v<sup>2</sup>)、(v<sup>2</sup>, v<sup>1</sup>, v<sup>3</sup>)、(v<sup>2</sup>, v<sup>3</sup>, v<sup>4</sup>)和(v<sup>4</sup>, v<sup>3</sup>, v<sup>5</sup>)的三角形（注意顺序）。总共绘制了n-2个三角形，其中n为`glDraw*`函数中的`count`指定的索引。\n\n`GL_TRIANGLE_FAN`也绘制一系列相连的三角形。如上图所示，绘制了3个顶点为(v<sup>0</sup>, v<sup>1</sup>, v<sup>2</sup>)、(v<sup>0</sup>, v<sup>2</sup>, v<sup>3</sup>)和(v<sup>0</sup>, v<sup>3</sup>, v<sup>4</sup>)的三角形，总共绘制了n-2个三角形，其中n为`glDraw*`函数中的`count`指定的索引。\n\n## 直线\n\nOpenGL ES支持的直线图元有`GL_LINES`、`GL_LINE_STRIP`和`GL_LINE_LOOP`。\n\n![直线图元类型](/img/article/20190801/2.png)\n\n`GL_LINES`绘制一系列不相连的线段。如上图所示，绘制了端点为(v<sup>0</sup>, v<sup>1</sup>)、(v<sup>2</sup>, v<sup>3</sup>)和(v<sup>4</sup>, v<sup>5</sup>)的单独线段。总共绘制了n/2条线段，其中n为`glDraw*`函数中的`count`指定的索引。\n\n`GL_LINE_STRIP`绘制一系列相连的线段。如上图所示，绘制了3条端点为(v<sup>0</sup>, v<sup>1</sup>)、(v<sup>1</sup>, v<sup>2</sup>)和(v<sup>2</sup>, v<sup>3</sup>)的线段。总共绘制了n-1条线段，其中n为`glDraw*`函数中的`count`指定的索引。\n\n除了最后一条线段从v<sup>n-1</sup>到v<sup>0</sup>之外，`GL_LINE_LOOP`和`GL_LINE_STRIP`的绘制方法类似。如上图所示，绘制了端点为(v<sup>0</sup>, v<sup>1</sup>)、(v<sup>1</sup>, v<sup>2</sup>)、(v<sup>2</sup>, v<sup>3</sup>)、(v<sup>3</sup>, v<sup>4</sup>)和(v<sup>4</sup>, v<sup>0</sup>)的线段。总共绘制了n条线段，其中n为`glDraw*`函数中的`count`指定的索引。\n\n线段的宽度用`glLineWidth`API调用指定：\n\n``` objc\n/**\n 设置线宽\n\n @param width#> 指定线宽，以像素数表示；默认宽度为1.0 description#>\n @return void\n */\nglLineWidth(GLfloat width);\n```\n\n`glLineWidth`指定的宽度将受限于OpenGL ES 3.0实现所支持的线宽范围。此外，指定的宽度将被OpenGL记住，直到应用程序更新。支持的线宽范围可以用如下的命令查询，对于大于1\n的线宽，没有强制支持。\n\n``` objc\nGLfloat lineWidthRange[2];\nglGetFloatv(GL_ALIASED_LINE_WIDTH_RANGE, lineWidthRange);\n```\n\n## 点精灵\n\nOpenGL ES支持的点精灵图元是`GL_POINTS`。点精灵对指定的每个顶点绘制。点精灵通常用于将粒子效果当做点而非正方形绘制，从而实现高效渲染。点精灵是指定位置和半径的屏幕对齐的正方形，位置描述正方形的中心，半径用于计算描述点精灵的正方形的4个坐标。\n\n`gl_PointSize`是可用于在顶点着色器中输出点半径（或者点尺寸）的内建变量。与点图元相关的顶点着色器输出`gl_PointSize`很重要，否则，点尺寸值被视为未定义，很可能会造成绘图错误。顶点着色器输出的`gl_PointSize`受到OpenGL ES 3.0实现所支持的非平滑点尺寸范围的限制。这个范围可以用如下命令查询：\n``` objc\nGLfloat pointSizeRange[2];\nglGetFloatv(GL_ALIASED_POINT_SIZE_RANGE, pointSizeRange);\n```\n\n默认情况下，OpenGL ES 3.0将窗口原点(0, 0)描述为(左, 下)区域，但是，对于点精灵，点坐标的原点是(左, 上)。\n\n`gl_PointCoord`是只能在渲染图元为点精灵时用于片段着色器内部的内建变量，它用`mediump`精度限定符声明一个vec2变量。随着我们从左侧移到右侧，从顶部移到底部，赋予`gl_PointCoord`的值从0~1变化。\n\n# 绘制图元\n\nOpenGL ES中有5个绘制图元的API调用：`glDrawArrays`、`glDrawElements`、`glDrawRangeElements`、`glDrawArraysInstanced`和`glDrawElementsInstanced`。\n\n``` objc\n/**\n 绘制图元\n\n @param mode#> 指定要渲染的图元，有效值为GL_POINTS, GL_LINES, GL_LINES_STRIP, GL_LINES_LOOP, GL_TRIANGLES, GL_TRIANGLES_STRIP, GL_TRIANGLE_FAN description#>\n @param first#> 指定启用的顶点数组中的起始顶点索引 description#>\n @param count#> 指定要绘制的顶点数量 description#>\n @return void\n */\nglDrawArrays(GLenum mode, GLint first, GLsizei count);\n\n/**\n 绘制图元\n\n @param mode#> 指定要渲染的图元，有效值为GL_POINTS, GL_LINES, GL_LINES_STRIP, GL_LINES_LOOP, GL_TRIANGLES, GL_TRIANGLES_STRIP, GL_TRIANGLE_FAN description#>\n @param count#> 指定要绘制的索引数量 description#>\n @param type#> 指定indices中保存的元素索引类型，有效值为GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, GL_UNSIGNED_INT description#>\n @param indices#> 指向元素索引存储位置的指针 description#>\n @return void\n */\nglDrawElements(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices)\n\n/**\n 绘制图元\n\n @param mode#> 指定要渲染的图元，有效值为GL_POINTS, GL_LINES, GL_LINES_STRIP, GL_LINES_LOOP, GL_TRIANGLES, GL_TRIANGLES_STRIP, GL_TRIANGLE_FAN description#>\n @param start#> 指定indices中的最小数组索引 description#>\n @param end#> 指定indices中的最大数组索引 description#> \n @param count#> 指定要绘制的索引数量 description#>\n @param type#> 指定indices中保存的元素索引类型，有效值为GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, GL_UNSIGNED_INT description#>\n @param indices#> 指向元素索引存储位置的指针 description#>\n @return void\n */\nglDrawRangeElements(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices)\n```\n\n如果有一个一系列顺序元素索引描述的图元，且几何形状的顶点不共享，则`glDrawArrays`很好用，但是，游戏或者其他3D应用程序使用的典型对象由多个三角形网格组成，其中的元素索引可能不一定按照顺序，顶点通常在网格的三角形直接共享。\n\n比如考虑上图立方体的绘制，如果我们用`glDrawArrays`绘制，则代码如下：\n\n``` objc\nGLfloat vertices[] = { .. };\nglEnableVertexAttribArray(0);\nglVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, vertices);\nglDrawArrays(GL_TRIANGLES, 0, 36);\n```\n\n为了用`glDrawArrays`绘制这个立方体，需要为立方体的每一个面调用`glDrawArrays`。共享的顶点必须重复，这意味着需要分配24个顶点（如果将每面当做`GL_TRIANGLE_FAN`绘制）或者36个顶点（如果使用`GL_TRIANGLES`），而不是8个顶点。这不是一个高效的做法。\n\n用`glDrawElements`绘制同一个立方体的代码如下：\n\n``` objc\nGLfloat vertices[] = { .. };\nGLubyte indices[36] = {\n    0, 1, 2, 0, 2, 3,\n    0, 3, 4, 0, 4, 5,\n    7, 1, 6, 7, 2, 1,\n    7, 5, 4, 7, 6, 5,\n    7, 3, 2, 7, 4, 3\n}\nglEnableVertexAttribArray(0);\nglVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, vertices);\nglDrawElements(GL_TRIANGLES, 36, GL_USINGED_BYTE, indices);\n```\n\n即使我们用`glDrawElements`绘制三角形，用`glDrawArrays`和`glDrawElements`绘制一个三角扇形，我们的应用程序在GPU上运行的也比`glDrawArrays`更快，这有很多原因。比如，由于顶点重用，顶点属性数据的尺寸将小于`glDrawElements`。这也导致较小的内存占用和内存贷款需求。\n\n## 图元重启\n\n使用图元重启，可以在一次绘图调用中渲染多个不相连的图元（例如三角扇形或者条带）。这对于降低绘图API的调用的开销是有利的。图元重启的另一种方法是生成退化三角形（需要一些注意事项），这种方法较不简洁。\n\n使用图元重启，可以通过在索引列表中插入一个特殊索引来重启一个用于索引绘图调用（如`glDrawElements`、`glDrawElementsInstances`或`glDrawRangeElements`）的图元。这个特殊索引是该索引类型的最大索引（例如，索引类型为`GL_UNSIGNED_BYTE`或`GL_UNSIGNED_SHORT`时，分别为255或者65535）。\n\n例如，假定两个三角形条带分别有元素索引(0, 1, 2, 3)和(8, 9, 10, 11)。如果我们想利用图元重启在一次调用`glDrawElements*`中绘制两个条带，索引类型为`GL_UNSIGNED_BYTE`，则组合的元素索引列表为(0, 1, 2, 3, 255, 8, 9, 10, 11)。\n\n可以用如下代码启用和禁用图元启用：\n``` objc\nglEnable(GL_PRIMITIVE_RESTART_FIXED_INDEX);\n// draw primitives\nglDisable(GL_PRIMITIVE_RESTART_FIXED_INDEX);\n```\n\n代码示例：\n\n``` objc\n// 配置\nGLfloat vertices[] = {\n    -0.75f, 0, 0,\n    -0.75f, 0.75f, 0,\n    -0.25f, 0, 0,\n    -0.25f, 0.75, 0,\n    \n    0.75f, 0, 0,\n    0.75f, 0.75f, 0,\n    0.25f, 0, 0,\n    0.25f, 0.75, 0\n};\nGLfloat colors[] = {\n    1.0f, 0.0f, 0.0f, 1.0f,\n    0.0f, 1.0f, 0.0f, 1.0f,\n    0.0f, 0.0f, 1.0f, 1.0f,\n    0.0f, 1.0f, 0.0f, 1.0f,\n    \n    1.0f, 0.0f, 0.0f, 1.0f,\n    0.0f, 1.0f, 0.0f, 1.0f,\n    0.0f, 0.0f, 1.0f, 1.0f,\n    0.0f, 1.0f, 0.0f, 1.0f\n};\nGLushort indices[] = {0, 1, 2, 3, 65535, 4, 5, 6, 7};\n\nGLuint vbos[3];\nglGenBuffers(3, vbos);\nglBindBuffer(GL_ARRAY_BUFFER, vbos[0]);\nglBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);\n\nglBindBuffer(GL_ARRAY_BUFFER, vbos[1]);\nglBufferData(GL_ARRAY_BUFFER, sizeof(colors), colors, GL_STATIC_DRAW);\n\nglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vbos[2]);\nglBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);\n\nglGenVertexArrays(1, &vaos);\nglBindVertexArray(vaos);\n\nglBindBuffer(GL_ARRAY_BUFFER, vbos[0]);\nglEnableVertexAttribArray(0);\nglVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(GLfloat), 0);\nglBindBuffer(GL_ARRAY_BUFFER, vbos[1]);\nglEnableVertexAttribArray(1);\nglVertexAttribPointer(1, 4, GL_FLOAT, GL_FALSE, 4 * sizeof(GLfloat), 0);\nglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vbos[2]);\n\nglBindVertexArray(0);\n\n// 绘制\nglEnable(GL_PRIMITIVE_RESTART_FIXED_INDEX);\n\nglBindVertexArray(vaos);\nglDrawElements(GL_TRIANGLE_STRIP, 9, GL_UNSIGNED_SHORT, 0);\n\nglDisable(GL_PRIMITIVE_RESTART_FIXED_INDEX);\n```\n\n## 驱动顶点\n\n如果没有限定符，那么顶点着色器的输出值在图元中使用线性插值。但是，使用平面着色时没有发生插值。因为没有发生插值，所以片段着色器中只有一个顶点值可用。对于给定的图元实例，这个驱动顶点确定使用顶点着色器的哪一个顶点输出，因为只能使用一个顶点。[插值限定符](/article/2019/opengl-es-glsl-0715/#插值限定符)。\n\n图元i的类型 | 驱动顶点\n- | -\nGL_POINT | i\nGL_LINES | 2i\nGL_LINE_LOOP | 如果i < n，为i + 1；如果i = n，为1\nGL_LINE_STRIP | i + 1\nGL_TRIANGLES | 3i\nGL_TRIANGLE_STRIP | i + 2\nGL_TRIANGLE_FAN | i + 2\n\n> 第i个图元实例的驱动顶点选择，顶点的编号从1到n，n是绘制的顶点数量。\n\n## 几何形状实例化\n\n几何形状实例化很高效，可以用一次API调用多次渲染具有不同属性（例如不同的变换矩阵、颜色或者大小）的一个对象。这一功能在渲染大量类似对象时很有用，例如对人群的渲染。几何图形实例化降低了向OpenGL ES引擎发送许多API调用的CPU处理开销。要使用实例化绘图调用渲染，可以使用如下命令：\n\n``` objc\n/**\n 实例化绘图\n\n @param mode#> 指定要渲染的图元，有效值为GL_POINTS, GL_LINES, GL_LINES_STRIP, GL_LINES_LOOP, GL_TRIANGLES, GL_TRIANGLES_STRIP, GL_TRIANGLE_FAN description#>\n @param first#> 指定要启用的顶点数组中的起始顶点索引 description#>\n @param count#> 指定绘制的索引数量 description#>\n @param instancecount#> 指定绘制的图元实例数量 description#>\n @return void\n */\nglDrawArraysInstanced(GLenum mode, GLint first, GLsizei count, GLsizei instancecount);\n\n/**\n 实例化绘图\n\n @param mode#> 指定要渲染的图元，有效值为GL_POINTS, GL_LINES, GL_LINES_STRIP, GL_LINES_LOOP, GL_TRIANGLES, GL_TRIANGLES_STRIP, GL_TRIANGLE_FAN description#>\n @param count#> 指定绘制的索引数量 description#>\n @param type#> 指定保存在indices中的元素索引类型，有效值为GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, GL_UNSIGNED_INT description#>\n @param indices#> 指定元素索引存储位置的一个指针 description#>\n @param instancecount#> 指定绘制的图元实例数量 description#>\n @return void\n */\nglDrawElementsInstanced(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei instancecount);\n```\n\n可以使用两种方法访问每个实例的数据。第一种方法是用如下命令指示OpenGL ES对每个实例读取一次或者多次顶点属性：\n\n``` objc\n/**\n 对每个实例读取一次或多次顶点属性\n\n @param index#> 指定通用顶点属性索引 description#>\n @param divisor#> 指定index位置的通用属性更新之间传递传递的实例数量 description#>\n @return void\n */\nglVertexAttribDivisor(GLuint index, GLuint divisor);\n```\n\n默认情况下，如果没有指定`glVertexAttribDivisor`或者每个顶点属性的`divisor`等于零，对每个顶点将读取一次顶点属性。如果`divisor`等于1，则每个图元实例读取一次顶点属性。[代码例子](https://github.com/danginsburg/opengles3-book/blob/master/Chapter_7/Instancing/Instancing.c)\n\n第二种方法是使用内建输入变量`glInstanceID`作为顶点着色器中的缓冲区索引，以访问每个实例的数据（仅限OpenGL ES 3.0）。使用前面提到的几何形状实例化API调用时，`gl_InstanceID`将保存当前图元实例的索引。使用非实例化绘图调用时，`gl_InstanceID`将返回0。\n\n## 性能提示\n\n应用程序应该确保用尽可能大的图元尺寸调用`glDrawElements`和`glDrawElementsInstanced`。如果我们绘制`GL_TRIANGLES`，这很容易做到，但是，如果有三角形条带或者扇形的网格，则可以用图元重启将这些网格连接在一起，而不用对每个三角形条带网格单独调用`glDrawElements*`。\n\n如果无法使用图元重启机制将网格连接到一起（为了维护和旧版本OpenGL ES的兼容性），可以添加造成退化三角形的元素索引，代价是使用更多的索引。退化三角形是两个或者更多顶点相同的三角形。GPU可以非常简单的检测和拒绝退化三角形，所以这是很好的性能改进，我们可以讲一个很大的图元放入右GPU渲染的队列。\n\n代码示例：\n\n``` objc\n// 配置\nGLfloat vertices[] = {\n    -0.75f, 0, 0,\n    -0.75f, 0.75f, 0,\n    -0.25f, 0, 0,\n    -0.25f, 0.75, 0,\n    \n    0.75f, 0, 0,\n    0.75f, 0.75f, 0,\n    0.25f, 0, 0,\n    0.25f, 0.75, 0\n};\nGLfloat colors[] = {\n    1.0f, 0.0f, 0.0f, 1.0f,\n    0.0f, 1.0f, 0.0f, 1.0f,\n    0.0f, 0.0f, 1.0f, 1.0f,\n    0.0f, 1.0f, 0.0f, 1.0f,\n    \n    1.0f, 0.0f, 0.0f, 1.0f,\n    0.0f, 1.0f, 0.0f, 1.0f,\n    0.0f, 0.0f, 1.0f, 1.0f,\n    0.0f, 1.0f, 0.0f, 1.0f\n};\nGLushort indices[] = {0, 1, 2, 3, 3, 4, 4, 5, 6, 7};\n\nGLuint vbos[3];\nglGenBuffers(3, vbos);\nglBindBuffer(GL_ARRAY_BUFFER, vbos[0]);\nglBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);\n\nglBindBuffer(GL_ARRAY_BUFFER, vbos[1]);\nglBufferData(GL_ARRAY_BUFFER, sizeof(colors), colors, GL_STATIC_DRAW);\n\nglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vbos[2]);\nglBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);\n\nglGenVertexArrays(1, &vaos);\nglBindVertexArray(vaos);\n\nglBindBuffer(GL_ARRAY_BUFFER, vbos[0]);\nglEnableVertexAttribArray(0);\nglVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(GLfloat), 0);\nglBindBuffer(GL_ARRAY_BUFFER, vbos[1]);\nglEnableVertexAttribArray(1);\nglVertexAttribPointer(1, 4, GL_FLOAT, GL_FALSE, 4 * sizeof(GLfloat), 0);\nglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vbos[2]);\n\nglBindVertexArray(0);\n\n// 绘制\nglBindVertexArray(vaos);\nglDrawElements(GL_TRIANGLE_STRIP, 10, GL_UNSIGNED_SHORT, 0);\n```\n\n# 图元装配\n\n下图展示了图元装配阶段。通过`glDraw***`提供的顶点由顶点着色器执行，顶点着色器变换的每个顶点包括描述顶点(x, y, z, w)值的顶点位置。图元位置和顶点索引确定将被渲染的单独图元。对于每个单独图元（三角形、直线和点）及其对应的顶点，图元装配阶段执行图中所示的操作。\n\n![OpenGL ES图元装配阶段](/img/article/20190801/3.png)\n\n## 坐标系统\n\n下图展示了顶点通过顶点着色器和图元装配阶段时的坐标系统。顶点以物体或者本地坐标空间输入到OpenGL ES，这是最可能用来建模和存储一个对象的坐标空间。在顶点着色器执行之后，顶点位置被认为是在裁剪坐标空间内。顶点位置从本地坐标系统（也就是物体坐标）到裁剪坐标的变换通过加载执行这一转换的对应矩阵来完成，这些矩阵保存在顶点着色器中定义的统一变量中。\n\n![坐标系统](/img/article/20190801/4.png)\n\n### 裁剪\n\n为了避免在可视景体之外处理图元，图元被裁剪到裁剪空间。执行顶点着色器之后的顶点位置处于裁剪坐标空间内。裁剪坐标是由(x<sub>c</sub>, y<sub>c</sub>, z<sub>c</sub>, w<sub>c</sub>)指定的同类坐标。在裁剪空间(x<sub>c</sub>, y<sub>c</sub>, z<sub>c</sub>, w<sub>c</sub>)中定义的顶点坐标根据视景体（又称裁剪体）裁剪。\n\n裁剪体由6个裁剪平面定义，这些平面称作近、远、左、右、上、下裁剪平面。在裁剪坐标中，裁剪体如下：-w<sub>c</sub> <= x<sub>c</sub> <= w<sub>c</sub>，-w<sub>c</sub> <= y<sub>c</sub> <= w<sub>c</sub>，-w<sub>c</sub> <= z<sub>c</sub> <= w<sub>c</sub>。\n\n![视景体](/img/article/20190801/5.png)\n\n裁剪阶段将把每个图元裁剪为上图所示的裁剪体。我们在这里说的“图元”，是指用`GL_TRIANGLES`绘制的单独三角形列表中的每一个三角形，或者一个三角形条带或者扇形中的一个三角形，或者用`GL_LINES`绘制的单独直线列表中的一条直线，或者一个直线条带或者闭合折线中的一条直线，或者点精灵列表中的一个特定点。对于每种图元类型，执行如下操作：\n- 裁剪三角形--如果三角形完全在视景体内部，则不执行任何裁剪。如果三角形完全在视景体之外，则该三角形被放弃。如果三角形部分在视景体内，则根据相应的平面裁剪三角形。裁剪操作将生成新的顶点，这些顶点被裁剪到安排为三角形扇形的平面。\n- 裁剪直线--如果直线完全在视景体内部，则不执行任何裁剪。如果直线完全在视景体之外，则该直线被放弃。如果直线部分在视景体内，则直线被裁剪并生成相应的新顶点。\n- 裁剪点精灵--如果点位置在近或者远裁剪平面之外，或者如果表示点精灵的正方形在裁剪体之外，裁剪阶段将抛弃点精灵。否则，它将不做变化地通过该阶段，点精灵将在其裁剪体内部移到外部时裁剪，反之亦然。\n\n在图元根据六个裁剪平面进行裁剪时，顶点坐标经历透视分割，从而成为规范化的设备坐标。规范化的设备坐标范围为-1.0到1.0。\n\n## 透视分割\n\n透视分割取得裁剪坐标(X<sub>c</sub>, Y<sub>c</sub>, Z<sub>c</sub>, W<sub>c</sub>)指定的点，并将其投影到屏幕或者视口上。这个投影通过将(X<sub>c</sub>, Y<sub>c</sub>, Z<sub>c</sub>)除以W<sub>c</sub>进行。执行(X<sub>c</sub>/W<sub>c</sub>)、(Y<sub>c</sub>/W<sub>c</sub>)和(Z<sub>c</sub>/W<sub>c</sub>)之后，我们得到规范化的设备坐标(X<sub>d</sub>, Y<sub>d</sub>, Z<sub>d</sub>)。这些坐标被称为规范化设备坐标，因为他们落在[-1.0...1.0]区间。这些规范化的(X<sub>d</sub>, Y<sub>d</sub>)坐标根据视口的大小将被转换为真正的屏幕（或者窗口）坐标。规范化的(Z<sub>d</sub>)坐标将用`glDepthRangef`指定的`near`和`far`深度值转换为屏幕的Z值，这些转换在视口变换阶段进行。\n\n## 视口变换\n\n视口是一个二维矩阵窗口区域，是所有OpenGL ES渲染操作最终显示的地方。视口变换可用如下API调用设置：\n\n``` objc\n/**\n 视口窗口\n\n @param x#> 指定视口左下角的窗口坐标x，以像素数表示 description#>\n @param y#> 指定视口左下角的窗口坐标y，以像素数表示 description#>\n @param width#> 指定视口的宽度（以像素数表示）；必须大于0 description#>\n @param height#> 指定视口的高度（以像素数表示）；必须大于0 description#>\n @return void\n */\nglViewport(GLint x, GLint y, GLsizei width, GLsizei height);\n```\n\n从规范化设备坐标(x<sub>d</sub>, y<sub>d</sub>, z<sub>d</sub>)到窗口坐标(x<sub>w</sub>, y<sub>w</sub>, z<sub>w</sub>)的转换用如下变换给出：\n\n![矩阵变换](/img/article/20190801/6.png)\n\n在这个变换中，o<sub>x</sub>=x+w/2，o<sub>y</sub>=y+h/2，n和f代表所需的深度范围。\n深度范围值n和f可以用如下API调用设置：\n\n```objc\n/**\n 设置深度值\n\n @param zNear#> 指定所需的深度范围，默认值为0.0，限于(0.0, 1.0)区间内 description#>\n @param zFar#> 指定所需的深度范围，默认值为1.0，限于(0.0, 1.0)区间内 description#>\n @return void\n */\nglDepthRangef(GLclampf zNear, GLclampf zFar);\n```\n\n`glDepthRangef`和`glViewport`指定的值用于将顶点位置从规范化设备坐标转换为窗口（屏幕）坐标。\n\n# 光栅化\n\n下图展示了光栅化管线。在顶点变换和图元裁剪之后，光栅化管线取得单独图元（如三角形、线段或者点精灵），并为该图元生成对应的片段。每个片段由屏幕空间中的整数位置(x, y)标识。片段代表了屏幕空间中(x, y)指定的像素位置和由片段着色器处理而生成片段颜色的附加片段数据。\n\n![OpenGL ES光栅化阶段](/img/article/20190801/7.png)\n\n## 剔除\n\n在三角形被光栅化之前，我们需要确定它们是正面（也就是面向观看者）或者背面（也就是背向观看者）。剔除（culling）操作抛弃背向观看者的三角形。要确定三角形是正面还是背面，首先需要知道它的方向。\n\n三角形的方向指定从第一个顶点开始，经过第二个和第三个顶点，最后回到第一个顶点的弯曲方向或者路径顺序。下图展示了弯曲顺序为顺时针和逆时针的两个三角形实例。\n\n![顺时针和逆时针的三角形](/img/article/20190801/8.png)\n\n三角形的方向通过以窗口坐标表示的有符号三角形的面积来计算。我们现在需要将计算出来的三角形面积符号翻译为顺时针（CW）或者逆时针（CCW）方向。这种从三角形面积的符号到顺时针或者逆时针方向的映射由应用程序用如下API调用指定：\n\n```objc\n/**\n 指定正面三角形的方向\n\n @param mode#> 指定正面三角形的方向，有效值为GL_CW或者GL_CCW，默认值为GL_CCW description#>\n @return void\n */\nglFrontFace(GLenum mode);\n```\n\n要确定需要提出的三角形，需要知道三角形将被剔除的面。通过如下API调用：\n\n``` objc\n/**\n 剔除三角形\n\n @param mode#> 指定要被剔除的三角形的面，有效值为GL_FROUNT、GL_BACK、GL_FROUNT_AND_BACK，默认值为GL_BACK description#>\n @return void\n */\nglCullFace(GLenum mode);\n```\n\n最后一个要点是，需要知道剔除操作是否应该执行。如果`GL_CULL_FACE`状态启用，剔除操作将被执行。通过如下API调用启用或者禁用：\n\n``` objc\n/**\n 启用剔除\n\n @param cap#> 设置为GL_CULL_FACE，默认情况下剔除被禁用 description#>\n @return void\n */\nglEnable(GLenum cap);\n\n/**\n 禁用剔除\n\n @param cap#> 设置为GL_CULL_FACE，默认情况下剔除被禁用 description#>\n @return void\n */\nglDisable(GLenum cap);\n```\n\n概括起来，要剔除合适的三角形，OpenGL ES应用程序首先必须用`glEnable(GL_CULL_FACE)`启用剔除，用`glCullFace`设置相应的剔除面，并用`glFrontFace`设置正面三角形的方向。\n\n> 剔除应该始终启用，以避免GPU浪费时间去光栅化不可见的三角形。启用剔除应该能够改善OpenGL ES应用程序的整体性能。\n\n## 多边形偏移\n\n考虑绘制两个相互重叠的多边形的情况。很可能会有伪像，这些伪像被称为深度冲突伪像，是因为三角形光栅化的精度有限而发生的，这种精度限制可能影响逐片段生成的深度值的精度，造成伪像。三角形光栅化使用的参数和生成的逐片段深度值的有限精度将越来越好，但是这个问题永远无法完全解决。\n\n为了避免看到伪像，我们需要在执行深度测试和深度值写入深度缓冲区之前，在计算出来的深度值上添加一个偏移量。如果深度测试通过，原始的深度值--而不是原始深度值+偏移--将被保存到深度缓冲区中。\n\n多边形偏移：\n\n``` objc\n/**\n 多边形偏移\n\n @param factor#> 因数 description#>\n @param units#> 单位数 description#>\n @return void\n */\nglPolygonOffset(GLfloat factor, GLfloat units);\n```\n\n深度偏移的计算如下：深度偏移 = m * 因数 + r * 单位数。m是三角形的最大深度斜率，斜率项在三角形光栅化阶段期间由OpenGL ES实现计算；r是一个OpenGL ES实现定义的常量，代表深度值中可以保证产生差异的最小值。\n多边形偏移可以分别用`glEnable(GL_POLYGON_OFFSET_FILL)`和`glDisable(GL_POLYGON_OFFSET_FILL)`启用或者禁用。\n\n例子：\n``` objc\nconst float polygonOffsetFactor = -1.0f;\nconst float polygonOffsetUnits = -2.0f;\n\nglClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n\n// load vertex shader\n// set the appropriate transformation matrices\n// set the vertex attribute state\n\n// draw the SMALLER quad\nglDrawArrays(GL_TRIANGLE_FAN, 0, 4);\n\n// set the depth func to <= as polygons are coplanar\nglDrawFunc(GL_LEQUAL);\n\nglEnable(GL_POLYGON_OFFSET_FILL);\n\nglPolygonOffset(polygonOffsetFactor, polygonOffsetUnits);\n\n// set the vertex attribute state\n\n// draw the LARGER quad\nglDrawArrays(GL_TRIANGLE_FAN, 0, 4);\n```\n\n# 遮挡查询\n\n遮挡查询用查询对象来跟踪通过深度测试的任何片段或者样本。这种方法可用于不同的技术，例如镜头炫光特效的可见性测试以及避免在包围体被遮挡的不可见对象上进行几何形状处理的优化。\n\n遮挡查询的开始和结束：\n\n``` objc\n/**\n 遮挡查询开始\n\n @param target#> 指定查询对象的目标类型；有效值是GL_ANY_SAMPLES_PASSED，GL_ANY_SAMPLES_PASSED_CONSERVATIVE，GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN description#>\n @param id#> 指定查询对象的名称 description#>\n @return void\n */\nglBeginQuery(GLenum target, GLuint id);\n    \n    \n/**\n 遮挡查询结束\n\n @param target#> 指定查询对象的目标类型；有效值是GL_ANY_SAMPLES_PASSED，GL_ANY_SAMPLES_PASSED_CONSERVATIVE，GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN description#>\n @return void\n */\nglEndQuery(GLenum target);\n```\n\n使用`GL_ANY_SAMPLES_PASSED`目标奖返回表示是否有样本通过深度测试的精确布尔状态；`GL_ANY_SAMPLES_PASSED_CONSERVATIVE`目标将提供更好的性能，但是答案的精确度较低；使用`GL_ANY_SAMPLES_PASSED_CONSERVATIVE`，有些实现将在没有样本通过深度测试时返回`GL_TRUE`。\n\n`id`用`glGenQueries`创建，用`glDeleteQueries`删除：\n\n``` objc\n/**\n 创建查询id\n\n @param n#> 指定生成的查询名称对象的数量 description#>\n @param ids#> 指定一个数组，以存储查询名称对象的列表 description#>\n @return void\n */\nglGenQueries(GLsizei n, GLuint *ids);\n    \n    \n/**\n 删除查询id\n\n @param n#> 指定要删除的查询名称对象的数量 description#>\n @param ids#> 指定一个需要删除的查询名称对象的列表数组 description#>\n @return void\n */ \nglDeleteQueries(GLsizei n, const GLuint *ids);\n```\n\n在用`glBeginQuery`和`glEndQuery`指定查询对象边界之后，可以使用`glGetQueryObjectuiv`检索查询对象的结果：\n\n``` objc\n/**\n 检索查询对象的结果\n\n @param id#> 指定查询对象的名称 description#>\n @param pname#> 指定需要检索的查询对象参数，可以为GL_QUERY_RESULT或GL_QUERY_RESULT_AVAILABLE description#>\n @param params#> 指定存储返回参数值得对象类型的数组 description#>\n @return void\n */\nglGetQueryObjectuiv(GLuint id, GLenum pname, GLuint *params);\n```\n\n# 总结\n\n这篇文章主要学习了OpenGL ES支持的图元类型，并且了解了如何用常规的非实例化和实例化绘图调用高效地绘制它们。还讨论了在顶点上执行坐标变换的方法。还学习了关于光栅化阶段的知识，在这个阶段，图元被转换为代表屏幕上绘制的像素的偏度。","source":"_posts/2019/opengl-es-primitive-0801.md","raw":"---\ntitle: \"OpenGL ES学习--图元装配和光栅化\"\ncatalog: true\ntoc_nav_num: true\ndate: 2019-08-01 19:09:32\nsubtitle: \"About OpenGL ES\"\nheader-img: \"/img/article_header/article_header.png\"\nbusuanzi: true\ntags:\n- iOS\n\n---\n\n> 本章描述OpenGL ES支持的图元和几何形状对象的类型，并说明绘制它们的方法。然后描述发生在顶点着色器处理图元顶点之后的图元装配阶段。在这一阶段，执行裁剪、透视分割和视口变换操作，对这些操作将作详细的讨论。本章以光栅化阶段的描述作为结束。光栅化是将图元转换为一组二维片段的过程，这些片段由片段着色器处理，代表可以在屏幕上绘制的像素。\n\n# 图元\n\n图元是可以用OpenGL ES中的`glDrawArrays`、`glDrawElements`、`glDrawRangeElements`、`glDrawArraysInstanced`、`glDrawElementsInstanced`命令绘制的几何形状对象。图元由一组表示顶点位置的顶点描述。其他如颜色、纹理坐标和几何法线等信息也作为通用属性与每个顶点关联。\n\nOpenGL ES 3.0可以绘制如下图元：\n- 三角形\n- 直线\n- 点精灵\n\n## 三角形\n\n三角形代表着描述由3D应用程序渲染的几何形状对象时最常用的方法。OpenGL ES支持的三角形图元有`GL_TRIANGLES`、`GL_TRIANGLE_STRIP`和`GL_TRIANGLE_FAN`。\n\n![三角形图元类型](/img/article/20190801/1.png)\n\n`GL_TRIANGLES`绘制一系列单独的三角形。如上图所示，绘制了顶点为(v<sup>0</sup>, v<sup>1</sup>, v<sup>2</sup>)和(v<sup>3</sup>, v<sup>4</sup>, v<sup>5</sup>)的两个三角形。总共绘制了n/3个三角形，其中n为`glDraw*`函数中的`count`指定的索引。\n\n`GL_TRIANGLE_STRIP`绘制一系列相互连接的三角形。如上图所示，绘制了4个顶点为(v<sup>0</sup>, v<sup>1</sup>, v<sup>2</sup>)、(v<sup>2</sup>, v<sup>1</sup>, v<sup>3</sup>)、(v<sup>2</sup>, v<sup>3</sup>, v<sup>4</sup>)和(v<sup>4</sup>, v<sup>3</sup>, v<sup>5</sup>)的三角形（注意顺序）。总共绘制了n-2个三角形，其中n为`glDraw*`函数中的`count`指定的索引。\n\n`GL_TRIANGLE_FAN`也绘制一系列相连的三角形。如上图所示，绘制了3个顶点为(v<sup>0</sup>, v<sup>1</sup>, v<sup>2</sup>)、(v<sup>0</sup>, v<sup>2</sup>, v<sup>3</sup>)和(v<sup>0</sup>, v<sup>3</sup>, v<sup>4</sup>)的三角形，总共绘制了n-2个三角形，其中n为`glDraw*`函数中的`count`指定的索引。\n\n## 直线\n\nOpenGL ES支持的直线图元有`GL_LINES`、`GL_LINE_STRIP`和`GL_LINE_LOOP`。\n\n![直线图元类型](/img/article/20190801/2.png)\n\n`GL_LINES`绘制一系列不相连的线段。如上图所示，绘制了端点为(v<sup>0</sup>, v<sup>1</sup>)、(v<sup>2</sup>, v<sup>3</sup>)和(v<sup>4</sup>, v<sup>5</sup>)的单独线段。总共绘制了n/2条线段，其中n为`glDraw*`函数中的`count`指定的索引。\n\n`GL_LINE_STRIP`绘制一系列相连的线段。如上图所示，绘制了3条端点为(v<sup>0</sup>, v<sup>1</sup>)、(v<sup>1</sup>, v<sup>2</sup>)和(v<sup>2</sup>, v<sup>3</sup>)的线段。总共绘制了n-1条线段，其中n为`glDraw*`函数中的`count`指定的索引。\n\n除了最后一条线段从v<sup>n-1</sup>到v<sup>0</sup>之外，`GL_LINE_LOOP`和`GL_LINE_STRIP`的绘制方法类似。如上图所示，绘制了端点为(v<sup>0</sup>, v<sup>1</sup>)、(v<sup>1</sup>, v<sup>2</sup>)、(v<sup>2</sup>, v<sup>3</sup>)、(v<sup>3</sup>, v<sup>4</sup>)和(v<sup>4</sup>, v<sup>0</sup>)的线段。总共绘制了n条线段，其中n为`glDraw*`函数中的`count`指定的索引。\n\n线段的宽度用`glLineWidth`API调用指定：\n\n``` objc\n/**\n 设置线宽\n\n @param width#> 指定线宽，以像素数表示；默认宽度为1.0 description#>\n @return void\n */\nglLineWidth(GLfloat width);\n```\n\n`glLineWidth`指定的宽度将受限于OpenGL ES 3.0实现所支持的线宽范围。此外，指定的宽度将被OpenGL记住，直到应用程序更新。支持的线宽范围可以用如下的命令查询，对于大于1\n的线宽，没有强制支持。\n\n``` objc\nGLfloat lineWidthRange[2];\nglGetFloatv(GL_ALIASED_LINE_WIDTH_RANGE, lineWidthRange);\n```\n\n## 点精灵\n\nOpenGL ES支持的点精灵图元是`GL_POINTS`。点精灵对指定的每个顶点绘制。点精灵通常用于将粒子效果当做点而非正方形绘制，从而实现高效渲染。点精灵是指定位置和半径的屏幕对齐的正方形，位置描述正方形的中心，半径用于计算描述点精灵的正方形的4个坐标。\n\n`gl_PointSize`是可用于在顶点着色器中输出点半径（或者点尺寸）的内建变量。与点图元相关的顶点着色器输出`gl_PointSize`很重要，否则，点尺寸值被视为未定义，很可能会造成绘图错误。顶点着色器输出的`gl_PointSize`受到OpenGL ES 3.0实现所支持的非平滑点尺寸范围的限制。这个范围可以用如下命令查询：\n``` objc\nGLfloat pointSizeRange[2];\nglGetFloatv(GL_ALIASED_POINT_SIZE_RANGE, pointSizeRange);\n```\n\n默认情况下，OpenGL ES 3.0将窗口原点(0, 0)描述为(左, 下)区域，但是，对于点精灵，点坐标的原点是(左, 上)。\n\n`gl_PointCoord`是只能在渲染图元为点精灵时用于片段着色器内部的内建变量，它用`mediump`精度限定符声明一个vec2变量。随着我们从左侧移到右侧，从顶部移到底部，赋予`gl_PointCoord`的值从0~1变化。\n\n# 绘制图元\n\nOpenGL ES中有5个绘制图元的API调用：`glDrawArrays`、`glDrawElements`、`glDrawRangeElements`、`glDrawArraysInstanced`和`glDrawElementsInstanced`。\n\n``` objc\n/**\n 绘制图元\n\n @param mode#> 指定要渲染的图元，有效值为GL_POINTS, GL_LINES, GL_LINES_STRIP, GL_LINES_LOOP, GL_TRIANGLES, GL_TRIANGLES_STRIP, GL_TRIANGLE_FAN description#>\n @param first#> 指定启用的顶点数组中的起始顶点索引 description#>\n @param count#> 指定要绘制的顶点数量 description#>\n @return void\n */\nglDrawArrays(GLenum mode, GLint first, GLsizei count);\n\n/**\n 绘制图元\n\n @param mode#> 指定要渲染的图元，有效值为GL_POINTS, GL_LINES, GL_LINES_STRIP, GL_LINES_LOOP, GL_TRIANGLES, GL_TRIANGLES_STRIP, GL_TRIANGLE_FAN description#>\n @param count#> 指定要绘制的索引数量 description#>\n @param type#> 指定indices中保存的元素索引类型，有效值为GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, GL_UNSIGNED_INT description#>\n @param indices#> 指向元素索引存储位置的指针 description#>\n @return void\n */\nglDrawElements(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices)\n\n/**\n 绘制图元\n\n @param mode#> 指定要渲染的图元，有效值为GL_POINTS, GL_LINES, GL_LINES_STRIP, GL_LINES_LOOP, GL_TRIANGLES, GL_TRIANGLES_STRIP, GL_TRIANGLE_FAN description#>\n @param start#> 指定indices中的最小数组索引 description#>\n @param end#> 指定indices中的最大数组索引 description#> \n @param count#> 指定要绘制的索引数量 description#>\n @param type#> 指定indices中保存的元素索引类型，有效值为GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, GL_UNSIGNED_INT description#>\n @param indices#> 指向元素索引存储位置的指针 description#>\n @return void\n */\nglDrawRangeElements(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices)\n```\n\n如果有一个一系列顺序元素索引描述的图元，且几何形状的顶点不共享，则`glDrawArrays`很好用，但是，游戏或者其他3D应用程序使用的典型对象由多个三角形网格组成，其中的元素索引可能不一定按照顺序，顶点通常在网格的三角形直接共享。\n\n比如考虑上图立方体的绘制，如果我们用`glDrawArrays`绘制，则代码如下：\n\n``` objc\nGLfloat vertices[] = { .. };\nglEnableVertexAttribArray(0);\nglVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, vertices);\nglDrawArrays(GL_TRIANGLES, 0, 36);\n```\n\n为了用`glDrawArrays`绘制这个立方体，需要为立方体的每一个面调用`glDrawArrays`。共享的顶点必须重复，这意味着需要分配24个顶点（如果将每面当做`GL_TRIANGLE_FAN`绘制）或者36个顶点（如果使用`GL_TRIANGLES`），而不是8个顶点。这不是一个高效的做法。\n\n用`glDrawElements`绘制同一个立方体的代码如下：\n\n``` objc\nGLfloat vertices[] = { .. };\nGLubyte indices[36] = {\n    0, 1, 2, 0, 2, 3,\n    0, 3, 4, 0, 4, 5,\n    7, 1, 6, 7, 2, 1,\n    7, 5, 4, 7, 6, 5,\n    7, 3, 2, 7, 4, 3\n}\nglEnableVertexAttribArray(0);\nglVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, vertices);\nglDrawElements(GL_TRIANGLES, 36, GL_USINGED_BYTE, indices);\n```\n\n即使我们用`glDrawElements`绘制三角形，用`glDrawArrays`和`glDrawElements`绘制一个三角扇形，我们的应用程序在GPU上运行的也比`glDrawArrays`更快，这有很多原因。比如，由于顶点重用，顶点属性数据的尺寸将小于`glDrawElements`。这也导致较小的内存占用和内存贷款需求。\n\n## 图元重启\n\n使用图元重启，可以在一次绘图调用中渲染多个不相连的图元（例如三角扇形或者条带）。这对于降低绘图API的调用的开销是有利的。图元重启的另一种方法是生成退化三角形（需要一些注意事项），这种方法较不简洁。\n\n使用图元重启，可以通过在索引列表中插入一个特殊索引来重启一个用于索引绘图调用（如`glDrawElements`、`glDrawElementsInstances`或`glDrawRangeElements`）的图元。这个特殊索引是该索引类型的最大索引（例如，索引类型为`GL_UNSIGNED_BYTE`或`GL_UNSIGNED_SHORT`时，分别为255或者65535）。\n\n例如，假定两个三角形条带分别有元素索引(0, 1, 2, 3)和(8, 9, 10, 11)。如果我们想利用图元重启在一次调用`glDrawElements*`中绘制两个条带，索引类型为`GL_UNSIGNED_BYTE`，则组合的元素索引列表为(0, 1, 2, 3, 255, 8, 9, 10, 11)。\n\n可以用如下代码启用和禁用图元启用：\n``` objc\nglEnable(GL_PRIMITIVE_RESTART_FIXED_INDEX);\n// draw primitives\nglDisable(GL_PRIMITIVE_RESTART_FIXED_INDEX);\n```\n\n代码示例：\n\n``` objc\n// 配置\nGLfloat vertices[] = {\n    -0.75f, 0, 0,\n    -0.75f, 0.75f, 0,\n    -0.25f, 0, 0,\n    -0.25f, 0.75, 0,\n    \n    0.75f, 0, 0,\n    0.75f, 0.75f, 0,\n    0.25f, 0, 0,\n    0.25f, 0.75, 0\n};\nGLfloat colors[] = {\n    1.0f, 0.0f, 0.0f, 1.0f,\n    0.0f, 1.0f, 0.0f, 1.0f,\n    0.0f, 0.0f, 1.0f, 1.0f,\n    0.0f, 1.0f, 0.0f, 1.0f,\n    \n    1.0f, 0.0f, 0.0f, 1.0f,\n    0.0f, 1.0f, 0.0f, 1.0f,\n    0.0f, 0.0f, 1.0f, 1.0f,\n    0.0f, 1.0f, 0.0f, 1.0f\n};\nGLushort indices[] = {0, 1, 2, 3, 65535, 4, 5, 6, 7};\n\nGLuint vbos[3];\nglGenBuffers(3, vbos);\nglBindBuffer(GL_ARRAY_BUFFER, vbos[0]);\nglBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);\n\nglBindBuffer(GL_ARRAY_BUFFER, vbos[1]);\nglBufferData(GL_ARRAY_BUFFER, sizeof(colors), colors, GL_STATIC_DRAW);\n\nglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vbos[2]);\nglBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);\n\nglGenVertexArrays(1, &vaos);\nglBindVertexArray(vaos);\n\nglBindBuffer(GL_ARRAY_BUFFER, vbos[0]);\nglEnableVertexAttribArray(0);\nglVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(GLfloat), 0);\nglBindBuffer(GL_ARRAY_BUFFER, vbos[1]);\nglEnableVertexAttribArray(1);\nglVertexAttribPointer(1, 4, GL_FLOAT, GL_FALSE, 4 * sizeof(GLfloat), 0);\nglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vbos[2]);\n\nglBindVertexArray(0);\n\n// 绘制\nglEnable(GL_PRIMITIVE_RESTART_FIXED_INDEX);\n\nglBindVertexArray(vaos);\nglDrawElements(GL_TRIANGLE_STRIP, 9, GL_UNSIGNED_SHORT, 0);\n\nglDisable(GL_PRIMITIVE_RESTART_FIXED_INDEX);\n```\n\n## 驱动顶点\n\n如果没有限定符，那么顶点着色器的输出值在图元中使用线性插值。但是，使用平面着色时没有发生插值。因为没有发生插值，所以片段着色器中只有一个顶点值可用。对于给定的图元实例，这个驱动顶点确定使用顶点着色器的哪一个顶点输出，因为只能使用一个顶点。[插值限定符](/article/2019/opengl-es-glsl-0715/#插值限定符)。\n\n图元i的类型 | 驱动顶点\n- | -\nGL_POINT | i\nGL_LINES | 2i\nGL_LINE_LOOP | 如果i < n，为i + 1；如果i = n，为1\nGL_LINE_STRIP | i + 1\nGL_TRIANGLES | 3i\nGL_TRIANGLE_STRIP | i + 2\nGL_TRIANGLE_FAN | i + 2\n\n> 第i个图元实例的驱动顶点选择，顶点的编号从1到n，n是绘制的顶点数量。\n\n## 几何形状实例化\n\n几何形状实例化很高效，可以用一次API调用多次渲染具有不同属性（例如不同的变换矩阵、颜色或者大小）的一个对象。这一功能在渲染大量类似对象时很有用，例如对人群的渲染。几何图形实例化降低了向OpenGL ES引擎发送许多API调用的CPU处理开销。要使用实例化绘图调用渲染，可以使用如下命令：\n\n``` objc\n/**\n 实例化绘图\n\n @param mode#> 指定要渲染的图元，有效值为GL_POINTS, GL_LINES, GL_LINES_STRIP, GL_LINES_LOOP, GL_TRIANGLES, GL_TRIANGLES_STRIP, GL_TRIANGLE_FAN description#>\n @param first#> 指定要启用的顶点数组中的起始顶点索引 description#>\n @param count#> 指定绘制的索引数量 description#>\n @param instancecount#> 指定绘制的图元实例数量 description#>\n @return void\n */\nglDrawArraysInstanced(GLenum mode, GLint first, GLsizei count, GLsizei instancecount);\n\n/**\n 实例化绘图\n\n @param mode#> 指定要渲染的图元，有效值为GL_POINTS, GL_LINES, GL_LINES_STRIP, GL_LINES_LOOP, GL_TRIANGLES, GL_TRIANGLES_STRIP, GL_TRIANGLE_FAN description#>\n @param count#> 指定绘制的索引数量 description#>\n @param type#> 指定保存在indices中的元素索引类型，有效值为GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, GL_UNSIGNED_INT description#>\n @param indices#> 指定元素索引存储位置的一个指针 description#>\n @param instancecount#> 指定绘制的图元实例数量 description#>\n @return void\n */\nglDrawElementsInstanced(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei instancecount);\n```\n\n可以使用两种方法访问每个实例的数据。第一种方法是用如下命令指示OpenGL ES对每个实例读取一次或者多次顶点属性：\n\n``` objc\n/**\n 对每个实例读取一次或多次顶点属性\n\n @param index#> 指定通用顶点属性索引 description#>\n @param divisor#> 指定index位置的通用属性更新之间传递传递的实例数量 description#>\n @return void\n */\nglVertexAttribDivisor(GLuint index, GLuint divisor);\n```\n\n默认情况下，如果没有指定`glVertexAttribDivisor`或者每个顶点属性的`divisor`等于零，对每个顶点将读取一次顶点属性。如果`divisor`等于1，则每个图元实例读取一次顶点属性。[代码例子](https://github.com/danginsburg/opengles3-book/blob/master/Chapter_7/Instancing/Instancing.c)\n\n第二种方法是使用内建输入变量`glInstanceID`作为顶点着色器中的缓冲区索引，以访问每个实例的数据（仅限OpenGL ES 3.0）。使用前面提到的几何形状实例化API调用时，`gl_InstanceID`将保存当前图元实例的索引。使用非实例化绘图调用时，`gl_InstanceID`将返回0。\n\n## 性能提示\n\n应用程序应该确保用尽可能大的图元尺寸调用`glDrawElements`和`glDrawElementsInstanced`。如果我们绘制`GL_TRIANGLES`，这很容易做到，但是，如果有三角形条带或者扇形的网格，则可以用图元重启将这些网格连接在一起，而不用对每个三角形条带网格单独调用`glDrawElements*`。\n\n如果无法使用图元重启机制将网格连接到一起（为了维护和旧版本OpenGL ES的兼容性），可以添加造成退化三角形的元素索引，代价是使用更多的索引。退化三角形是两个或者更多顶点相同的三角形。GPU可以非常简单的检测和拒绝退化三角形，所以这是很好的性能改进，我们可以讲一个很大的图元放入右GPU渲染的队列。\n\n代码示例：\n\n``` objc\n// 配置\nGLfloat vertices[] = {\n    -0.75f, 0, 0,\n    -0.75f, 0.75f, 0,\n    -0.25f, 0, 0,\n    -0.25f, 0.75, 0,\n    \n    0.75f, 0, 0,\n    0.75f, 0.75f, 0,\n    0.25f, 0, 0,\n    0.25f, 0.75, 0\n};\nGLfloat colors[] = {\n    1.0f, 0.0f, 0.0f, 1.0f,\n    0.0f, 1.0f, 0.0f, 1.0f,\n    0.0f, 0.0f, 1.0f, 1.0f,\n    0.0f, 1.0f, 0.0f, 1.0f,\n    \n    1.0f, 0.0f, 0.0f, 1.0f,\n    0.0f, 1.0f, 0.0f, 1.0f,\n    0.0f, 0.0f, 1.0f, 1.0f,\n    0.0f, 1.0f, 0.0f, 1.0f\n};\nGLushort indices[] = {0, 1, 2, 3, 3, 4, 4, 5, 6, 7};\n\nGLuint vbos[3];\nglGenBuffers(3, vbos);\nglBindBuffer(GL_ARRAY_BUFFER, vbos[0]);\nglBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);\n\nglBindBuffer(GL_ARRAY_BUFFER, vbos[1]);\nglBufferData(GL_ARRAY_BUFFER, sizeof(colors), colors, GL_STATIC_DRAW);\n\nglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vbos[2]);\nglBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);\n\nglGenVertexArrays(1, &vaos);\nglBindVertexArray(vaos);\n\nglBindBuffer(GL_ARRAY_BUFFER, vbos[0]);\nglEnableVertexAttribArray(0);\nglVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(GLfloat), 0);\nglBindBuffer(GL_ARRAY_BUFFER, vbos[1]);\nglEnableVertexAttribArray(1);\nglVertexAttribPointer(1, 4, GL_FLOAT, GL_FALSE, 4 * sizeof(GLfloat), 0);\nglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vbos[2]);\n\nglBindVertexArray(0);\n\n// 绘制\nglBindVertexArray(vaos);\nglDrawElements(GL_TRIANGLE_STRIP, 10, GL_UNSIGNED_SHORT, 0);\n```\n\n# 图元装配\n\n下图展示了图元装配阶段。通过`glDraw***`提供的顶点由顶点着色器执行，顶点着色器变换的每个顶点包括描述顶点(x, y, z, w)值的顶点位置。图元位置和顶点索引确定将被渲染的单独图元。对于每个单独图元（三角形、直线和点）及其对应的顶点，图元装配阶段执行图中所示的操作。\n\n![OpenGL ES图元装配阶段](/img/article/20190801/3.png)\n\n## 坐标系统\n\n下图展示了顶点通过顶点着色器和图元装配阶段时的坐标系统。顶点以物体或者本地坐标空间输入到OpenGL ES，这是最可能用来建模和存储一个对象的坐标空间。在顶点着色器执行之后，顶点位置被认为是在裁剪坐标空间内。顶点位置从本地坐标系统（也就是物体坐标）到裁剪坐标的变换通过加载执行这一转换的对应矩阵来完成，这些矩阵保存在顶点着色器中定义的统一变量中。\n\n![坐标系统](/img/article/20190801/4.png)\n\n### 裁剪\n\n为了避免在可视景体之外处理图元，图元被裁剪到裁剪空间。执行顶点着色器之后的顶点位置处于裁剪坐标空间内。裁剪坐标是由(x<sub>c</sub>, y<sub>c</sub>, z<sub>c</sub>, w<sub>c</sub>)指定的同类坐标。在裁剪空间(x<sub>c</sub>, y<sub>c</sub>, z<sub>c</sub>, w<sub>c</sub>)中定义的顶点坐标根据视景体（又称裁剪体）裁剪。\n\n裁剪体由6个裁剪平面定义，这些平面称作近、远、左、右、上、下裁剪平面。在裁剪坐标中，裁剪体如下：-w<sub>c</sub> <= x<sub>c</sub> <= w<sub>c</sub>，-w<sub>c</sub> <= y<sub>c</sub> <= w<sub>c</sub>，-w<sub>c</sub> <= z<sub>c</sub> <= w<sub>c</sub>。\n\n![视景体](/img/article/20190801/5.png)\n\n裁剪阶段将把每个图元裁剪为上图所示的裁剪体。我们在这里说的“图元”，是指用`GL_TRIANGLES`绘制的单独三角形列表中的每一个三角形，或者一个三角形条带或者扇形中的一个三角形，或者用`GL_LINES`绘制的单独直线列表中的一条直线，或者一个直线条带或者闭合折线中的一条直线，或者点精灵列表中的一个特定点。对于每种图元类型，执行如下操作：\n- 裁剪三角形--如果三角形完全在视景体内部，则不执行任何裁剪。如果三角形完全在视景体之外，则该三角形被放弃。如果三角形部分在视景体内，则根据相应的平面裁剪三角形。裁剪操作将生成新的顶点，这些顶点被裁剪到安排为三角形扇形的平面。\n- 裁剪直线--如果直线完全在视景体内部，则不执行任何裁剪。如果直线完全在视景体之外，则该直线被放弃。如果直线部分在视景体内，则直线被裁剪并生成相应的新顶点。\n- 裁剪点精灵--如果点位置在近或者远裁剪平面之外，或者如果表示点精灵的正方形在裁剪体之外，裁剪阶段将抛弃点精灵。否则，它将不做变化地通过该阶段，点精灵将在其裁剪体内部移到外部时裁剪，反之亦然。\n\n在图元根据六个裁剪平面进行裁剪时，顶点坐标经历透视分割，从而成为规范化的设备坐标。规范化的设备坐标范围为-1.0到1.0。\n\n## 透视分割\n\n透视分割取得裁剪坐标(X<sub>c</sub>, Y<sub>c</sub>, Z<sub>c</sub>, W<sub>c</sub>)指定的点，并将其投影到屏幕或者视口上。这个投影通过将(X<sub>c</sub>, Y<sub>c</sub>, Z<sub>c</sub>)除以W<sub>c</sub>进行。执行(X<sub>c</sub>/W<sub>c</sub>)、(Y<sub>c</sub>/W<sub>c</sub>)和(Z<sub>c</sub>/W<sub>c</sub>)之后，我们得到规范化的设备坐标(X<sub>d</sub>, Y<sub>d</sub>, Z<sub>d</sub>)。这些坐标被称为规范化设备坐标，因为他们落在[-1.0...1.0]区间。这些规范化的(X<sub>d</sub>, Y<sub>d</sub>)坐标根据视口的大小将被转换为真正的屏幕（或者窗口）坐标。规范化的(Z<sub>d</sub>)坐标将用`glDepthRangef`指定的`near`和`far`深度值转换为屏幕的Z值，这些转换在视口变换阶段进行。\n\n## 视口变换\n\n视口是一个二维矩阵窗口区域，是所有OpenGL ES渲染操作最终显示的地方。视口变换可用如下API调用设置：\n\n``` objc\n/**\n 视口窗口\n\n @param x#> 指定视口左下角的窗口坐标x，以像素数表示 description#>\n @param y#> 指定视口左下角的窗口坐标y，以像素数表示 description#>\n @param width#> 指定视口的宽度（以像素数表示）；必须大于0 description#>\n @param height#> 指定视口的高度（以像素数表示）；必须大于0 description#>\n @return void\n */\nglViewport(GLint x, GLint y, GLsizei width, GLsizei height);\n```\n\n从规范化设备坐标(x<sub>d</sub>, y<sub>d</sub>, z<sub>d</sub>)到窗口坐标(x<sub>w</sub>, y<sub>w</sub>, z<sub>w</sub>)的转换用如下变换给出：\n\n![矩阵变换](/img/article/20190801/6.png)\n\n在这个变换中，o<sub>x</sub>=x+w/2，o<sub>y</sub>=y+h/2，n和f代表所需的深度范围。\n深度范围值n和f可以用如下API调用设置：\n\n```objc\n/**\n 设置深度值\n\n @param zNear#> 指定所需的深度范围，默认值为0.0，限于(0.0, 1.0)区间内 description#>\n @param zFar#> 指定所需的深度范围，默认值为1.0，限于(0.0, 1.0)区间内 description#>\n @return void\n */\nglDepthRangef(GLclampf zNear, GLclampf zFar);\n```\n\n`glDepthRangef`和`glViewport`指定的值用于将顶点位置从规范化设备坐标转换为窗口（屏幕）坐标。\n\n# 光栅化\n\n下图展示了光栅化管线。在顶点变换和图元裁剪之后，光栅化管线取得单独图元（如三角形、线段或者点精灵），并为该图元生成对应的片段。每个片段由屏幕空间中的整数位置(x, y)标识。片段代表了屏幕空间中(x, y)指定的像素位置和由片段着色器处理而生成片段颜色的附加片段数据。\n\n![OpenGL ES光栅化阶段](/img/article/20190801/7.png)\n\n## 剔除\n\n在三角形被光栅化之前，我们需要确定它们是正面（也就是面向观看者）或者背面（也就是背向观看者）。剔除（culling）操作抛弃背向观看者的三角形。要确定三角形是正面还是背面，首先需要知道它的方向。\n\n三角形的方向指定从第一个顶点开始，经过第二个和第三个顶点，最后回到第一个顶点的弯曲方向或者路径顺序。下图展示了弯曲顺序为顺时针和逆时针的两个三角形实例。\n\n![顺时针和逆时针的三角形](/img/article/20190801/8.png)\n\n三角形的方向通过以窗口坐标表示的有符号三角形的面积来计算。我们现在需要将计算出来的三角形面积符号翻译为顺时针（CW）或者逆时针（CCW）方向。这种从三角形面积的符号到顺时针或者逆时针方向的映射由应用程序用如下API调用指定：\n\n```objc\n/**\n 指定正面三角形的方向\n\n @param mode#> 指定正面三角形的方向，有效值为GL_CW或者GL_CCW，默认值为GL_CCW description#>\n @return void\n */\nglFrontFace(GLenum mode);\n```\n\n要确定需要提出的三角形，需要知道三角形将被剔除的面。通过如下API调用：\n\n``` objc\n/**\n 剔除三角形\n\n @param mode#> 指定要被剔除的三角形的面，有效值为GL_FROUNT、GL_BACK、GL_FROUNT_AND_BACK，默认值为GL_BACK description#>\n @return void\n */\nglCullFace(GLenum mode);\n```\n\n最后一个要点是，需要知道剔除操作是否应该执行。如果`GL_CULL_FACE`状态启用，剔除操作将被执行。通过如下API调用启用或者禁用：\n\n``` objc\n/**\n 启用剔除\n\n @param cap#> 设置为GL_CULL_FACE，默认情况下剔除被禁用 description#>\n @return void\n */\nglEnable(GLenum cap);\n\n/**\n 禁用剔除\n\n @param cap#> 设置为GL_CULL_FACE，默认情况下剔除被禁用 description#>\n @return void\n */\nglDisable(GLenum cap);\n```\n\n概括起来，要剔除合适的三角形，OpenGL ES应用程序首先必须用`glEnable(GL_CULL_FACE)`启用剔除，用`glCullFace`设置相应的剔除面，并用`glFrontFace`设置正面三角形的方向。\n\n> 剔除应该始终启用，以避免GPU浪费时间去光栅化不可见的三角形。启用剔除应该能够改善OpenGL ES应用程序的整体性能。\n\n## 多边形偏移\n\n考虑绘制两个相互重叠的多边形的情况。很可能会有伪像，这些伪像被称为深度冲突伪像，是因为三角形光栅化的精度有限而发生的，这种精度限制可能影响逐片段生成的深度值的精度，造成伪像。三角形光栅化使用的参数和生成的逐片段深度值的有限精度将越来越好，但是这个问题永远无法完全解决。\n\n为了避免看到伪像，我们需要在执行深度测试和深度值写入深度缓冲区之前，在计算出来的深度值上添加一个偏移量。如果深度测试通过，原始的深度值--而不是原始深度值+偏移--将被保存到深度缓冲区中。\n\n多边形偏移：\n\n``` objc\n/**\n 多边形偏移\n\n @param factor#> 因数 description#>\n @param units#> 单位数 description#>\n @return void\n */\nglPolygonOffset(GLfloat factor, GLfloat units);\n```\n\n深度偏移的计算如下：深度偏移 = m * 因数 + r * 单位数。m是三角形的最大深度斜率，斜率项在三角形光栅化阶段期间由OpenGL ES实现计算；r是一个OpenGL ES实现定义的常量，代表深度值中可以保证产生差异的最小值。\n多边形偏移可以分别用`glEnable(GL_POLYGON_OFFSET_FILL)`和`glDisable(GL_POLYGON_OFFSET_FILL)`启用或者禁用。\n\n例子：\n``` objc\nconst float polygonOffsetFactor = -1.0f;\nconst float polygonOffsetUnits = -2.0f;\n\nglClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n\n// load vertex shader\n// set the appropriate transformation matrices\n// set the vertex attribute state\n\n// draw the SMALLER quad\nglDrawArrays(GL_TRIANGLE_FAN, 0, 4);\n\n// set the depth func to <= as polygons are coplanar\nglDrawFunc(GL_LEQUAL);\n\nglEnable(GL_POLYGON_OFFSET_FILL);\n\nglPolygonOffset(polygonOffsetFactor, polygonOffsetUnits);\n\n// set the vertex attribute state\n\n// draw the LARGER quad\nglDrawArrays(GL_TRIANGLE_FAN, 0, 4);\n```\n\n# 遮挡查询\n\n遮挡查询用查询对象来跟踪通过深度测试的任何片段或者样本。这种方法可用于不同的技术，例如镜头炫光特效的可见性测试以及避免在包围体被遮挡的不可见对象上进行几何形状处理的优化。\n\n遮挡查询的开始和结束：\n\n``` objc\n/**\n 遮挡查询开始\n\n @param target#> 指定查询对象的目标类型；有效值是GL_ANY_SAMPLES_PASSED，GL_ANY_SAMPLES_PASSED_CONSERVATIVE，GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN description#>\n @param id#> 指定查询对象的名称 description#>\n @return void\n */\nglBeginQuery(GLenum target, GLuint id);\n    \n    \n/**\n 遮挡查询结束\n\n @param target#> 指定查询对象的目标类型；有效值是GL_ANY_SAMPLES_PASSED，GL_ANY_SAMPLES_PASSED_CONSERVATIVE，GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN description#>\n @return void\n */\nglEndQuery(GLenum target);\n```\n\n使用`GL_ANY_SAMPLES_PASSED`目标奖返回表示是否有样本通过深度测试的精确布尔状态；`GL_ANY_SAMPLES_PASSED_CONSERVATIVE`目标将提供更好的性能，但是答案的精确度较低；使用`GL_ANY_SAMPLES_PASSED_CONSERVATIVE`，有些实现将在没有样本通过深度测试时返回`GL_TRUE`。\n\n`id`用`glGenQueries`创建，用`glDeleteQueries`删除：\n\n``` objc\n/**\n 创建查询id\n\n @param n#> 指定生成的查询名称对象的数量 description#>\n @param ids#> 指定一个数组，以存储查询名称对象的列表 description#>\n @return void\n */\nglGenQueries(GLsizei n, GLuint *ids);\n    \n    \n/**\n 删除查询id\n\n @param n#> 指定要删除的查询名称对象的数量 description#>\n @param ids#> 指定一个需要删除的查询名称对象的列表数组 description#>\n @return void\n */ \nglDeleteQueries(GLsizei n, const GLuint *ids);\n```\n\n在用`glBeginQuery`和`glEndQuery`指定查询对象边界之后，可以使用`glGetQueryObjectuiv`检索查询对象的结果：\n\n``` objc\n/**\n 检索查询对象的结果\n\n @param id#> 指定查询对象的名称 description#>\n @param pname#> 指定需要检索的查询对象参数，可以为GL_QUERY_RESULT或GL_QUERY_RESULT_AVAILABLE description#>\n @param params#> 指定存储返回参数值得对象类型的数组 description#>\n @return void\n */\nglGetQueryObjectuiv(GLuint id, GLenum pname, GLuint *params);\n```\n\n# 总结\n\n这篇文章主要学习了OpenGL ES支持的图元类型，并且了解了如何用常规的非实例化和实例化绘图调用高效地绘制它们。还讨论了在顶点上执行坐标变换的方法。还学习了关于光栅化阶段的知识，在这个阶段，图元被转换为代表屏幕上绘制的像素的偏度。","slug":"2019/opengl-es-primitive-0801","published":1,"updated":"2022-01-10T09:04:52.807Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cky8gmc4c0011d1qhnfnwfi2w","content":"<blockquote>\n<p>本章描述OpenGL ES支持的图元和几何形状对象的类型，并说明绘制它们的方法。然后描述发生在顶点着色器处理图元顶点之后的图元装配阶段。在这一阶段，执行裁剪、透视分割和视口变换操作，对这些操作将作详细的讨论。本章以光栅化阶段的描述作为结束。光栅化是将图元转换为一组二维片段的过程，这些片段由片段着色器处理，代表可以在屏幕上绘制的像素。</p>\n</blockquote>\n<h1 id=\"图元\">图元</h1>\n<p>图元是可以用OpenGL ES中的<code>glDrawArrays</code>、<code>glDrawElements</code>、<code>glDrawRangeElements</code>、<code>glDrawArraysInstanced</code>、<code>glDrawElementsInstanced</code>命令绘制的几何形状对象。图元由一组表示顶点位置的顶点描述。其他如颜色、纹理坐标和几何法线等信息也作为通用属性与每个顶点关联。</p>\n<p>OpenGL ES 3.0可以绘制如下图元：</p>\n<ul>\n<li>三角形</li>\n<li>直线</li>\n<li>点精灵</li>\n</ul>\n<h2 id=\"三角形\">三角形</h2>\n<p>三角形代表着描述由3D应用程序渲染的几何形状对象时最常用的方法。OpenGL ES支持的三角形图元有<code>GL_TRIANGLES</code>、<code>GL_TRIANGLE_STRIP</code>和<code>GL_TRIANGLE_FAN</code>。</p>\n<p><img src=\"/img/article/20190801/1.png\" alt=\"三角形图元类型\"></p>\n<p><code>GL_TRIANGLES</code>绘制一系列单独的三角形。如上图所示，绘制了顶点为(v<sup>0</sup>, v<sup>1</sup>, v<sup>2</sup>)和(v<sup>3</sup>, v<sup>4</sup>, v<sup>5</sup>)的两个三角形。总共绘制了n/3个三角形，其中n为<code>glDraw*</code>函数中的<code>count</code>指定的索引。</p>\n<p><code>GL_TRIANGLE_STRIP</code>绘制一系列相互连接的三角形。如上图所示，绘制了4个顶点为(v<sup>0</sup>, v<sup>1</sup>, v<sup>2</sup>)、(v<sup>2</sup>, v<sup>1</sup>, v<sup>3</sup>)、(v<sup>2</sup>, v<sup>3</sup>, v<sup>4</sup>)和(v<sup>4</sup>, v<sup>3</sup>, v<sup>5</sup>)的三角形（注意顺序）。总共绘制了n-2个三角形，其中n为<code>glDraw*</code>函数中的<code>count</code>指定的索引。</p>\n<p><code>GL_TRIANGLE_FAN</code>也绘制一系列相连的三角形。如上图所示，绘制了3个顶点为(v<sup>0</sup>, v<sup>1</sup>, v<sup>2</sup>)、(v<sup>0</sup>, v<sup>2</sup>, v<sup>3</sup>)和(v<sup>0</sup>, v<sup>3</sup>, v<sup>4</sup>)的三角形，总共绘制了n-2个三角形，其中n为<code>glDraw*</code>函数中的<code>count</code>指定的索引。</p>\n<h2 id=\"直线\">直线</h2>\n<p>OpenGL ES支持的直线图元有<code>GL_LINES</code>、<code>GL_LINE_STRIP</code>和<code>GL_LINE_LOOP</code>。</p>\n<p><img src=\"/img/article/20190801/2.png\" alt=\"直线图元类型\"></p>\n<p><code>GL_LINES</code>绘制一系列不相连的线段。如上图所示，绘制了端点为(v<sup>0</sup>, v<sup>1</sup>)、(v<sup>2</sup>, v<sup>3</sup>)和(v<sup>4</sup>, v<sup>5</sup>)的单独线段。总共绘制了n/2条线段，其中n为<code>glDraw*</code>函数中的<code>count</code>指定的索引。</p>\n<p><code>GL_LINE_STRIP</code>绘制一系列相连的线段。如上图所示，绘制了3条端点为(v<sup>0</sup>, v<sup>1</sup>)、(v<sup>1</sup>, v<sup>2</sup>)和(v<sup>2</sup>, v<sup>3</sup>)的线段。总共绘制了n-1条线段，其中n为<code>glDraw*</code>函数中的<code>count</code>指定的索引。</p>\n<p>除了最后一条线段从v<sup>n-1</sup>到v<sup>0</sup>之外，<code>GL_LINE_LOOP</code>和<code>GL_LINE_STRIP</code>的绘制方法类似。如上图所示，绘制了端点为(v<sup>0</sup>, v<sup>1</sup>)、(v<sup>1</sup>, v<sup>2</sup>)、(v<sup>2</sup>, v<sup>3</sup>)、(v<sup>3</sup>, v<sup>4</sup>)和(v<sup>4</sup>, v<sup>0</sup>)的线段。总共绘制了n条线段，其中n为<code>glDraw*</code>函数中的<code>count</code>指定的索引。</p>\n<p>线段的宽度用<code>glLineWidth</code>API调用指定：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 设置线宽</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param width#&gt; 指定线宽，以像素数表示；默认宽度为1.0 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glLineWidth(GLfloat width);</span><br></pre></td></tr></table></figure>\n<p><code>glLineWidth</code>指定的宽度将受限于OpenGL ES 3.0实现所支持的线宽范围。此外，指定的宽度将被OpenGL记住，直到应用程序更新。支持的线宽范围可以用如下的命令查询，对于大于1<br>\n的线宽，没有强制支持。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GLfloat lineWidthRange[<span class=\"number\">2</span>];</span><br><span class=\"line\">glGetFloatv(GL_ALIASED_LINE_WIDTH_RANGE, lineWidthRange);</span><br></pre></td></tr></table></figure>\n<h2 id=\"点精灵\">点精灵</h2>\n<p>OpenGL ES支持的点精灵图元是<code>GL_POINTS</code>。点精灵对指定的每个顶点绘制。点精灵通常用于将粒子效果当做点而非正方形绘制，从而实现高效渲染。点精灵是指定位置和半径的屏幕对齐的正方形，位置描述正方形的中心，半径用于计算描述点精灵的正方形的4个坐标。</p>\n<p><code>gl_PointSize</code>是可用于在顶点着色器中输出点半径（或者点尺寸）的内建变量。与点图元相关的顶点着色器输出<code>gl_PointSize</code>很重要，否则，点尺寸值被视为未定义，很可能会造成绘图错误。顶点着色器输出的<code>gl_PointSize</code>受到OpenGL ES 3.0实现所支持的非平滑点尺寸范围的限制。这个范围可以用如下命令查询：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GLfloat pointSizeRange[<span class=\"number\">2</span>];</span><br><span class=\"line\">glGetFloatv(GL_ALIASED_POINT_SIZE_RANGE, pointSizeRange);</span><br></pre></td></tr></table></figure>\n<p>默认情况下，OpenGL ES 3.0将窗口原点(0, 0)描述为(左, 下)区域，但是，对于点精灵，点坐标的原点是(左, 上)。</p>\n<p><code>gl_PointCoord</code>是只能在渲染图元为点精灵时用于片段着色器内部的内建变量，它用<code>mediump</code>精度限定符声明一个vec2变量。随着我们从左侧移到右侧，从顶部移到底部，赋予<code>gl_PointCoord</code>的值从0~1变化。</p>\n<h1 id=\"绘制图元\">绘制图元</h1>\n<p>OpenGL ES中有5个绘制图元的API调用：<code>glDrawArrays</code>、<code>glDrawElements</code>、<code>glDrawRangeElements</code>、<code>glDrawArraysInstanced</code>和<code>glDrawElementsInstanced</code>。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 绘制图元</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param mode#&gt; 指定要渲染的图元，有效值为GL_POINTS, GL_LINES, GL_LINES_STRIP, GL_LINES_LOOP, GL_TRIANGLES, GL_TRIANGLES_STRIP, GL_TRIANGLE_FAN description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param first#&gt; 指定启用的顶点数组中的起始顶点索引 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param count#&gt; 指定要绘制的顶点数量 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glDrawArrays(GLenum mode, GLint first, GLsizei count);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 绘制图元</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param mode#&gt; 指定要渲染的图元，有效值为GL_POINTS, GL_LINES, GL_LINES_STRIP, GL_LINES_LOOP, GL_TRIANGLES, GL_TRIANGLES_STRIP, GL_TRIANGLE_FAN description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param count#&gt; 指定要绘制的索引数量 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param type#&gt; 指定indices中保存的元素索引类型，有效值为GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, GL_UNSIGNED_INT description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param indices#&gt; 指向元素索引存储位置的指针 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glDrawElements(GLenum mode, GLsizei count, GLenum type, <span class=\"keyword\">const</span> GLvoid *indices)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 绘制图元</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param mode#&gt; 指定要渲染的图元，有效值为GL_POINTS, GL_LINES, GL_LINES_STRIP, GL_LINES_LOOP, GL_TRIANGLES, GL_TRIANGLES_STRIP, GL_TRIANGLE_FAN description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param start#&gt; 指定indices中的最小数组索引 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param end#&gt; 指定indices中的最大数组索引 description#&gt; </span></span><br><span class=\"line\"><span class=\"comment\"> @param count#&gt; 指定要绘制的索引数量 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param type#&gt; 指定indices中保存的元素索引类型，有效值为GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, GL_UNSIGNED_INT description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param indices#&gt; 指向元素索引存储位置的指针 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glDrawRangeElements(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, <span class=\"keyword\">const</span> GLvoid *indices)</span><br></pre></td></tr></table></figure>\n<p>如果有一个一系列顺序元素索引描述的图元，且几何形状的顶点不共享，则<code>glDrawArrays</code>很好用，但是，游戏或者其他3D应用程序使用的典型对象由多个三角形网格组成，其中的元素索引可能不一定按照顺序，顶点通常在网格的三角形直接共享。</p>\n<p>比如考虑上图立方体的绘制，如果我们用<code>glDrawArrays</code>绘制，则代码如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GLfloat vertices[] = &#123; .. &#125;;</span><br><span class=\"line\">glEnableVertexAttribArray(<span class=\"number\">0</span>);</span><br><span class=\"line\">glVertexAttribPointer(<span class=\"number\">0</span>, <span class=\"number\">3</span>, GL_FLOAT, GL_FALSE, <span class=\"number\">0</span>, vertices);</span><br><span class=\"line\">glDrawArrays(GL_TRIANGLES, <span class=\"number\">0</span>, <span class=\"number\">36</span>);</span><br></pre></td></tr></table></figure>\n<p>为了用<code>glDrawArrays</code>绘制这个立方体，需要为立方体的每一个面调用<code>glDrawArrays</code>。共享的顶点必须重复，这意味着需要分配24个顶点（如果将每面当做<code>GL_TRIANGLE_FAN</code>绘制）或者36个顶点（如果使用<code>GL_TRIANGLES</code>），而不是8个顶点。这不是一个高效的做法。</p>\n<p>用<code>glDrawElements</code>绘制同一个立方体的代码如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GLfloat vertices[] = &#123; .. &#125;;</span><br><span class=\"line\">GLubyte indices[<span class=\"number\">36</span>] = &#123;</span><br><span class=\"line\">    <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>,</span><br><span class=\"line\">    <span class=\"number\">0</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">0</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>,</span><br><span class=\"line\">    <span class=\"number\">7</span>, <span class=\"number\">1</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"number\">7</span>, <span class=\"number\">5</span>, <span class=\"number\">4</span>, <span class=\"number\">7</span>, <span class=\"number\">6</span>, <span class=\"number\">5</span>,</span><br><span class=\"line\">    <span class=\"number\">7</span>, <span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">7</span>, <span class=\"number\">4</span>, <span class=\"number\">3</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">glEnableVertexAttribArray(<span class=\"number\">0</span>);</span><br><span class=\"line\">glVertexAttribPointer(<span class=\"number\">0</span>, <span class=\"number\">3</span>, GL_FLOAT, GL_FALSE, <span class=\"number\">0</span>, vertices);</span><br><span class=\"line\">glDrawElements(GL_TRIANGLES, <span class=\"number\">36</span>, GL_USINGED_BYTE, indices);</span><br></pre></td></tr></table></figure>\n<p>即使我们用<code>glDrawElements</code>绘制三角形，用<code>glDrawArrays</code>和<code>glDrawElements</code>绘制一个三角扇形，我们的应用程序在GPU上运行的也比<code>glDrawArrays</code>更快，这有很多原因。比如，由于顶点重用，顶点属性数据的尺寸将小于<code>glDrawElements</code>。这也导致较小的内存占用和内存贷款需求。</p>\n<h2 id=\"图元重启\">图元重启</h2>\n<p>使用图元重启，可以在一次绘图调用中渲染多个不相连的图元（例如三角扇形或者条带）。这对于降低绘图API的调用的开销是有利的。图元重启的另一种方法是生成退化三角形（需要一些注意事项），这种方法较不简洁。</p>\n<p>使用图元重启，可以通过在索引列表中插入一个特殊索引来重启一个用于索引绘图调用（如<code>glDrawElements</code>、<code>glDrawElementsInstances</code>或<code>glDrawRangeElements</code>）的图元。这个特殊索引是该索引类型的最大索引（例如，索引类型为<code>GL_UNSIGNED_BYTE</code>或<code>GL_UNSIGNED_SHORT</code>时，分别为255或者65535）。</p>\n<p>例如，假定两个三角形条带分别有元素索引(0, 1, 2, 3)和(8, 9, 10, 11)。如果我们想利用图元重启在一次调用<code>glDrawElements*</code>中绘制两个条带，索引类型为<code>GL_UNSIGNED_BYTE</code>，则组合的元素索引列表为(0, 1, 2, 3, 255, 8, 9, 10, 11)。</p>\n<p>可以用如下代码启用和禁用图元启用：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">glEnable(GL_PRIMITIVE_RESTART_FIXED_INDEX);</span><br><span class=\"line\"><span class=\"comment\">// draw primitives</span></span><br><span class=\"line\">glDisable(GL_PRIMITIVE_RESTART_FIXED_INDEX);</span><br></pre></td></tr></table></figure>\n<p>代码示例：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 配置</span></span><br><span class=\"line\">GLfloat vertices[] = &#123;</span><br><span class=\"line\">    <span class=\"number\">-0.75</span>f, <span class=\"number\">0</span>, <span class=\"number\">0</span>,</span><br><span class=\"line\">    <span class=\"number\">-0.75</span>f, <span class=\"number\">0.75</span>f, <span class=\"number\">0</span>,</span><br><span class=\"line\">    <span class=\"number\">-0.25</span>f, <span class=\"number\">0</span>, <span class=\"number\">0</span>,</span><br><span class=\"line\">    <span class=\"number\">-0.25</span>f, <span class=\"number\">0.75</span>, <span class=\"number\">0</span>,</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"number\">0.75</span>f, <span class=\"number\">0</span>, <span class=\"number\">0</span>,</span><br><span class=\"line\">    <span class=\"number\">0.75</span>f, <span class=\"number\">0.75</span>f, <span class=\"number\">0</span>,</span><br><span class=\"line\">    <span class=\"number\">0.25</span>f, <span class=\"number\">0</span>, <span class=\"number\">0</span>,</span><br><span class=\"line\">    <span class=\"number\">0.25</span>f, <span class=\"number\">0.75</span>, <span class=\"number\">0</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">GLfloat colors[] = &#123;</span><br><span class=\"line\">    <span class=\"number\">1.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f,</span><br><span class=\"line\">    <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f,</span><br><span class=\"line\">    <span class=\"number\">0.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f, <span class=\"number\">1.0</span>f,</span><br><span class=\"line\">    <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f,</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"number\">1.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f,</span><br><span class=\"line\">    <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f,</span><br><span class=\"line\">    <span class=\"number\">0.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f, <span class=\"number\">1.0</span>f,</span><br><span class=\"line\">    <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">GLushort indices[] = &#123;<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">65535</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">GLuint vbos[<span class=\"number\">3</span>];</span><br><span class=\"line\">glGenBuffers(<span class=\"number\">3</span>, vbos);</span><br><span class=\"line\">glBindBuffer(GL_ARRAY_BUFFER, vbos[<span class=\"number\">0</span>]);</span><br><span class=\"line\">glBufferData(GL_ARRAY_BUFFER, <span class=\"keyword\">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class=\"line\"></span><br><span class=\"line\">glBindBuffer(GL_ARRAY_BUFFER, vbos[<span class=\"number\">1</span>]);</span><br><span class=\"line\">glBufferData(GL_ARRAY_BUFFER, <span class=\"keyword\">sizeof</span>(colors), colors, GL_STATIC_DRAW);</span><br><span class=\"line\"></span><br><span class=\"line\">glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vbos[<span class=\"number\">2</span>]);</span><br><span class=\"line\">glBufferData(GL_ELEMENT_ARRAY_BUFFER, <span class=\"keyword\">sizeof</span>(indices), indices, GL_STATIC_DRAW);</span><br><span class=\"line\"></span><br><span class=\"line\">glGenVertexArrays(<span class=\"number\">1</span>, &amp;vaos);</span><br><span class=\"line\">glBindVertexArray(vaos);</span><br><span class=\"line\"></span><br><span class=\"line\">glBindBuffer(GL_ARRAY_BUFFER, vbos[<span class=\"number\">0</span>]);</span><br><span class=\"line\">glEnableVertexAttribArray(<span class=\"number\">0</span>);</span><br><span class=\"line\">glVertexAttribPointer(<span class=\"number\">0</span>, <span class=\"number\">3</span>, GL_FLOAT, GL_FALSE, <span class=\"number\">3</span> * <span class=\"keyword\">sizeof</span>(GLfloat), <span class=\"number\">0</span>);</span><br><span class=\"line\">glBindBuffer(GL_ARRAY_BUFFER, vbos[<span class=\"number\">1</span>]);</span><br><span class=\"line\">glEnableVertexAttribArray(<span class=\"number\">1</span>);</span><br><span class=\"line\">glVertexAttribPointer(<span class=\"number\">1</span>, <span class=\"number\">4</span>, GL_FLOAT, GL_FALSE, <span class=\"number\">4</span> * <span class=\"keyword\">sizeof</span>(GLfloat), <span class=\"number\">0</span>);</span><br><span class=\"line\">glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vbos[<span class=\"number\">2</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">glBindVertexArray(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 绘制</span></span><br><span class=\"line\">glEnable(GL_PRIMITIVE_RESTART_FIXED_INDEX);</span><br><span class=\"line\"></span><br><span class=\"line\">glBindVertexArray(vaos);</span><br><span class=\"line\">glDrawElements(GL_TRIANGLE_STRIP, <span class=\"number\">9</span>, GL_UNSIGNED_SHORT, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">glDisable(GL_PRIMITIVE_RESTART_FIXED_INDEX);</span><br></pre></td></tr></table></figure>\n<h2 id=\"驱动顶点\">驱动顶点</h2>\n<p>如果没有限定符，那么顶点着色器的输出值在图元中使用线性插值。但是，使用平面着色时没有发生插值。因为没有发生插值，所以片段着色器中只有一个顶点值可用。对于给定的图元实例，这个驱动顶点确定使用顶点着色器的哪一个顶点输出，因为只能使用一个顶点。<a href=\"/article/2019/opengl-es-glsl-0715/#%E6%8F%92%E5%80%BC%E9%99%90%E5%AE%9A%E7%AC%A6\">插值限定符</a>。</p>\n<table>\n<thead>\n<tr>\n<th>图元i的类型</th>\n<th>驱动顶点</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>GL_POINT</td>\n<td>i</td>\n</tr>\n<tr>\n<td>GL_LINES</td>\n<td>2i</td>\n</tr>\n<tr>\n<td>GL_LINE_LOOP</td>\n<td>如果i &lt; n，为i + 1；如果i = n，为1</td>\n</tr>\n<tr>\n<td>GL_LINE_STRIP</td>\n<td>i + 1</td>\n</tr>\n<tr>\n<td>GL_TRIANGLES</td>\n<td>3i</td>\n</tr>\n<tr>\n<td>GL_TRIANGLE_STRIP</td>\n<td>i + 2</td>\n</tr>\n<tr>\n<td>GL_TRIANGLE_FAN</td>\n<td>i + 2</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>第i个图元实例的驱动顶点选择，顶点的编号从1到n，n是绘制的顶点数量。</p>\n</blockquote>\n<h2 id=\"几何形状实例化\">几何形状实例化</h2>\n<p>几何形状实例化很高效，可以用一次API调用多次渲染具有不同属性（例如不同的变换矩阵、颜色或者大小）的一个对象。这一功能在渲染大量类似对象时很有用，例如对人群的渲染。几何图形实例化降低了向OpenGL ES引擎发送许多API调用的CPU处理开销。要使用实例化绘图调用渲染，可以使用如下命令：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 实例化绘图</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param mode#&gt; 指定要渲染的图元，有效值为GL_POINTS, GL_LINES, GL_LINES_STRIP, GL_LINES_LOOP, GL_TRIANGLES, GL_TRIANGLES_STRIP, GL_TRIANGLE_FAN description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param first#&gt; 指定要启用的顶点数组中的起始顶点索引 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param count#&gt; 指定绘制的索引数量 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param instancecount#&gt; 指定绘制的图元实例数量 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glDrawArraysInstanced(GLenum mode, GLint first, GLsizei count, GLsizei instancecount);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 实例化绘图</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param mode#&gt; 指定要渲染的图元，有效值为GL_POINTS, GL_LINES, GL_LINES_STRIP, GL_LINES_LOOP, GL_TRIANGLES, GL_TRIANGLES_STRIP, GL_TRIANGLE_FAN description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param count#&gt; 指定绘制的索引数量 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param type#&gt; 指定保存在indices中的元素索引类型，有效值为GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, GL_UNSIGNED_INT description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param indices#&gt; 指定元素索引存储位置的一个指针 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param instancecount#&gt; 指定绘制的图元实例数量 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glDrawElementsInstanced(GLenum mode, GLsizei count, GLenum type, <span class=\"keyword\">const</span> GLvoid *indices, GLsizei instancecount);</span><br></pre></td></tr></table></figure>\n<p>可以使用两种方法访问每个实例的数据。第一种方法是用如下命令指示OpenGL ES对每个实例读取一次或者多次顶点属性：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 对每个实例读取一次或多次顶点属性</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param index#&gt; 指定通用顶点属性索引 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param divisor#&gt; 指定index位置的通用属性更新之间传递传递的实例数量 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glVertexAttribDivisor(GLuint index, GLuint divisor);</span><br></pre></td></tr></table></figure>\n<p>默认情况下，如果没有指定<code>glVertexAttribDivisor</code>或者每个顶点属性的<code>divisor</code>等于零，对每个顶点将读取一次顶点属性。如果<code>divisor</code>等于1，则每个图元实例读取一次顶点属性。<a href=\"https://github.com/danginsburg/opengles3-book/blob/master/Chapter_7/Instancing/Instancing.c\" target=\"_blank\" rel=\"noopener\">代码例子</a></p>\n<p>第二种方法是使用内建输入变量<code>glInstanceID</code>作为顶点着色器中的缓冲区索引，以访问每个实例的数据（仅限OpenGL ES 3.0）。使用前面提到的几何形状实例化API调用时，<code>gl_InstanceID</code>将保存当前图元实例的索引。使用非实例化绘图调用时，<code>gl_InstanceID</code>将返回0。</p>\n<h2 id=\"性能提示\">性能提示</h2>\n<p>应用程序应该确保用尽可能大的图元尺寸调用<code>glDrawElements</code>和<code>glDrawElementsInstanced</code>。如果我们绘制<code>GL_TRIANGLES</code>，这很容易做到，但是，如果有三角形条带或者扇形的网格，则可以用图元重启将这些网格连接在一起，而不用对每个三角形条带网格单独调用<code>glDrawElements*</code>。</p>\n<p>如果无法使用图元重启机制将网格连接到一起（为了维护和旧版本OpenGL ES的兼容性），可以添加造成退化三角形的元素索引，代价是使用更多的索引。退化三角形是两个或者更多顶点相同的三角形。GPU可以非常简单的检测和拒绝退化三角形，所以这是很好的性能改进，我们可以讲一个很大的图元放入右GPU渲染的队列。</p>\n<p>代码示例：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 配置</span></span><br><span class=\"line\">GLfloat vertices[] = &#123;</span><br><span class=\"line\">    <span class=\"number\">-0.75</span>f, <span class=\"number\">0</span>, <span class=\"number\">0</span>,</span><br><span class=\"line\">    <span class=\"number\">-0.75</span>f, <span class=\"number\">0.75</span>f, <span class=\"number\">0</span>,</span><br><span class=\"line\">    <span class=\"number\">-0.25</span>f, <span class=\"number\">0</span>, <span class=\"number\">0</span>,</span><br><span class=\"line\">    <span class=\"number\">-0.25</span>f, <span class=\"number\">0.75</span>, <span class=\"number\">0</span>,</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"number\">0.75</span>f, <span class=\"number\">0</span>, <span class=\"number\">0</span>,</span><br><span class=\"line\">    <span class=\"number\">0.75</span>f, <span class=\"number\">0.75</span>f, <span class=\"number\">0</span>,</span><br><span class=\"line\">    <span class=\"number\">0.25</span>f, <span class=\"number\">0</span>, <span class=\"number\">0</span>,</span><br><span class=\"line\">    <span class=\"number\">0.25</span>f, <span class=\"number\">0.75</span>, <span class=\"number\">0</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">GLfloat colors[] = &#123;</span><br><span class=\"line\">    <span class=\"number\">1.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f,</span><br><span class=\"line\">    <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f,</span><br><span class=\"line\">    <span class=\"number\">0.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f, <span class=\"number\">1.0</span>f,</span><br><span class=\"line\">    <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f,</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"number\">1.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f,</span><br><span class=\"line\">    <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f,</span><br><span class=\"line\">    <span class=\"number\">0.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f, <span class=\"number\">1.0</span>f,</span><br><span class=\"line\">    <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">GLushort indices[] = &#123;<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">GLuint vbos[<span class=\"number\">3</span>];</span><br><span class=\"line\">glGenBuffers(<span class=\"number\">3</span>, vbos);</span><br><span class=\"line\">glBindBuffer(GL_ARRAY_BUFFER, vbos[<span class=\"number\">0</span>]);</span><br><span class=\"line\">glBufferData(GL_ARRAY_BUFFER, <span class=\"keyword\">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class=\"line\"></span><br><span class=\"line\">glBindBuffer(GL_ARRAY_BUFFER, vbos[<span class=\"number\">1</span>]);</span><br><span class=\"line\">glBufferData(GL_ARRAY_BUFFER, <span class=\"keyword\">sizeof</span>(colors), colors, GL_STATIC_DRAW);</span><br><span class=\"line\"></span><br><span class=\"line\">glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vbos[<span class=\"number\">2</span>]);</span><br><span class=\"line\">glBufferData(GL_ELEMENT_ARRAY_BUFFER, <span class=\"keyword\">sizeof</span>(indices), indices, GL_STATIC_DRAW);</span><br><span class=\"line\"></span><br><span class=\"line\">glGenVertexArrays(<span class=\"number\">1</span>, &amp;vaos);</span><br><span class=\"line\">glBindVertexArray(vaos);</span><br><span class=\"line\"></span><br><span class=\"line\">glBindBuffer(GL_ARRAY_BUFFER, vbos[<span class=\"number\">0</span>]);</span><br><span class=\"line\">glEnableVertexAttribArray(<span class=\"number\">0</span>);</span><br><span class=\"line\">glVertexAttribPointer(<span class=\"number\">0</span>, <span class=\"number\">3</span>, GL_FLOAT, GL_FALSE, <span class=\"number\">3</span> * <span class=\"keyword\">sizeof</span>(GLfloat), <span class=\"number\">0</span>);</span><br><span class=\"line\">glBindBuffer(GL_ARRAY_BUFFER, vbos[<span class=\"number\">1</span>]);</span><br><span class=\"line\">glEnableVertexAttribArray(<span class=\"number\">1</span>);</span><br><span class=\"line\">glVertexAttribPointer(<span class=\"number\">1</span>, <span class=\"number\">4</span>, GL_FLOAT, GL_FALSE, <span class=\"number\">4</span> * <span class=\"keyword\">sizeof</span>(GLfloat), <span class=\"number\">0</span>);</span><br><span class=\"line\">glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vbos[<span class=\"number\">2</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">glBindVertexArray(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 绘制</span></span><br><span class=\"line\">glBindVertexArray(vaos);</span><br><span class=\"line\">glDrawElements(GL_TRIANGLE_STRIP, <span class=\"number\">10</span>, GL_UNSIGNED_SHORT, <span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure>\n<h1 id=\"图元装配\">图元装配</h1>\n<p>下图展示了图元装配阶段。通过<code>glDraw***</code>提供的顶点由顶点着色器执行，顶点着色器变换的每个顶点包括描述顶点(x, y, z, w)值的顶点位置。图元位置和顶点索引确定将被渲染的单独图元。对于每个单独图元（三角形、直线和点）及其对应的顶点，图元装配阶段执行图中所示的操作。</p>\n<p><img src=\"/img/article/20190801/3.png\" alt=\"OpenGL ES图元装配阶段\"></p>\n<h2 id=\"坐标系统\">坐标系统</h2>\n<p>下图展示了顶点通过顶点着色器和图元装配阶段时的坐标系统。顶点以物体或者本地坐标空间输入到OpenGL ES，这是最可能用来建模和存储一个对象的坐标空间。在顶点着色器执行之后，顶点位置被认为是在裁剪坐标空间内。顶点位置从本地坐标系统（也就是物体坐标）到裁剪坐标的变换通过加载执行这一转换的对应矩阵来完成，这些矩阵保存在顶点着色器中定义的统一变量中。</p>\n<p><img src=\"/img/article/20190801/4.png\" alt=\"坐标系统\"></p>\n<h3 id=\"裁剪\">裁剪</h3>\n<p>为了避免在可视景体之外处理图元，图元被裁剪到裁剪空间。执行顶点着色器之后的顶点位置处于裁剪坐标空间内。裁剪坐标是由(x<sub>c</sub>, y<sub>c</sub>, z<sub>c</sub>, w<sub>c</sub>)指定的同类坐标。在裁剪空间(x<sub>c</sub>, y<sub>c</sub>, z<sub>c</sub>, w<sub>c</sub>)中定义的顶点坐标根据视景体（又称裁剪体）裁剪。</p>\n<p>裁剪体由6个裁剪平面定义，这些平面称作近、远、左、右、上、下裁剪平面。在裁剪坐标中，裁剪体如下：-w<sub>c</sub> &lt;= x<sub>c</sub> &lt;= w<sub>c</sub>，-w<sub>c</sub> &lt;= y<sub>c</sub> &lt;= w<sub>c</sub>，-w<sub>c</sub> &lt;= z<sub>c</sub> &lt;= w<sub>c</sub>。</p>\n<p><img src=\"/img/article/20190801/5.png\" alt=\"视景体\"></p>\n<p>裁剪阶段将把每个图元裁剪为上图所示的裁剪体。我们在这里说的“图元”，是指用<code>GL_TRIANGLES</code>绘制的单独三角形列表中的每一个三角形，或者一个三角形条带或者扇形中的一个三角形，或者用<code>GL_LINES</code>绘制的单独直线列表中的一条直线，或者一个直线条带或者闭合折线中的一条直线，或者点精灵列表中的一个特定点。对于每种图元类型，执行如下操作：</p>\n<ul>\n<li>裁剪三角形–如果三角形完全在视景体内部，则不执行任何裁剪。如果三角形完全在视景体之外，则该三角形被放弃。如果三角形部分在视景体内，则根据相应的平面裁剪三角形。裁剪操作将生成新的顶点，这些顶点被裁剪到安排为三角形扇形的平面。</li>\n<li>裁剪直线–如果直线完全在视景体内部，则不执行任何裁剪。如果直线完全在视景体之外，则该直线被放弃。如果直线部分在视景体内，则直线被裁剪并生成相应的新顶点。</li>\n<li>裁剪点精灵–如果点位置在近或者远裁剪平面之外，或者如果表示点精灵的正方形在裁剪体之外，裁剪阶段将抛弃点精灵。否则，它将不做变化地通过该阶段，点精灵将在其裁剪体内部移到外部时裁剪，反之亦然。</li>\n</ul>\n<p>在图元根据六个裁剪平面进行裁剪时，顶点坐标经历透视分割，从而成为规范化的设备坐标。规范化的设备坐标范围为-1.0到1.0。</p>\n<h2 id=\"透视分割\">透视分割</h2>\n<p>透视分割取得裁剪坐标(X<sub>c</sub>, Y<sub>c</sub>, Z<sub>c</sub>, W<sub>c</sub>)指定的点，并将其投影到屏幕或者视口上。这个投影通过将(X<sub>c</sub>, Y<sub>c</sub>, Z<sub>c</sub>)除以W<sub>c</sub>进行。执行(X<sub>c</sub>/W<sub>c</sub>)、(Y<sub>c</sub>/W<sub>c</sub>)和(Z<sub>c</sub>/W<sub>c</sub>)之后，我们得到规范化的设备坐标(X<sub>d</sub>, Y<sub>d</sub>, Z<sub>d</sub>)。这些坐标被称为规范化设备坐标，因为他们落在[-1.0…1.0]区间。这些规范化的(X<sub>d</sub>, Y<sub>d</sub>)坐标根据视口的大小将被转换为真正的屏幕（或者窗口）坐标。规范化的(Z<sub>d</sub>)坐标将用<code>glDepthRangef</code>指定的<code>near</code>和<code>far</code>深度值转换为屏幕的Z值，这些转换在视口变换阶段进行。</p>\n<h2 id=\"视口变换\">视口变换</h2>\n<p>视口是一个二维矩阵窗口区域，是所有OpenGL ES渲染操作最终显示的地方。视口变换可用如下API调用设置：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 视口窗口</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param x#&gt; 指定视口左下角的窗口坐标x，以像素数表示 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param y#&gt; 指定视口左下角的窗口坐标y，以像素数表示 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param width#&gt; 指定视口的宽度（以像素数表示）；必须大于0 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param height#&gt; 指定视口的高度（以像素数表示）；必须大于0 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glViewport(GLint x, GLint y, GLsizei width, GLsizei height);</span><br></pre></td></tr></table></figure>\n<p>从规范化设备坐标(x<sub>d</sub>, y<sub>d</sub>, z<sub>d</sub>)到窗口坐标(x<sub>w</sub>, y<sub>w</sub>, z<sub>w</sub>)的转换用如下变换给出：</p>\n<p><img src=\"/img/article/20190801/6.png\" alt=\"矩阵变换\"></p>\n<p>在这个变换中，o<sub>x</sub>=x+w/2，o<sub>y</sub>=y+h/2，n和f代表所需的深度范围。<br>\n深度范围值n和f可以用如下API调用设置：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 设置深度值</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param zNear#&gt; 指定所需的深度范围，默认值为0.0，限于(0.0, 1.0)区间内 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param zFar#&gt; 指定所需的深度范围，默认值为1.0，限于(0.0, 1.0)区间内 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glDepthRangef(GLclampf zNear, GLclampf zFar);</span><br></pre></td></tr></table></figure>\n<p><code>glDepthRangef</code>和<code>glViewport</code>指定的值用于将顶点位置从规范化设备坐标转换为窗口（屏幕）坐标。</p>\n<h1 id=\"光栅化\">光栅化</h1>\n<p>下图展示了光栅化管线。在顶点变换和图元裁剪之后，光栅化管线取得单独图元（如三角形、线段或者点精灵），并为该图元生成对应的片段。每个片段由屏幕空间中的整数位置(x, y)标识。片段代表了屏幕空间中(x, y)指定的像素位置和由片段着色器处理而生成片段颜色的附加片段数据。</p>\n<p><img src=\"/img/article/20190801/7.png\" alt=\"OpenGL ES光栅化阶段\"></p>\n<h2 id=\"剔除\">剔除</h2>\n<p>在三角形被光栅化之前，我们需要确定它们是正面（也就是面向观看者）或者背面（也就是背向观看者）。剔除（culling）操作抛弃背向观看者的三角形。要确定三角形是正面还是背面，首先需要知道它的方向。</p>\n<p>三角形的方向指定从第一个顶点开始，经过第二个和第三个顶点，最后回到第一个顶点的弯曲方向或者路径顺序。下图展示了弯曲顺序为顺时针和逆时针的两个三角形实例。</p>\n<p><img src=\"/img/article/20190801/8.png\" alt=\"顺时针和逆时针的三角形\"></p>\n<p>三角形的方向通过以窗口坐标表示的有符号三角形的面积来计算。我们现在需要将计算出来的三角形面积符号翻译为顺时针（CW）或者逆时针（CCW）方向。这种从三角形面积的符号到顺时针或者逆时针方向的映射由应用程序用如下API调用指定：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 指定正面三角形的方向</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param mode#&gt; 指定正面三角形的方向，有效值为GL_CW或者GL_CCW，默认值为GL_CCW description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glFrontFace(GLenum mode);</span><br></pre></td></tr></table></figure>\n<p>要确定需要提出的三角形，需要知道三角形将被剔除的面。通过如下API调用：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 剔除三角形</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param mode#&gt; 指定要被剔除的三角形的面，有效值为GL_FROUNT、GL_BACK、GL_FROUNT_AND_BACK，默认值为GL_BACK description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glCullFace(GLenum mode);</span><br></pre></td></tr></table></figure>\n<p>最后一个要点是，需要知道剔除操作是否应该执行。如果<code>GL_CULL_FACE</code>状态启用，剔除操作将被执行。通过如下API调用启用或者禁用：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 启用剔除</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param cap#&gt; 设置为GL_CULL_FACE，默认情况下剔除被禁用 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glEnable(GLenum cap);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 禁用剔除</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param cap#&gt; 设置为GL_CULL_FACE，默认情况下剔除被禁用 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glDisable(GLenum cap);</span><br></pre></td></tr></table></figure>\n<p>概括起来，要剔除合适的三角形，OpenGL ES应用程序首先必须用<code>glEnable(GL_CULL_FACE)</code>启用剔除，用<code>glCullFace</code>设置相应的剔除面，并用<code>glFrontFace</code>设置正面三角形的方向。</p>\n<blockquote>\n<p>剔除应该始终启用，以避免GPU浪费时间去光栅化不可见的三角形。启用剔除应该能够改善OpenGL ES应用程序的整体性能。</p>\n</blockquote>\n<h2 id=\"多边形偏移\">多边形偏移</h2>\n<p>考虑绘制两个相互重叠的多边形的情况。很可能会有伪像，这些伪像被称为深度冲突伪像，是因为三角形光栅化的精度有限而发生的，这种精度限制可能影响逐片段生成的深度值的精度，造成伪像。三角形光栅化使用的参数和生成的逐片段深度值的有限精度将越来越好，但是这个问题永远无法完全解决。</p>\n<p>为了避免看到伪像，我们需要在执行深度测试和深度值写入深度缓冲区之前，在计算出来的深度值上添加一个偏移量。如果深度测试通过，原始的深度值–而不是原始深度值+偏移–将被保存到深度缓冲区中。</p>\n<p>多边形偏移：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 多边形偏移</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param factor#&gt; 因数 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param units#&gt; 单位数 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glPolygonOffset(GLfloat factor, GLfloat units);</span><br></pre></td></tr></table></figure>\n<p>深度偏移的计算如下：深度偏移 = m * 因数 + r * 单位数。m是三角形的最大深度斜率，斜率项在三角形光栅化阶段期间由OpenGL ES实现计算；r是一个OpenGL ES实现定义的常量，代表深度值中可以保证产生差异的最小值。<br>\n多边形偏移可以分别用<code>glEnable(GL_POLYGON_OFFSET_FILL)</code>和<code>glDisable(GL_POLYGON_OFFSET_FILL)</code>启用或者禁用。</p>\n<p>例子：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">float</span> polygonOffsetFactor = <span class=\"number\">-1.0</span>f;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">float</span> polygonOffsetUnits = <span class=\"number\">-2.0</span>f;</span><br><span class=\"line\"></span><br><span class=\"line\">glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// load vertex shader</span></span><br><span class=\"line\"><span class=\"comment\">// set the appropriate transformation matrices</span></span><br><span class=\"line\"><span class=\"comment\">// set the vertex attribute state</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// draw the SMALLER quad</span></span><br><span class=\"line\">glDrawArrays(GL_TRIANGLE_FAN, <span class=\"number\">0</span>, <span class=\"number\">4</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// set the depth func to &lt;= as polygons are coplanar</span></span><br><span class=\"line\">glDrawFunc(GL_LEQUAL);</span><br><span class=\"line\"></span><br><span class=\"line\">glEnable(GL_POLYGON_OFFSET_FILL);</span><br><span class=\"line\"></span><br><span class=\"line\">glPolygonOffset(polygonOffsetFactor, polygonOffsetUnits);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// set the vertex attribute state</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// draw the LARGER quad</span></span><br><span class=\"line\">glDrawArrays(GL_TRIANGLE_FAN, <span class=\"number\">0</span>, <span class=\"number\">4</span>);</span><br></pre></td></tr></table></figure>\n<h1 id=\"遮挡查询\">遮挡查询</h1>\n<p>遮挡查询用查询对象来跟踪通过深度测试的任何片段或者样本。这种方法可用于不同的技术，例如镜头炫光特效的可见性测试以及避免在包围体被遮挡的不可见对象上进行几何形状处理的优化。</p>\n<p>遮挡查询的开始和结束：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 遮挡查询开始</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param target#&gt; 指定查询对象的目标类型；有效值是GL_ANY_SAMPLES_PASSED，GL_ANY_SAMPLES_PASSED_CONSERVATIVE，GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param id#&gt; 指定查询对象的名称 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glBeginQuery(GLenum target, GLuint <span class=\"keyword\">id</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 遮挡查询结束</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param target#&gt; 指定查询对象的目标类型；有效值是GL_ANY_SAMPLES_PASSED，GL_ANY_SAMPLES_PASSED_CONSERVATIVE，GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glEndQuery(GLenum target);</span><br></pre></td></tr></table></figure>\n<p>使用<code>GL_ANY_SAMPLES_PASSED</code>目标奖返回表示是否有样本通过深度测试的精确布尔状态；<code>GL_ANY_SAMPLES_PASSED_CONSERVATIVE</code>目标将提供更好的性能，但是答案的精确度较低；使用<code>GL_ANY_SAMPLES_PASSED_CONSERVATIVE</code>，有些实现将在没有样本通过深度测试时返回<code>GL_TRUE</code>。</p>\n<p><code>id</code>用<code>glGenQueries</code>创建，用<code>glDeleteQueries</code>删除：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 创建查询id</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param n#&gt; 指定生成的查询名称对象的数量 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param ids#&gt; 指定一个数组，以存储查询名称对象的列表 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glGenQueries(GLsizei n, GLuint *ids);</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 删除查询id</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param n#&gt; 指定要删除的查询名称对象的数量 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param ids#&gt; 指定一个需要删除的查询名称对象的列表数组 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span> </span><br><span class=\"line\">glDeleteQueries(GLsizei n, <span class=\"keyword\">const</span> GLuint *ids);</span><br></pre></td></tr></table></figure>\n<p>在用<code>glBeginQuery</code>和<code>glEndQuery</code>指定查询对象边界之后，可以使用<code>glGetQueryObjectuiv</code>检索查询对象的结果：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 检索查询对象的结果</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param id#&gt; 指定查询对象的名称 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param pname#&gt; 指定需要检索的查询对象参数，可以为GL_QUERY_RESULT或GL_QUERY_RESULT_AVAILABLE description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param params#&gt; 指定存储返回参数值得对象类型的数组 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glGetQueryObjectuiv(GLuint <span class=\"keyword\">id</span>, GLenum pname, GLuint *params);</span><br></pre></td></tr></table></figure>\n<h1 id=\"总结\">总结</h1>\n<p>这篇文章主要学习了OpenGL ES支持的图元类型，并且了解了如何用常规的非实例化和实例化绘图调用高效地绘制它们。还讨论了在顶点上执行坐标变换的方法。还学习了关于光栅化阶段的知识，在这个阶段，图元被转换为代表屏幕上绘制的像素的偏度。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>本章描述OpenGL ES支持的图元和几何形状对象的类型，并说明绘制它们的方法。然后描述发生在顶点着色器处理图元顶点之后的图元装配阶段。在这一阶段，执行裁剪、透视分割和视口变换操作，对这些操作将作详细的讨论。本章以光栅化阶段的描述作为结束。光栅化是将图元转换为一组二维片段的过程，这些片段由片段着色器处理，代表可以在屏幕上绘制的像素。</p>\n</blockquote>\n<h1>图元</h1>\n<p>图元是可以用OpenGL ES中的<code>glDrawArrays</code>、<code>glDrawElements</code>、<code>glDrawRangeElements</code>、<code>glDrawArraysInstanced</code>、<code>glDrawElementsInstanced</code>命令绘制的几何形状对象。图元由一组表示顶点位置的顶点描述。其他如颜色、纹理坐标和几何法线等信息也作为通用属性与每个顶点关联。</p>\n<p>OpenGL ES 3.0可以绘制如下图元：</p>\n<ul>\n<li>三角形</li>\n<li>直线</li>\n<li>点精灵</li>\n</ul>\n<h2>三角形</h2>\n<p>三角形代表着描述由3D应用程序渲染的几何形状对象时最常用的方法。OpenGL ES支持的三角形图元有<code>GL_TRIANGLES</code>、<code>GL_TRIANGLE_STRIP</code>和<code>GL_TRIANGLE_FAN</code>。</p>\n<p><img src=\"/img/article/20190801/1.png\" alt=\"三角形图元类型\"></p>\n<p><code>GL_TRIANGLES</code>绘制一系列单独的三角形。如上图所示，绘制了顶点为(v<sup>0</sup>, v<sup>1</sup>, v<sup>2</sup>)和(v<sup>3</sup>, v<sup>4</sup>, v<sup>5</sup>)的两个三角形。总共绘制了n/3个三角形，其中n为<code>glDraw*</code>函数中的<code>count</code>指定的索引。</p>\n<p><code>GL_TRIANGLE_STRIP</code>绘制一系列相互连接的三角形。如上图所示，绘制了4个顶点为(v<sup>0</sup>, v<sup>1</sup>, v<sup>2</sup>)、(v<sup>2</sup>, v<sup>1</sup>, v<sup>3</sup>)、(v<sup>2</sup>, v<sup>3</sup>, v<sup>4</sup>)和(v<sup>4</sup>, v<sup>3</sup>, v<sup>5</sup>)的三角形（注意顺序）。总共绘制了n-2个三角形，其中n为<code>glDraw*</code>函数中的<code>count</code>指定的索引。</p>\n<p><code>GL_TRIANGLE_FAN</code>也绘制一系列相连的三角形。如上图所示，绘制了3个顶点为(v<sup>0</sup>, v<sup>1</sup>, v<sup>2</sup>)、(v<sup>0</sup>, v<sup>2</sup>, v<sup>3</sup>)和(v<sup>0</sup>, v<sup>3</sup>, v<sup>4</sup>)的三角形，总共绘制了n-2个三角形，其中n为<code>glDraw*</code>函数中的<code>count</code>指定的索引。</p>\n<h2>直线</h2>\n<p>OpenGL ES支持的直线图元有<code>GL_LINES</code>、<code>GL_LINE_STRIP</code>和<code>GL_LINE_LOOP</code>。</p>\n<p><img src=\"/img/article/20190801/2.png\" alt=\"直线图元类型\"></p>\n<p><code>GL_LINES</code>绘制一系列不相连的线段。如上图所示，绘制了端点为(v<sup>0</sup>, v<sup>1</sup>)、(v<sup>2</sup>, v<sup>3</sup>)和(v<sup>4</sup>, v<sup>5</sup>)的单独线段。总共绘制了n/2条线段，其中n为<code>glDraw*</code>函数中的<code>count</code>指定的索引。</p>\n<p><code>GL_LINE_STRIP</code>绘制一系列相连的线段。如上图所示，绘制了3条端点为(v<sup>0</sup>, v<sup>1</sup>)、(v<sup>1</sup>, v<sup>2</sup>)和(v<sup>2</sup>, v<sup>3</sup>)的线段。总共绘制了n-1条线段，其中n为<code>glDraw*</code>函数中的<code>count</code>指定的索引。</p>\n<p>除了最后一条线段从v<sup>n-1</sup>到v<sup>0</sup>之外，<code>GL_LINE_LOOP</code>和<code>GL_LINE_STRIP</code>的绘制方法类似。如上图所示，绘制了端点为(v<sup>0</sup>, v<sup>1</sup>)、(v<sup>1</sup>, v<sup>2</sup>)、(v<sup>2</sup>, v<sup>3</sup>)、(v<sup>3</sup>, v<sup>4</sup>)和(v<sup>4</sup>, v<sup>0</sup>)的线段。总共绘制了n条线段，其中n为<code>glDraw*</code>函数中的<code>count</code>指定的索引。</p>\n<p>线段的宽度用<code>glLineWidth</code>API调用指定：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 设置线宽</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param width#&gt; 指定线宽，以像素数表示；默认宽度为1.0 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glLineWidth(GLfloat width);</span><br></pre></td></tr></table></figure>\n<p><code>glLineWidth</code>指定的宽度将受限于OpenGL ES 3.0实现所支持的线宽范围。此外，指定的宽度将被OpenGL记住，直到应用程序更新。支持的线宽范围可以用如下的命令查询，对于大于1<br>\n的线宽，没有强制支持。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GLfloat lineWidthRange[<span class=\"number\">2</span>];</span><br><span class=\"line\">glGetFloatv(GL_ALIASED_LINE_WIDTH_RANGE, lineWidthRange);</span><br></pre></td></tr></table></figure>\n<h2>点精灵</h2>\n<p>OpenGL ES支持的点精灵图元是<code>GL_POINTS</code>。点精灵对指定的每个顶点绘制。点精灵通常用于将粒子效果当做点而非正方形绘制，从而实现高效渲染。点精灵是指定位置和半径的屏幕对齐的正方形，位置描述正方形的中心，半径用于计算描述点精灵的正方形的4个坐标。</p>\n<p><code>gl_PointSize</code>是可用于在顶点着色器中输出点半径（或者点尺寸）的内建变量。与点图元相关的顶点着色器输出<code>gl_PointSize</code>很重要，否则，点尺寸值被视为未定义，很可能会造成绘图错误。顶点着色器输出的<code>gl_PointSize</code>受到OpenGL ES 3.0实现所支持的非平滑点尺寸范围的限制。这个范围可以用如下命令查询：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GLfloat pointSizeRange[<span class=\"number\">2</span>];</span><br><span class=\"line\">glGetFloatv(GL_ALIASED_POINT_SIZE_RANGE, pointSizeRange);</span><br></pre></td></tr></table></figure>\n<p>默认情况下，OpenGL ES 3.0将窗口原点(0, 0)描述为(左, 下)区域，但是，对于点精灵，点坐标的原点是(左, 上)。</p>\n<p><code>gl_PointCoord</code>是只能在渲染图元为点精灵时用于片段着色器内部的内建变量，它用<code>mediump</code>精度限定符声明一个vec2变量。随着我们从左侧移到右侧，从顶部移到底部，赋予<code>gl_PointCoord</code>的值从0~1变化。</p>\n<h1>绘制图元</h1>\n<p>OpenGL ES中有5个绘制图元的API调用：<code>glDrawArrays</code>、<code>glDrawElements</code>、<code>glDrawRangeElements</code>、<code>glDrawArraysInstanced</code>和<code>glDrawElementsInstanced</code>。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 绘制图元</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param mode#&gt; 指定要渲染的图元，有效值为GL_POINTS, GL_LINES, GL_LINES_STRIP, GL_LINES_LOOP, GL_TRIANGLES, GL_TRIANGLES_STRIP, GL_TRIANGLE_FAN description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param first#&gt; 指定启用的顶点数组中的起始顶点索引 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param count#&gt; 指定要绘制的顶点数量 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glDrawArrays(GLenum mode, GLint first, GLsizei count);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 绘制图元</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param mode#&gt; 指定要渲染的图元，有效值为GL_POINTS, GL_LINES, GL_LINES_STRIP, GL_LINES_LOOP, GL_TRIANGLES, GL_TRIANGLES_STRIP, GL_TRIANGLE_FAN description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param count#&gt; 指定要绘制的索引数量 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param type#&gt; 指定indices中保存的元素索引类型，有效值为GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, GL_UNSIGNED_INT description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param indices#&gt; 指向元素索引存储位置的指针 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glDrawElements(GLenum mode, GLsizei count, GLenum type, <span class=\"keyword\">const</span> GLvoid *indices)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 绘制图元</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param mode#&gt; 指定要渲染的图元，有效值为GL_POINTS, GL_LINES, GL_LINES_STRIP, GL_LINES_LOOP, GL_TRIANGLES, GL_TRIANGLES_STRIP, GL_TRIANGLE_FAN description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param start#&gt; 指定indices中的最小数组索引 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param end#&gt; 指定indices中的最大数组索引 description#&gt; </span></span><br><span class=\"line\"><span class=\"comment\"> @param count#&gt; 指定要绘制的索引数量 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param type#&gt; 指定indices中保存的元素索引类型，有效值为GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, GL_UNSIGNED_INT description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param indices#&gt; 指向元素索引存储位置的指针 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glDrawRangeElements(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, <span class=\"keyword\">const</span> GLvoid *indices)</span><br></pre></td></tr></table></figure>\n<p>如果有一个一系列顺序元素索引描述的图元，且几何形状的顶点不共享，则<code>glDrawArrays</code>很好用，但是，游戏或者其他3D应用程序使用的典型对象由多个三角形网格组成，其中的元素索引可能不一定按照顺序，顶点通常在网格的三角形直接共享。</p>\n<p>比如考虑上图立方体的绘制，如果我们用<code>glDrawArrays</code>绘制，则代码如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GLfloat vertices[] = &#123; .. &#125;;</span><br><span class=\"line\">glEnableVertexAttribArray(<span class=\"number\">0</span>);</span><br><span class=\"line\">glVertexAttribPointer(<span class=\"number\">0</span>, <span class=\"number\">3</span>, GL_FLOAT, GL_FALSE, <span class=\"number\">0</span>, vertices);</span><br><span class=\"line\">glDrawArrays(GL_TRIANGLES, <span class=\"number\">0</span>, <span class=\"number\">36</span>);</span><br></pre></td></tr></table></figure>\n<p>为了用<code>glDrawArrays</code>绘制这个立方体，需要为立方体的每一个面调用<code>glDrawArrays</code>。共享的顶点必须重复，这意味着需要分配24个顶点（如果将每面当做<code>GL_TRIANGLE_FAN</code>绘制）或者36个顶点（如果使用<code>GL_TRIANGLES</code>），而不是8个顶点。这不是一个高效的做法。</p>\n<p>用<code>glDrawElements</code>绘制同一个立方体的代码如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GLfloat vertices[] = &#123; .. &#125;;</span><br><span class=\"line\">GLubyte indices[<span class=\"number\">36</span>] = &#123;</span><br><span class=\"line\">    <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>,</span><br><span class=\"line\">    <span class=\"number\">0</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">0</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>,</span><br><span class=\"line\">    <span class=\"number\">7</span>, <span class=\"number\">1</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"number\">7</span>, <span class=\"number\">5</span>, <span class=\"number\">4</span>, <span class=\"number\">7</span>, <span class=\"number\">6</span>, <span class=\"number\">5</span>,</span><br><span class=\"line\">    <span class=\"number\">7</span>, <span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">7</span>, <span class=\"number\">4</span>, <span class=\"number\">3</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">glEnableVertexAttribArray(<span class=\"number\">0</span>);</span><br><span class=\"line\">glVertexAttribPointer(<span class=\"number\">0</span>, <span class=\"number\">3</span>, GL_FLOAT, GL_FALSE, <span class=\"number\">0</span>, vertices);</span><br><span class=\"line\">glDrawElements(GL_TRIANGLES, <span class=\"number\">36</span>, GL_USINGED_BYTE, indices);</span><br></pre></td></tr></table></figure>\n<p>即使我们用<code>glDrawElements</code>绘制三角形，用<code>glDrawArrays</code>和<code>glDrawElements</code>绘制一个三角扇形，我们的应用程序在GPU上运行的也比<code>glDrawArrays</code>更快，这有很多原因。比如，由于顶点重用，顶点属性数据的尺寸将小于<code>glDrawElements</code>。这也导致较小的内存占用和内存贷款需求。</p>\n<h2>图元重启</h2>\n<p>使用图元重启，可以在一次绘图调用中渲染多个不相连的图元（例如三角扇形或者条带）。这对于降低绘图API的调用的开销是有利的。图元重启的另一种方法是生成退化三角形（需要一些注意事项），这种方法较不简洁。</p>\n<p>使用图元重启，可以通过在索引列表中插入一个特殊索引来重启一个用于索引绘图调用（如<code>glDrawElements</code>、<code>glDrawElementsInstances</code>或<code>glDrawRangeElements</code>）的图元。这个特殊索引是该索引类型的最大索引（例如，索引类型为<code>GL_UNSIGNED_BYTE</code>或<code>GL_UNSIGNED_SHORT</code>时，分别为255或者65535）。</p>\n<p>例如，假定两个三角形条带分别有元素索引(0, 1, 2, 3)和(8, 9, 10, 11)。如果我们想利用图元重启在一次调用<code>glDrawElements*</code>中绘制两个条带，索引类型为<code>GL_UNSIGNED_BYTE</code>，则组合的元素索引列表为(0, 1, 2, 3, 255, 8, 9, 10, 11)。</p>\n<p>可以用如下代码启用和禁用图元启用：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">glEnable(GL_PRIMITIVE_RESTART_FIXED_INDEX);</span><br><span class=\"line\"><span class=\"comment\">// draw primitives</span></span><br><span class=\"line\">glDisable(GL_PRIMITIVE_RESTART_FIXED_INDEX);</span><br></pre></td></tr></table></figure>\n<p>代码示例：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 配置</span></span><br><span class=\"line\">GLfloat vertices[] = &#123;</span><br><span class=\"line\">    <span class=\"number\">-0.75</span>f, <span class=\"number\">0</span>, <span class=\"number\">0</span>,</span><br><span class=\"line\">    <span class=\"number\">-0.75</span>f, <span class=\"number\">0.75</span>f, <span class=\"number\">0</span>,</span><br><span class=\"line\">    <span class=\"number\">-0.25</span>f, <span class=\"number\">0</span>, <span class=\"number\">0</span>,</span><br><span class=\"line\">    <span class=\"number\">-0.25</span>f, <span class=\"number\">0.75</span>, <span class=\"number\">0</span>,</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"number\">0.75</span>f, <span class=\"number\">0</span>, <span class=\"number\">0</span>,</span><br><span class=\"line\">    <span class=\"number\">0.75</span>f, <span class=\"number\">0.75</span>f, <span class=\"number\">0</span>,</span><br><span class=\"line\">    <span class=\"number\">0.25</span>f, <span class=\"number\">0</span>, <span class=\"number\">0</span>,</span><br><span class=\"line\">    <span class=\"number\">0.25</span>f, <span class=\"number\">0.75</span>, <span class=\"number\">0</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">GLfloat colors[] = &#123;</span><br><span class=\"line\">    <span class=\"number\">1.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f,</span><br><span class=\"line\">    <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f,</span><br><span class=\"line\">    <span class=\"number\">0.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f, <span class=\"number\">1.0</span>f,</span><br><span class=\"line\">    <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f,</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"number\">1.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f,</span><br><span class=\"line\">    <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f,</span><br><span class=\"line\">    <span class=\"number\">0.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f, <span class=\"number\">1.0</span>f,</span><br><span class=\"line\">    <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">GLushort indices[] = &#123;<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">65535</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">GLuint vbos[<span class=\"number\">3</span>];</span><br><span class=\"line\">glGenBuffers(<span class=\"number\">3</span>, vbos);</span><br><span class=\"line\">glBindBuffer(GL_ARRAY_BUFFER, vbos[<span class=\"number\">0</span>]);</span><br><span class=\"line\">glBufferData(GL_ARRAY_BUFFER, <span class=\"keyword\">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class=\"line\"></span><br><span class=\"line\">glBindBuffer(GL_ARRAY_BUFFER, vbos[<span class=\"number\">1</span>]);</span><br><span class=\"line\">glBufferData(GL_ARRAY_BUFFER, <span class=\"keyword\">sizeof</span>(colors), colors, GL_STATIC_DRAW);</span><br><span class=\"line\"></span><br><span class=\"line\">glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vbos[<span class=\"number\">2</span>]);</span><br><span class=\"line\">glBufferData(GL_ELEMENT_ARRAY_BUFFER, <span class=\"keyword\">sizeof</span>(indices), indices, GL_STATIC_DRAW);</span><br><span class=\"line\"></span><br><span class=\"line\">glGenVertexArrays(<span class=\"number\">1</span>, &amp;vaos);</span><br><span class=\"line\">glBindVertexArray(vaos);</span><br><span class=\"line\"></span><br><span class=\"line\">glBindBuffer(GL_ARRAY_BUFFER, vbos[<span class=\"number\">0</span>]);</span><br><span class=\"line\">glEnableVertexAttribArray(<span class=\"number\">0</span>);</span><br><span class=\"line\">glVertexAttribPointer(<span class=\"number\">0</span>, <span class=\"number\">3</span>, GL_FLOAT, GL_FALSE, <span class=\"number\">3</span> * <span class=\"keyword\">sizeof</span>(GLfloat), <span class=\"number\">0</span>);</span><br><span class=\"line\">glBindBuffer(GL_ARRAY_BUFFER, vbos[<span class=\"number\">1</span>]);</span><br><span class=\"line\">glEnableVertexAttribArray(<span class=\"number\">1</span>);</span><br><span class=\"line\">glVertexAttribPointer(<span class=\"number\">1</span>, <span class=\"number\">4</span>, GL_FLOAT, GL_FALSE, <span class=\"number\">4</span> * <span class=\"keyword\">sizeof</span>(GLfloat), <span class=\"number\">0</span>);</span><br><span class=\"line\">glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vbos[<span class=\"number\">2</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">glBindVertexArray(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 绘制</span></span><br><span class=\"line\">glEnable(GL_PRIMITIVE_RESTART_FIXED_INDEX);</span><br><span class=\"line\"></span><br><span class=\"line\">glBindVertexArray(vaos);</span><br><span class=\"line\">glDrawElements(GL_TRIANGLE_STRIP, <span class=\"number\">9</span>, GL_UNSIGNED_SHORT, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">glDisable(GL_PRIMITIVE_RESTART_FIXED_INDEX);</span><br></pre></td></tr></table></figure>\n<h2>驱动顶点</h2>\n<p>如果没有限定符，那么顶点着色器的输出值在图元中使用线性插值。但是，使用平面着色时没有发生插值。因为没有发生插值，所以片段着色器中只有一个顶点值可用。对于给定的图元实例，这个驱动顶点确定使用顶点着色器的哪一个顶点输出，因为只能使用一个顶点。<a href=\"/article/2019/opengl-es-glsl-0715/#%E6%8F%92%E5%80%BC%E9%99%90%E5%AE%9A%E7%AC%A6\">插值限定符</a>。</p>\n<table>\n<thead>\n<tr>\n<th>图元i的类型</th>\n<th>驱动顶点</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>GL_POINT</td>\n<td>i</td>\n</tr>\n<tr>\n<td>GL_LINES</td>\n<td>2i</td>\n</tr>\n<tr>\n<td>GL_LINE_LOOP</td>\n<td>如果i &lt; n，为i + 1；如果i = n，为1</td>\n</tr>\n<tr>\n<td>GL_LINE_STRIP</td>\n<td>i + 1</td>\n</tr>\n<tr>\n<td>GL_TRIANGLES</td>\n<td>3i</td>\n</tr>\n<tr>\n<td>GL_TRIANGLE_STRIP</td>\n<td>i + 2</td>\n</tr>\n<tr>\n<td>GL_TRIANGLE_FAN</td>\n<td>i + 2</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>第i个图元实例的驱动顶点选择，顶点的编号从1到n，n是绘制的顶点数量。</p>\n</blockquote>\n<h2>几何形状实例化</h2>\n<p>几何形状实例化很高效，可以用一次API调用多次渲染具有不同属性（例如不同的变换矩阵、颜色或者大小）的一个对象。这一功能在渲染大量类似对象时很有用，例如对人群的渲染。几何图形实例化降低了向OpenGL ES引擎发送许多API调用的CPU处理开销。要使用实例化绘图调用渲染，可以使用如下命令：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 实例化绘图</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param mode#&gt; 指定要渲染的图元，有效值为GL_POINTS, GL_LINES, GL_LINES_STRIP, GL_LINES_LOOP, GL_TRIANGLES, GL_TRIANGLES_STRIP, GL_TRIANGLE_FAN description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param first#&gt; 指定要启用的顶点数组中的起始顶点索引 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param count#&gt; 指定绘制的索引数量 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param instancecount#&gt; 指定绘制的图元实例数量 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glDrawArraysInstanced(GLenum mode, GLint first, GLsizei count, GLsizei instancecount);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 实例化绘图</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param mode#&gt; 指定要渲染的图元，有效值为GL_POINTS, GL_LINES, GL_LINES_STRIP, GL_LINES_LOOP, GL_TRIANGLES, GL_TRIANGLES_STRIP, GL_TRIANGLE_FAN description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param count#&gt; 指定绘制的索引数量 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param type#&gt; 指定保存在indices中的元素索引类型，有效值为GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, GL_UNSIGNED_INT description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param indices#&gt; 指定元素索引存储位置的一个指针 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param instancecount#&gt; 指定绘制的图元实例数量 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glDrawElementsInstanced(GLenum mode, GLsizei count, GLenum type, <span class=\"keyword\">const</span> GLvoid *indices, GLsizei instancecount);</span><br></pre></td></tr></table></figure>\n<p>可以使用两种方法访问每个实例的数据。第一种方法是用如下命令指示OpenGL ES对每个实例读取一次或者多次顶点属性：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 对每个实例读取一次或多次顶点属性</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param index#&gt; 指定通用顶点属性索引 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param divisor#&gt; 指定index位置的通用属性更新之间传递传递的实例数量 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glVertexAttribDivisor(GLuint index, GLuint divisor);</span><br></pre></td></tr></table></figure>\n<p>默认情况下，如果没有指定<code>glVertexAttribDivisor</code>或者每个顶点属性的<code>divisor</code>等于零，对每个顶点将读取一次顶点属性。如果<code>divisor</code>等于1，则每个图元实例读取一次顶点属性。<a href=\"https://github.com/danginsburg/opengles3-book/blob/master/Chapter_7/Instancing/Instancing.c\" target=\"_blank\" rel=\"noopener\">代码例子</a></p>\n<p>第二种方法是使用内建输入变量<code>glInstanceID</code>作为顶点着色器中的缓冲区索引，以访问每个实例的数据（仅限OpenGL ES 3.0）。使用前面提到的几何形状实例化API调用时，<code>gl_InstanceID</code>将保存当前图元实例的索引。使用非实例化绘图调用时，<code>gl_InstanceID</code>将返回0。</p>\n<h2>性能提示</h2>\n<p>应用程序应该确保用尽可能大的图元尺寸调用<code>glDrawElements</code>和<code>glDrawElementsInstanced</code>。如果我们绘制<code>GL_TRIANGLES</code>，这很容易做到，但是，如果有三角形条带或者扇形的网格，则可以用图元重启将这些网格连接在一起，而不用对每个三角形条带网格单独调用<code>glDrawElements*</code>。</p>\n<p>如果无法使用图元重启机制将网格连接到一起（为了维护和旧版本OpenGL ES的兼容性），可以添加造成退化三角形的元素索引，代价是使用更多的索引。退化三角形是两个或者更多顶点相同的三角形。GPU可以非常简单的检测和拒绝退化三角形，所以这是很好的性能改进，我们可以讲一个很大的图元放入右GPU渲染的队列。</p>\n<p>代码示例：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 配置</span></span><br><span class=\"line\">GLfloat vertices[] = &#123;</span><br><span class=\"line\">    <span class=\"number\">-0.75</span>f, <span class=\"number\">0</span>, <span class=\"number\">0</span>,</span><br><span class=\"line\">    <span class=\"number\">-0.75</span>f, <span class=\"number\">0.75</span>f, <span class=\"number\">0</span>,</span><br><span class=\"line\">    <span class=\"number\">-0.25</span>f, <span class=\"number\">0</span>, <span class=\"number\">0</span>,</span><br><span class=\"line\">    <span class=\"number\">-0.25</span>f, <span class=\"number\">0.75</span>, <span class=\"number\">0</span>,</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"number\">0.75</span>f, <span class=\"number\">0</span>, <span class=\"number\">0</span>,</span><br><span class=\"line\">    <span class=\"number\">0.75</span>f, <span class=\"number\">0.75</span>f, <span class=\"number\">0</span>,</span><br><span class=\"line\">    <span class=\"number\">0.25</span>f, <span class=\"number\">0</span>, <span class=\"number\">0</span>,</span><br><span class=\"line\">    <span class=\"number\">0.25</span>f, <span class=\"number\">0.75</span>, <span class=\"number\">0</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">GLfloat colors[] = &#123;</span><br><span class=\"line\">    <span class=\"number\">1.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f,</span><br><span class=\"line\">    <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f,</span><br><span class=\"line\">    <span class=\"number\">0.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f, <span class=\"number\">1.0</span>f,</span><br><span class=\"line\">    <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f,</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"number\">1.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f,</span><br><span class=\"line\">    <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f,</span><br><span class=\"line\">    <span class=\"number\">0.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f, <span class=\"number\">1.0</span>f,</span><br><span class=\"line\">    <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">GLushort indices[] = &#123;<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">GLuint vbos[<span class=\"number\">3</span>];</span><br><span class=\"line\">glGenBuffers(<span class=\"number\">3</span>, vbos);</span><br><span class=\"line\">glBindBuffer(GL_ARRAY_BUFFER, vbos[<span class=\"number\">0</span>]);</span><br><span class=\"line\">glBufferData(GL_ARRAY_BUFFER, <span class=\"keyword\">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class=\"line\"></span><br><span class=\"line\">glBindBuffer(GL_ARRAY_BUFFER, vbos[<span class=\"number\">1</span>]);</span><br><span class=\"line\">glBufferData(GL_ARRAY_BUFFER, <span class=\"keyword\">sizeof</span>(colors), colors, GL_STATIC_DRAW);</span><br><span class=\"line\"></span><br><span class=\"line\">glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vbos[<span class=\"number\">2</span>]);</span><br><span class=\"line\">glBufferData(GL_ELEMENT_ARRAY_BUFFER, <span class=\"keyword\">sizeof</span>(indices), indices, GL_STATIC_DRAW);</span><br><span class=\"line\"></span><br><span class=\"line\">glGenVertexArrays(<span class=\"number\">1</span>, &amp;vaos);</span><br><span class=\"line\">glBindVertexArray(vaos);</span><br><span class=\"line\"></span><br><span class=\"line\">glBindBuffer(GL_ARRAY_BUFFER, vbos[<span class=\"number\">0</span>]);</span><br><span class=\"line\">glEnableVertexAttribArray(<span class=\"number\">0</span>);</span><br><span class=\"line\">glVertexAttribPointer(<span class=\"number\">0</span>, <span class=\"number\">3</span>, GL_FLOAT, GL_FALSE, <span class=\"number\">3</span> * <span class=\"keyword\">sizeof</span>(GLfloat), <span class=\"number\">0</span>);</span><br><span class=\"line\">glBindBuffer(GL_ARRAY_BUFFER, vbos[<span class=\"number\">1</span>]);</span><br><span class=\"line\">glEnableVertexAttribArray(<span class=\"number\">1</span>);</span><br><span class=\"line\">glVertexAttribPointer(<span class=\"number\">1</span>, <span class=\"number\">4</span>, GL_FLOAT, GL_FALSE, <span class=\"number\">4</span> * <span class=\"keyword\">sizeof</span>(GLfloat), <span class=\"number\">0</span>);</span><br><span class=\"line\">glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vbos[<span class=\"number\">2</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">glBindVertexArray(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 绘制</span></span><br><span class=\"line\">glBindVertexArray(vaos);</span><br><span class=\"line\">glDrawElements(GL_TRIANGLE_STRIP, <span class=\"number\">10</span>, GL_UNSIGNED_SHORT, <span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure>\n<h1>图元装配</h1>\n<p>下图展示了图元装配阶段。通过<code>glDraw***</code>提供的顶点由顶点着色器执行，顶点着色器变换的每个顶点包括描述顶点(x, y, z, w)值的顶点位置。图元位置和顶点索引确定将被渲染的单独图元。对于每个单独图元（三角形、直线和点）及其对应的顶点，图元装配阶段执行图中所示的操作。</p>\n<p><img src=\"/img/article/20190801/3.png\" alt=\"OpenGL ES图元装配阶段\"></p>\n<h2>坐标系统</h2>\n<p>下图展示了顶点通过顶点着色器和图元装配阶段时的坐标系统。顶点以物体或者本地坐标空间输入到OpenGL ES，这是最可能用来建模和存储一个对象的坐标空间。在顶点着色器执行之后，顶点位置被认为是在裁剪坐标空间内。顶点位置从本地坐标系统（也就是物体坐标）到裁剪坐标的变换通过加载执行这一转换的对应矩阵来完成，这些矩阵保存在顶点着色器中定义的统一变量中。</p>\n<p><img src=\"/img/article/20190801/4.png\" alt=\"坐标系统\"></p>\n<h3>裁剪</h3>\n<p>为了避免在可视景体之外处理图元，图元被裁剪到裁剪空间。执行顶点着色器之后的顶点位置处于裁剪坐标空间内。裁剪坐标是由(x<sub>c</sub>, y<sub>c</sub>, z<sub>c</sub>, w<sub>c</sub>)指定的同类坐标。在裁剪空间(x<sub>c</sub>, y<sub>c</sub>, z<sub>c</sub>, w<sub>c</sub>)中定义的顶点坐标根据视景体（又称裁剪体）裁剪。</p>\n<p>裁剪体由6个裁剪平面定义，这些平面称作近、远、左、右、上、下裁剪平面。在裁剪坐标中，裁剪体如下：-w<sub>c</sub> &lt;= x<sub>c</sub> &lt;= w<sub>c</sub>，-w<sub>c</sub> &lt;= y<sub>c</sub> &lt;= w<sub>c</sub>，-w<sub>c</sub> &lt;= z<sub>c</sub> &lt;= w<sub>c</sub>。</p>\n<p><img src=\"/img/article/20190801/5.png\" alt=\"视景体\"></p>\n<p>裁剪阶段将把每个图元裁剪为上图所示的裁剪体。我们在这里说的“图元”，是指用<code>GL_TRIANGLES</code>绘制的单独三角形列表中的每一个三角形，或者一个三角形条带或者扇形中的一个三角形，或者用<code>GL_LINES</code>绘制的单独直线列表中的一条直线，或者一个直线条带或者闭合折线中的一条直线，或者点精灵列表中的一个特定点。对于每种图元类型，执行如下操作：</p>\n<ul>\n<li>裁剪三角形–如果三角形完全在视景体内部，则不执行任何裁剪。如果三角形完全在视景体之外，则该三角形被放弃。如果三角形部分在视景体内，则根据相应的平面裁剪三角形。裁剪操作将生成新的顶点，这些顶点被裁剪到安排为三角形扇形的平面。</li>\n<li>裁剪直线–如果直线完全在视景体内部，则不执行任何裁剪。如果直线完全在视景体之外，则该直线被放弃。如果直线部分在视景体内，则直线被裁剪并生成相应的新顶点。</li>\n<li>裁剪点精灵–如果点位置在近或者远裁剪平面之外，或者如果表示点精灵的正方形在裁剪体之外，裁剪阶段将抛弃点精灵。否则，它将不做变化地通过该阶段，点精灵将在其裁剪体内部移到外部时裁剪，反之亦然。</li>\n</ul>\n<p>在图元根据六个裁剪平面进行裁剪时，顶点坐标经历透视分割，从而成为规范化的设备坐标。规范化的设备坐标范围为-1.0到1.0。</p>\n<h2>透视分割</h2>\n<p>透视分割取得裁剪坐标(X<sub>c</sub>, Y<sub>c</sub>, Z<sub>c</sub>, W<sub>c</sub>)指定的点，并将其投影到屏幕或者视口上。这个投影通过将(X<sub>c</sub>, Y<sub>c</sub>, Z<sub>c</sub>)除以W<sub>c</sub>进行。执行(X<sub>c</sub>/W<sub>c</sub>)、(Y<sub>c</sub>/W<sub>c</sub>)和(Z<sub>c</sub>/W<sub>c</sub>)之后，我们得到规范化的设备坐标(X<sub>d</sub>, Y<sub>d</sub>, Z<sub>d</sub>)。这些坐标被称为规范化设备坐标，因为他们落在[-1.0…1.0]区间。这些规范化的(X<sub>d</sub>, Y<sub>d</sub>)坐标根据视口的大小将被转换为真正的屏幕（或者窗口）坐标。规范化的(Z<sub>d</sub>)坐标将用<code>glDepthRangef</code>指定的<code>near</code>和<code>far</code>深度值转换为屏幕的Z值，这些转换在视口变换阶段进行。</p>\n<h2>视口变换</h2>\n<p>视口是一个二维矩阵窗口区域，是所有OpenGL ES渲染操作最终显示的地方。视口变换可用如下API调用设置：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 视口窗口</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param x#&gt; 指定视口左下角的窗口坐标x，以像素数表示 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param y#&gt; 指定视口左下角的窗口坐标y，以像素数表示 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param width#&gt; 指定视口的宽度（以像素数表示）；必须大于0 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param height#&gt; 指定视口的高度（以像素数表示）；必须大于0 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glViewport(GLint x, GLint y, GLsizei width, GLsizei height);</span><br></pre></td></tr></table></figure>\n<p>从规范化设备坐标(x<sub>d</sub>, y<sub>d</sub>, z<sub>d</sub>)到窗口坐标(x<sub>w</sub>, y<sub>w</sub>, z<sub>w</sub>)的转换用如下变换给出：</p>\n<p><img src=\"/img/article/20190801/6.png\" alt=\"矩阵变换\"></p>\n<p>在这个变换中，o<sub>x</sub>=x+w/2，o<sub>y</sub>=y+h/2，n和f代表所需的深度范围。<br>\n深度范围值n和f可以用如下API调用设置：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 设置深度值</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param zNear#&gt; 指定所需的深度范围，默认值为0.0，限于(0.0, 1.0)区间内 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param zFar#&gt; 指定所需的深度范围，默认值为1.0，限于(0.0, 1.0)区间内 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glDepthRangef(GLclampf zNear, GLclampf zFar);</span><br></pre></td></tr></table></figure>\n<p><code>glDepthRangef</code>和<code>glViewport</code>指定的值用于将顶点位置从规范化设备坐标转换为窗口（屏幕）坐标。</p>\n<h1>光栅化</h1>\n<p>下图展示了光栅化管线。在顶点变换和图元裁剪之后，光栅化管线取得单独图元（如三角形、线段或者点精灵），并为该图元生成对应的片段。每个片段由屏幕空间中的整数位置(x, y)标识。片段代表了屏幕空间中(x, y)指定的像素位置和由片段着色器处理而生成片段颜色的附加片段数据。</p>\n<p><img src=\"/img/article/20190801/7.png\" alt=\"OpenGL ES光栅化阶段\"></p>\n<h2>剔除</h2>\n<p>在三角形被光栅化之前，我们需要确定它们是正面（也就是面向观看者）或者背面（也就是背向观看者）。剔除（culling）操作抛弃背向观看者的三角形。要确定三角形是正面还是背面，首先需要知道它的方向。</p>\n<p>三角形的方向指定从第一个顶点开始，经过第二个和第三个顶点，最后回到第一个顶点的弯曲方向或者路径顺序。下图展示了弯曲顺序为顺时针和逆时针的两个三角形实例。</p>\n<p><img src=\"/img/article/20190801/8.png\" alt=\"顺时针和逆时针的三角形\"></p>\n<p>三角形的方向通过以窗口坐标表示的有符号三角形的面积来计算。我们现在需要将计算出来的三角形面积符号翻译为顺时针（CW）或者逆时针（CCW）方向。这种从三角形面积的符号到顺时针或者逆时针方向的映射由应用程序用如下API调用指定：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 指定正面三角形的方向</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param mode#&gt; 指定正面三角形的方向，有效值为GL_CW或者GL_CCW，默认值为GL_CCW description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glFrontFace(GLenum mode);</span><br></pre></td></tr></table></figure>\n<p>要确定需要提出的三角形，需要知道三角形将被剔除的面。通过如下API调用：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 剔除三角形</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param mode#&gt; 指定要被剔除的三角形的面，有效值为GL_FROUNT、GL_BACK、GL_FROUNT_AND_BACK，默认值为GL_BACK description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glCullFace(GLenum mode);</span><br></pre></td></tr></table></figure>\n<p>最后一个要点是，需要知道剔除操作是否应该执行。如果<code>GL_CULL_FACE</code>状态启用，剔除操作将被执行。通过如下API调用启用或者禁用：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 启用剔除</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param cap#&gt; 设置为GL_CULL_FACE，默认情况下剔除被禁用 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glEnable(GLenum cap);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 禁用剔除</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param cap#&gt; 设置为GL_CULL_FACE，默认情况下剔除被禁用 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glDisable(GLenum cap);</span><br></pre></td></tr></table></figure>\n<p>概括起来，要剔除合适的三角形，OpenGL ES应用程序首先必须用<code>glEnable(GL_CULL_FACE)</code>启用剔除，用<code>glCullFace</code>设置相应的剔除面，并用<code>glFrontFace</code>设置正面三角形的方向。</p>\n<blockquote>\n<p>剔除应该始终启用，以避免GPU浪费时间去光栅化不可见的三角形。启用剔除应该能够改善OpenGL ES应用程序的整体性能。</p>\n</blockquote>\n<h2>多边形偏移</h2>\n<p>考虑绘制两个相互重叠的多边形的情况。很可能会有伪像，这些伪像被称为深度冲突伪像，是因为三角形光栅化的精度有限而发生的，这种精度限制可能影响逐片段生成的深度值的精度，造成伪像。三角形光栅化使用的参数和生成的逐片段深度值的有限精度将越来越好，但是这个问题永远无法完全解决。</p>\n<p>为了避免看到伪像，我们需要在执行深度测试和深度值写入深度缓冲区之前，在计算出来的深度值上添加一个偏移量。如果深度测试通过，原始的深度值–而不是原始深度值+偏移–将被保存到深度缓冲区中。</p>\n<p>多边形偏移：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 多边形偏移</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param factor#&gt; 因数 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param units#&gt; 单位数 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glPolygonOffset(GLfloat factor, GLfloat units);</span><br></pre></td></tr></table></figure>\n<p>深度偏移的计算如下：深度偏移 = m * 因数 + r * 单位数。m是三角形的最大深度斜率，斜率项在三角形光栅化阶段期间由OpenGL ES实现计算；r是一个OpenGL ES实现定义的常量，代表深度值中可以保证产生差异的最小值。<br>\n多边形偏移可以分别用<code>glEnable(GL_POLYGON_OFFSET_FILL)</code>和<code>glDisable(GL_POLYGON_OFFSET_FILL)</code>启用或者禁用。</p>\n<p>例子：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">float</span> polygonOffsetFactor = <span class=\"number\">-1.0</span>f;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">float</span> polygonOffsetUnits = <span class=\"number\">-2.0</span>f;</span><br><span class=\"line\"></span><br><span class=\"line\">glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// load vertex shader</span></span><br><span class=\"line\"><span class=\"comment\">// set the appropriate transformation matrices</span></span><br><span class=\"line\"><span class=\"comment\">// set the vertex attribute state</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// draw the SMALLER quad</span></span><br><span class=\"line\">glDrawArrays(GL_TRIANGLE_FAN, <span class=\"number\">0</span>, <span class=\"number\">4</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// set the depth func to &lt;= as polygons are coplanar</span></span><br><span class=\"line\">glDrawFunc(GL_LEQUAL);</span><br><span class=\"line\"></span><br><span class=\"line\">glEnable(GL_POLYGON_OFFSET_FILL);</span><br><span class=\"line\"></span><br><span class=\"line\">glPolygonOffset(polygonOffsetFactor, polygonOffsetUnits);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// set the vertex attribute state</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// draw the LARGER quad</span></span><br><span class=\"line\">glDrawArrays(GL_TRIANGLE_FAN, <span class=\"number\">0</span>, <span class=\"number\">4</span>);</span><br></pre></td></tr></table></figure>\n<h1>遮挡查询</h1>\n<p>遮挡查询用查询对象来跟踪通过深度测试的任何片段或者样本。这种方法可用于不同的技术，例如镜头炫光特效的可见性测试以及避免在包围体被遮挡的不可见对象上进行几何形状处理的优化。</p>\n<p>遮挡查询的开始和结束：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 遮挡查询开始</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param target#&gt; 指定查询对象的目标类型；有效值是GL_ANY_SAMPLES_PASSED，GL_ANY_SAMPLES_PASSED_CONSERVATIVE，GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param id#&gt; 指定查询对象的名称 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glBeginQuery(GLenum target, GLuint <span class=\"keyword\">id</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 遮挡查询结束</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param target#&gt; 指定查询对象的目标类型；有效值是GL_ANY_SAMPLES_PASSED，GL_ANY_SAMPLES_PASSED_CONSERVATIVE，GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glEndQuery(GLenum target);</span><br></pre></td></tr></table></figure>\n<p>使用<code>GL_ANY_SAMPLES_PASSED</code>目标奖返回表示是否有样本通过深度测试的精确布尔状态；<code>GL_ANY_SAMPLES_PASSED_CONSERVATIVE</code>目标将提供更好的性能，但是答案的精确度较低；使用<code>GL_ANY_SAMPLES_PASSED_CONSERVATIVE</code>，有些实现将在没有样本通过深度测试时返回<code>GL_TRUE</code>。</p>\n<p><code>id</code>用<code>glGenQueries</code>创建，用<code>glDeleteQueries</code>删除：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 创建查询id</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param n#&gt; 指定生成的查询名称对象的数量 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param ids#&gt; 指定一个数组，以存储查询名称对象的列表 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glGenQueries(GLsizei n, GLuint *ids);</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 删除查询id</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param n#&gt; 指定要删除的查询名称对象的数量 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param ids#&gt; 指定一个需要删除的查询名称对象的列表数组 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span> </span><br><span class=\"line\">glDeleteQueries(GLsizei n, <span class=\"keyword\">const</span> GLuint *ids);</span><br></pre></td></tr></table></figure>\n<p>在用<code>glBeginQuery</code>和<code>glEndQuery</code>指定查询对象边界之后，可以使用<code>glGetQueryObjectuiv</code>检索查询对象的结果：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 检索查询对象的结果</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param id#&gt; 指定查询对象的名称 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param pname#&gt; 指定需要检索的查询对象参数，可以为GL_QUERY_RESULT或GL_QUERY_RESULT_AVAILABLE description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param params#&gt; 指定存储返回参数值得对象类型的数组 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glGetQueryObjectuiv(GLuint <span class=\"keyword\">id</span>, GLenum pname, GLuint *params);</span><br></pre></td></tr></table></figure>\n<h1>总结</h1>\n<p>这篇文章主要学习了OpenGL ES支持的图元类型，并且了解了如何用常规的非实例化和实例化绘图调用高效地绘制它们。还讨论了在顶点上执行坐标变换的方法。还学习了关于光栅化阶段的知识，在这个阶段，图元被转换为代表屏幕上绘制的像素的偏度。</p>\n"},{"title":"OpenGL ES学习--着色器与程序","catalog":true,"toc_nav_num":true,"date":"2019-07-06T09:30:55.000Z","subtitle":"About OpenGL ES","header-img":"/img/article_header/article_header.png","busuanzi":true,"_content":"\n> 上一篇文章介绍了绘制一个三角形的简单程序，在例子中，我们创建了两个着色器对象（顶点着色器和片段着色器）和一个程序对象，以渲染三角形。\n\n# 着色器和程序\n\n着色器对象是包含单个着色器对象，源代码提供给着色器对象，然后着色器被编译为一个目标形式。编译后，着色器对象可以连接到一个程序对象。程序对象可以连接多个着色器对象。在OpenGL ES中，每个程序对象都必须连接一个顶点着色器和一个片段着色器。程序对象最终被链接为用于渲染的最后”可执行程序“。\n获得链接后的着色器对象的一般过程包括6个步骤：\n1. 创建一个顶点着色器对象和一个片段着色器对象；\n2. 将源代码连接到每个着色器对象；\n3. 编译着色器对象；\n4. 创建一个程序对象；\n5. 将编译后的着色器对象连接到程序对象；\n6. 链接程序对象。\n\n## 创建和编译一个着色器\n\n着色器的创建与删除：\n``` objc\n/**\n 创建着色器\n\n @param type#> 类型可以是顶点着色器 GL_VERTEX_SHADER 或者是片段着色器 GL_FRAGMENT_SHADER description#>\n @return 着色器对象\n */\nglCreateShader(GLenum type);\n\n/**\n 删除着色器\n\n @param shader#> 着色器对象 description#>\n @return void\n */\nglDeleteShader(GLuint shader)\n```\n注意，如果一个着色器连接到程序对象，那么调用删除方法并不会立刻删除着色器，而是将着色器标记，在着色器不再连接到任何程序对象时，它的内存对象被释放。\n\n创建着色器对象后，下一步是提供着色器源代码：\n``` objc\n/**\n 提供着色器源代码\n\n @param shader#> 着色器对象 description#>\n @param count#> 着色器源字符串的数量 description#>\n @param string#> 指向保存数量为count的着色器源字符串的数组指针 description#>\n @param length#> 指向字符串长度 description#>\n @return void\n */\nglShaderSource(GLuint shader, GLsizei count, const GLchar *const *string, const GLint *length)\n```\n\n指定着色器代码之后，下一步是编译着色器：\n``` objc\n/**\n 着色器编译\n\n @param shader#> 着色器对象 description#>\n @return void\n */\nglCompileShader(GLuint shader)\n```\n\n编译之后可以通过`glGetShderiv`查询有关着色器对象的信息：\n``` objc\n/**\n 获取编译器相关信息\n\n @param shader#> 着色器对象 description#>\n @param pname#> 查询参数，可以是：GL_COMPILE_STATUS，GL_DELETE_STATUS，GL_INFO_LOG_LENGTH，GL_SHADER_SOURCE_LENGTH，GL_SHADER_TYPE description#>\n @param params#> 查询结果存储位置的指针 description#>\n @return void\n */\nglGetShaderiv(GLuint shader, GLenum pname, GLint *params)\n```\n\n通过`glGetShaderiv`传入`GL_INFO_LOG_LENGTH`参数获取日志缓冲区大小，然后用`glGetShaderInfoLog`检索信息日志：\n``` objc\n/**\n 检索信息日志\n\n @param shader#> 着色器对象 description#>\n @param bufsize#> 保存信息日志的缓冲大小 description#>\n @param length#> 写入信息日志的长度，可以为NULL description#>\n @param infolog#> 指向保存信息日志的字符缓冲区指针 description#>\n @return void\n */\nglGetShaderInfoLog(GLuint shader, GLsizei bufsize, GLsizei *length, GLchar *infolog)\n```\n\n通过上述步骤就可以加载一个着色器。\n\n## 创建和链接程序\n\n下一步就是创建一个程序对象。程序对象是一个容器对象，可以将着色器与之连接，并链接一个最终可执行程序。\n创建一个程序对象：\n``` objc\n/**\n 创建程序对象\n\n @param void void\n @return 程序对象\n */\nglCreateProgram()\n```\n\n删除一个程序对象：\n``` objc\n/**\n 删除一个程序对象\n\n @param program#> 程序对象 description#>\n @return void\n */\nglDeleteProgram(GLuint program)\n```\n\n创建程序对象之后，下一步就是将着色器与之连接：\n``` objc\n/**\n 连接着色器和程序\n\n @param program#> 程序对象 description#>\n @param shader#> 着色器对象 description#>\n @return void\n */\nglAttachShader(GLuint program, GLuint shader)\n```\n> 着色器可以在任何时候连接--连接到程序之前不一定需要编译，甚至可以没有源代码。唯一的要求是，每个程序对象必须有且仅有一个顶点着色器和片段着色器与之连接。\n\n断开程序和着色器：\n``` objc\n/**\n 断开程序和着色器\n\n @param program#> 程序对象 description#>\n @param shader#> 着色器对象 description#>\n @return void\n */\nglDetachShader(GLuint program, GLuint shader)\n```\n\n最后链接程序对象：\n``` objc\n/**\n 链接程序\n\n @param program#> 程序对象 description#>\n @return void\n */\nglLinkProgram(GLuint program)\n```\n\n这个链接操作负责生产最终的可执行程序。链接程序将确保顶点着色器写入片段着色器使用的所有顶点着色器输出变量（并用相同类型声明），链接程序还将确保任何在顶点和片段着色器中声明的统一变量和统一变量缓冲区的类型相符，此外，链接程序将确保最终的程序符合棘突实现的限制（例如，属性、统一变量或者输入输出着色器变量的数量）。一般来说，链接阶段是生成在硬件上运行的最终硬件指令的时候。\n\n链接程序之后，检查链接状态：\n``` objc\n/**\n 检查链接程序状态\n\n @param program#> 程序对象 description#>\n @param pname#> 获取信息的参数，可以是：GL_ACTIVE_(ATTRIBUTES, ATTRIBUTE_MAX_LENGTH, UNIFORM_BLOCK, UNIFORM_BLOCK_MAX_LENGTH, UNIFORMS, UNFORM_MAX_LENGTH), GL_ATTACHED_SHADERS, GL_DELETE_STATUS, GL_INFO_LOG_LENGTH, GL_LINK_STATUS, GL_PROGRAM_BINARY_RETRIEVABLE_HINT, GL_TRANSFORM_FEEDBACK_(BUFFER_MODE, VARYINGS, VARYING_MAX_LENGTH), GL_VALIDATE_STATUS description#>\n @param params#> 指向查询结果整数存储位置的指针 description#>\n @return void\n */\nglGetProgramiv(GLuint program, GLenum pname, GLint *params)\n```\n\n同样可以通过`glGetProgramiv`函数传入`GL_INFO_LOG_LENGTH`参数获取信息日志缓冲区大小，查询链接程序日志：\n``` objc\n/**\n 检索链接程序日志\n\n @param program#> 程序对象 description#>\n @param bufsize#> 存储信息日志的缓冲区大小 description#>\n @param length#> 写入信息日志长度，可以为NULL description#>\n @param infolog#> 指向存储信息日志的字符缓冲区指针 description#>\n @return void\n */\nglGetProgramInfoLog(GLuint program, GLsizei bufsize, GLsizei *length, GLchar *infolog)\n```\n\n一旦成功链接程序，我们就几乎为使用它渲染做好了准备，但是，我们还需要检查程序是否有效。也就是说，成功链接不能保证执行的某些方面，如应用程序可能没有把有效的纹理绑定到采样器，这时候我们需要再次验证程序当前状态：\n``` objc\n/**\n 检查程序能以当前状态执行\n\n @param program#> 程序对象 description#>\n @return void\n */\nglValidateProgram(GLuint program)\n```\n调用`glValidProgram`函数后，通过之前的`glGetProgramiv`传入`GL_VALIDATE_STATUS`参数检查，信息日志也将更新。\n\n在完成创建程序对象，连接着色器，链接以及获取信息日志确认无误，在渲染之前，我们还要对程序对象做一件事，就是将其设置为活动程序：\n``` objc\n/**\n 设置为活动程序\n\n @param program#> 程序对象 description#>\n @return void\n */\nglUseProgram(GLuint program)\n```\n\n# 统一变量和属性\n\n一旦链接了程序对象，就可以在对象上进行许多查询。首先，我们可能需要找出程序中的活动统一变量（uniform）。\n\n统一变量被组合成两类统一变量块。第一类是命名统一变量块，统一变量的值由所谓的统一变量缓冲区对象支持：\n``` objc\nuniform TransformBlock {\n    mat4 matViewProj;\n    mat3 matNormal;\n    mat3 matTexGen\n}\n```\n\n第二类是默认的统一变量块，用于在命名统一变量块之外的声明的统一变量：\n```\nuniform mat4 matViewProj;\nuniform mat3 matNormal;\nuniform mat3 matTexGen;\n```\n\n如果统一变量在顶点着色器和片段着色器均有声明，则声明的类型必须相同，且在两个着色器中的值也需相同。在链接阶段，链接程序将为程序中与默认统一变量块相关的活动统一变量指定位置。这些位置是应用程序用于加载统一变量的标识符。链接程序还将为与命名统一变量块相关的活动统一变量分配偏移和跨距（对于数组和矩阵类型的统一变量）。\n\n## 获取和设置统一变量\n\n要查询程序中活动统一变量的列表，首先通过`glGetProgramiv`函数传入`GL_ACTIVE_UNIFORMS`获取程序中活动统一变量的数量，传入`GL_ACTIVE_UNIFORM_MAX_LENGTH`参数获取统一变量最长字符数量，知道这两个参数之后可以使用`glGetActiveUniform`和`glGetActiveUniformsiv`找出每个统一变量的细节：\n``` objc\nGLint uniformsCount;\nGLint maxUniformLength;\nglGetProgramiv(program, GL_ACTIVE_UNIFORMS, &uniformsCount);\nglGetProgramiv(program, GL_ACTIVE_UNIFORM_MAX_LENGTH, &maxUniformLength);\nfor (int i = 0; i < uniformsCount; i++) {\n    GLsizei length;\n    GLint size;\n    GLenum type;\n    GLchar *name = malloc(sizeof(GLchar) * maxUniformLength);\n    glGetActiveUniform(program, i, maxUniformLength, &length, &size, &type, name);\n    NSLog(@\"length: %d, size: %d, type: %u, name: %s\", length, size, type, name);\n}\n```\n\n使用`glGetActiveUniform`，可以确定几乎所有统一变量的属性。通过统一变量的名称，我们就可以找到它的位置：\n``` objc\n/**\n 获取统一变量在程序中的位置\n\n @param program#> 程序对象 description#>\n @param name#> 统一变量名称 description#>\n @return 位置\n */\nglGetUniformLocation(GLuint program, const GLchar *name)\n```\n\n获取到位置下标后，我们就可以加载统一变量的值，各个类型都有对应不同的函数，举几个例子：\n```\nvoid glUniformlf(GLint location, GLfloat x);\nvoid glUniformfv(GLint location, GLsizei count, const GLfloat* value);\n...\n```\n\n>  `glUniform*`调用不以程序对象句柄作为参数，原因是，`glUniform*`总是在于`glUseProgram`绑定的当前程序上操作。统一变量值本身保存在程序对象中。也就是说，一旦在程序对象中设置一个统一变量的值，即使我们让另一个程序处于活动状态，该值仍然保留在原来的程序对象中。从这个意义上，我们可以说统一变量值是程序对象局部所有。\n\n## 统一变量缓冲区对象\n\n可以使用缓冲区对象存储变量数据，从而在程序中的着色器之间甚至程序之间共享统一变量，这种缓冲区被称为统一变量缓冲区对象 UBO（Uniform Buffer Object）。使用统一变量缓冲区对象可以在更新大的统一变量块时降低API开销，此外，这种方法增加了统一变量的可用存储。\n要更新统一变量缓冲区对象的统一变量数据，我们可以使用`glBufferData`、`glBufferSubData`、`glMapBufferRange`、`glUnmapBuffer`等命令修改缓冲区对象的内容，而不是使用`glUniform*`命令。\n\nUBO必须配合Uniform Block（命名统一变量块）一起使用，在显存中创建缓存对象（Buffer），在buffer中存储统一变量数据，将buffer与指定的point（不得大于`GL_MAX_UNIFORM_BUFFER_BINDINGS`，通过`glGet`函数查询）绑定，将统一变量缓冲区的索引和point绑定，这样通过point将变量和缓存链接。\n\n![UBO原理图](/img/article/20190706/1.png)\n\n首先检索统一变量块索引：\n``` objc\n/**\n 检索统一变量块索引\n\n @param program#> 程序对象 description#>\n @param uniformBlockName#> 统一变量块名称 description#>\n @return 索引\n */\nglGetUniformBlockIndex(GLuint program, const GLchar *uniformBlockName)\n```\n\n可以通过`glGetActiveUniformBlockName`获取统一变量块名：\n``` objc\n/**\n 获取统一变量块名\n\n @param program#> 程序对象 description#>\n @param uniformBlockIndex#> 统一变量块索引 description#>\n @param bufSize#> 名称数组中的字符数 description#>\n @param length#> 可为NULL，否则可以写入字符数 description#>\n @param uniformBlockName#> 写入统一变量块名称 description#>\n @return 块名\n */\nglGetActiveUniformBlockName(GLuint program, GLuint uniformBlockIndex, GLsizei bufSize, GLsizei *length, GLchar *uniformBlockName)\n```\n\n通过`glGetActiveUniformBlockiv`获取统一变量块的许多属性：\n``` objc\n/**\n 获取统一变量块的属性\n\n @param program#> 程序对象 description#>\n @param uniformBlockIndex#> 需要查询的统一变量块索引 description#>\n @param pname#> 查询属性，可以是：GL_UNIFORM_BLOCK_(BINDING, DATA_SIZE, NAME_LENGTH, ACTIVE_UNIFORMS, ACTIVE_UNIFORM_INDICES, REFERENCED_BY_VERTEX_SHADER, REFERENCED_BY_FRAGMENT_SHADER) description#>\n @param params#> 写入pname指定的结果 description#>\n @return void\n */\nglGetActiveUniformBlockiv(GLuint program, GLuint uniformBlockIndex, GLenum pname, GLint *params)\n```\n\n一旦有了统一变量块索引，就可以将该索引与程序中的统一变量块绑定点关联：\n``` objc\n/**\n 将统一变量块索引与程序中的统一变量块绑定点关联\n\n @param program#> 程序对象 description#>\n @param uniformBlockIndex#> 统一变量块索引 description#>\n @param uniformBlockBinding#> 统一变量缓冲区对象绑定点 description#>\n @return void\n */\nglUniformBlockBinding(GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding)\n```\n\n最后可以将统一变量缓冲区对象绑定到`GL_UNIFORM_BUFFER`目标和程序中的统一变量块绑定点：\n``` objc\n/**\n 将统一变量缓冲区对象绑定到目标和程序中的统一变量块绑定点\n\n @param target#> 必须是GL_UNIFORM_BUFFER或GL_TRANSFORM_FEEDBACK_BUFFER description#>\n @param index#> 绑定索引 description#>\n @param buffer#> 缓冲区对象句柄 description#>\n @return void\n */\nglBindBufferBase(GLenum target, GLuint index, GLuint buffer)\n\n/**\n 将统一变量缓冲区对象绑定到目标和程序中的统一变量块绑定点\n\n @param target#> 必须是GL_UNIFORM_BUFFER或GL_TRANSFORM_FEEDBACK_BUFFER description#>\n @param index#> 绑定索引 description#>\n @param buffer#> b缓冲区对象句柄 description#>\n @param offset#> 以字节数计算的缓冲区对象其实偏移 description#>\n @param size#> 可以从缓冲区对象读取或者写入缓冲对象的数据量 description#>\n @return void\n */\nglBindBufferRange(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size)\n```\n\n下面举个例子：\n对于着色器代码，除非我们使用std140统一变量块布局（默认），否则需要查询程序对象得到字节偏移和跨距，以在统一变量缓冲区对象中设置统一变量数据。std140布局保证使用由OpengGL ES 3.0规范定义的明确布局规范进行特定包装。因此，使用std140，我们就可以在不同的OpengGL ES 3.0实现之间共享统一变量块。\n其他限定符：\n限定符 | 描述\n-|-\nshared | 限定符指定多个着色器或者多个程序中统一变量块的内存布局相同。要使用这个限定符，不同定义中的row_major/column_major值必须相等。覆盖std140和packed（默认）\npacked | 指定编译器可以优化统一变量块的内存布局。使用这个限定符时必须查询偏移位置，而且统一变量块无法在顶点/片段着色器或者程序间共享。覆盖std140和shared\nstd140 | 指定统一变量块的布局基于OpenGL ES 3.0规范的“标准统一变量块布局”一节中定义的一组标准规则。覆盖shared和packed\nrow_major | 矩阵在内存中以行优先顺序布局\ncolumn_major | 矩阵在内存中以列优先顺序布局（默认）\n\n着色器代码：\n``` objc\nlayout (std140) uniform LightBlock {\n    vec3 lightDirection;\n    vec4 lightPosition;\n}\n```\n\n设置UBO代码：\n``` objc\nGLuint blockId, bufferId;\nGLint blockSize;\nGLuint bindingPoint = 1;\nGLfloat lightData[] = {\n    1.0f, 0.0f, 0.0f, 0.0f,\n    0.0f, 0.0f, 0.0f, 1.0f\n};\n\nblockId = glGetUniformBlockIndex(program, \"LightBlock\");\n\nglUniformBlockBinding(program, blockId, bindingPoint);\n\nglGetActiveUniformBlockiv(program, blockId, GL_UNIFORM_BLOCK_DATA_SIZE, &blockSize);\n\nglGenBuffers(1, &bufferId);\nglBindBuffer(GL_UNIFORM_BUFFER, bufferId);\nglBufferData(GL_UNIFORM_BUFFER, blockSize, lightData, GL_DYNAMIC_DRAW);\n\nglBindBufferBase(GL_UNIFORM_BUFFER, bindingPoint, bufferId);\n```\n\n修改UBO代码：\n``` objc\nGLfloat updateData[] = {\n    1.0f, 0.0f, 0.0f, 0.0f\n};\n\nglBindBuffer(GL_UNIFORM_BUFFER, bufferId);\n\nconst GLchar *names[] = {\"lightDirection\"};\nGLuint indices;\nGLint offset;\nGLint size;\nglGetUniformIndices(program, 1, names, &indices);\nglGetActiveUniformsiv(program, 1, &indices, GL_UNIFORM_OFFSET, &offset);\nglGetActiveUniformsiv(program, 1, &indices, GL_UNIFORM_SIZE, &size);\nglBufferSubData(GL_UNIFORM_BUFFER, offset, size, updateData);\n```\n\n# 程序二进制码\n\n程序二进制码是完全编译和链接的程序的二进制表现形式。它们很有用，因为可以保存到文件系统供以后使用，从而避免在线编译的代价。我们也可以是使用程序二进制码，这样就没有必要在实现中分发着色器源代码。\n我们可以在成功编译和链接程序之后，检索程序二进制码：\n``` objc\n/**\n 检索程序二进制码\n \n @param program#> 程序对象 description#>\n @param bufSize#> 可以写入binary的最大字节数 description#>\n @param length#> 二进制数据字节数 description#>\n @param binaryFormat#> 供应商专用二进制格式标识 description#>\n @param binary#> 着色器编译器生成的二进制数据指针 description#>\n @return void\n */\nglGetProgramBinary(GLuint program, GLsizei bufSize, GLsizei *length, GLenum *binaryFormat, GLvoid *binary)\n```\n\n检索之后，可以将其保存到文件系统，或者将程序二进制码读回OpenGL ES实现：\n``` objc\n/**\n 将二进制码读回OpenGL ES实现\n\n @param program#> 程序对象 description#>\n @param binaryFormat#> 供应商专用二进制格式标识 description#>\n @param binary#> 着色器编译器生成的二进制数据指针 description#>\n @param length#> 二进制数据的字节数 description#>\n @return void\n */\nglProgramBinary(GLuint program, GLenum binaryFormat, const GLvoid *binary, GLsizei length)\n```\n\n为了确保存储的程序二进制码仍然兼容，在调用`glProgramBinary`之后，可以通过`glProgramiv`查询`GL_LINK_STATUS`。如果二进制码不兼容，我们需要重新编译着色器源码。\n\n# 总结\n\n这篇文章主要介绍了创建、编译和链接着色器到程序的方法，着色器对象和程序对象组成了OpenGL ES 3.0中的基本对象。同时介绍了查询着色器和程序信息以及加载统一变量的方法等。","source":"_posts/2019/opengl-es-shader-and-program-0706.md","raw":"---\ntitle: \"OpenGL ES学习--着色器与程序\"\ncatalog: true\ntoc_nav_num: true\ndate: 2019-07-06 17:30:55\nsubtitle: \"About OpenGL ES\"\nheader-img: \"/img/article_header/article_header.png\"\nbusuanzi: true\ntags:\n- iOS\n\n---\n\n> 上一篇文章介绍了绘制一个三角形的简单程序，在例子中，我们创建了两个着色器对象（顶点着色器和片段着色器）和一个程序对象，以渲染三角形。\n\n# 着色器和程序\n\n着色器对象是包含单个着色器对象，源代码提供给着色器对象，然后着色器被编译为一个目标形式。编译后，着色器对象可以连接到一个程序对象。程序对象可以连接多个着色器对象。在OpenGL ES中，每个程序对象都必须连接一个顶点着色器和一个片段着色器。程序对象最终被链接为用于渲染的最后”可执行程序“。\n获得链接后的着色器对象的一般过程包括6个步骤：\n1. 创建一个顶点着色器对象和一个片段着色器对象；\n2. 将源代码连接到每个着色器对象；\n3. 编译着色器对象；\n4. 创建一个程序对象；\n5. 将编译后的着色器对象连接到程序对象；\n6. 链接程序对象。\n\n## 创建和编译一个着色器\n\n着色器的创建与删除：\n``` objc\n/**\n 创建着色器\n\n @param type#> 类型可以是顶点着色器 GL_VERTEX_SHADER 或者是片段着色器 GL_FRAGMENT_SHADER description#>\n @return 着色器对象\n */\nglCreateShader(GLenum type);\n\n/**\n 删除着色器\n\n @param shader#> 着色器对象 description#>\n @return void\n */\nglDeleteShader(GLuint shader)\n```\n注意，如果一个着色器连接到程序对象，那么调用删除方法并不会立刻删除着色器，而是将着色器标记，在着色器不再连接到任何程序对象时，它的内存对象被释放。\n\n创建着色器对象后，下一步是提供着色器源代码：\n``` objc\n/**\n 提供着色器源代码\n\n @param shader#> 着色器对象 description#>\n @param count#> 着色器源字符串的数量 description#>\n @param string#> 指向保存数量为count的着色器源字符串的数组指针 description#>\n @param length#> 指向字符串长度 description#>\n @return void\n */\nglShaderSource(GLuint shader, GLsizei count, const GLchar *const *string, const GLint *length)\n```\n\n指定着色器代码之后，下一步是编译着色器：\n``` objc\n/**\n 着色器编译\n\n @param shader#> 着色器对象 description#>\n @return void\n */\nglCompileShader(GLuint shader)\n```\n\n编译之后可以通过`glGetShderiv`查询有关着色器对象的信息：\n``` objc\n/**\n 获取编译器相关信息\n\n @param shader#> 着色器对象 description#>\n @param pname#> 查询参数，可以是：GL_COMPILE_STATUS，GL_DELETE_STATUS，GL_INFO_LOG_LENGTH，GL_SHADER_SOURCE_LENGTH，GL_SHADER_TYPE description#>\n @param params#> 查询结果存储位置的指针 description#>\n @return void\n */\nglGetShaderiv(GLuint shader, GLenum pname, GLint *params)\n```\n\n通过`glGetShaderiv`传入`GL_INFO_LOG_LENGTH`参数获取日志缓冲区大小，然后用`glGetShaderInfoLog`检索信息日志：\n``` objc\n/**\n 检索信息日志\n\n @param shader#> 着色器对象 description#>\n @param bufsize#> 保存信息日志的缓冲大小 description#>\n @param length#> 写入信息日志的长度，可以为NULL description#>\n @param infolog#> 指向保存信息日志的字符缓冲区指针 description#>\n @return void\n */\nglGetShaderInfoLog(GLuint shader, GLsizei bufsize, GLsizei *length, GLchar *infolog)\n```\n\n通过上述步骤就可以加载一个着色器。\n\n## 创建和链接程序\n\n下一步就是创建一个程序对象。程序对象是一个容器对象，可以将着色器与之连接，并链接一个最终可执行程序。\n创建一个程序对象：\n``` objc\n/**\n 创建程序对象\n\n @param void void\n @return 程序对象\n */\nglCreateProgram()\n```\n\n删除一个程序对象：\n``` objc\n/**\n 删除一个程序对象\n\n @param program#> 程序对象 description#>\n @return void\n */\nglDeleteProgram(GLuint program)\n```\n\n创建程序对象之后，下一步就是将着色器与之连接：\n``` objc\n/**\n 连接着色器和程序\n\n @param program#> 程序对象 description#>\n @param shader#> 着色器对象 description#>\n @return void\n */\nglAttachShader(GLuint program, GLuint shader)\n```\n> 着色器可以在任何时候连接--连接到程序之前不一定需要编译，甚至可以没有源代码。唯一的要求是，每个程序对象必须有且仅有一个顶点着色器和片段着色器与之连接。\n\n断开程序和着色器：\n``` objc\n/**\n 断开程序和着色器\n\n @param program#> 程序对象 description#>\n @param shader#> 着色器对象 description#>\n @return void\n */\nglDetachShader(GLuint program, GLuint shader)\n```\n\n最后链接程序对象：\n``` objc\n/**\n 链接程序\n\n @param program#> 程序对象 description#>\n @return void\n */\nglLinkProgram(GLuint program)\n```\n\n这个链接操作负责生产最终的可执行程序。链接程序将确保顶点着色器写入片段着色器使用的所有顶点着色器输出变量（并用相同类型声明），链接程序还将确保任何在顶点和片段着色器中声明的统一变量和统一变量缓冲区的类型相符，此外，链接程序将确保最终的程序符合棘突实现的限制（例如，属性、统一变量或者输入输出着色器变量的数量）。一般来说，链接阶段是生成在硬件上运行的最终硬件指令的时候。\n\n链接程序之后，检查链接状态：\n``` objc\n/**\n 检查链接程序状态\n\n @param program#> 程序对象 description#>\n @param pname#> 获取信息的参数，可以是：GL_ACTIVE_(ATTRIBUTES, ATTRIBUTE_MAX_LENGTH, UNIFORM_BLOCK, UNIFORM_BLOCK_MAX_LENGTH, UNIFORMS, UNFORM_MAX_LENGTH), GL_ATTACHED_SHADERS, GL_DELETE_STATUS, GL_INFO_LOG_LENGTH, GL_LINK_STATUS, GL_PROGRAM_BINARY_RETRIEVABLE_HINT, GL_TRANSFORM_FEEDBACK_(BUFFER_MODE, VARYINGS, VARYING_MAX_LENGTH), GL_VALIDATE_STATUS description#>\n @param params#> 指向查询结果整数存储位置的指针 description#>\n @return void\n */\nglGetProgramiv(GLuint program, GLenum pname, GLint *params)\n```\n\n同样可以通过`glGetProgramiv`函数传入`GL_INFO_LOG_LENGTH`参数获取信息日志缓冲区大小，查询链接程序日志：\n``` objc\n/**\n 检索链接程序日志\n\n @param program#> 程序对象 description#>\n @param bufsize#> 存储信息日志的缓冲区大小 description#>\n @param length#> 写入信息日志长度，可以为NULL description#>\n @param infolog#> 指向存储信息日志的字符缓冲区指针 description#>\n @return void\n */\nglGetProgramInfoLog(GLuint program, GLsizei bufsize, GLsizei *length, GLchar *infolog)\n```\n\n一旦成功链接程序，我们就几乎为使用它渲染做好了准备，但是，我们还需要检查程序是否有效。也就是说，成功链接不能保证执行的某些方面，如应用程序可能没有把有效的纹理绑定到采样器，这时候我们需要再次验证程序当前状态：\n``` objc\n/**\n 检查程序能以当前状态执行\n\n @param program#> 程序对象 description#>\n @return void\n */\nglValidateProgram(GLuint program)\n```\n调用`glValidProgram`函数后，通过之前的`glGetProgramiv`传入`GL_VALIDATE_STATUS`参数检查，信息日志也将更新。\n\n在完成创建程序对象，连接着色器，链接以及获取信息日志确认无误，在渲染之前，我们还要对程序对象做一件事，就是将其设置为活动程序：\n``` objc\n/**\n 设置为活动程序\n\n @param program#> 程序对象 description#>\n @return void\n */\nglUseProgram(GLuint program)\n```\n\n# 统一变量和属性\n\n一旦链接了程序对象，就可以在对象上进行许多查询。首先，我们可能需要找出程序中的活动统一变量（uniform）。\n\n统一变量被组合成两类统一变量块。第一类是命名统一变量块，统一变量的值由所谓的统一变量缓冲区对象支持：\n``` objc\nuniform TransformBlock {\n    mat4 matViewProj;\n    mat3 matNormal;\n    mat3 matTexGen\n}\n```\n\n第二类是默认的统一变量块，用于在命名统一变量块之外的声明的统一变量：\n```\nuniform mat4 matViewProj;\nuniform mat3 matNormal;\nuniform mat3 matTexGen;\n```\n\n如果统一变量在顶点着色器和片段着色器均有声明，则声明的类型必须相同，且在两个着色器中的值也需相同。在链接阶段，链接程序将为程序中与默认统一变量块相关的活动统一变量指定位置。这些位置是应用程序用于加载统一变量的标识符。链接程序还将为与命名统一变量块相关的活动统一变量分配偏移和跨距（对于数组和矩阵类型的统一变量）。\n\n## 获取和设置统一变量\n\n要查询程序中活动统一变量的列表，首先通过`glGetProgramiv`函数传入`GL_ACTIVE_UNIFORMS`获取程序中活动统一变量的数量，传入`GL_ACTIVE_UNIFORM_MAX_LENGTH`参数获取统一变量最长字符数量，知道这两个参数之后可以使用`glGetActiveUniform`和`glGetActiveUniformsiv`找出每个统一变量的细节：\n``` objc\nGLint uniformsCount;\nGLint maxUniformLength;\nglGetProgramiv(program, GL_ACTIVE_UNIFORMS, &uniformsCount);\nglGetProgramiv(program, GL_ACTIVE_UNIFORM_MAX_LENGTH, &maxUniformLength);\nfor (int i = 0; i < uniformsCount; i++) {\n    GLsizei length;\n    GLint size;\n    GLenum type;\n    GLchar *name = malloc(sizeof(GLchar) * maxUniformLength);\n    glGetActiveUniform(program, i, maxUniformLength, &length, &size, &type, name);\n    NSLog(@\"length: %d, size: %d, type: %u, name: %s\", length, size, type, name);\n}\n```\n\n使用`glGetActiveUniform`，可以确定几乎所有统一变量的属性。通过统一变量的名称，我们就可以找到它的位置：\n``` objc\n/**\n 获取统一变量在程序中的位置\n\n @param program#> 程序对象 description#>\n @param name#> 统一变量名称 description#>\n @return 位置\n */\nglGetUniformLocation(GLuint program, const GLchar *name)\n```\n\n获取到位置下标后，我们就可以加载统一变量的值，各个类型都有对应不同的函数，举几个例子：\n```\nvoid glUniformlf(GLint location, GLfloat x);\nvoid glUniformfv(GLint location, GLsizei count, const GLfloat* value);\n...\n```\n\n>  `glUniform*`调用不以程序对象句柄作为参数，原因是，`glUniform*`总是在于`glUseProgram`绑定的当前程序上操作。统一变量值本身保存在程序对象中。也就是说，一旦在程序对象中设置一个统一变量的值，即使我们让另一个程序处于活动状态，该值仍然保留在原来的程序对象中。从这个意义上，我们可以说统一变量值是程序对象局部所有。\n\n## 统一变量缓冲区对象\n\n可以使用缓冲区对象存储变量数据，从而在程序中的着色器之间甚至程序之间共享统一变量，这种缓冲区被称为统一变量缓冲区对象 UBO（Uniform Buffer Object）。使用统一变量缓冲区对象可以在更新大的统一变量块时降低API开销，此外，这种方法增加了统一变量的可用存储。\n要更新统一变量缓冲区对象的统一变量数据，我们可以使用`glBufferData`、`glBufferSubData`、`glMapBufferRange`、`glUnmapBuffer`等命令修改缓冲区对象的内容，而不是使用`glUniform*`命令。\n\nUBO必须配合Uniform Block（命名统一变量块）一起使用，在显存中创建缓存对象（Buffer），在buffer中存储统一变量数据，将buffer与指定的point（不得大于`GL_MAX_UNIFORM_BUFFER_BINDINGS`，通过`glGet`函数查询）绑定，将统一变量缓冲区的索引和point绑定，这样通过point将变量和缓存链接。\n\n![UBO原理图](/img/article/20190706/1.png)\n\n首先检索统一变量块索引：\n``` objc\n/**\n 检索统一变量块索引\n\n @param program#> 程序对象 description#>\n @param uniformBlockName#> 统一变量块名称 description#>\n @return 索引\n */\nglGetUniformBlockIndex(GLuint program, const GLchar *uniformBlockName)\n```\n\n可以通过`glGetActiveUniformBlockName`获取统一变量块名：\n``` objc\n/**\n 获取统一变量块名\n\n @param program#> 程序对象 description#>\n @param uniformBlockIndex#> 统一变量块索引 description#>\n @param bufSize#> 名称数组中的字符数 description#>\n @param length#> 可为NULL，否则可以写入字符数 description#>\n @param uniformBlockName#> 写入统一变量块名称 description#>\n @return 块名\n */\nglGetActiveUniformBlockName(GLuint program, GLuint uniformBlockIndex, GLsizei bufSize, GLsizei *length, GLchar *uniformBlockName)\n```\n\n通过`glGetActiveUniformBlockiv`获取统一变量块的许多属性：\n``` objc\n/**\n 获取统一变量块的属性\n\n @param program#> 程序对象 description#>\n @param uniformBlockIndex#> 需要查询的统一变量块索引 description#>\n @param pname#> 查询属性，可以是：GL_UNIFORM_BLOCK_(BINDING, DATA_SIZE, NAME_LENGTH, ACTIVE_UNIFORMS, ACTIVE_UNIFORM_INDICES, REFERENCED_BY_VERTEX_SHADER, REFERENCED_BY_FRAGMENT_SHADER) description#>\n @param params#> 写入pname指定的结果 description#>\n @return void\n */\nglGetActiveUniformBlockiv(GLuint program, GLuint uniformBlockIndex, GLenum pname, GLint *params)\n```\n\n一旦有了统一变量块索引，就可以将该索引与程序中的统一变量块绑定点关联：\n``` objc\n/**\n 将统一变量块索引与程序中的统一变量块绑定点关联\n\n @param program#> 程序对象 description#>\n @param uniformBlockIndex#> 统一变量块索引 description#>\n @param uniformBlockBinding#> 统一变量缓冲区对象绑定点 description#>\n @return void\n */\nglUniformBlockBinding(GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding)\n```\n\n最后可以将统一变量缓冲区对象绑定到`GL_UNIFORM_BUFFER`目标和程序中的统一变量块绑定点：\n``` objc\n/**\n 将统一变量缓冲区对象绑定到目标和程序中的统一变量块绑定点\n\n @param target#> 必须是GL_UNIFORM_BUFFER或GL_TRANSFORM_FEEDBACK_BUFFER description#>\n @param index#> 绑定索引 description#>\n @param buffer#> 缓冲区对象句柄 description#>\n @return void\n */\nglBindBufferBase(GLenum target, GLuint index, GLuint buffer)\n\n/**\n 将统一变量缓冲区对象绑定到目标和程序中的统一变量块绑定点\n\n @param target#> 必须是GL_UNIFORM_BUFFER或GL_TRANSFORM_FEEDBACK_BUFFER description#>\n @param index#> 绑定索引 description#>\n @param buffer#> b缓冲区对象句柄 description#>\n @param offset#> 以字节数计算的缓冲区对象其实偏移 description#>\n @param size#> 可以从缓冲区对象读取或者写入缓冲对象的数据量 description#>\n @return void\n */\nglBindBufferRange(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size)\n```\n\n下面举个例子：\n对于着色器代码，除非我们使用std140统一变量块布局（默认），否则需要查询程序对象得到字节偏移和跨距，以在统一变量缓冲区对象中设置统一变量数据。std140布局保证使用由OpengGL ES 3.0规范定义的明确布局规范进行特定包装。因此，使用std140，我们就可以在不同的OpengGL ES 3.0实现之间共享统一变量块。\n其他限定符：\n限定符 | 描述\n-|-\nshared | 限定符指定多个着色器或者多个程序中统一变量块的内存布局相同。要使用这个限定符，不同定义中的row_major/column_major值必须相等。覆盖std140和packed（默认）\npacked | 指定编译器可以优化统一变量块的内存布局。使用这个限定符时必须查询偏移位置，而且统一变量块无法在顶点/片段着色器或者程序间共享。覆盖std140和shared\nstd140 | 指定统一变量块的布局基于OpenGL ES 3.0规范的“标准统一变量块布局”一节中定义的一组标准规则。覆盖shared和packed\nrow_major | 矩阵在内存中以行优先顺序布局\ncolumn_major | 矩阵在内存中以列优先顺序布局（默认）\n\n着色器代码：\n``` objc\nlayout (std140) uniform LightBlock {\n    vec3 lightDirection;\n    vec4 lightPosition;\n}\n```\n\n设置UBO代码：\n``` objc\nGLuint blockId, bufferId;\nGLint blockSize;\nGLuint bindingPoint = 1;\nGLfloat lightData[] = {\n    1.0f, 0.0f, 0.0f, 0.0f,\n    0.0f, 0.0f, 0.0f, 1.0f\n};\n\nblockId = glGetUniformBlockIndex(program, \"LightBlock\");\n\nglUniformBlockBinding(program, blockId, bindingPoint);\n\nglGetActiveUniformBlockiv(program, blockId, GL_UNIFORM_BLOCK_DATA_SIZE, &blockSize);\n\nglGenBuffers(1, &bufferId);\nglBindBuffer(GL_UNIFORM_BUFFER, bufferId);\nglBufferData(GL_UNIFORM_BUFFER, blockSize, lightData, GL_DYNAMIC_DRAW);\n\nglBindBufferBase(GL_UNIFORM_BUFFER, bindingPoint, bufferId);\n```\n\n修改UBO代码：\n``` objc\nGLfloat updateData[] = {\n    1.0f, 0.0f, 0.0f, 0.0f\n};\n\nglBindBuffer(GL_UNIFORM_BUFFER, bufferId);\n\nconst GLchar *names[] = {\"lightDirection\"};\nGLuint indices;\nGLint offset;\nGLint size;\nglGetUniformIndices(program, 1, names, &indices);\nglGetActiveUniformsiv(program, 1, &indices, GL_UNIFORM_OFFSET, &offset);\nglGetActiveUniformsiv(program, 1, &indices, GL_UNIFORM_SIZE, &size);\nglBufferSubData(GL_UNIFORM_BUFFER, offset, size, updateData);\n```\n\n# 程序二进制码\n\n程序二进制码是完全编译和链接的程序的二进制表现形式。它们很有用，因为可以保存到文件系统供以后使用，从而避免在线编译的代价。我们也可以是使用程序二进制码，这样就没有必要在实现中分发着色器源代码。\n我们可以在成功编译和链接程序之后，检索程序二进制码：\n``` objc\n/**\n 检索程序二进制码\n \n @param program#> 程序对象 description#>\n @param bufSize#> 可以写入binary的最大字节数 description#>\n @param length#> 二进制数据字节数 description#>\n @param binaryFormat#> 供应商专用二进制格式标识 description#>\n @param binary#> 着色器编译器生成的二进制数据指针 description#>\n @return void\n */\nglGetProgramBinary(GLuint program, GLsizei bufSize, GLsizei *length, GLenum *binaryFormat, GLvoid *binary)\n```\n\n检索之后，可以将其保存到文件系统，或者将程序二进制码读回OpenGL ES实现：\n``` objc\n/**\n 将二进制码读回OpenGL ES实现\n\n @param program#> 程序对象 description#>\n @param binaryFormat#> 供应商专用二进制格式标识 description#>\n @param binary#> 着色器编译器生成的二进制数据指针 description#>\n @param length#> 二进制数据的字节数 description#>\n @return void\n */\nglProgramBinary(GLuint program, GLenum binaryFormat, const GLvoid *binary, GLsizei length)\n```\n\n为了确保存储的程序二进制码仍然兼容，在调用`glProgramBinary`之后，可以通过`glProgramiv`查询`GL_LINK_STATUS`。如果二进制码不兼容，我们需要重新编译着色器源码。\n\n# 总结\n\n这篇文章主要介绍了创建、编译和链接着色器到程序的方法，着色器对象和程序对象组成了OpenGL ES 3.0中的基本对象。同时介绍了查询着色器和程序信息以及加载统一变量的方法等。","slug":"2019/opengl-es-shader-and-program-0706","published":1,"updated":"2022-01-10T09:04:52.807Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cky8gmc4d0014d1qhz8wwln6u","content":"<blockquote>\n<p>上一篇文章介绍了绘制一个三角形的简单程序，在例子中，我们创建了两个着色器对象（顶点着色器和片段着色器）和一个程序对象，以渲染三角形。</p>\n</blockquote>\n<h1 id=\"着色器和程序\">着色器和程序</h1>\n<p>着色器对象是包含单个着色器对象，源代码提供给着色器对象，然后着色器被编译为一个目标形式。编译后，着色器对象可以连接到一个程序对象。程序对象可以连接多个着色器对象。在OpenGL ES中，每个程序对象都必须连接一个顶点着色器和一个片段着色器。程序对象最终被链接为用于渲染的最后”可执行程序“。<br>\n获得链接后的着色器对象的一般过程包括6个步骤：</p>\n<ol>\n<li>创建一个顶点着色器对象和一个片段着色器对象；</li>\n<li>将源代码连接到每个着色器对象；</li>\n<li>编译着色器对象；</li>\n<li>创建一个程序对象；</li>\n<li>将编译后的着色器对象连接到程序对象；</li>\n<li>链接程序对象。</li>\n</ol>\n<h2 id=\"创建和编译一个着色器\">创建和编译一个着色器</h2>\n<p>着色器的创建与删除：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 创建着色器</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param type#&gt; 类型可以是顶点着色器 GL_VERTEX_SHADER 或者是片段着色器 GL_FRAGMENT_SHADER description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return 着色器对象</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glCreateShader(GLenum type);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 删除着色器</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param shader#&gt; 着色器对象 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glDeleteShader(GLuint shader)</span><br></pre></td></tr></table></figure>\n<p>注意，如果一个着色器连接到程序对象，那么调用删除方法并不会立刻删除着色器，而是将着色器标记，在着色器不再连接到任何程序对象时，它的内存对象被释放。</p>\n<p>创建着色器对象后，下一步是提供着色器源代码：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 提供着色器源代码</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param shader#&gt; 着色器对象 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param count#&gt; 着色器源字符串的数量 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param string#&gt; 指向保存数量为count的着色器源字符串的数组指针 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param length#&gt; 指向字符串长度 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glShaderSource(GLuint shader, GLsizei count, <span class=\"keyword\">const</span> GLchar *<span class=\"keyword\">const</span> *string, <span class=\"keyword\">const</span> GLint *length)</span><br></pre></td></tr></table></figure>\n<p>指定着色器代码之后，下一步是编译着色器：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 着色器编译</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param shader#&gt; 着色器对象 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glCompileShader(GLuint shader)</span><br></pre></td></tr></table></figure>\n<p>编译之后可以通过<code>glGetShderiv</code>查询有关着色器对象的信息：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 获取编译器相关信息</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param shader#&gt; 着色器对象 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param pname#&gt; 查询参数，可以是：GL_COMPILE_STATUS，GL_DELETE_STATUS，GL_INFO_LOG_LENGTH，GL_SHADER_SOURCE_LENGTH，GL_SHADER_TYPE description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param params#&gt; 查询结果存储位置的指针 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glGetShaderiv(GLuint shader, GLenum pname, GLint *params)</span><br></pre></td></tr></table></figure>\n<p>通过<code>glGetShaderiv</code>传入<code>GL_INFO_LOG_LENGTH</code>参数获取日志缓冲区大小，然后用<code>glGetShaderInfoLog</code>检索信息日志：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 检索信息日志</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param shader#&gt; 着色器对象 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param bufsize#&gt; 保存信息日志的缓冲大小 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param length#&gt; 写入信息日志的长度，可以为NULL description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param infolog#&gt; 指向保存信息日志的字符缓冲区指针 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glGetShaderInfoLog(GLuint shader, GLsizei bufsize, GLsizei *length, GLchar *infolog)</span><br></pre></td></tr></table></figure>\n<p>通过上述步骤就可以加载一个着色器。</p>\n<h2 id=\"创建和链接程序\">创建和链接程序</h2>\n<p>下一步就是创建一个程序对象。程序对象是一个容器对象，可以将着色器与之连接，并链接一个最终可执行程序。<br>\n创建一个程序对象：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 创建程序对象</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param void void</span></span><br><span class=\"line\"><span class=\"comment\"> @return 程序对象</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glCreateProgram()</span><br></pre></td></tr></table></figure>\n<p>删除一个程序对象：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 删除一个程序对象</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param program#&gt; 程序对象 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glDeleteProgram(GLuint program)</span><br></pre></td></tr></table></figure>\n<p>创建程序对象之后，下一步就是将着色器与之连接：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 连接着色器和程序</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param program#&gt; 程序对象 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param shader#&gt; 着色器对象 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glAttachShader(GLuint program, GLuint shader)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>着色器可以在任何时候连接–连接到程序之前不一定需要编译，甚至可以没有源代码。唯一的要求是，每个程序对象必须有且仅有一个顶点着色器和片段着色器与之连接。</p>\n</blockquote>\n<p>断开程序和着色器：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 断开程序和着色器</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param program#&gt; 程序对象 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param shader#&gt; 着色器对象 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glDetachShader(GLuint program, GLuint shader)</span><br></pre></td></tr></table></figure>\n<p>最后链接程序对象：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 链接程序</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param program#&gt; 程序对象 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glLinkProgram(GLuint program)</span><br></pre></td></tr></table></figure>\n<p>这个链接操作负责生产最终的可执行程序。链接程序将确保顶点着色器写入片段着色器使用的所有顶点着色器输出变量（并用相同类型声明），链接程序还将确保任何在顶点和片段着色器中声明的统一变量和统一变量缓冲区的类型相符，此外，链接程序将确保最终的程序符合棘突实现的限制（例如，属性、统一变量或者输入输出着色器变量的数量）。一般来说，链接阶段是生成在硬件上运行的最终硬件指令的时候。</p>\n<p>链接程序之后，检查链接状态：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 检查链接程序状态</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param program#&gt; 程序对象 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param pname#&gt; 获取信息的参数，可以是：GL_ACTIVE_(ATTRIBUTES, ATTRIBUTE_MAX_LENGTH, UNIFORM_BLOCK, UNIFORM_BLOCK_MAX_LENGTH, UNIFORMS, UNFORM_MAX_LENGTH), GL_ATTACHED_SHADERS, GL_DELETE_STATUS, GL_INFO_LOG_LENGTH, GL_LINK_STATUS, GL_PROGRAM_BINARY_RETRIEVABLE_HINT, GL_TRANSFORM_FEEDBACK_(BUFFER_MODE, VARYINGS, VARYING_MAX_LENGTH), GL_VALIDATE_STATUS description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param params#&gt; 指向查询结果整数存储位置的指针 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glGetProgramiv(GLuint program, GLenum pname, GLint *params)</span><br></pre></td></tr></table></figure>\n<p>同样可以通过<code>glGetProgramiv</code>函数传入<code>GL_INFO_LOG_LENGTH</code>参数获取信息日志缓冲区大小，查询链接程序日志：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 检索链接程序日志</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param program#&gt; 程序对象 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param bufsize#&gt; 存储信息日志的缓冲区大小 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param length#&gt; 写入信息日志长度，可以为NULL description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param infolog#&gt; 指向存储信息日志的字符缓冲区指针 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glGetProgramInfoLog(GLuint program, GLsizei bufsize, GLsizei *length, GLchar *infolog)</span><br></pre></td></tr></table></figure>\n<p>一旦成功链接程序，我们就几乎为使用它渲染做好了准备，但是，我们还需要检查程序是否有效。也就是说，成功链接不能保证执行的某些方面，如应用程序可能没有把有效的纹理绑定到采样器，这时候我们需要再次验证程序当前状态：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 检查程序能以当前状态执行</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param program#&gt; 程序对象 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glValidateProgram(GLuint program)</span><br></pre></td></tr></table></figure>\n<p>调用<code>glValidProgram</code>函数后，通过之前的<code>glGetProgramiv</code>传入<code>GL_VALIDATE_STATUS</code>参数检查，信息日志也将更新。</p>\n<p>在完成创建程序对象，连接着色器，链接以及获取信息日志确认无误，在渲染之前，我们还要对程序对象做一件事，就是将其设置为活动程序：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 设置为活动程序</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param program#&gt; 程序对象 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glUseProgram(GLuint program)</span><br></pre></td></tr></table></figure>\n<h1 id=\"统一变量和属性\">统一变量和属性</h1>\n<p>一旦链接了程序对象，就可以在对象上进行许多查询。首先，我们可能需要找出程序中的活动统一变量（uniform）。</p>\n<p>统一变量被组合成两类统一变量块。第一类是命名统一变量块，统一变量的值由所谓的统一变量缓冲区对象支持：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">uniform TransformBlock &#123;</span><br><span class=\"line\">    mat4 matViewProj;</span><br><span class=\"line\">    mat3 matNormal;</span><br><span class=\"line\">    mat3 matTexGen</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>第二类是默认的统一变量块，用于在命名统一变量块之外的声明的统一变量：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">uniform mat4 matViewProj;</span><br><span class=\"line\">uniform mat3 matNormal;</span><br><span class=\"line\">uniform mat3 matTexGen;</span><br></pre></td></tr></table></figure>\n<p>如果统一变量在顶点着色器和片段着色器均有声明，则声明的类型必须相同，且在两个着色器中的值也需相同。在链接阶段，链接程序将为程序中与默认统一变量块相关的活动统一变量指定位置。这些位置是应用程序用于加载统一变量的标识符。链接程序还将为与命名统一变量块相关的活动统一变量分配偏移和跨距（对于数组和矩阵类型的统一变量）。</p>\n<h2 id=\"获取和设置统一变量\">获取和设置统一变量</h2>\n<p>要查询程序中活动统一变量的列表，首先通过<code>glGetProgramiv</code>函数传入<code>GL_ACTIVE_UNIFORMS</code>获取程序中活动统一变量的数量，传入<code>GL_ACTIVE_UNIFORM_MAX_LENGTH</code>参数获取统一变量最长字符数量，知道这两个参数之后可以使用<code>glGetActiveUniform</code>和<code>glGetActiveUniformsiv</code>找出每个统一变量的细节：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GLint uniformsCount;</span><br><span class=\"line\">GLint maxUniformLength;</span><br><span class=\"line\">glGetProgramiv(program, GL_ACTIVE_UNIFORMS, &amp;uniformsCount);</span><br><span class=\"line\">glGetProgramiv(program, GL_ACTIVE_UNIFORM_MAX_LENGTH, &amp;maxUniformLength);</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; uniformsCount; i++) &#123;</span><br><span class=\"line\">    GLsizei length;</span><br><span class=\"line\">    GLint size;</span><br><span class=\"line\">    GLenum type;</span><br><span class=\"line\">    GLchar *name = malloc(<span class=\"keyword\">sizeof</span>(GLchar) * maxUniformLength);</span><br><span class=\"line\">    glGetActiveUniform(program, i, maxUniformLength, &amp;length, &amp;size, &amp;type, name);</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"length: %d, size: %d, type: %u, name: %s\"</span>, length, size, type, name);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用<code>glGetActiveUniform</code>，可以确定几乎所有统一变量的属性。通过统一变量的名称，我们就可以找到它的位置：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 获取统一变量在程序中的位置</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param program#&gt; 程序对象 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param name#&gt; 统一变量名称 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return 位置</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glGetUniformLocation(GLuint program, <span class=\"keyword\">const</span> GLchar *name)</span><br></pre></td></tr></table></figure>\n<p>获取到位置下标后，我们就可以加载统一变量的值，各个类型都有对应不同的函数，举几个例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void glUniformlf(GLint location, GLfloat x);</span><br><span class=\"line\">void glUniformfv(GLint location, GLsizei count, const GLfloat* value);</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>glUniform*</code>调用不以程序对象句柄作为参数，原因是，<code>glUniform*</code>总是在于<code>glUseProgram</code>绑定的当前程序上操作。统一变量值本身保存在程序对象中。也就是说，一旦在程序对象中设置一个统一变量的值，即使我们让另一个程序处于活动状态，该值仍然保留在原来的程序对象中。从这个意义上，我们可以说统一变量值是程序对象局部所有。</p>\n</blockquote>\n<h2 id=\"统一变量缓冲区对象\">统一变量缓冲区对象</h2>\n<p>可以使用缓冲区对象存储变量数据，从而在程序中的着色器之间甚至程序之间共享统一变量，这种缓冲区被称为统一变量缓冲区对象 UBO（Uniform Buffer Object）。使用统一变量缓冲区对象可以在更新大的统一变量块时降低API开销，此外，这种方法增加了统一变量的可用存储。<br>\n要更新统一变量缓冲区对象的统一变量数据，我们可以使用<code>glBufferData</code>、<code>glBufferSubData</code>、<code>glMapBufferRange</code>、<code>glUnmapBuffer</code>等命令修改缓冲区对象的内容，而不是使用<code>glUniform*</code>命令。</p>\n<p>UBO必须配合Uniform Block（命名统一变量块）一起使用，在显存中创建缓存对象（Buffer），在buffer中存储统一变量数据，将buffer与指定的point（不得大于<code>GL_MAX_UNIFORM_BUFFER_BINDINGS</code>，通过<code>glGet</code>函数查询）绑定，将统一变量缓冲区的索引和point绑定，这样通过point将变量和缓存链接。</p>\n<p><img src=\"/img/article/20190706/1.png\" alt=\"UBO原理图\"></p>\n<p>首先检索统一变量块索引：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 检索统一变量块索引</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param program#&gt; 程序对象 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param uniformBlockName#&gt; 统一变量块名称 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return 索引</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glGetUniformBlockIndex(GLuint program, <span class=\"keyword\">const</span> GLchar *uniformBlockName)</span><br></pre></td></tr></table></figure>\n<p>可以通过<code>glGetActiveUniformBlockName</code>获取统一变量块名：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 获取统一变量块名</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param program#&gt; 程序对象 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param uniformBlockIndex#&gt; 统一变量块索引 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param bufSize#&gt; 名称数组中的字符数 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param length#&gt; 可为NULL，否则可以写入字符数 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param uniformBlockName#&gt; 写入统一变量块名称 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return 块名</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glGetActiveUniformBlockName(GLuint program, GLuint uniformBlockIndex, GLsizei bufSize, GLsizei *length, GLchar *uniformBlockName)</span><br></pre></td></tr></table></figure>\n<p>通过<code>glGetActiveUniformBlockiv</code>获取统一变量块的许多属性：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 获取统一变量块的属性</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param program#&gt; 程序对象 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param uniformBlockIndex#&gt; 需要查询的统一变量块索引 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param pname#&gt; 查询属性，可以是：GL_UNIFORM_BLOCK_(BINDING, DATA_SIZE, NAME_LENGTH, ACTIVE_UNIFORMS, ACTIVE_UNIFORM_INDICES, REFERENCED_BY_VERTEX_SHADER, REFERENCED_BY_FRAGMENT_SHADER) description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param params#&gt; 写入pname指定的结果 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glGetActiveUniformBlockiv(GLuint program, GLuint uniformBlockIndex, GLenum pname, GLint *params)</span><br></pre></td></tr></table></figure>\n<p>一旦有了统一变量块索引，就可以将该索引与程序中的统一变量块绑定点关联：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 将统一变量块索引与程序中的统一变量块绑定点关联</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param program#&gt; 程序对象 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param uniformBlockIndex#&gt; 统一变量块索引 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param uniformBlockBinding#&gt; 统一变量缓冲区对象绑定点 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glUniformBlockBinding(GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding)</span><br></pre></td></tr></table></figure>\n<p>最后可以将统一变量缓冲区对象绑定到<code>GL_UNIFORM_BUFFER</code>目标和程序中的统一变量块绑定点：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 将统一变量缓冲区对象绑定到目标和程序中的统一变量块绑定点</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param target#&gt; 必须是GL_UNIFORM_BUFFER或GL_TRANSFORM_FEEDBACK_BUFFER description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param index#&gt; 绑定索引 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param buffer#&gt; 缓冲区对象句柄 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glBindBufferBase(GLenum target, GLuint index, GLuint buffer)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 将统一变量缓冲区对象绑定到目标和程序中的统一变量块绑定点</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param target#&gt; 必须是GL_UNIFORM_BUFFER或GL_TRANSFORM_FEEDBACK_BUFFER description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param index#&gt; 绑定索引 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param buffer#&gt; b缓冲区对象句柄 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param offset#&gt; 以字节数计算的缓冲区对象其实偏移 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param size#&gt; 可以从缓冲区对象读取或者写入缓冲对象的数据量 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glBindBufferRange(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size)</span><br></pre></td></tr></table></figure>\n<p>下面举个例子：<br>\n对于着色器代码，除非我们使用std140统一变量块布局（默认），否则需要查询程序对象得到字节偏移和跨距，以在统一变量缓冲区对象中设置统一变量数据。std140布局保证使用由OpengGL ES 3.0规范定义的明确布局规范进行特定包装。因此，使用std140，我们就可以在不同的OpengGL ES 3.0实现之间共享统一变量块。<br>\n其他限定符：</p>\n<table>\n<thead>\n<tr>\n<th>限定符</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>shared</td>\n<td>限定符指定多个着色器或者多个程序中统一变量块的内存布局相同。要使用这个限定符，不同定义中的row_major/column_major值必须相等。覆盖std140和packed（默认）</td>\n</tr>\n<tr>\n<td>packed</td>\n<td>指定编译器可以优化统一变量块的内存布局。使用这个限定符时必须查询偏移位置，而且统一变量块无法在顶点/片段着色器或者程序间共享。覆盖std140和shared</td>\n</tr>\n<tr>\n<td>std140</td>\n<td>指定统一变量块的布局基于OpenGL ES 3.0规范的“标准统一变量块布局”一节中定义的一组标准规则。覆盖shared和packed</td>\n</tr>\n<tr>\n<td>row_major</td>\n<td>矩阵在内存中以行优先顺序布局</td>\n</tr>\n<tr>\n<td>column_major</td>\n<td>矩阵在内存中以列优先顺序布局（默认）</td>\n</tr>\n</tbody>\n</table>\n<p>着色器代码：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">layout (std140) uniform LightBlock &#123;</span><br><span class=\"line\">    vec3 lightDirection;</span><br><span class=\"line\">    vec4 lightPosition;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>设置UBO代码：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GLuint blockId, bufferId;</span><br><span class=\"line\">GLint blockSize;</span><br><span class=\"line\">GLuint bindingPoint = <span class=\"number\">1</span>;</span><br><span class=\"line\">GLfloat lightData[] = &#123;</span><br><span class=\"line\">    <span class=\"number\">1.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">0.0</span>f,</span><br><span class=\"line\">    <span class=\"number\">0.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">blockId = glGetUniformBlockIndex(program, <span class=\"string\">\"LightBlock\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">glUniformBlockBinding(program, blockId, bindingPoint);</span><br><span class=\"line\"></span><br><span class=\"line\">glGetActiveUniformBlockiv(program, blockId, GL_UNIFORM_BLOCK_DATA_SIZE, &amp;blockSize);</span><br><span class=\"line\"></span><br><span class=\"line\">glGenBuffers(<span class=\"number\">1</span>, &amp;bufferId);</span><br><span class=\"line\">glBindBuffer(GL_UNIFORM_BUFFER, bufferId);</span><br><span class=\"line\">glBufferData(GL_UNIFORM_BUFFER, blockSize, lightData, GL_DYNAMIC_DRAW);</span><br><span class=\"line\"></span><br><span class=\"line\">glBindBufferBase(GL_UNIFORM_BUFFER, bindingPoint, bufferId);</span><br></pre></td></tr></table></figure>\n<p>修改UBO代码：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GLfloat updateData[] = &#123;</span><br><span class=\"line\">    <span class=\"number\">1.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">0.0</span>f</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">glBindBuffer(GL_UNIFORM_BUFFER, bufferId);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> GLchar *names[] = &#123;<span class=\"string\">\"lightDirection\"</span>&#125;;</span><br><span class=\"line\">GLuint indices;</span><br><span class=\"line\">GLint offset;</span><br><span class=\"line\">GLint size;</span><br><span class=\"line\">glGetUniformIndices(program, <span class=\"number\">1</span>, names, &amp;indices);</span><br><span class=\"line\">glGetActiveUniformsiv(program, <span class=\"number\">1</span>, &amp;indices, GL_UNIFORM_OFFSET, &amp;offset);</span><br><span class=\"line\">glGetActiveUniformsiv(program, <span class=\"number\">1</span>, &amp;indices, GL_UNIFORM_SIZE, &amp;size);</span><br><span class=\"line\">glBufferSubData(GL_UNIFORM_BUFFER, offset, size, updateData);</span><br></pre></td></tr></table></figure>\n<h1 id=\"程序二进制码\">程序二进制码</h1>\n<p>程序二进制码是完全编译和链接的程序的二进制表现形式。它们很有用，因为可以保存到文件系统供以后使用，从而避免在线编译的代价。我们也可以是使用程序二进制码，这样就没有必要在实现中分发着色器源代码。<br>\n我们可以在成功编译和链接程序之后，检索程序二进制码：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 检索程序二进制码</span></span><br><span class=\"line\"><span class=\"comment\"> </span></span><br><span class=\"line\"><span class=\"comment\"> @param program#&gt; 程序对象 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param bufSize#&gt; 可以写入binary的最大字节数 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param length#&gt; 二进制数据字节数 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param binaryFormat#&gt; 供应商专用二进制格式标识 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param binary#&gt; 着色器编译器生成的二进制数据指针 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glGetProgramBinary(GLuint program, GLsizei bufSize, GLsizei *length, GLenum *binaryFormat, GLvoid *binary)</span><br></pre></td></tr></table></figure>\n<p>检索之后，可以将其保存到文件系统，或者将程序二进制码读回OpenGL ES实现：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 将二进制码读回OpenGL ES实现</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param program#&gt; 程序对象 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param binaryFormat#&gt; 供应商专用二进制格式标识 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param binary#&gt; 着色器编译器生成的二进制数据指针 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param length#&gt; 二进制数据的字节数 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glProgramBinary(GLuint program, GLenum binaryFormat, <span class=\"keyword\">const</span> GLvoid *binary, GLsizei length)</span><br></pre></td></tr></table></figure>\n<p>为了确保存储的程序二进制码仍然兼容，在调用<code>glProgramBinary</code>之后，可以通过<code>glProgramiv</code>查询<code>GL_LINK_STATUS</code>。如果二进制码不兼容，我们需要重新编译着色器源码。</p>\n<h1 id=\"总结\">总结</h1>\n<p>这篇文章主要介绍了创建、编译和链接着色器到程序的方法，着色器对象和程序对象组成了OpenGL ES 3.0中的基本对象。同时介绍了查询着色器和程序信息以及加载统一变量的方法等。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>上一篇文章介绍了绘制一个三角形的简单程序，在例子中，我们创建了两个着色器对象（顶点着色器和片段着色器）和一个程序对象，以渲染三角形。</p>\n</blockquote>\n<h1>着色器和程序</h1>\n<p>着色器对象是包含单个着色器对象，源代码提供给着色器对象，然后着色器被编译为一个目标形式。编译后，着色器对象可以连接到一个程序对象。程序对象可以连接多个着色器对象。在OpenGL ES中，每个程序对象都必须连接一个顶点着色器和一个片段着色器。程序对象最终被链接为用于渲染的最后”可执行程序“。<br>\n获得链接后的着色器对象的一般过程包括6个步骤：</p>\n<ol>\n<li>创建一个顶点着色器对象和一个片段着色器对象；</li>\n<li>将源代码连接到每个着色器对象；</li>\n<li>编译着色器对象；</li>\n<li>创建一个程序对象；</li>\n<li>将编译后的着色器对象连接到程序对象；</li>\n<li>链接程序对象。</li>\n</ol>\n<h2>创建和编译一个着色器</h2>\n<p>着色器的创建与删除：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 创建着色器</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param type#&gt; 类型可以是顶点着色器 GL_VERTEX_SHADER 或者是片段着色器 GL_FRAGMENT_SHADER description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return 着色器对象</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glCreateShader(GLenum type);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 删除着色器</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param shader#&gt; 着色器对象 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glDeleteShader(GLuint shader)</span><br></pre></td></tr></table></figure>\n<p>注意，如果一个着色器连接到程序对象，那么调用删除方法并不会立刻删除着色器，而是将着色器标记，在着色器不再连接到任何程序对象时，它的内存对象被释放。</p>\n<p>创建着色器对象后，下一步是提供着色器源代码：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 提供着色器源代码</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param shader#&gt; 着色器对象 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param count#&gt; 着色器源字符串的数量 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param string#&gt; 指向保存数量为count的着色器源字符串的数组指针 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param length#&gt; 指向字符串长度 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glShaderSource(GLuint shader, GLsizei count, <span class=\"keyword\">const</span> GLchar *<span class=\"keyword\">const</span> *string, <span class=\"keyword\">const</span> GLint *length)</span><br></pre></td></tr></table></figure>\n<p>指定着色器代码之后，下一步是编译着色器：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 着色器编译</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param shader#&gt; 着色器对象 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glCompileShader(GLuint shader)</span><br></pre></td></tr></table></figure>\n<p>编译之后可以通过<code>glGetShderiv</code>查询有关着色器对象的信息：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 获取编译器相关信息</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param shader#&gt; 着色器对象 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param pname#&gt; 查询参数，可以是：GL_COMPILE_STATUS，GL_DELETE_STATUS，GL_INFO_LOG_LENGTH，GL_SHADER_SOURCE_LENGTH，GL_SHADER_TYPE description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param params#&gt; 查询结果存储位置的指针 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glGetShaderiv(GLuint shader, GLenum pname, GLint *params)</span><br></pre></td></tr></table></figure>\n<p>通过<code>glGetShaderiv</code>传入<code>GL_INFO_LOG_LENGTH</code>参数获取日志缓冲区大小，然后用<code>glGetShaderInfoLog</code>检索信息日志：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 检索信息日志</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param shader#&gt; 着色器对象 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param bufsize#&gt; 保存信息日志的缓冲大小 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param length#&gt; 写入信息日志的长度，可以为NULL description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param infolog#&gt; 指向保存信息日志的字符缓冲区指针 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glGetShaderInfoLog(GLuint shader, GLsizei bufsize, GLsizei *length, GLchar *infolog)</span><br></pre></td></tr></table></figure>\n<p>通过上述步骤就可以加载一个着色器。</p>\n<h2>创建和链接程序</h2>\n<p>下一步就是创建一个程序对象。程序对象是一个容器对象，可以将着色器与之连接，并链接一个最终可执行程序。<br>\n创建一个程序对象：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 创建程序对象</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param void void</span></span><br><span class=\"line\"><span class=\"comment\"> @return 程序对象</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glCreateProgram()</span><br></pre></td></tr></table></figure>\n<p>删除一个程序对象：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 删除一个程序对象</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param program#&gt; 程序对象 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glDeleteProgram(GLuint program)</span><br></pre></td></tr></table></figure>\n<p>创建程序对象之后，下一步就是将着色器与之连接：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 连接着色器和程序</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param program#&gt; 程序对象 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param shader#&gt; 着色器对象 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glAttachShader(GLuint program, GLuint shader)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>着色器可以在任何时候连接–连接到程序之前不一定需要编译，甚至可以没有源代码。唯一的要求是，每个程序对象必须有且仅有一个顶点着色器和片段着色器与之连接。</p>\n</blockquote>\n<p>断开程序和着色器：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 断开程序和着色器</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param program#&gt; 程序对象 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param shader#&gt; 着色器对象 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glDetachShader(GLuint program, GLuint shader)</span><br></pre></td></tr></table></figure>\n<p>最后链接程序对象：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 链接程序</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param program#&gt; 程序对象 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glLinkProgram(GLuint program)</span><br></pre></td></tr></table></figure>\n<p>这个链接操作负责生产最终的可执行程序。链接程序将确保顶点着色器写入片段着色器使用的所有顶点着色器输出变量（并用相同类型声明），链接程序还将确保任何在顶点和片段着色器中声明的统一变量和统一变量缓冲区的类型相符，此外，链接程序将确保最终的程序符合棘突实现的限制（例如，属性、统一变量或者输入输出着色器变量的数量）。一般来说，链接阶段是生成在硬件上运行的最终硬件指令的时候。</p>\n<p>链接程序之后，检查链接状态：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 检查链接程序状态</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param program#&gt; 程序对象 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param pname#&gt; 获取信息的参数，可以是：GL_ACTIVE_(ATTRIBUTES, ATTRIBUTE_MAX_LENGTH, UNIFORM_BLOCK, UNIFORM_BLOCK_MAX_LENGTH, UNIFORMS, UNFORM_MAX_LENGTH), GL_ATTACHED_SHADERS, GL_DELETE_STATUS, GL_INFO_LOG_LENGTH, GL_LINK_STATUS, GL_PROGRAM_BINARY_RETRIEVABLE_HINT, GL_TRANSFORM_FEEDBACK_(BUFFER_MODE, VARYINGS, VARYING_MAX_LENGTH), GL_VALIDATE_STATUS description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param params#&gt; 指向查询结果整数存储位置的指针 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glGetProgramiv(GLuint program, GLenum pname, GLint *params)</span><br></pre></td></tr></table></figure>\n<p>同样可以通过<code>glGetProgramiv</code>函数传入<code>GL_INFO_LOG_LENGTH</code>参数获取信息日志缓冲区大小，查询链接程序日志：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 检索链接程序日志</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param program#&gt; 程序对象 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param bufsize#&gt; 存储信息日志的缓冲区大小 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param length#&gt; 写入信息日志长度，可以为NULL description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param infolog#&gt; 指向存储信息日志的字符缓冲区指针 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glGetProgramInfoLog(GLuint program, GLsizei bufsize, GLsizei *length, GLchar *infolog)</span><br></pre></td></tr></table></figure>\n<p>一旦成功链接程序，我们就几乎为使用它渲染做好了准备，但是，我们还需要检查程序是否有效。也就是说，成功链接不能保证执行的某些方面，如应用程序可能没有把有效的纹理绑定到采样器，这时候我们需要再次验证程序当前状态：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 检查程序能以当前状态执行</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param program#&gt; 程序对象 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glValidateProgram(GLuint program)</span><br></pre></td></tr></table></figure>\n<p>调用<code>glValidProgram</code>函数后，通过之前的<code>glGetProgramiv</code>传入<code>GL_VALIDATE_STATUS</code>参数检查，信息日志也将更新。</p>\n<p>在完成创建程序对象，连接着色器，链接以及获取信息日志确认无误，在渲染之前，我们还要对程序对象做一件事，就是将其设置为活动程序：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 设置为活动程序</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param program#&gt; 程序对象 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glUseProgram(GLuint program)</span><br></pre></td></tr></table></figure>\n<h1>统一变量和属性</h1>\n<p>一旦链接了程序对象，就可以在对象上进行许多查询。首先，我们可能需要找出程序中的活动统一变量（uniform）。</p>\n<p>统一变量被组合成两类统一变量块。第一类是命名统一变量块，统一变量的值由所谓的统一变量缓冲区对象支持：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">uniform TransformBlock &#123;</span><br><span class=\"line\">    mat4 matViewProj;</span><br><span class=\"line\">    mat3 matNormal;</span><br><span class=\"line\">    mat3 matTexGen</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>第二类是默认的统一变量块，用于在命名统一变量块之外的声明的统一变量：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">uniform mat4 matViewProj;</span><br><span class=\"line\">uniform mat3 matNormal;</span><br><span class=\"line\">uniform mat3 matTexGen;</span><br></pre></td></tr></table></figure>\n<p>如果统一变量在顶点着色器和片段着色器均有声明，则声明的类型必须相同，且在两个着色器中的值也需相同。在链接阶段，链接程序将为程序中与默认统一变量块相关的活动统一变量指定位置。这些位置是应用程序用于加载统一变量的标识符。链接程序还将为与命名统一变量块相关的活动统一变量分配偏移和跨距（对于数组和矩阵类型的统一变量）。</p>\n<h2>获取和设置统一变量</h2>\n<p>要查询程序中活动统一变量的列表，首先通过<code>glGetProgramiv</code>函数传入<code>GL_ACTIVE_UNIFORMS</code>获取程序中活动统一变量的数量，传入<code>GL_ACTIVE_UNIFORM_MAX_LENGTH</code>参数获取统一变量最长字符数量，知道这两个参数之后可以使用<code>glGetActiveUniform</code>和<code>glGetActiveUniformsiv</code>找出每个统一变量的细节：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GLint uniformsCount;</span><br><span class=\"line\">GLint maxUniformLength;</span><br><span class=\"line\">glGetProgramiv(program, GL_ACTIVE_UNIFORMS, &amp;uniformsCount);</span><br><span class=\"line\">glGetProgramiv(program, GL_ACTIVE_UNIFORM_MAX_LENGTH, &amp;maxUniformLength);</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; uniformsCount; i++) &#123;</span><br><span class=\"line\">    GLsizei length;</span><br><span class=\"line\">    GLint size;</span><br><span class=\"line\">    GLenum type;</span><br><span class=\"line\">    GLchar *name = malloc(<span class=\"keyword\">sizeof</span>(GLchar) * maxUniformLength);</span><br><span class=\"line\">    glGetActiveUniform(program, i, maxUniformLength, &amp;length, &amp;size, &amp;type, name);</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"length: %d, size: %d, type: %u, name: %s\"</span>, length, size, type, name);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用<code>glGetActiveUniform</code>，可以确定几乎所有统一变量的属性。通过统一变量的名称，我们就可以找到它的位置：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 获取统一变量在程序中的位置</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param program#&gt; 程序对象 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param name#&gt; 统一变量名称 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return 位置</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glGetUniformLocation(GLuint program, <span class=\"keyword\">const</span> GLchar *name)</span><br></pre></td></tr></table></figure>\n<p>获取到位置下标后，我们就可以加载统一变量的值，各个类型都有对应不同的函数，举几个例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void glUniformlf(GLint location, GLfloat x);</span><br><span class=\"line\">void glUniformfv(GLint location, GLsizei count, const GLfloat* value);</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>glUniform*</code>调用不以程序对象句柄作为参数，原因是，<code>glUniform*</code>总是在于<code>glUseProgram</code>绑定的当前程序上操作。统一变量值本身保存在程序对象中。也就是说，一旦在程序对象中设置一个统一变量的值，即使我们让另一个程序处于活动状态，该值仍然保留在原来的程序对象中。从这个意义上，我们可以说统一变量值是程序对象局部所有。</p>\n</blockquote>\n<h2>统一变量缓冲区对象</h2>\n<p>可以使用缓冲区对象存储变量数据，从而在程序中的着色器之间甚至程序之间共享统一变量，这种缓冲区被称为统一变量缓冲区对象 UBO（Uniform Buffer Object）。使用统一变量缓冲区对象可以在更新大的统一变量块时降低API开销，此外，这种方法增加了统一变量的可用存储。<br>\n要更新统一变量缓冲区对象的统一变量数据，我们可以使用<code>glBufferData</code>、<code>glBufferSubData</code>、<code>glMapBufferRange</code>、<code>glUnmapBuffer</code>等命令修改缓冲区对象的内容，而不是使用<code>glUniform*</code>命令。</p>\n<p>UBO必须配合Uniform Block（命名统一变量块）一起使用，在显存中创建缓存对象（Buffer），在buffer中存储统一变量数据，将buffer与指定的point（不得大于<code>GL_MAX_UNIFORM_BUFFER_BINDINGS</code>，通过<code>glGet</code>函数查询）绑定，将统一变量缓冲区的索引和point绑定，这样通过point将变量和缓存链接。</p>\n<p><img src=\"/img/article/20190706/1.png\" alt=\"UBO原理图\"></p>\n<p>首先检索统一变量块索引：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 检索统一变量块索引</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param program#&gt; 程序对象 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param uniformBlockName#&gt; 统一变量块名称 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return 索引</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glGetUniformBlockIndex(GLuint program, <span class=\"keyword\">const</span> GLchar *uniformBlockName)</span><br></pre></td></tr></table></figure>\n<p>可以通过<code>glGetActiveUniformBlockName</code>获取统一变量块名：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 获取统一变量块名</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param program#&gt; 程序对象 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param uniformBlockIndex#&gt; 统一变量块索引 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param bufSize#&gt; 名称数组中的字符数 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param length#&gt; 可为NULL，否则可以写入字符数 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param uniformBlockName#&gt; 写入统一变量块名称 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return 块名</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glGetActiveUniformBlockName(GLuint program, GLuint uniformBlockIndex, GLsizei bufSize, GLsizei *length, GLchar *uniformBlockName)</span><br></pre></td></tr></table></figure>\n<p>通过<code>glGetActiveUniformBlockiv</code>获取统一变量块的许多属性：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 获取统一变量块的属性</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param program#&gt; 程序对象 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param uniformBlockIndex#&gt; 需要查询的统一变量块索引 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param pname#&gt; 查询属性，可以是：GL_UNIFORM_BLOCK_(BINDING, DATA_SIZE, NAME_LENGTH, ACTIVE_UNIFORMS, ACTIVE_UNIFORM_INDICES, REFERENCED_BY_VERTEX_SHADER, REFERENCED_BY_FRAGMENT_SHADER) description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param params#&gt; 写入pname指定的结果 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glGetActiveUniformBlockiv(GLuint program, GLuint uniformBlockIndex, GLenum pname, GLint *params)</span><br></pre></td></tr></table></figure>\n<p>一旦有了统一变量块索引，就可以将该索引与程序中的统一变量块绑定点关联：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 将统一变量块索引与程序中的统一变量块绑定点关联</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param program#&gt; 程序对象 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param uniformBlockIndex#&gt; 统一变量块索引 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param uniformBlockBinding#&gt; 统一变量缓冲区对象绑定点 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glUniformBlockBinding(GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding)</span><br></pre></td></tr></table></figure>\n<p>最后可以将统一变量缓冲区对象绑定到<code>GL_UNIFORM_BUFFER</code>目标和程序中的统一变量块绑定点：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 将统一变量缓冲区对象绑定到目标和程序中的统一变量块绑定点</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param target#&gt; 必须是GL_UNIFORM_BUFFER或GL_TRANSFORM_FEEDBACK_BUFFER description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param index#&gt; 绑定索引 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param buffer#&gt; 缓冲区对象句柄 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glBindBufferBase(GLenum target, GLuint index, GLuint buffer)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 将统一变量缓冲区对象绑定到目标和程序中的统一变量块绑定点</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param target#&gt; 必须是GL_UNIFORM_BUFFER或GL_TRANSFORM_FEEDBACK_BUFFER description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param index#&gt; 绑定索引 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param buffer#&gt; b缓冲区对象句柄 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param offset#&gt; 以字节数计算的缓冲区对象其实偏移 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param size#&gt; 可以从缓冲区对象读取或者写入缓冲对象的数据量 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glBindBufferRange(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size)</span><br></pre></td></tr></table></figure>\n<p>下面举个例子：<br>\n对于着色器代码，除非我们使用std140统一变量块布局（默认），否则需要查询程序对象得到字节偏移和跨距，以在统一变量缓冲区对象中设置统一变量数据。std140布局保证使用由OpengGL ES 3.0规范定义的明确布局规范进行特定包装。因此，使用std140，我们就可以在不同的OpengGL ES 3.0实现之间共享统一变量块。<br>\n其他限定符：</p>\n<table>\n<thead>\n<tr>\n<th>限定符</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>shared</td>\n<td>限定符指定多个着色器或者多个程序中统一变量块的内存布局相同。要使用这个限定符，不同定义中的row_major/column_major值必须相等。覆盖std140和packed（默认）</td>\n</tr>\n<tr>\n<td>packed</td>\n<td>指定编译器可以优化统一变量块的内存布局。使用这个限定符时必须查询偏移位置，而且统一变量块无法在顶点/片段着色器或者程序间共享。覆盖std140和shared</td>\n</tr>\n<tr>\n<td>std140</td>\n<td>指定统一变量块的布局基于OpenGL ES 3.0规范的“标准统一变量块布局”一节中定义的一组标准规则。覆盖shared和packed</td>\n</tr>\n<tr>\n<td>row_major</td>\n<td>矩阵在内存中以行优先顺序布局</td>\n</tr>\n<tr>\n<td>column_major</td>\n<td>矩阵在内存中以列优先顺序布局（默认）</td>\n</tr>\n</tbody>\n</table>\n<p>着色器代码：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">layout (std140) uniform LightBlock &#123;</span><br><span class=\"line\">    vec3 lightDirection;</span><br><span class=\"line\">    vec4 lightPosition;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>设置UBO代码：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GLuint blockId, bufferId;</span><br><span class=\"line\">GLint blockSize;</span><br><span class=\"line\">GLuint bindingPoint = <span class=\"number\">1</span>;</span><br><span class=\"line\">GLfloat lightData[] = &#123;</span><br><span class=\"line\">    <span class=\"number\">1.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">0.0</span>f,</span><br><span class=\"line\">    <span class=\"number\">0.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">blockId = glGetUniformBlockIndex(program, <span class=\"string\">\"LightBlock\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">glUniformBlockBinding(program, blockId, bindingPoint);</span><br><span class=\"line\"></span><br><span class=\"line\">glGetActiveUniformBlockiv(program, blockId, GL_UNIFORM_BLOCK_DATA_SIZE, &amp;blockSize);</span><br><span class=\"line\"></span><br><span class=\"line\">glGenBuffers(<span class=\"number\">1</span>, &amp;bufferId);</span><br><span class=\"line\">glBindBuffer(GL_UNIFORM_BUFFER, bufferId);</span><br><span class=\"line\">glBufferData(GL_UNIFORM_BUFFER, blockSize, lightData, GL_DYNAMIC_DRAW);</span><br><span class=\"line\"></span><br><span class=\"line\">glBindBufferBase(GL_UNIFORM_BUFFER, bindingPoint, bufferId);</span><br></pre></td></tr></table></figure>\n<p>修改UBO代码：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GLfloat updateData[] = &#123;</span><br><span class=\"line\">    <span class=\"number\">1.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">0.0</span>f</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">glBindBuffer(GL_UNIFORM_BUFFER, bufferId);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> GLchar *names[] = &#123;<span class=\"string\">\"lightDirection\"</span>&#125;;</span><br><span class=\"line\">GLuint indices;</span><br><span class=\"line\">GLint offset;</span><br><span class=\"line\">GLint size;</span><br><span class=\"line\">glGetUniformIndices(program, <span class=\"number\">1</span>, names, &amp;indices);</span><br><span class=\"line\">glGetActiveUniformsiv(program, <span class=\"number\">1</span>, &amp;indices, GL_UNIFORM_OFFSET, &amp;offset);</span><br><span class=\"line\">glGetActiveUniformsiv(program, <span class=\"number\">1</span>, &amp;indices, GL_UNIFORM_SIZE, &amp;size);</span><br><span class=\"line\">glBufferSubData(GL_UNIFORM_BUFFER, offset, size, updateData);</span><br></pre></td></tr></table></figure>\n<h1>程序二进制码</h1>\n<p>程序二进制码是完全编译和链接的程序的二进制表现形式。它们很有用，因为可以保存到文件系统供以后使用，从而避免在线编译的代价。我们也可以是使用程序二进制码，这样就没有必要在实现中分发着色器源代码。<br>\n我们可以在成功编译和链接程序之后，检索程序二进制码：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 检索程序二进制码</span></span><br><span class=\"line\"><span class=\"comment\"> </span></span><br><span class=\"line\"><span class=\"comment\"> @param program#&gt; 程序对象 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param bufSize#&gt; 可以写入binary的最大字节数 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param length#&gt; 二进制数据字节数 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param binaryFormat#&gt; 供应商专用二进制格式标识 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param binary#&gt; 着色器编译器生成的二进制数据指针 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glGetProgramBinary(GLuint program, GLsizei bufSize, GLsizei *length, GLenum *binaryFormat, GLvoid *binary)</span><br></pre></td></tr></table></figure>\n<p>检索之后，可以将其保存到文件系统，或者将程序二进制码读回OpenGL ES实现：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 将二进制码读回OpenGL ES实现</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param program#&gt; 程序对象 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param binaryFormat#&gt; 供应商专用二进制格式标识 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param binary#&gt; 着色器编译器生成的二进制数据指针 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param length#&gt; 二进制数据的字节数 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glProgramBinary(GLuint program, GLenum binaryFormat, <span class=\"keyword\">const</span> GLvoid *binary, GLsizei length)</span><br></pre></td></tr></table></figure>\n<p>为了确保存储的程序二进制码仍然兼容，在调用<code>glProgramBinary</code>之后，可以通过<code>glProgramiv</code>查询<code>GL_LINK_STATUS</code>。如果二进制码不兼容，我们需要重新编译着色器源码。</p>\n<h1>总结</h1>\n<p>这篇文章主要介绍了创建、编译和链接着色器到程序的方法，着色器对象和程序对象组成了OpenGL ES 3.0中的基本对象。同时介绍了查询着色器和程序信息以及加载统一变量的方法等。</p>\n"},{"title":"OpenGL ES学习--帧缓冲区对象","catalog":true,"toc_nav_num":true,"date":"2019-08-19T12:03:12.000Z","subtitle":"About OpenGL ES","header-img":"/img/article_header/article_header.png","busuanzi":true,"_content":"\n> 在本篇中我们将描述帧缓冲区对象的概念、应用程序创建它们的方法以及应用程序使用它们渲染到屏幕外缓冲区或者纹理的方法。\n\n# 为什么使用帧缓冲区对象\n\n在应用程序调用任何OpenGL ES命令之前，需要首先创建一个渲染上下文和绘图表面，并使之成为现行上下文和表面。渲染上下文和绘图表面通常由原生窗口系统通过EGL等API提供。渲染上下文包含正确操作所需的对应状态。由原生窗口系统提供的绘图表面可以是一个在屏幕上显示的表面（称为窗口系统提供的帧缓冲区），也可以是屏幕外表面（称作pbuffer）。创建EGL绘图表面的调用让我们以像素数的形式指定表面的宽度和高度、表面是否使用颜色、深度和模板缓冲区以及这些缓冲区的位深。\n默认情况下，OpenGL ES使用窗口系统提供的帧缓冲区作为绘图表面。如果应用程序只在屏幕上的表面绘图，则窗口系统提供的帧缓冲区通常很高效。但是，许多应用程序需要渲染到纹理，为此，使用窗口系统提供的帧缓冲区作为绘图表面通常不是理想的选择。\n应用程序可以使用以下两种技术之一渲染到纹理：\n- 通过绘制到窗口系统提供的帧缓冲区，然后将帧缓冲区的对应区域复制到纹理来实现渲染到纹理。这可以用`glCopyTexImage2D`和`glCopyTexSubImage2D`API实现。顾名思义，这些API执行从帧缓冲区到纹理缓冲区的复制，这一复制操作往往对性能有不利影响。此外，这种方法只有在纹理的尺寸小于或者等于帧缓冲区尺寸的时候才有效。\n- 通过使用连接到纹理的pbuffer来实现渲染到纹理。我们知道，窗口系统提供的表面必须连接到一个渲染上下文。这在某些对每个pbuffer和窗口表面需要不同上下文的实现中可能效率低下。此外，在窗口系统提供的可绘制表面之间切换有时候需要OpenGL ES实现清除所有切换之前渲染的图像。这可能在渲染管线中造成代价很高的“起泡效应”（CPU闲置）。在这种系统上，我们建议避免使用pbuffer渲染到纹理，因为与上下文和窗口系统提供的可绘制表面之间的切换相关的开销很大。\n\n上述两种方法对于渲染到纹理或者其他屏幕外表面来说都不理想。作为替代，我们需要允许应用程序直接渲染到纹理的API，或者在OpenGL ES API中具备创建屏幕外表面的能力，并将它作为渲染目标。帧缓冲区对象和渲染缓冲区对象允许应用程序完成这些操作，不需要额外创建渲染上下文。结果是，我们在使用窗口系统提供的可绘制表面时，不再需要担心上下文和可绘制表面切换的开销。因此，帧缓冲区对象提供了渲染到纹理或者屏幕外表面的更好、更有效的方法。\n帧缓冲区对象API支持如下操作：\n- 仅适用OpenGL ES命令创建帧缓冲区对象\n- 在单一EGL上下文中创建和使用多个缓冲区对象--也就是说，不需要每个帧缓冲区都有一个渲染上下文\n- 创建屏幕外颜色、深度或者模板渲染缓冲区和纹理，并将它们连接到帧缓冲区对象\n- 在多个帧缓冲区之间共享颜色、深度或者模板缓冲区\n- 将纹理直接连接到帧缓冲区作为颜色或者深度，从而避免了进行复制操作的必要\n- 在帧缓冲区之间复制并使帧缓冲区内容失效\n\n# 帧缓冲区和渲染缓冲区对象\n\n渲染缓冲区对象是一个由应用程序分配的2D图像缓冲区。渲染缓冲区可以用于分配和存储颜色、深度或者模板值，可以用作帧缓冲区对象中的颜色、深度或者模板附着。渲染缓冲区类似于屏幕外的窗口系统的可绘制表面--如pbuffer。但是，渲染缓冲区不能直接用作GL纹理。\n帧缓冲区对象（FBO）是一组颜色、深度和模板纹理或者渲染目标。各种2D图像可以连接到帧缓冲区对象中的颜色附着点。这些附着点包括一个渲染缓冲区对象，它保存颜色值、2D纹理或者立方图面的mip级别、2D数组纹理的层次甚至3D纹理中一个2D切片的mip级别。同样，包含深度值的各种2D图像可以连接到FBO的深度附着点。这些附着点包括渲染缓冲区、2D纹理的mip级别或者保存深度值的一个立方图面。可以连接到FBO模板附着点的唯一2D图像是保存模板值的渲染缓冲区对象。\n下图展示了帧缓冲区对象、渲染缓冲区对象和纹理之间的关系。注意，一个帧缓冲区对象中只能有一个颜色、深度和模板附着。\n\n![帧缓冲区对象、渲染缓冲区对象和纹理](/img/article/20190819/1.png)\n\n## 选择渲染缓冲区与纹理作为帧缓冲区附着的对比\n\n对于渲染到纹理的用例，我们应该将一个纹理对象连接到帧缓冲区对象。这方面的例子包括渲染到一个用作颜色纹理的颜色缓冲区以及渲染到用作阴影的深度纹理的深度缓冲区。\n使用渲染缓冲区代替纹理有以下几种原因：\n- 渲染缓冲区支持多重采样。\n- 如果图像没有被当做纹理使用，则使用渲染缓冲区可能带来性能上的好处。出现这种好处是因为OpenGL ES实现可能以更为高效的格式存储渲染缓冲区，比起纹理来说更适合于渲染。但是，如果预先知道图像不被用作纹理，那么OpenGL ES实现所能做的也仅仅如此。\n\n## 帧缓冲区对象与EGL表面的对比\n\nFBO和窗口系统提供的可绘制表面之间的区别：\n- 像素归属测试确定帧缓冲区中(x<sub>w</sub>), y<sub>w</sub>)位置的像素目前是否归OpenGL ES所有，这个测试允许窗口系统控制帧缓冲区中的哪些像素属于OpenGL ES上下文--例如，当OpenGL ES渲染的窗口被遮蔽时。对于应用程序创建的帧缓冲区对象，像素归属测试始终成功，因为帧缓冲区对象拥有所有像素。\n- 窗口系统可能只支持双缓冲表面。相反，帧缓冲区对象只支持单缓冲区附着。\n- 使用帧缓冲区对象可以实现帧缓冲区之间模板和深度缓冲区的共享，而窗口系统提供的帧缓冲区通常不能实现这一功能。在窗口系统提供的可绘制表面中，模板和深度缓冲区及其对应的状态通常是隐含分配的，因此，无法在可绘制表面之间共享。对于应用程序创建的帧缓冲区对象，模板和深度缓冲区可以独立创建，然后在必要时通过将这些缓冲区连接到多个缓冲区对象中的对应连接点，实现与帧缓冲区对象的关联。\n\n# 创建帧缓冲区和渲染缓冲区对象\n\n创建帧缓冲区和渲染缓冲区对象类似于在OpenGL ES 3.0中创建纹理或者顶点缓冲区对象。\n`glGenRenderbuffers`API调用用于分配渲染缓冲区对象名称：\n\n``` objc\n/**\n 创建渲染缓冲区对象\n\n @param n#> 返回的渲染缓冲区对象名称的数量 description#>\n @param renderbuffers#> 返回一个有n个元素的数组的指针，分配的渲染缓冲区对象名称将在该数组中返回 description#>\n @return void\n */\nglGenRenderbuffers(GLsizei n, GLuint *renderbuffers);\n```\n\n`glGenRenderbuffers`分配n个渲染缓冲区对象名称，并在`renderbuffers`中返回。由`glGenRenderbuffers`返回的渲染缓冲区对象名称是不为0的无符号整数。这些名称被标记为`在用`但是没有任何关联的状态。数值0由OpenGL ES保留，不能用于指代一个渲染缓冲区对象。试图修改或者查询帧缓冲区对象0的缓冲区对象状态的应用程序将产生一个对应的错误。\n`glGenFramebuffers`API调用用于分配帧缓冲区对象名称：\n\n``` objc\n/**\n 创建帧缓冲区对象\n\n @param n#> 返回的帧缓冲区对象名称的数量 description#>\n @param framebuffers#> 指向一个包含n个元素的数组的指针，分配的帧缓冲区对象在该数组中返回 description#>\n @return void\n */\nglGenFramebuffers(GLsizei n, GLuint *framebuffers);\n```\n\n`glGenFramebuffers`分配n个帧缓冲区对象名称，并在`framebuffers`中返回它们。由`glGenFramebuffers`返回的帧缓冲区对象名称是不为0的无符号整数。这些名称被标记为“在用”但是没有任何关联的状态。数值0由OpenGL ES保留，不能用于指代一个窗口系统提供的帧缓冲区。视图修改或者查询帧缓冲区对象0的缓冲区对象状态的应用程序将产生一个对应的错误。\n\n# 使用渲染缓冲区对象\n\n要为特定的渲染缓冲区对象指定图像的数据存储、格式和尺寸，需要使该对象成为当前渲染缓冲区对象。`glBindRenderbuffer`命令用于设置当前渲染缓冲区对象：\n\n``` objc\n/**\n 绑定渲染缓冲区对象\n\n @param target#> 必须设置为GL_RENDERBUFFER description#>\n @param renderbuffer#> 渲染缓冲区对象名称 description#>\n @return void\n */\nglBindRenderbuffer(GLenum target, GLuint renderbuffer);\n```\n\n注意，`glGenRenderbuffers`不一定要在用`glBindRenderbuffer`绑定之前分配渲染缓冲区对象名称。虽然调用`glGenRenderbuffers`是一个好的做法，但许多应用程序还是为其缓冲区指定编译时常量。应用程序可以将未使用的渲染缓冲区名称指定到`glBindRenderbuffer`。但是，我们建议OpenGL ES应用程序调用`glGenRenderbuffers`，并使用`glGenRenderbuffers`返回的渲染缓冲区对象名称，而不是指定自己的缓冲区对象名称。\n在第一次通过调用`glBindRenderbuffer`绑定渲染缓冲区对象名称时，渲染缓冲区对象被分配相应的默认状态。如果分配成功，分配的对象将成为新绑定的渲染缓冲区对象。下面是与渲染缓冲区对象相关的状态和默认值：\n- 以像素数表示的宽度和高度--默认值为0。\n- 内部格式--描述了渲染缓冲区中存储的像素格式，必须是颜色、深度或者模板可渲染格式。\n- 颜色位深--这只有在内部格式是颜色可渲染格式时有效。默认值为0。\n- 深度位深--这只有在内部格式是深度可渲染格式时有效。默认值为0。\n- 模板位深--这只有在内部格式是模板可渲染格式时有效。默认值为0。\n\n`glBindRenderbuffer`也可以用于绑定到现有的渲染缓冲区对象（也就是之前已经分配使用因而有关联有效状态的缓冲区对象）。绑定命令对于新绑定的渲染缓冲区对象的状态不做任何改变。\n一旦绑定渲染缓冲区对象，就可以指定保存在渲染缓冲区中的图像大小和格式。`glRenderbufferStorage`命令可用于这个目的。\n除了不提供图像数据，`glRenderbufferStorage`看起来与`glTexImage2D`很相似。我们也可以使用`glRenderbufferStorageMultisample`命令创建一个多重采样渲染缓冲区。`glRenderbufferStorage`等价于样本数设置为0的`glRenderStorageMultisample`。渲染缓冲区的宽度和高度以像素数指定，其值必须小于OpenGL ES实现所支持的最大渲染缓冲区尺寸。所有OpenGL ES实现都支持的最小尺寸为1，实际支持的最大尺寸可以用如下代码查询：\n\n``` objc\nGLint maxRenderbufferSize = 0;\nglGetIntegerv(GL_MAX_RENDERBUFFER_SIZE, &maxRenderbufferSize);\n```\n\n``` objc\n/**\n 指定渲染缓冲区的图像大小和格式\n\n @param target#> 必须设置为GL_RENDERBUFFER description#>\n @param internalformat#> 必须为可用于颜色缓冲区、深度缓冲区或者模板缓冲区的格式 description#>\n @param width#> 以像素数表示的渲染缓冲区宽度；必须小于或者等于GL_MAX_RENDERBUFFER_SIZE description#>\n @param height#> 以像素数表示的渲染缓冲区高度；必须小于或者等于GL_MAX_RENDERBUFFER_SIZE description#>\n @return void\n */\nglRenderbufferStorage(GLenum target, GLenum internalformat, GLsizei width, GLsizei height);\n\n/**\n 创建一个多重采样渲染缓冲区\n\n @param target#> 必须设置为GL_RENDERBUFFER description#>\n @param samples#> 用于渲染缓冲区对象存储的样本数。必须小于GL_MAX_SAMPLES description#>\n @param internalformat#> 必须为可用于颜色缓冲区、深度缓冲区或者模板缓冲区的格式 description#>\n @param width#> 以像素数表示的渲染缓冲区宽度；必须小于或者等于GL_MAX_RENDERBUFFER_SIZE description#>\n @param height#> 以像素数表示的渲染缓冲区高度；必须小于或者等于GL_MAX_RENDERBUFFER_SIZE description#>\n @return void\n */\nglRenderbufferStorageMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);\n```\n\n渲染缓冲区对象可以连接到帧缓冲区对象的颜色、深度或者模板附着，而不需要指定渲染缓冲区存储格式和大小。渲染缓冲区的存储格式和大小可以在渲染缓冲区对象连接到帧缓冲区对象前后指定。但是，这些信息必须在帧缓冲区对象和渲染缓冲区附着用于渲染之前指定。\n\n## 多重采样渲染缓冲区\n\n多重采样渲染缓冲区使应用程序可以用多重采样抗锯齿技术渲染到屏幕外帧缓冲区。多重采样渲染缓冲区不能直接绑定到纹理，但是可以用新推出的[帧缓冲区位块传送](#帧缓冲区位块传送)解析为单采样纹理。\n\n# 使用帧缓冲区对象\n\n我们将说明如何使用帧缓冲区对象渲染到一个屏幕外缓冲区（也就是渲染缓冲区）或者渲染到一个纹理。在使用帧缓冲区对象并指定其附着之前，需要使其成为当前帧缓冲区对象。`glBindFramebuffer`命令用于设置当前帧缓冲区对象：\n\n``` objc\n/**\n 设置当前帧缓冲区对象\n\n @param target#> 必须设置为GL_READ_FRAMEBUFFER、GL_DRAW_FRAMEBUFFER或GL_FRAMEBUFFER description#>\n @param framebuffer#> 帧缓冲区对象名称 description#>\n @return void\n */\nglBindFramebuffer(GLenum target, GLuint framebuffer);\n```\n\n注意，对于在用`glBindFramebuffer`绑定帧缓冲区对象之前指定其名称来说，`glGenFramebuffers`并不是必需的。应用程序可以将未用的帧缓冲区对象名称指定给`glBindFramebuffer`。但是，我们建议OpenGL ES应用程序调用`glGenFramebuffers`，并使用`glGenFramebuffers`返回的帧缓冲区对象名称，而不是指定自己的缓冲区对象名称。\n在某些OpenGL ES 3.0实现上，当调用`glBindFramebuffer`首次绑定帧缓冲区对象名称时，为帧缓冲区对象分配对应的默认状态。如果分配成功，分配的对象将作为渲染上下文的当前缓冲区对象进行绑定。\n与帧缓冲区对象相关的状态如下：\n- 颜色附着点--颜色缓冲区的附着点\n- 深度附着点--深度缓冲区的附着点\n- 模板附着点--模板缓冲区的附着点\n- 帧缓冲区完整性状态--帧缓冲器是否处于完整状态，是否可以用于渲染\n对于每个附着点，指定如下信息：\n- 对象类型--指定与附着点相关的对象的类型。如果连接一个渲染缓冲区对象，则类型可以是`GL_RENDERBUFFER`；如果连接一个纹理对象，那么类型可以是`GL_TEXTURE`。默认值为`GL_NONE`。\n- 对象名称--指定连接的对象的名称，可以是渲染缓冲区对象名称或者纹理对象名称。默认值为0。\n- 纹理级别--如果连接一个纹理对象，则指定了与附着点线管的纹理的mip级别。默认值为0。\n- 纹理立方图面--如果连接一个纹理对象，切纹理为立方图，则指定了6个立方图面中哪一个用于该附着点。默认值为`GL_TEXTURE_CUBE_MAP_POSITIVE_X`。\n- 纹理层次--指定3D纹理中用于该附着点的2D切片。默认值为0。\n`glBindFramebuffer`也可以用于绑定到现有的帧缓冲区对象（也就是之前已经分配并使用因而有相关的有效状态的对象）。新绑定的帧缓冲区对象的状态没有任何变化。\n一旦绑定了帧缓冲区对象，当前绑定的帧缓冲区对象的颜色、深度和模板附着就可以设置为一个渲染缓冲区对象或者一个纹理。如下图所示，颜色附着可以设置为存储颜色值的渲染缓冲区、2D纹理的一个mip级别或者一个立方图面、2D数组纹理的一个层次或者3D纹理中一个2D切片的mip级别。深度附着可以设置为存储深度值或者经过打包的深度和模板值的渲染缓冲区、2D深度纹理的一个mip级别或者深度立方图面。模板附着必须设置为存储模板值或者打包的深度和模板值的渲染缓冲区。\n\n## 连接渲染缓冲区作为帧缓冲区附着\n\n`glFramebufferRenderbuffer`命令用于将一个渲染缓冲区对象连接到帧缓冲区附着点：\n\n``` objc\n/**\n 将一个渲染缓冲区对象连接到帧缓冲区附着点\n\n @param target#> 必须设置为GL_READ_FRAMEBUFFER、GL_DRAW_FRAMEBUFFER或GL_FRAMEBUFFER description#>\n @param attachment#> 必须为如下枚举值之一：GL_COLOR_ATTACHMENTi、GL_DEPTH_ATTACHMENT、GL_STENCIL_ATTACHMENT、GL_DEPTH_STENCIL_ATTACHMENT description#>\n @param renderbuffertarget#> 必须设置为GL_RENDERBUFFER description#>\n @param renderbuffer#> 应该用作附着的渲染缓冲区对象；必须为0或者现有渲染缓冲区对象名称 description#>\n @return void\n */\nglFramebufferRenderbuffer(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);\n```\n\n如果调用`glFramebufferRenderbuffer`时`renderbuffer`不为0，这个渲染缓冲区对象将被用作`attachment`参数值指定的新颜色、深度或者模板附着点。\n附着点的状态将被修改为：\n- 对象类型 = GL_RENDERBUFFER\n- 对象名称 = renderbuffer\n- 纹理级别和纹理层次 = 0\n- 纹理立方图面 = GL_NONE\n\n新连接的渲染缓冲区对象状态或者缓冲区内容不做任何修改。\n如果`glFramebufferRenderbuffer`调用中`renderbuffer`等于0，则`attachment`指定的颜色、深度或者模板缓冲区将被断开并重置为0。\n\n## 连接一个2D纹理作为帧缓冲区附着\n\n`glFramebufferTexture2D`命令用于将一个2D纹理的某个mip级别或者立方图面连接到帧缓冲区附着点。它可以用来将纹理作为颜色、缓冲区或者模板附着点连接：\n\n``` objc\n/**\n 将一个2D纹理的某个mip级别或者立方图面连接到帧缓冲区附着点\n\n @param target#> 必须设置为GL_READ_FRAMEBUFFER、GL_DRAW_FRAMEBUFFER、GL_FRAMEBUFFER description#>\n @param attachment#> 必须为如下枚举值之一：GL_COLOR_ATTACHMENTi、GL_DEPTH_ATTACHMENT、GL_STENCIL_ATTACHMENT、GL_DEPTH_STENCIL_ATTACHMENT description#>\n @param textarget#> 指定纹理目标；这是glTexImage2D中的target参数指定的值 description#>\n @param texture#> 指定纹理对象 description#>\n @param level#> 指定纹理图像的mip级别 description#>\n @return void\n */\nglFramebufferTexture2D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);\n```\n\n如果`glFramebufferTexture2D`调用中`texture`不为0，则颜色、深度或者模板附着将被设置为`texture`。如果`glFramebufferTexture2D`发生错误，帧缓冲区的状态将不做修改。\n附着点状态将被修改为：\n- 对象类型 = GL_TEXTURE\n- 对象名称 = texture\n- 纹理级别 = level\n- 纹理立方图面在纹理附着为立方图时有效，是如下值之一： GL_TEXTURE_CUBE_MAP_POSITIVE_(X | Y | Z)，GL_TEXTURE_CUBE_MAP_NEGATIVE_(X | Y | Z)\n- 纹理层次 = 0\n`glFramebufferTexture2D`不修改新连接的纹理对象状态或者图像内容。注意，纹理对象的状态和图像可以连接到帧缓冲区对象之后修改。\n如果`glFramebufferTexture2D`调用中`texture`等于0，则颜色、深度或者模板附着将被断开并重置为0。\n\n## 连接3D纹理的一个图像作为帧缓冲区附着\n\n`glFramebufferTextureLayer`命令用于将3D纹理的一个2D切片或者某个mip级别或者2D数组纹理的一个级别连接到帧缓冲区附着点。\n\n``` objc\n/**\n 将3D纹理的一个2D切片或者某个mip级别或者2D数组纹理的一个级别连接到帧缓冲区附着点\n\n @param target#> 必须设置为GL_READ_FRAMEBUFFER、GL_DRAW_FRAMEBUFFER、GL_FRAMEBUFFER description#>\n @param attachment#> 必须为如下枚举值之一：GL_COLOR_ATTACHMENTi、GL_DEPTH_ATTACHMENT、GL_STENCIL_ATTACHMENT、GL_DEPTH_STENCIL_ATTACHMENT description#>\n @param texture#> 指定纹理对象 description#>\n @param level#> 指定纹理图像的mip级别 description#>\n @param layer#> 指定纹理图像层次。如果texture是GL_TEXTURE_CUBE_MAP_3D，则level必须大于或等于0并且小于或等于GL_MAX3D_TEXTURE_SIZE值以2位底的对数。如果texture是GL_TEXTURE_2D_ARRAY，则level必须大于或等于0且不大于GL_MAX_TEXTURE_SIZE值以2为底的对数 description#>\n @return void\n */\nglFramebufferTextureLayer(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer);\n```\n\n`glFramebufferTextureLayer`不修改新连接的纹理对象状态或者其图像的内容。注意，纹理对象的状态和图像可以在连接到帧缓冲器对象之后修改。\n附着点的状态被修改为：\n- 对象类型 = GL_TEXTURE\n- 对象名称 = texture\n- 纹理级别 = level\n- 纹理立方图面 = GL_NONE\n- 纹理层次 = 0\n如果`glFramebufferTextureLayer`调用中`texture`等于0，则附着将被断开并重置为0。\n\n## 检查帧缓冲区完整性\n\n帧缓冲区对象必须定义为完整的才能够用作渲染目标。如果当前绑定的帧缓冲区对象不完整，绘制图元或者读取像素的OpenGL ES命令将会失败，并产生表示帧缓冲区不完整原因的对应错误。\n帧缓冲区对象被视为完整的规则如下：\n- 确保颜色、深度和模板附着有效。帧缓冲区至少有一个有效的附着，如果没有任何附着，帧缓冲区就是不完整的，因为没有可以绘制或者读取的区域。\n- 与帧缓冲区对象相关的有效附着必须由相同的宽度和高度。\n- 如果存在深度和模板附着，则它们必须是相同的图像。\n- 所有渲染缓冲区附着的`GL_RENDERBUFFER_SAMPLES`值都相同。如果附着是渲染缓冲区和纹理的组合，则`GL_RENDERBUFFER_SAMPLES`的值为0。\n\n`glCheckFramebufferStatus`命令可用于验证帧缓冲区对象是否完整：\n\n``` objc\n/**\n 验证帧缓冲区对象是否完整\n\n @param target#> 必须设置为GL_READ_FRAMEBUFFER、GL_DRAW_FRMAEBUFFER或GL_FRAMEBUFFER description#>\n @return void\n */\nglCheckFramebufferStatus(GLenum target);\n```\n\n如果`target`不等于`GL_FRAMEBUFFER`，则`glCheckFramebufferStatus`返回0。如果`target`等于`GL_FRAMEBUFFER`，则返回如下枚举值之一：\n- GL_FRAMEBUFFER_COMPLETE -- 帧缓冲区完整\n- GL_FRAMEBUFFER_UNDEFINED -- 如果`target`是默认的帧缓冲区但是它不存在\n- GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT -- 帧缓冲区附着点不完整。这可能是因为需要的附着为0，或者不是有效纹理或渲染缓冲区对象\n- GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT -- 帧缓冲区中没有有效的附着\n- GL_FRAMEBUFFER_UNSUPPORTED -- 帧缓冲区中的附着使用的内部格式组合造成不可渲染的目标\n- GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE -- 所有渲染缓冲区附着的GL_RENDERBUFFER_SAMPLES不都相同，或者GL_RENDERBUFFER_SAMPLES在附着是渲染缓冲区和纹理的组合时不为0\n\n如果当前绑定的帧缓冲区对象不完整，则试图使用该对象读取和写入像素将会失败。接着，绘制图元的调用（如`glDrawArrays`和`glDrawElements`）和读取帧缓冲区的命令（如`glReadPixels`、`glCopyTeximage2D`、`glCopyTexSubimage2D`和`glCopyTexSubimage3D`）将生成一个`GL_INVALID_FRAMEBUFFER_OPERATION`错误。\n\n# 帧缓冲区位块传送\n\n帧缓冲区位块传送（Blit）可以高效地将一个矩形区域的像素值从一个帧缓冲区（读帧缓冲区）复制到另一个帧缓冲区（绘图帧缓冲区）。帧缓冲区位块传送的关键应用之一是将一个多重采样渲染缓冲区解析为一个纹理（用一个帧缓冲区对象，纹理绑定为它的颜色附着）。\n可以用如下命令执行上述操作：\n\n``` objc\n/**\n 将一个矩形区域的像素从一个帧缓冲区复制到另一个帧缓冲区\n\n @param srcX0，srcY0，srcX1，srcY1#> 指定读缓冲区内的来源矩形的边界 description#>\n @param dstX0，dstY0，dstX1，dstY1#> 指定写缓冲区内的目标矩形的边界 description#>\n @param mask#> 指定表示哪些缓冲区被复制的标识的按位或；组成如下：GL_COLOR_BUFFER_BIT，GL_DEPTH_BUFFER_BIT，GL_STENCIL_BUFFER_BIT，GL_DEPTH_STENCIL_ATTACHMENT description#>\n @param filter#> 指定图像被拉伸时应用的插值；必须为GL_NEAREST或GL_LINEAR description#>\n @return void\n */\nglBlitFramebuffer(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);\n```\n\n举例：\n\n``` objc\n// set the default framebuffer for writing\nglBindFramebuffer(GL_DRAW_FRAMEBUFFER, defaultFramebuffer);\n// set the fbo with color attachments for reading\nglBindFramebuffer(GL_READ_FRAMEBUFFER, fbo);\n// copy the output buffer to target\nglReadBuffer(GL_COLOR_ATTACHMENT0);\nglBlitFramebuffer(0, 0, width, height, 0, 0, width/2, height, GL_COLOR_BUFFER_BIT, GL_LINEAR);\nglReadBuffer(GL_COLOR_ATTACHMENT1);\nglBlitFramebuffer(0, 0, width, height, width/2, 0, width/2, height, GL_COLOR_BUFFER_BIT, GL_LINEAR);\n```\n\n# 帧缓冲区失效\n\n帧缓冲区失效为应用程序提供了一个通知驱动程序不再需要帧缓冲区内容的机制。这使得驱动程序可以采取多种优化步骤：（1）跳过在块状渲染（TBR）架构中为了进一步渲染到帧缓冲区而做的不必要的图块内容恢复，（2）跳过多CPU系统中GPU之间不必要的数据复制，（3）跳过某些实现中为了改进性能而对特定缓存的刷新。这种功能对于许多应用程序中实现峰值性能很重要，特别是那些执行大量屏幕外渲染的应用。\n让我们研究一下TBR GPU的设计，以理解帧缓冲区失效对这些GPU的重要性。TBR GPU尝尝部署在移动设备上，以最小化GPU和系统内存之间的数据传输量，从而减少最大的电力消耗者之一--内存带宽。这通过添加能够保存少量像素数据的芯片内建快速存储器来实现。然后，帧缓冲区被分为许多个图块。对于每个图块，图元被渲染到芯片内建的存储器中，然后结果在完成时被复制到系统内存。因为每个像素的最少量数据（最终像素结果）被复制到系统内存，所以这种方法节约了GPU和系统内存之间的内存带宽。\n有了帧缓冲区失效机制，GPU就可以删除不再需要的帧缓冲区内容，以减少每个帧保留的内容数量。此外，如果图块数据不再有效，GPU还可以消除从芯片内建存储器到系统内存不必要的数据传输，因为GPU和系统内存之间内存带宽需求明显降低，所以电力消耗随之下降，性能则得到改善。\n`glInvalidateFramebuffer`和`glInvalidateSubFramebuffer`命令用于使整个帧缓冲区或者帧缓冲区的像素子区域失效：\n\n``` objc\n/**\n 使整个帧缓冲区失效\n\n @param target#> 必须设置为GL_READ_FRAMEBUFFER、GL_DRAW_FRAMEBUFFER或GL_FRAMEBUFFER description#>\n @param numAttachments#> attachments列表中的附着数量 description#>\n @param attachments#> 指定包含numAttachments个附着的数组的指针 description#>\n @return void\n */\nglInvalidateFramebuffer(GLenum target, GLsizei numAttachments, const GLenum *attachments);\n\n/**\n 使帧缓冲区的像素子区域失效\n\n @param target#> 必须设置为GL_READ_FRAMEBUFFER、GL_DRAW_FRAMEBUFFER或GL_FRAMEBUFFER description#>\n @param numAttachments#> attachments列表中的附着数量 description#>\n @param attachments#> 指定包含numAttachments个附着的数组的指针 description#>\n @param x，y#> 指定要失效的像素矩形的左下角原点（左下角为0，0） description#>\n @param width#> 指定要失效的像素矩形宽度 description#>\n @param height#> 指定要失效的像素矩形高度 description#>\n @return void\n */\nglInvalidateSubFramebuffer(GLenum target, GLsizei numAttachments, const GLenum *attachments, GLint x, GLint y, GLsizei width, GLsizei height);\n```\n\n# 删除帧缓冲区和渲染缓冲区对象\n\n在应用程序结束渲染缓冲区对象的使用之后，可以删除它们。删除渲染缓冲区和帧缓冲区对象与删除纹理对象非常相似。\n渲染缓冲区对象用`glDeleteRenderbuffers`API删除：\n\n``` objc\n/**\n 删除渲染缓冲区对象\n\n @param n#> 要删除的渲染缓冲区对象名称的数量 description#>\n @param renderbuffers#> 指向包含n个要删除的渲染x缓冲区对象名称的数组的指针 description#>\n @return void\n */\nglDeleteRenderbuffers(GLsizei n, const GLuint *renderbuffers);\n```\n\n`glDeleteRenderbuffers`删除`renderbuffers`中指定的渲染缓冲区对象。一旦删除了渲染缓冲区对象，就没有任何与之关联，对象被标记为未用，以后可以被重用，作为新的渲染缓冲区对象。删除当前绑定的渲染缓冲区对象时，该对象被删除，当前渲染缓冲区被重置为0。如果`renderbuffers`中指定的渲染缓冲区对象名称无效或者为0，则它们被忽略（不会生成任何错误）。而且，如果渲染缓冲区连接到当前绑定的帧缓冲区对象，则它首先要与帧缓冲区断开，然后才能被删除。\n帧缓冲区对象用`glDeleteFramebuffers`API删除：\n\n``` objc\n/**\n 删除帧缓冲区对象\n\n @param n#> 要删除的帧缓冲区对象名称的数量 description#>\n @param framebuffers#> 指向包含n个要删除的帧缓冲区对象名称的数组的指针 description#>\n @return void\n */\nglDeleteFramebuffers(GLsizei n, const GLuint *framebuffers);\n```\n\n`glDeleteFramebuffers`删除`framebuffers`中指定的帧缓冲区对象。一旦删除了帧缓冲区对象，该对象就不会有任何与之关联的状态，并被标记为未使用，以后可以作为新的帧缓冲区对象重用。删除当前绑定的帧缓冲区对象时，该对象被删除且当前帧缓冲区绑定重置为0。如果`framebuffers`中指定的帧缓冲区对象名称无效或者为0，则它们被忽略，不会生成任何错误。\n\n# 删除用作帧缓冲区附着的渲染缓冲区对象\n\n如果被删除的渲染缓冲区对象作为帧缓冲区对象的一个附着，会发生什么情况？如果要删除的帧缓冲区对象作为当前绑定的帧缓冲区对象中的一个附着，则`glDeleteRenderbuffers`将附着重置为0。如果要删除的渲染缓冲区对象是当前没有绑定的帧缓冲区对象的一个附着，则`glDeleteRenderbuffers`不会将这些附着重置为0。将这些被删除的渲染缓冲区对象与对应的帧缓冲区对象断开是应用程序的责任。\n\n## 读取像素和帧缓冲区对象\n\n`glReadPixels`命令从颜色缓冲区读取像素，并在一个用户分配的缓冲区中返回它们。读取的颜色缓冲区是窗口系统提供的帧缓冲区分配的颜色缓冲区，或者是当前绑定的帧缓冲区对象的颜色附着。当用`glBindBuffer`将一个非零的缓冲区对象绑定到`GL_PIXEL_PACK_BUFFER`时，`glReadPixels`命令可以立即返回，并调用DMA传输从帧缓冲区中读取像素，然后将数据写入像素缓冲区对象。\n`glReadPixels`支持多种`format`和`type`参数组合：`format`可以是`GL_RGBA`、`GL_RGBA_INTEGER`或者由查询`GL_IMPLEMENTATION_COLOR_READ_FORMAT`返回的特定于实现的值；`type`可以是`GL_UNSIGNED_BYTE`、`GL_UNSIGNED_INT`、`GL_INT`、`GL_FLOAT`或者由查询`GL_IMPLEMENTATION_COLOR_READ_TYPE`返回的特定于实现的值。返回的特定于实现的格式和类型取决于当前连接的颜色缓冲区的格式和类型。如果当前绑定的帧缓冲区改变，则这些值也可能改变。当前绑定的帧缓冲区对象改变时都必须查询这些值，以确定传递给`glReadPixels`的正确的特定于实现的格式和类型值。\n\n# 性能提示和技巧\n\n下面，我们讨论开发人员在使用帧缓冲区对象时应该认真考虑的性能提示：\n- 避免频繁地在渲染到窗口系统提供的帧缓冲区和渲染到帧缓冲区对象之间切换。这对于手持OpenGL ES 3.0实现是一个问题，因为许多这类实现使用块状渲染架构。在块状渲染架构中，使用专用的内部存储器存储帧缓冲区图块（区域）的颜色、深度和模板值。这些内部存储器在电源利用上更为高效，而且与外部内存相比具有更低的内存延迟和更大的带宽。在渲染到图块完成之后，图块被写到设备（系统）内存。每当从一个渲染目标切换到另一个，就需要渲染、保存和恢复对应的纹理和渲染缓冲区附着，这可能带来很大的代价。最佳的方法是首先渲染到场景中合适的帧缓冲区，然后渲染到窗口系统提供的帧缓冲区，最后执行`eglSwapBuffers`命令切换显示缓冲区。\n- 不要逐帧创建和删除帧缓冲区和渲染缓冲区对象（或者任何其他大型数据对象）。\n- 尝试避免修改用作渲染目标的帧缓冲区对象附着的纹理（使用`glTexImage2D`、`glTexSubImage2D`、`glCopyTexImage2D`等）。\n- 如果整个纹理图像将被渲染，则将`glTexImage2D`和`glTexImage3D`中的`pixel`参数设置为`NULL`，因为原始数据不会被使用。如果希望图像不包含任何预先定义的像素值，那么在绘制到纹理之前使用`glInvalidateFramebuffer`清除纹理图像。\n- 尽可能共享帧缓冲区对象使用的用作附着的深度和模板渲染缓冲区，以保障内存占用需求最小。\n\n# 总结\n\n这篇文章主要是对用于渲染到屏幕外表面的帧缓冲区对象的使用方法。","source":"_posts/2019/opengl-es-framebuffer-0819.md","raw":"---\ntitle: \"OpenGL ES学习--帧缓冲区对象\"\ncatalog: true\ntoc_nav_num: true\ndate: 2019-08-19 20:03:12\nsubtitle: \"About OpenGL ES\"\nheader-img: \"/img/article_header/article_header.png\"\nbusuanzi: true\ntags:\n- iOS\n\n---\n\n> 在本篇中我们将描述帧缓冲区对象的概念、应用程序创建它们的方法以及应用程序使用它们渲染到屏幕外缓冲区或者纹理的方法。\n\n# 为什么使用帧缓冲区对象\n\n在应用程序调用任何OpenGL ES命令之前，需要首先创建一个渲染上下文和绘图表面，并使之成为现行上下文和表面。渲染上下文和绘图表面通常由原生窗口系统通过EGL等API提供。渲染上下文包含正确操作所需的对应状态。由原生窗口系统提供的绘图表面可以是一个在屏幕上显示的表面（称为窗口系统提供的帧缓冲区），也可以是屏幕外表面（称作pbuffer）。创建EGL绘图表面的调用让我们以像素数的形式指定表面的宽度和高度、表面是否使用颜色、深度和模板缓冲区以及这些缓冲区的位深。\n默认情况下，OpenGL ES使用窗口系统提供的帧缓冲区作为绘图表面。如果应用程序只在屏幕上的表面绘图，则窗口系统提供的帧缓冲区通常很高效。但是，许多应用程序需要渲染到纹理，为此，使用窗口系统提供的帧缓冲区作为绘图表面通常不是理想的选择。\n应用程序可以使用以下两种技术之一渲染到纹理：\n- 通过绘制到窗口系统提供的帧缓冲区，然后将帧缓冲区的对应区域复制到纹理来实现渲染到纹理。这可以用`glCopyTexImage2D`和`glCopyTexSubImage2D`API实现。顾名思义，这些API执行从帧缓冲区到纹理缓冲区的复制，这一复制操作往往对性能有不利影响。此外，这种方法只有在纹理的尺寸小于或者等于帧缓冲区尺寸的时候才有效。\n- 通过使用连接到纹理的pbuffer来实现渲染到纹理。我们知道，窗口系统提供的表面必须连接到一个渲染上下文。这在某些对每个pbuffer和窗口表面需要不同上下文的实现中可能效率低下。此外，在窗口系统提供的可绘制表面之间切换有时候需要OpenGL ES实现清除所有切换之前渲染的图像。这可能在渲染管线中造成代价很高的“起泡效应”（CPU闲置）。在这种系统上，我们建议避免使用pbuffer渲染到纹理，因为与上下文和窗口系统提供的可绘制表面之间的切换相关的开销很大。\n\n上述两种方法对于渲染到纹理或者其他屏幕外表面来说都不理想。作为替代，我们需要允许应用程序直接渲染到纹理的API，或者在OpenGL ES API中具备创建屏幕外表面的能力，并将它作为渲染目标。帧缓冲区对象和渲染缓冲区对象允许应用程序完成这些操作，不需要额外创建渲染上下文。结果是，我们在使用窗口系统提供的可绘制表面时，不再需要担心上下文和可绘制表面切换的开销。因此，帧缓冲区对象提供了渲染到纹理或者屏幕外表面的更好、更有效的方法。\n帧缓冲区对象API支持如下操作：\n- 仅适用OpenGL ES命令创建帧缓冲区对象\n- 在单一EGL上下文中创建和使用多个缓冲区对象--也就是说，不需要每个帧缓冲区都有一个渲染上下文\n- 创建屏幕外颜色、深度或者模板渲染缓冲区和纹理，并将它们连接到帧缓冲区对象\n- 在多个帧缓冲区之间共享颜色、深度或者模板缓冲区\n- 将纹理直接连接到帧缓冲区作为颜色或者深度，从而避免了进行复制操作的必要\n- 在帧缓冲区之间复制并使帧缓冲区内容失效\n\n# 帧缓冲区和渲染缓冲区对象\n\n渲染缓冲区对象是一个由应用程序分配的2D图像缓冲区。渲染缓冲区可以用于分配和存储颜色、深度或者模板值，可以用作帧缓冲区对象中的颜色、深度或者模板附着。渲染缓冲区类似于屏幕外的窗口系统的可绘制表面--如pbuffer。但是，渲染缓冲区不能直接用作GL纹理。\n帧缓冲区对象（FBO）是一组颜色、深度和模板纹理或者渲染目标。各种2D图像可以连接到帧缓冲区对象中的颜色附着点。这些附着点包括一个渲染缓冲区对象，它保存颜色值、2D纹理或者立方图面的mip级别、2D数组纹理的层次甚至3D纹理中一个2D切片的mip级别。同样，包含深度值的各种2D图像可以连接到FBO的深度附着点。这些附着点包括渲染缓冲区、2D纹理的mip级别或者保存深度值的一个立方图面。可以连接到FBO模板附着点的唯一2D图像是保存模板值的渲染缓冲区对象。\n下图展示了帧缓冲区对象、渲染缓冲区对象和纹理之间的关系。注意，一个帧缓冲区对象中只能有一个颜色、深度和模板附着。\n\n![帧缓冲区对象、渲染缓冲区对象和纹理](/img/article/20190819/1.png)\n\n## 选择渲染缓冲区与纹理作为帧缓冲区附着的对比\n\n对于渲染到纹理的用例，我们应该将一个纹理对象连接到帧缓冲区对象。这方面的例子包括渲染到一个用作颜色纹理的颜色缓冲区以及渲染到用作阴影的深度纹理的深度缓冲区。\n使用渲染缓冲区代替纹理有以下几种原因：\n- 渲染缓冲区支持多重采样。\n- 如果图像没有被当做纹理使用，则使用渲染缓冲区可能带来性能上的好处。出现这种好处是因为OpenGL ES实现可能以更为高效的格式存储渲染缓冲区，比起纹理来说更适合于渲染。但是，如果预先知道图像不被用作纹理，那么OpenGL ES实现所能做的也仅仅如此。\n\n## 帧缓冲区对象与EGL表面的对比\n\nFBO和窗口系统提供的可绘制表面之间的区别：\n- 像素归属测试确定帧缓冲区中(x<sub>w</sub>), y<sub>w</sub>)位置的像素目前是否归OpenGL ES所有，这个测试允许窗口系统控制帧缓冲区中的哪些像素属于OpenGL ES上下文--例如，当OpenGL ES渲染的窗口被遮蔽时。对于应用程序创建的帧缓冲区对象，像素归属测试始终成功，因为帧缓冲区对象拥有所有像素。\n- 窗口系统可能只支持双缓冲表面。相反，帧缓冲区对象只支持单缓冲区附着。\n- 使用帧缓冲区对象可以实现帧缓冲区之间模板和深度缓冲区的共享，而窗口系统提供的帧缓冲区通常不能实现这一功能。在窗口系统提供的可绘制表面中，模板和深度缓冲区及其对应的状态通常是隐含分配的，因此，无法在可绘制表面之间共享。对于应用程序创建的帧缓冲区对象，模板和深度缓冲区可以独立创建，然后在必要时通过将这些缓冲区连接到多个缓冲区对象中的对应连接点，实现与帧缓冲区对象的关联。\n\n# 创建帧缓冲区和渲染缓冲区对象\n\n创建帧缓冲区和渲染缓冲区对象类似于在OpenGL ES 3.0中创建纹理或者顶点缓冲区对象。\n`glGenRenderbuffers`API调用用于分配渲染缓冲区对象名称：\n\n``` objc\n/**\n 创建渲染缓冲区对象\n\n @param n#> 返回的渲染缓冲区对象名称的数量 description#>\n @param renderbuffers#> 返回一个有n个元素的数组的指针，分配的渲染缓冲区对象名称将在该数组中返回 description#>\n @return void\n */\nglGenRenderbuffers(GLsizei n, GLuint *renderbuffers);\n```\n\n`glGenRenderbuffers`分配n个渲染缓冲区对象名称，并在`renderbuffers`中返回。由`glGenRenderbuffers`返回的渲染缓冲区对象名称是不为0的无符号整数。这些名称被标记为`在用`但是没有任何关联的状态。数值0由OpenGL ES保留，不能用于指代一个渲染缓冲区对象。试图修改或者查询帧缓冲区对象0的缓冲区对象状态的应用程序将产生一个对应的错误。\n`glGenFramebuffers`API调用用于分配帧缓冲区对象名称：\n\n``` objc\n/**\n 创建帧缓冲区对象\n\n @param n#> 返回的帧缓冲区对象名称的数量 description#>\n @param framebuffers#> 指向一个包含n个元素的数组的指针，分配的帧缓冲区对象在该数组中返回 description#>\n @return void\n */\nglGenFramebuffers(GLsizei n, GLuint *framebuffers);\n```\n\n`glGenFramebuffers`分配n个帧缓冲区对象名称，并在`framebuffers`中返回它们。由`glGenFramebuffers`返回的帧缓冲区对象名称是不为0的无符号整数。这些名称被标记为“在用”但是没有任何关联的状态。数值0由OpenGL ES保留，不能用于指代一个窗口系统提供的帧缓冲区。视图修改或者查询帧缓冲区对象0的缓冲区对象状态的应用程序将产生一个对应的错误。\n\n# 使用渲染缓冲区对象\n\n要为特定的渲染缓冲区对象指定图像的数据存储、格式和尺寸，需要使该对象成为当前渲染缓冲区对象。`glBindRenderbuffer`命令用于设置当前渲染缓冲区对象：\n\n``` objc\n/**\n 绑定渲染缓冲区对象\n\n @param target#> 必须设置为GL_RENDERBUFFER description#>\n @param renderbuffer#> 渲染缓冲区对象名称 description#>\n @return void\n */\nglBindRenderbuffer(GLenum target, GLuint renderbuffer);\n```\n\n注意，`glGenRenderbuffers`不一定要在用`glBindRenderbuffer`绑定之前分配渲染缓冲区对象名称。虽然调用`glGenRenderbuffers`是一个好的做法，但许多应用程序还是为其缓冲区指定编译时常量。应用程序可以将未使用的渲染缓冲区名称指定到`glBindRenderbuffer`。但是，我们建议OpenGL ES应用程序调用`glGenRenderbuffers`，并使用`glGenRenderbuffers`返回的渲染缓冲区对象名称，而不是指定自己的缓冲区对象名称。\n在第一次通过调用`glBindRenderbuffer`绑定渲染缓冲区对象名称时，渲染缓冲区对象被分配相应的默认状态。如果分配成功，分配的对象将成为新绑定的渲染缓冲区对象。下面是与渲染缓冲区对象相关的状态和默认值：\n- 以像素数表示的宽度和高度--默认值为0。\n- 内部格式--描述了渲染缓冲区中存储的像素格式，必须是颜色、深度或者模板可渲染格式。\n- 颜色位深--这只有在内部格式是颜色可渲染格式时有效。默认值为0。\n- 深度位深--这只有在内部格式是深度可渲染格式时有效。默认值为0。\n- 模板位深--这只有在内部格式是模板可渲染格式时有效。默认值为0。\n\n`glBindRenderbuffer`也可以用于绑定到现有的渲染缓冲区对象（也就是之前已经分配使用因而有关联有效状态的缓冲区对象）。绑定命令对于新绑定的渲染缓冲区对象的状态不做任何改变。\n一旦绑定渲染缓冲区对象，就可以指定保存在渲染缓冲区中的图像大小和格式。`glRenderbufferStorage`命令可用于这个目的。\n除了不提供图像数据，`glRenderbufferStorage`看起来与`glTexImage2D`很相似。我们也可以使用`glRenderbufferStorageMultisample`命令创建一个多重采样渲染缓冲区。`glRenderbufferStorage`等价于样本数设置为0的`glRenderStorageMultisample`。渲染缓冲区的宽度和高度以像素数指定，其值必须小于OpenGL ES实现所支持的最大渲染缓冲区尺寸。所有OpenGL ES实现都支持的最小尺寸为1，实际支持的最大尺寸可以用如下代码查询：\n\n``` objc\nGLint maxRenderbufferSize = 0;\nglGetIntegerv(GL_MAX_RENDERBUFFER_SIZE, &maxRenderbufferSize);\n```\n\n``` objc\n/**\n 指定渲染缓冲区的图像大小和格式\n\n @param target#> 必须设置为GL_RENDERBUFFER description#>\n @param internalformat#> 必须为可用于颜色缓冲区、深度缓冲区或者模板缓冲区的格式 description#>\n @param width#> 以像素数表示的渲染缓冲区宽度；必须小于或者等于GL_MAX_RENDERBUFFER_SIZE description#>\n @param height#> 以像素数表示的渲染缓冲区高度；必须小于或者等于GL_MAX_RENDERBUFFER_SIZE description#>\n @return void\n */\nglRenderbufferStorage(GLenum target, GLenum internalformat, GLsizei width, GLsizei height);\n\n/**\n 创建一个多重采样渲染缓冲区\n\n @param target#> 必须设置为GL_RENDERBUFFER description#>\n @param samples#> 用于渲染缓冲区对象存储的样本数。必须小于GL_MAX_SAMPLES description#>\n @param internalformat#> 必须为可用于颜色缓冲区、深度缓冲区或者模板缓冲区的格式 description#>\n @param width#> 以像素数表示的渲染缓冲区宽度；必须小于或者等于GL_MAX_RENDERBUFFER_SIZE description#>\n @param height#> 以像素数表示的渲染缓冲区高度；必须小于或者等于GL_MAX_RENDERBUFFER_SIZE description#>\n @return void\n */\nglRenderbufferStorageMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);\n```\n\n渲染缓冲区对象可以连接到帧缓冲区对象的颜色、深度或者模板附着，而不需要指定渲染缓冲区存储格式和大小。渲染缓冲区的存储格式和大小可以在渲染缓冲区对象连接到帧缓冲区对象前后指定。但是，这些信息必须在帧缓冲区对象和渲染缓冲区附着用于渲染之前指定。\n\n## 多重采样渲染缓冲区\n\n多重采样渲染缓冲区使应用程序可以用多重采样抗锯齿技术渲染到屏幕外帧缓冲区。多重采样渲染缓冲区不能直接绑定到纹理，但是可以用新推出的[帧缓冲区位块传送](#帧缓冲区位块传送)解析为单采样纹理。\n\n# 使用帧缓冲区对象\n\n我们将说明如何使用帧缓冲区对象渲染到一个屏幕外缓冲区（也就是渲染缓冲区）或者渲染到一个纹理。在使用帧缓冲区对象并指定其附着之前，需要使其成为当前帧缓冲区对象。`glBindFramebuffer`命令用于设置当前帧缓冲区对象：\n\n``` objc\n/**\n 设置当前帧缓冲区对象\n\n @param target#> 必须设置为GL_READ_FRAMEBUFFER、GL_DRAW_FRAMEBUFFER或GL_FRAMEBUFFER description#>\n @param framebuffer#> 帧缓冲区对象名称 description#>\n @return void\n */\nglBindFramebuffer(GLenum target, GLuint framebuffer);\n```\n\n注意，对于在用`glBindFramebuffer`绑定帧缓冲区对象之前指定其名称来说，`glGenFramebuffers`并不是必需的。应用程序可以将未用的帧缓冲区对象名称指定给`glBindFramebuffer`。但是，我们建议OpenGL ES应用程序调用`glGenFramebuffers`，并使用`glGenFramebuffers`返回的帧缓冲区对象名称，而不是指定自己的缓冲区对象名称。\n在某些OpenGL ES 3.0实现上，当调用`glBindFramebuffer`首次绑定帧缓冲区对象名称时，为帧缓冲区对象分配对应的默认状态。如果分配成功，分配的对象将作为渲染上下文的当前缓冲区对象进行绑定。\n与帧缓冲区对象相关的状态如下：\n- 颜色附着点--颜色缓冲区的附着点\n- 深度附着点--深度缓冲区的附着点\n- 模板附着点--模板缓冲区的附着点\n- 帧缓冲区完整性状态--帧缓冲器是否处于完整状态，是否可以用于渲染\n对于每个附着点，指定如下信息：\n- 对象类型--指定与附着点相关的对象的类型。如果连接一个渲染缓冲区对象，则类型可以是`GL_RENDERBUFFER`；如果连接一个纹理对象，那么类型可以是`GL_TEXTURE`。默认值为`GL_NONE`。\n- 对象名称--指定连接的对象的名称，可以是渲染缓冲区对象名称或者纹理对象名称。默认值为0。\n- 纹理级别--如果连接一个纹理对象，则指定了与附着点线管的纹理的mip级别。默认值为0。\n- 纹理立方图面--如果连接一个纹理对象，切纹理为立方图，则指定了6个立方图面中哪一个用于该附着点。默认值为`GL_TEXTURE_CUBE_MAP_POSITIVE_X`。\n- 纹理层次--指定3D纹理中用于该附着点的2D切片。默认值为0。\n`glBindFramebuffer`也可以用于绑定到现有的帧缓冲区对象（也就是之前已经分配并使用因而有相关的有效状态的对象）。新绑定的帧缓冲区对象的状态没有任何变化。\n一旦绑定了帧缓冲区对象，当前绑定的帧缓冲区对象的颜色、深度和模板附着就可以设置为一个渲染缓冲区对象或者一个纹理。如下图所示，颜色附着可以设置为存储颜色值的渲染缓冲区、2D纹理的一个mip级别或者一个立方图面、2D数组纹理的一个层次或者3D纹理中一个2D切片的mip级别。深度附着可以设置为存储深度值或者经过打包的深度和模板值的渲染缓冲区、2D深度纹理的一个mip级别或者深度立方图面。模板附着必须设置为存储模板值或者打包的深度和模板值的渲染缓冲区。\n\n## 连接渲染缓冲区作为帧缓冲区附着\n\n`glFramebufferRenderbuffer`命令用于将一个渲染缓冲区对象连接到帧缓冲区附着点：\n\n``` objc\n/**\n 将一个渲染缓冲区对象连接到帧缓冲区附着点\n\n @param target#> 必须设置为GL_READ_FRAMEBUFFER、GL_DRAW_FRAMEBUFFER或GL_FRAMEBUFFER description#>\n @param attachment#> 必须为如下枚举值之一：GL_COLOR_ATTACHMENTi、GL_DEPTH_ATTACHMENT、GL_STENCIL_ATTACHMENT、GL_DEPTH_STENCIL_ATTACHMENT description#>\n @param renderbuffertarget#> 必须设置为GL_RENDERBUFFER description#>\n @param renderbuffer#> 应该用作附着的渲染缓冲区对象；必须为0或者现有渲染缓冲区对象名称 description#>\n @return void\n */\nglFramebufferRenderbuffer(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);\n```\n\n如果调用`glFramebufferRenderbuffer`时`renderbuffer`不为0，这个渲染缓冲区对象将被用作`attachment`参数值指定的新颜色、深度或者模板附着点。\n附着点的状态将被修改为：\n- 对象类型 = GL_RENDERBUFFER\n- 对象名称 = renderbuffer\n- 纹理级别和纹理层次 = 0\n- 纹理立方图面 = GL_NONE\n\n新连接的渲染缓冲区对象状态或者缓冲区内容不做任何修改。\n如果`glFramebufferRenderbuffer`调用中`renderbuffer`等于0，则`attachment`指定的颜色、深度或者模板缓冲区将被断开并重置为0。\n\n## 连接一个2D纹理作为帧缓冲区附着\n\n`glFramebufferTexture2D`命令用于将一个2D纹理的某个mip级别或者立方图面连接到帧缓冲区附着点。它可以用来将纹理作为颜色、缓冲区或者模板附着点连接：\n\n``` objc\n/**\n 将一个2D纹理的某个mip级别或者立方图面连接到帧缓冲区附着点\n\n @param target#> 必须设置为GL_READ_FRAMEBUFFER、GL_DRAW_FRAMEBUFFER、GL_FRAMEBUFFER description#>\n @param attachment#> 必须为如下枚举值之一：GL_COLOR_ATTACHMENTi、GL_DEPTH_ATTACHMENT、GL_STENCIL_ATTACHMENT、GL_DEPTH_STENCIL_ATTACHMENT description#>\n @param textarget#> 指定纹理目标；这是glTexImage2D中的target参数指定的值 description#>\n @param texture#> 指定纹理对象 description#>\n @param level#> 指定纹理图像的mip级别 description#>\n @return void\n */\nglFramebufferTexture2D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);\n```\n\n如果`glFramebufferTexture2D`调用中`texture`不为0，则颜色、深度或者模板附着将被设置为`texture`。如果`glFramebufferTexture2D`发生错误，帧缓冲区的状态将不做修改。\n附着点状态将被修改为：\n- 对象类型 = GL_TEXTURE\n- 对象名称 = texture\n- 纹理级别 = level\n- 纹理立方图面在纹理附着为立方图时有效，是如下值之一： GL_TEXTURE_CUBE_MAP_POSITIVE_(X | Y | Z)，GL_TEXTURE_CUBE_MAP_NEGATIVE_(X | Y | Z)\n- 纹理层次 = 0\n`glFramebufferTexture2D`不修改新连接的纹理对象状态或者图像内容。注意，纹理对象的状态和图像可以连接到帧缓冲区对象之后修改。\n如果`glFramebufferTexture2D`调用中`texture`等于0，则颜色、深度或者模板附着将被断开并重置为0。\n\n## 连接3D纹理的一个图像作为帧缓冲区附着\n\n`glFramebufferTextureLayer`命令用于将3D纹理的一个2D切片或者某个mip级别或者2D数组纹理的一个级别连接到帧缓冲区附着点。\n\n``` objc\n/**\n 将3D纹理的一个2D切片或者某个mip级别或者2D数组纹理的一个级别连接到帧缓冲区附着点\n\n @param target#> 必须设置为GL_READ_FRAMEBUFFER、GL_DRAW_FRAMEBUFFER、GL_FRAMEBUFFER description#>\n @param attachment#> 必须为如下枚举值之一：GL_COLOR_ATTACHMENTi、GL_DEPTH_ATTACHMENT、GL_STENCIL_ATTACHMENT、GL_DEPTH_STENCIL_ATTACHMENT description#>\n @param texture#> 指定纹理对象 description#>\n @param level#> 指定纹理图像的mip级别 description#>\n @param layer#> 指定纹理图像层次。如果texture是GL_TEXTURE_CUBE_MAP_3D，则level必须大于或等于0并且小于或等于GL_MAX3D_TEXTURE_SIZE值以2位底的对数。如果texture是GL_TEXTURE_2D_ARRAY，则level必须大于或等于0且不大于GL_MAX_TEXTURE_SIZE值以2为底的对数 description#>\n @return void\n */\nglFramebufferTextureLayer(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer);\n```\n\n`glFramebufferTextureLayer`不修改新连接的纹理对象状态或者其图像的内容。注意，纹理对象的状态和图像可以在连接到帧缓冲器对象之后修改。\n附着点的状态被修改为：\n- 对象类型 = GL_TEXTURE\n- 对象名称 = texture\n- 纹理级别 = level\n- 纹理立方图面 = GL_NONE\n- 纹理层次 = 0\n如果`glFramebufferTextureLayer`调用中`texture`等于0，则附着将被断开并重置为0。\n\n## 检查帧缓冲区完整性\n\n帧缓冲区对象必须定义为完整的才能够用作渲染目标。如果当前绑定的帧缓冲区对象不完整，绘制图元或者读取像素的OpenGL ES命令将会失败，并产生表示帧缓冲区不完整原因的对应错误。\n帧缓冲区对象被视为完整的规则如下：\n- 确保颜色、深度和模板附着有效。帧缓冲区至少有一个有效的附着，如果没有任何附着，帧缓冲区就是不完整的，因为没有可以绘制或者读取的区域。\n- 与帧缓冲区对象相关的有效附着必须由相同的宽度和高度。\n- 如果存在深度和模板附着，则它们必须是相同的图像。\n- 所有渲染缓冲区附着的`GL_RENDERBUFFER_SAMPLES`值都相同。如果附着是渲染缓冲区和纹理的组合，则`GL_RENDERBUFFER_SAMPLES`的值为0。\n\n`glCheckFramebufferStatus`命令可用于验证帧缓冲区对象是否完整：\n\n``` objc\n/**\n 验证帧缓冲区对象是否完整\n\n @param target#> 必须设置为GL_READ_FRAMEBUFFER、GL_DRAW_FRMAEBUFFER或GL_FRAMEBUFFER description#>\n @return void\n */\nglCheckFramebufferStatus(GLenum target);\n```\n\n如果`target`不等于`GL_FRAMEBUFFER`，则`glCheckFramebufferStatus`返回0。如果`target`等于`GL_FRAMEBUFFER`，则返回如下枚举值之一：\n- GL_FRAMEBUFFER_COMPLETE -- 帧缓冲区完整\n- GL_FRAMEBUFFER_UNDEFINED -- 如果`target`是默认的帧缓冲区但是它不存在\n- GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT -- 帧缓冲区附着点不完整。这可能是因为需要的附着为0，或者不是有效纹理或渲染缓冲区对象\n- GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT -- 帧缓冲区中没有有效的附着\n- GL_FRAMEBUFFER_UNSUPPORTED -- 帧缓冲区中的附着使用的内部格式组合造成不可渲染的目标\n- GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE -- 所有渲染缓冲区附着的GL_RENDERBUFFER_SAMPLES不都相同，或者GL_RENDERBUFFER_SAMPLES在附着是渲染缓冲区和纹理的组合时不为0\n\n如果当前绑定的帧缓冲区对象不完整，则试图使用该对象读取和写入像素将会失败。接着，绘制图元的调用（如`glDrawArrays`和`glDrawElements`）和读取帧缓冲区的命令（如`glReadPixels`、`glCopyTeximage2D`、`glCopyTexSubimage2D`和`glCopyTexSubimage3D`）将生成一个`GL_INVALID_FRAMEBUFFER_OPERATION`错误。\n\n# 帧缓冲区位块传送\n\n帧缓冲区位块传送（Blit）可以高效地将一个矩形区域的像素值从一个帧缓冲区（读帧缓冲区）复制到另一个帧缓冲区（绘图帧缓冲区）。帧缓冲区位块传送的关键应用之一是将一个多重采样渲染缓冲区解析为一个纹理（用一个帧缓冲区对象，纹理绑定为它的颜色附着）。\n可以用如下命令执行上述操作：\n\n``` objc\n/**\n 将一个矩形区域的像素从一个帧缓冲区复制到另一个帧缓冲区\n\n @param srcX0，srcY0，srcX1，srcY1#> 指定读缓冲区内的来源矩形的边界 description#>\n @param dstX0，dstY0，dstX1，dstY1#> 指定写缓冲区内的目标矩形的边界 description#>\n @param mask#> 指定表示哪些缓冲区被复制的标识的按位或；组成如下：GL_COLOR_BUFFER_BIT，GL_DEPTH_BUFFER_BIT，GL_STENCIL_BUFFER_BIT，GL_DEPTH_STENCIL_ATTACHMENT description#>\n @param filter#> 指定图像被拉伸时应用的插值；必须为GL_NEAREST或GL_LINEAR description#>\n @return void\n */\nglBlitFramebuffer(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);\n```\n\n举例：\n\n``` objc\n// set the default framebuffer for writing\nglBindFramebuffer(GL_DRAW_FRAMEBUFFER, defaultFramebuffer);\n// set the fbo with color attachments for reading\nglBindFramebuffer(GL_READ_FRAMEBUFFER, fbo);\n// copy the output buffer to target\nglReadBuffer(GL_COLOR_ATTACHMENT0);\nglBlitFramebuffer(0, 0, width, height, 0, 0, width/2, height, GL_COLOR_BUFFER_BIT, GL_LINEAR);\nglReadBuffer(GL_COLOR_ATTACHMENT1);\nglBlitFramebuffer(0, 0, width, height, width/2, 0, width/2, height, GL_COLOR_BUFFER_BIT, GL_LINEAR);\n```\n\n# 帧缓冲区失效\n\n帧缓冲区失效为应用程序提供了一个通知驱动程序不再需要帧缓冲区内容的机制。这使得驱动程序可以采取多种优化步骤：（1）跳过在块状渲染（TBR）架构中为了进一步渲染到帧缓冲区而做的不必要的图块内容恢复，（2）跳过多CPU系统中GPU之间不必要的数据复制，（3）跳过某些实现中为了改进性能而对特定缓存的刷新。这种功能对于许多应用程序中实现峰值性能很重要，特别是那些执行大量屏幕外渲染的应用。\n让我们研究一下TBR GPU的设计，以理解帧缓冲区失效对这些GPU的重要性。TBR GPU尝尝部署在移动设备上，以最小化GPU和系统内存之间的数据传输量，从而减少最大的电力消耗者之一--内存带宽。这通过添加能够保存少量像素数据的芯片内建快速存储器来实现。然后，帧缓冲区被分为许多个图块。对于每个图块，图元被渲染到芯片内建的存储器中，然后结果在完成时被复制到系统内存。因为每个像素的最少量数据（最终像素结果）被复制到系统内存，所以这种方法节约了GPU和系统内存之间的内存带宽。\n有了帧缓冲区失效机制，GPU就可以删除不再需要的帧缓冲区内容，以减少每个帧保留的内容数量。此外，如果图块数据不再有效，GPU还可以消除从芯片内建存储器到系统内存不必要的数据传输，因为GPU和系统内存之间内存带宽需求明显降低，所以电力消耗随之下降，性能则得到改善。\n`glInvalidateFramebuffer`和`glInvalidateSubFramebuffer`命令用于使整个帧缓冲区或者帧缓冲区的像素子区域失效：\n\n``` objc\n/**\n 使整个帧缓冲区失效\n\n @param target#> 必须设置为GL_READ_FRAMEBUFFER、GL_DRAW_FRAMEBUFFER或GL_FRAMEBUFFER description#>\n @param numAttachments#> attachments列表中的附着数量 description#>\n @param attachments#> 指定包含numAttachments个附着的数组的指针 description#>\n @return void\n */\nglInvalidateFramebuffer(GLenum target, GLsizei numAttachments, const GLenum *attachments);\n\n/**\n 使帧缓冲区的像素子区域失效\n\n @param target#> 必须设置为GL_READ_FRAMEBUFFER、GL_DRAW_FRAMEBUFFER或GL_FRAMEBUFFER description#>\n @param numAttachments#> attachments列表中的附着数量 description#>\n @param attachments#> 指定包含numAttachments个附着的数组的指针 description#>\n @param x，y#> 指定要失效的像素矩形的左下角原点（左下角为0，0） description#>\n @param width#> 指定要失效的像素矩形宽度 description#>\n @param height#> 指定要失效的像素矩形高度 description#>\n @return void\n */\nglInvalidateSubFramebuffer(GLenum target, GLsizei numAttachments, const GLenum *attachments, GLint x, GLint y, GLsizei width, GLsizei height);\n```\n\n# 删除帧缓冲区和渲染缓冲区对象\n\n在应用程序结束渲染缓冲区对象的使用之后，可以删除它们。删除渲染缓冲区和帧缓冲区对象与删除纹理对象非常相似。\n渲染缓冲区对象用`glDeleteRenderbuffers`API删除：\n\n``` objc\n/**\n 删除渲染缓冲区对象\n\n @param n#> 要删除的渲染缓冲区对象名称的数量 description#>\n @param renderbuffers#> 指向包含n个要删除的渲染x缓冲区对象名称的数组的指针 description#>\n @return void\n */\nglDeleteRenderbuffers(GLsizei n, const GLuint *renderbuffers);\n```\n\n`glDeleteRenderbuffers`删除`renderbuffers`中指定的渲染缓冲区对象。一旦删除了渲染缓冲区对象，就没有任何与之关联，对象被标记为未用，以后可以被重用，作为新的渲染缓冲区对象。删除当前绑定的渲染缓冲区对象时，该对象被删除，当前渲染缓冲区被重置为0。如果`renderbuffers`中指定的渲染缓冲区对象名称无效或者为0，则它们被忽略（不会生成任何错误）。而且，如果渲染缓冲区连接到当前绑定的帧缓冲区对象，则它首先要与帧缓冲区断开，然后才能被删除。\n帧缓冲区对象用`glDeleteFramebuffers`API删除：\n\n``` objc\n/**\n 删除帧缓冲区对象\n\n @param n#> 要删除的帧缓冲区对象名称的数量 description#>\n @param framebuffers#> 指向包含n个要删除的帧缓冲区对象名称的数组的指针 description#>\n @return void\n */\nglDeleteFramebuffers(GLsizei n, const GLuint *framebuffers);\n```\n\n`glDeleteFramebuffers`删除`framebuffers`中指定的帧缓冲区对象。一旦删除了帧缓冲区对象，该对象就不会有任何与之关联的状态，并被标记为未使用，以后可以作为新的帧缓冲区对象重用。删除当前绑定的帧缓冲区对象时，该对象被删除且当前帧缓冲区绑定重置为0。如果`framebuffers`中指定的帧缓冲区对象名称无效或者为0，则它们被忽略，不会生成任何错误。\n\n# 删除用作帧缓冲区附着的渲染缓冲区对象\n\n如果被删除的渲染缓冲区对象作为帧缓冲区对象的一个附着，会发生什么情况？如果要删除的帧缓冲区对象作为当前绑定的帧缓冲区对象中的一个附着，则`glDeleteRenderbuffers`将附着重置为0。如果要删除的渲染缓冲区对象是当前没有绑定的帧缓冲区对象的一个附着，则`glDeleteRenderbuffers`不会将这些附着重置为0。将这些被删除的渲染缓冲区对象与对应的帧缓冲区对象断开是应用程序的责任。\n\n## 读取像素和帧缓冲区对象\n\n`glReadPixels`命令从颜色缓冲区读取像素，并在一个用户分配的缓冲区中返回它们。读取的颜色缓冲区是窗口系统提供的帧缓冲区分配的颜色缓冲区，或者是当前绑定的帧缓冲区对象的颜色附着。当用`glBindBuffer`将一个非零的缓冲区对象绑定到`GL_PIXEL_PACK_BUFFER`时，`glReadPixels`命令可以立即返回，并调用DMA传输从帧缓冲区中读取像素，然后将数据写入像素缓冲区对象。\n`glReadPixels`支持多种`format`和`type`参数组合：`format`可以是`GL_RGBA`、`GL_RGBA_INTEGER`或者由查询`GL_IMPLEMENTATION_COLOR_READ_FORMAT`返回的特定于实现的值；`type`可以是`GL_UNSIGNED_BYTE`、`GL_UNSIGNED_INT`、`GL_INT`、`GL_FLOAT`或者由查询`GL_IMPLEMENTATION_COLOR_READ_TYPE`返回的特定于实现的值。返回的特定于实现的格式和类型取决于当前连接的颜色缓冲区的格式和类型。如果当前绑定的帧缓冲区改变，则这些值也可能改变。当前绑定的帧缓冲区对象改变时都必须查询这些值，以确定传递给`glReadPixels`的正确的特定于实现的格式和类型值。\n\n# 性能提示和技巧\n\n下面，我们讨论开发人员在使用帧缓冲区对象时应该认真考虑的性能提示：\n- 避免频繁地在渲染到窗口系统提供的帧缓冲区和渲染到帧缓冲区对象之间切换。这对于手持OpenGL ES 3.0实现是一个问题，因为许多这类实现使用块状渲染架构。在块状渲染架构中，使用专用的内部存储器存储帧缓冲区图块（区域）的颜色、深度和模板值。这些内部存储器在电源利用上更为高效，而且与外部内存相比具有更低的内存延迟和更大的带宽。在渲染到图块完成之后，图块被写到设备（系统）内存。每当从一个渲染目标切换到另一个，就需要渲染、保存和恢复对应的纹理和渲染缓冲区附着，这可能带来很大的代价。最佳的方法是首先渲染到场景中合适的帧缓冲区，然后渲染到窗口系统提供的帧缓冲区，最后执行`eglSwapBuffers`命令切换显示缓冲区。\n- 不要逐帧创建和删除帧缓冲区和渲染缓冲区对象（或者任何其他大型数据对象）。\n- 尝试避免修改用作渲染目标的帧缓冲区对象附着的纹理（使用`glTexImage2D`、`glTexSubImage2D`、`glCopyTexImage2D`等）。\n- 如果整个纹理图像将被渲染，则将`glTexImage2D`和`glTexImage3D`中的`pixel`参数设置为`NULL`，因为原始数据不会被使用。如果希望图像不包含任何预先定义的像素值，那么在绘制到纹理之前使用`glInvalidateFramebuffer`清除纹理图像。\n- 尽可能共享帧缓冲区对象使用的用作附着的深度和模板渲染缓冲区，以保障内存占用需求最小。\n\n# 总结\n\n这篇文章主要是对用于渲染到屏幕外表面的帧缓冲区对象的使用方法。","slug":"2019/opengl-es-framebuffer-0819","published":1,"updated":"2022-01-10T09:04:52.806Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cky8gmc4e0016d1qhpo15r5d1","content":"<blockquote>\n<p>在本篇中我们将描述帧缓冲区对象的概念、应用程序创建它们的方法以及应用程序使用它们渲染到屏幕外缓冲区或者纹理的方法。</p>\n</blockquote>\n<h1 id=\"为什么使用帧缓冲区对象\">为什么使用帧缓冲区对象</h1>\n<p>在应用程序调用任何OpenGL ES命令之前，需要首先创建一个渲染上下文和绘图表面，并使之成为现行上下文和表面。渲染上下文和绘图表面通常由原生窗口系统通过EGL等API提供。渲染上下文包含正确操作所需的对应状态。由原生窗口系统提供的绘图表面可以是一个在屏幕上显示的表面（称为窗口系统提供的帧缓冲区），也可以是屏幕外表面（称作pbuffer）。创建EGL绘图表面的调用让我们以像素数的形式指定表面的宽度和高度、表面是否使用颜色、深度和模板缓冲区以及这些缓冲区的位深。<br>\n默认情况下，OpenGL ES使用窗口系统提供的帧缓冲区作为绘图表面。如果应用程序只在屏幕上的表面绘图，则窗口系统提供的帧缓冲区通常很高效。但是，许多应用程序需要渲染到纹理，为此，使用窗口系统提供的帧缓冲区作为绘图表面通常不是理想的选择。<br>\n应用程序可以使用以下两种技术之一渲染到纹理：</p>\n<ul>\n<li>通过绘制到窗口系统提供的帧缓冲区，然后将帧缓冲区的对应区域复制到纹理来实现渲染到纹理。这可以用<code>glCopyTexImage2D</code>和<code>glCopyTexSubImage2D</code>API实现。顾名思义，这些API执行从帧缓冲区到纹理缓冲区的复制，这一复制操作往往对性能有不利影响。此外，这种方法只有在纹理的尺寸小于或者等于帧缓冲区尺寸的时候才有效。</li>\n<li>通过使用连接到纹理的pbuffer来实现渲染到纹理。我们知道，窗口系统提供的表面必须连接到一个渲染上下文。这在某些对每个pbuffer和窗口表面需要不同上下文的实现中可能效率低下。此外，在窗口系统提供的可绘制表面之间切换有时候需要OpenGL ES实现清除所有切换之前渲染的图像。这可能在渲染管线中造成代价很高的“起泡效应”（CPU闲置）。在这种系统上，我们建议避免使用pbuffer渲染到纹理，因为与上下文和窗口系统提供的可绘制表面之间的切换相关的开销很大。</li>\n</ul>\n<p>上述两种方法对于渲染到纹理或者其他屏幕外表面来说都不理想。作为替代，我们需要允许应用程序直接渲染到纹理的API，或者在OpenGL ES API中具备创建屏幕外表面的能力，并将它作为渲染目标。帧缓冲区对象和渲染缓冲区对象允许应用程序完成这些操作，不需要额外创建渲染上下文。结果是，我们在使用窗口系统提供的可绘制表面时，不再需要担心上下文和可绘制表面切换的开销。因此，帧缓冲区对象提供了渲染到纹理或者屏幕外表面的更好、更有效的方法。<br>\n帧缓冲区对象API支持如下操作：</p>\n<ul>\n<li>仅适用OpenGL ES命令创建帧缓冲区对象</li>\n<li>在单一EGL上下文中创建和使用多个缓冲区对象–也就是说，不需要每个帧缓冲区都有一个渲染上下文</li>\n<li>创建屏幕外颜色、深度或者模板渲染缓冲区和纹理，并将它们连接到帧缓冲区对象</li>\n<li>在多个帧缓冲区之间共享颜色、深度或者模板缓冲区</li>\n<li>将纹理直接连接到帧缓冲区作为颜色或者深度，从而避免了进行复制操作的必要</li>\n<li>在帧缓冲区之间复制并使帧缓冲区内容失效</li>\n</ul>\n<h1 id=\"帧缓冲区和渲染缓冲区对象\">帧缓冲区和渲染缓冲区对象</h1>\n<p>渲染缓冲区对象是一个由应用程序分配的2D图像缓冲区。渲染缓冲区可以用于分配和存储颜色、深度或者模板值，可以用作帧缓冲区对象中的颜色、深度或者模板附着。渲染缓冲区类似于屏幕外的窗口系统的可绘制表面–如pbuffer。但是，渲染缓冲区不能直接用作GL纹理。<br>\n帧缓冲区对象（FBO）是一组颜色、深度和模板纹理或者渲染目标。各种2D图像可以连接到帧缓冲区对象中的颜色附着点。这些附着点包括一个渲染缓冲区对象，它保存颜色值、2D纹理或者立方图面的mip级别、2D数组纹理的层次甚至3D纹理中一个2D切片的mip级别。同样，包含深度值的各种2D图像可以连接到FBO的深度附着点。这些附着点包括渲染缓冲区、2D纹理的mip级别或者保存深度值的一个立方图面。可以连接到FBO模板附着点的唯一2D图像是保存模板值的渲染缓冲区对象。<br>\n下图展示了帧缓冲区对象、渲染缓冲区对象和纹理之间的关系。注意，一个帧缓冲区对象中只能有一个颜色、深度和模板附着。</p>\n<p><img src=\"/img/article/20190819/1.png\" alt=\"帧缓冲区对象、渲染缓冲区对象和纹理\"></p>\n<h2 id=\"选择渲染缓冲区与纹理作为帧缓冲区附着的对比\">选择渲染缓冲区与纹理作为帧缓冲区附着的对比</h2>\n<p>对于渲染到纹理的用例，我们应该将一个纹理对象连接到帧缓冲区对象。这方面的例子包括渲染到一个用作颜色纹理的颜色缓冲区以及渲染到用作阴影的深度纹理的深度缓冲区。<br>\n使用渲染缓冲区代替纹理有以下几种原因：</p>\n<ul>\n<li>渲染缓冲区支持多重采样。</li>\n<li>如果图像没有被当做纹理使用，则使用渲染缓冲区可能带来性能上的好处。出现这种好处是因为OpenGL ES实现可能以更为高效的格式存储渲染缓冲区，比起纹理来说更适合于渲染。但是，如果预先知道图像不被用作纹理，那么OpenGL ES实现所能做的也仅仅如此。</li>\n</ul>\n<h2 id=\"帧缓冲区对象与egl表面的对比\">帧缓冲区对象与EGL表面的对比</h2>\n<p>FBO和窗口系统提供的可绘制表面之间的区别：</p>\n<ul>\n<li>像素归属测试确定帧缓冲区中(x<sub>w</sub>), y<sub>w</sub>)位置的像素目前是否归OpenGL ES所有，这个测试允许窗口系统控制帧缓冲区中的哪些像素属于OpenGL ES上下文–例如，当OpenGL ES渲染的窗口被遮蔽时。对于应用程序创建的帧缓冲区对象，像素归属测试始终成功，因为帧缓冲区对象拥有所有像素。</li>\n<li>窗口系统可能只支持双缓冲表面。相反，帧缓冲区对象只支持单缓冲区附着。</li>\n<li>使用帧缓冲区对象可以实现帧缓冲区之间模板和深度缓冲区的共享，而窗口系统提供的帧缓冲区通常不能实现这一功能。在窗口系统提供的可绘制表面中，模板和深度缓冲区及其对应的状态通常是隐含分配的，因此，无法在可绘制表面之间共享。对于应用程序创建的帧缓冲区对象，模板和深度缓冲区可以独立创建，然后在必要时通过将这些缓冲区连接到多个缓冲区对象中的对应连接点，实现与帧缓冲区对象的关联。</li>\n</ul>\n<h1 id=\"创建帧缓冲区和渲染缓冲区对象\">创建帧缓冲区和渲染缓冲区对象</h1>\n<p>创建帧缓冲区和渲染缓冲区对象类似于在OpenGL ES 3.0中创建纹理或者顶点缓冲区对象。<br>\n<code>glGenRenderbuffers</code>API调用用于分配渲染缓冲区对象名称：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 创建渲染缓冲区对象</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param n#&gt; 返回的渲染缓冲区对象名称的数量 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param renderbuffers#&gt; 返回一个有n个元素的数组的指针，分配的渲染缓冲区对象名称将在该数组中返回 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glGenRenderbuffers(GLsizei n, GLuint *renderbuffers);</span><br></pre></td></tr></table></figure>\n<p><code>glGenRenderbuffers</code>分配n个渲染缓冲区对象名称，并在<code>renderbuffers</code>中返回。由<code>glGenRenderbuffers</code>返回的渲染缓冲区对象名称是不为0的无符号整数。这些名称被标记为<code>在用</code>但是没有任何关联的状态。数值0由OpenGL ES保留，不能用于指代一个渲染缓冲区对象。试图修改或者查询帧缓冲区对象0的缓冲区对象状态的应用程序将产生一个对应的错误。<br>\n<code>glGenFramebuffers</code>API调用用于分配帧缓冲区对象名称：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 创建帧缓冲区对象</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param n#&gt; 返回的帧缓冲区对象名称的数量 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param framebuffers#&gt; 指向一个包含n个元素的数组的指针，分配的帧缓冲区对象在该数组中返回 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glGenFramebuffers(GLsizei n, GLuint *framebuffers);</span><br></pre></td></tr></table></figure>\n<p><code>glGenFramebuffers</code>分配n个帧缓冲区对象名称，并在<code>framebuffers</code>中返回它们。由<code>glGenFramebuffers</code>返回的帧缓冲区对象名称是不为0的无符号整数。这些名称被标记为“在用”但是没有任何关联的状态。数值0由OpenGL ES保留，不能用于指代一个窗口系统提供的帧缓冲区。视图修改或者查询帧缓冲区对象0的缓冲区对象状态的应用程序将产生一个对应的错误。</p>\n<h1 id=\"使用渲染缓冲区对象\">使用渲染缓冲区对象</h1>\n<p>要为特定的渲染缓冲区对象指定图像的数据存储、格式和尺寸，需要使该对象成为当前渲染缓冲区对象。<code>glBindRenderbuffer</code>命令用于设置当前渲染缓冲区对象：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 绑定渲染缓冲区对象</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param target#&gt; 必须设置为GL_RENDERBUFFER description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param renderbuffer#&gt; 渲染缓冲区对象名称 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glBindRenderbuffer(GLenum target, GLuint renderbuffer);</span><br></pre></td></tr></table></figure>\n<p>注意，<code>glGenRenderbuffers</code>不一定要在用<code>glBindRenderbuffer</code>绑定之前分配渲染缓冲区对象名称。虽然调用<code>glGenRenderbuffers</code>是一个好的做法，但许多应用程序还是为其缓冲区指定编译时常量。应用程序可以将未使用的渲染缓冲区名称指定到<code>glBindRenderbuffer</code>。但是，我们建议OpenGL ES应用程序调用<code>glGenRenderbuffers</code>，并使用<code>glGenRenderbuffers</code>返回的渲染缓冲区对象名称，而不是指定自己的缓冲区对象名称。<br>\n在第一次通过调用<code>glBindRenderbuffer</code>绑定渲染缓冲区对象名称时，渲染缓冲区对象被分配相应的默认状态。如果分配成功，分配的对象将成为新绑定的渲染缓冲区对象。下面是与渲染缓冲区对象相关的状态和默认值：</p>\n<ul>\n<li>以像素数表示的宽度和高度–默认值为0。</li>\n<li>内部格式–描述了渲染缓冲区中存储的像素格式，必须是颜色、深度或者模板可渲染格式。</li>\n<li>颜色位深–这只有在内部格式是颜色可渲染格式时有效。默认值为0。</li>\n<li>深度位深–这只有在内部格式是深度可渲染格式时有效。默认值为0。</li>\n<li>模板位深–这只有在内部格式是模板可渲染格式时有效。默认值为0。</li>\n</ul>\n<p><code>glBindRenderbuffer</code>也可以用于绑定到现有的渲染缓冲区对象（也就是之前已经分配使用因而有关联有效状态的缓冲区对象）。绑定命令对于新绑定的渲染缓冲区对象的状态不做任何改变。<br>\n一旦绑定渲染缓冲区对象，就可以指定保存在渲染缓冲区中的图像大小和格式。<code>glRenderbufferStorage</code>命令可用于这个目的。<br>\n除了不提供图像数据，<code>glRenderbufferStorage</code>看起来与<code>glTexImage2D</code>很相似。我们也可以使用<code>glRenderbufferStorageMultisample</code>命令创建一个多重采样渲染缓冲区。<code>glRenderbufferStorage</code>等价于样本数设置为0的<code>glRenderStorageMultisample</code>。渲染缓冲区的宽度和高度以像素数指定，其值必须小于OpenGL ES实现所支持的最大渲染缓冲区尺寸。所有OpenGL ES实现都支持的最小尺寸为1，实际支持的最大尺寸可以用如下代码查询：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GLint maxRenderbufferSize = <span class=\"number\">0</span>;</span><br><span class=\"line\">glGetIntegerv(GL_MAX_RENDERBUFFER_SIZE, &amp;maxRenderbufferSize);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 指定渲染缓冲区的图像大小和格式</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param target#&gt; 必须设置为GL_RENDERBUFFER description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param internalformat#&gt; 必须为可用于颜色缓冲区、深度缓冲区或者模板缓冲区的格式 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param width#&gt; 以像素数表示的渲染缓冲区宽度；必须小于或者等于GL_MAX_RENDERBUFFER_SIZE description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param height#&gt; 以像素数表示的渲染缓冲区高度；必须小于或者等于GL_MAX_RENDERBUFFER_SIZE description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glRenderbufferStorage(GLenum target, GLenum internalformat, GLsizei width, GLsizei height);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 创建一个多重采样渲染缓冲区</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param target#&gt; 必须设置为GL_RENDERBUFFER description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param samples#&gt; 用于渲染缓冲区对象存储的样本数。必须小于GL_MAX_SAMPLES description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param internalformat#&gt; 必须为可用于颜色缓冲区、深度缓冲区或者模板缓冲区的格式 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param width#&gt; 以像素数表示的渲染缓冲区宽度；必须小于或者等于GL_MAX_RENDERBUFFER_SIZE description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param height#&gt; 以像素数表示的渲染缓冲区高度；必须小于或者等于GL_MAX_RENDERBUFFER_SIZE description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glRenderbufferStorageMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);</span><br></pre></td></tr></table></figure>\n<p>渲染缓冲区对象可以连接到帧缓冲区对象的颜色、深度或者模板附着，而不需要指定渲染缓冲区存储格式和大小。渲染缓冲区的存储格式和大小可以在渲染缓冲区对象连接到帧缓冲区对象前后指定。但是，这些信息必须在帧缓冲区对象和渲染缓冲区附着用于渲染之前指定。</p>\n<h2 id=\"多重采样渲染缓冲区\">多重采样渲染缓冲区</h2>\n<p>多重采样渲染缓冲区使应用程序可以用多重采样抗锯齿技术渲染到屏幕外帧缓冲区。多重采样渲染缓冲区不能直接绑定到纹理，但是可以用新推出的<a href=\"#%E5%B8%A7%E7%BC%93%E5%86%B2%E5%8C%BA%E4%BD%8D%E5%9D%97%E4%BC%A0%E9%80%81\">帧缓冲区位块传送</a>解析为单采样纹理。</p>\n<h1 id=\"使用帧缓冲区对象\">使用帧缓冲区对象</h1>\n<p>我们将说明如何使用帧缓冲区对象渲染到一个屏幕外缓冲区（也就是渲染缓冲区）或者渲染到一个纹理。在使用帧缓冲区对象并指定其附着之前，需要使其成为当前帧缓冲区对象。<code>glBindFramebuffer</code>命令用于设置当前帧缓冲区对象：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 设置当前帧缓冲区对象</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param target#&gt; 必须设置为GL_READ_FRAMEBUFFER、GL_DRAW_FRAMEBUFFER或GL_FRAMEBUFFER description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param framebuffer#&gt; 帧缓冲区对象名称 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glBindFramebuffer(GLenum target, GLuint framebuffer);</span><br></pre></td></tr></table></figure>\n<p>注意，对于在用<code>glBindFramebuffer</code>绑定帧缓冲区对象之前指定其名称来说，<code>glGenFramebuffers</code>并不是必需的。应用程序可以将未用的帧缓冲区对象名称指定给<code>glBindFramebuffer</code>。但是，我们建议OpenGL ES应用程序调用<code>glGenFramebuffers</code>，并使用<code>glGenFramebuffers</code>返回的帧缓冲区对象名称，而不是指定自己的缓冲区对象名称。<br>\n在某些OpenGL ES 3.0实现上，当调用<code>glBindFramebuffer</code>首次绑定帧缓冲区对象名称时，为帧缓冲区对象分配对应的默认状态。如果分配成功，分配的对象将作为渲染上下文的当前缓冲区对象进行绑定。<br>\n与帧缓冲区对象相关的状态如下：</p>\n<ul>\n<li>颜色附着点–颜色缓冲区的附着点</li>\n<li>深度附着点–深度缓冲区的附着点</li>\n<li>模板附着点–模板缓冲区的附着点</li>\n<li>帧缓冲区完整性状态–帧缓冲器是否处于完整状态，是否可以用于渲染<br>\n对于每个附着点，指定如下信息：</li>\n<li>对象类型–指定与附着点相关的对象的类型。如果连接一个渲染缓冲区对象，则类型可以是<code>GL_RENDERBUFFER</code>；如果连接一个纹理对象，那么类型可以是<code>GL_TEXTURE</code>。默认值为<code>GL_NONE</code>。</li>\n<li>对象名称–指定连接的对象的名称，可以是渲染缓冲区对象名称或者纹理对象名称。默认值为0。</li>\n<li>纹理级别–如果连接一个纹理对象，则指定了与附着点线管的纹理的mip级别。默认值为0。</li>\n<li>纹理立方图面–如果连接一个纹理对象，切纹理为立方图，则指定了6个立方图面中哪一个用于该附着点。默认值为<code>GL_TEXTURE_CUBE_MAP_POSITIVE_X</code>。</li>\n<li>纹理层次–指定3D纹理中用于该附着点的2D切片。默认值为0。<br>\n<code>glBindFramebuffer</code>也可以用于绑定到现有的帧缓冲区对象（也就是之前已经分配并使用因而有相关的有效状态的对象）。新绑定的帧缓冲区对象的状态没有任何变化。<br>\n一旦绑定了帧缓冲区对象，当前绑定的帧缓冲区对象的颜色、深度和模板附着就可以设置为一个渲染缓冲区对象或者一个纹理。如下图所示，颜色附着可以设置为存储颜色值的渲染缓冲区、2D纹理的一个mip级别或者一个立方图面、2D数组纹理的一个层次或者3D纹理中一个2D切片的mip级别。深度附着可以设置为存储深度值或者经过打包的深度和模板值的渲染缓冲区、2D深度纹理的一个mip级别或者深度立方图面。模板附着必须设置为存储模板值或者打包的深度和模板值的渲染缓冲区。</li>\n</ul>\n<h2 id=\"连接渲染缓冲区作为帧缓冲区附着\">连接渲染缓冲区作为帧缓冲区附着</h2>\n<p><code>glFramebufferRenderbuffer</code>命令用于将一个渲染缓冲区对象连接到帧缓冲区附着点：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 将一个渲染缓冲区对象连接到帧缓冲区附着点</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param target#&gt; 必须设置为GL_READ_FRAMEBUFFER、GL_DRAW_FRAMEBUFFER或GL_FRAMEBUFFER description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param attachment#&gt; 必须为如下枚举值之一：GL_COLOR_ATTACHMENTi、GL_DEPTH_ATTACHMENT、GL_STENCIL_ATTACHMENT、GL_DEPTH_STENCIL_ATTACHMENT description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param renderbuffertarget#&gt; 必须设置为GL_RENDERBUFFER description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param renderbuffer#&gt; 应该用作附着的渲染缓冲区对象；必须为0或者现有渲染缓冲区对象名称 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glFramebufferRenderbuffer(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);</span><br></pre></td></tr></table></figure>\n<p>如果调用<code>glFramebufferRenderbuffer</code>时<code>renderbuffer</code>不为0，这个渲染缓冲区对象将被用作<code>attachment</code>参数值指定的新颜色、深度或者模板附着点。<br>\n附着点的状态将被修改为：</p>\n<ul>\n<li>对象类型 = GL_RENDERBUFFER</li>\n<li>对象名称 = renderbuffer</li>\n<li>纹理级别和纹理层次 = 0</li>\n<li>纹理立方图面 = GL_NONE</li>\n</ul>\n<p>新连接的渲染缓冲区对象状态或者缓冲区内容不做任何修改。<br>\n如果<code>glFramebufferRenderbuffer</code>调用中<code>renderbuffer</code>等于0，则<code>attachment</code>指定的颜色、深度或者模板缓冲区将被断开并重置为0。</p>\n<h2 id=\"连接一个2d纹理作为帧缓冲区附着\">连接一个2D纹理作为帧缓冲区附着</h2>\n<p><code>glFramebufferTexture2D</code>命令用于将一个2D纹理的某个mip级别或者立方图面连接到帧缓冲区附着点。它可以用来将纹理作为颜色、缓冲区或者模板附着点连接：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 将一个2D纹理的某个mip级别或者立方图面连接到帧缓冲区附着点</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param target#&gt; 必须设置为GL_READ_FRAMEBUFFER、GL_DRAW_FRAMEBUFFER、GL_FRAMEBUFFER description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param attachment#&gt; 必须为如下枚举值之一：GL_COLOR_ATTACHMENTi、GL_DEPTH_ATTACHMENT、GL_STENCIL_ATTACHMENT、GL_DEPTH_STENCIL_ATTACHMENT description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param textarget#&gt; 指定纹理目标；这是glTexImage2D中的target参数指定的值 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param texture#&gt; 指定纹理对象 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param level#&gt; 指定纹理图像的mip级别 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glFramebufferTexture2D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);</span><br></pre></td></tr></table></figure>\n<p>如果<code>glFramebufferTexture2D</code>调用中<code>texture</code>不为0，则颜色、深度或者模板附着将被设置为<code>texture</code>。如果<code>glFramebufferTexture2D</code>发生错误，帧缓冲区的状态将不做修改。<br>\n附着点状态将被修改为：</p>\n<ul>\n<li>对象类型 = GL_TEXTURE</li>\n<li>对象名称 = texture</li>\n<li>纹理级别 = level</li>\n<li>纹理立方图面在纹理附着为立方图时有效，是如下值之一： GL_TEXTURE_CUBE_MAP_POSITIVE_(X | Y | Z)，GL_TEXTURE_CUBE_MAP_NEGATIVE_(X | Y | Z)</li>\n<li>纹理层次 = 0<br>\n<code>glFramebufferTexture2D</code>不修改新连接的纹理对象状态或者图像内容。注意，纹理对象的状态和图像可以连接到帧缓冲区对象之后修改。<br>\n如果<code>glFramebufferTexture2D</code>调用中<code>texture</code>等于0，则颜色、深度或者模板附着将被断开并重置为0。</li>\n</ul>\n<h2 id=\"连接3d纹理的一个图像作为帧缓冲区附着\">连接3D纹理的一个图像作为帧缓冲区附着</h2>\n<p><code>glFramebufferTextureLayer</code>命令用于将3D纹理的一个2D切片或者某个mip级别或者2D数组纹理的一个级别连接到帧缓冲区附着点。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 将3D纹理的一个2D切片或者某个mip级别或者2D数组纹理的一个级别连接到帧缓冲区附着点</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param target#&gt; 必须设置为GL_READ_FRAMEBUFFER、GL_DRAW_FRAMEBUFFER、GL_FRAMEBUFFER description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param attachment#&gt; 必须为如下枚举值之一：GL_COLOR_ATTACHMENTi、GL_DEPTH_ATTACHMENT、GL_STENCIL_ATTACHMENT、GL_DEPTH_STENCIL_ATTACHMENT description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param texture#&gt; 指定纹理对象 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param level#&gt; 指定纹理图像的mip级别 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param layer#&gt; 指定纹理图像层次。如果texture是GL_TEXTURE_CUBE_MAP_3D，则level必须大于或等于0并且小于或等于GL_MAX3D_TEXTURE_SIZE值以2位底的对数。如果texture是GL_TEXTURE_2D_ARRAY，则level必须大于或等于0且不大于GL_MAX_TEXTURE_SIZE值以2为底的对数 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glFramebufferTextureLayer(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer);</span><br></pre></td></tr></table></figure>\n<p><code>glFramebufferTextureLayer</code>不修改新连接的纹理对象状态或者其图像的内容。注意，纹理对象的状态和图像可以在连接到帧缓冲器对象之后修改。<br>\n附着点的状态被修改为：</p>\n<ul>\n<li>对象类型 = GL_TEXTURE</li>\n<li>对象名称 = texture</li>\n<li>纹理级别 = level</li>\n<li>纹理立方图面 = GL_NONE</li>\n<li>纹理层次 = 0<br>\n如果<code>glFramebufferTextureLayer</code>调用中<code>texture</code>等于0，则附着将被断开并重置为0。</li>\n</ul>\n<h2 id=\"检查帧缓冲区完整性\">检查帧缓冲区完整性</h2>\n<p>帧缓冲区对象必须定义为完整的才能够用作渲染目标。如果当前绑定的帧缓冲区对象不完整，绘制图元或者读取像素的OpenGL ES命令将会失败，并产生表示帧缓冲区不完整原因的对应错误。<br>\n帧缓冲区对象被视为完整的规则如下：</p>\n<ul>\n<li>确保颜色、深度和模板附着有效。帧缓冲区至少有一个有效的附着，如果没有任何附着，帧缓冲区就是不完整的，因为没有可以绘制或者读取的区域。</li>\n<li>与帧缓冲区对象相关的有效附着必须由相同的宽度和高度。</li>\n<li>如果存在深度和模板附着，则它们必须是相同的图像。</li>\n<li>所有渲染缓冲区附着的<code>GL_RENDERBUFFER_SAMPLES</code>值都相同。如果附着是渲染缓冲区和纹理的组合，则<code>GL_RENDERBUFFER_SAMPLES</code>的值为0。</li>\n</ul>\n<p><code>glCheckFramebufferStatus</code>命令可用于验证帧缓冲区对象是否完整：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 验证帧缓冲区对象是否完整</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param target#&gt; 必须设置为GL_READ_FRAMEBUFFER、GL_DRAW_FRMAEBUFFER或GL_FRAMEBUFFER description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glCheckFramebufferStatus(GLenum target);</span><br></pre></td></tr></table></figure>\n<p>如果<code>target</code>不等于<code>GL_FRAMEBUFFER</code>，则<code>glCheckFramebufferStatus</code>返回0。如果<code>target</code>等于<code>GL_FRAMEBUFFER</code>，则返回如下枚举值之一：</p>\n<ul>\n<li>GL_FRAMEBUFFER_COMPLETE – 帧缓冲区完整</li>\n<li>GL_FRAMEBUFFER_UNDEFINED – 如果<code>target</code>是默认的帧缓冲区但是它不存在</li>\n<li>GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT – 帧缓冲区附着点不完整。这可能是因为需要的附着为0，或者不是有效纹理或渲染缓冲区对象</li>\n<li>GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT – 帧缓冲区中没有有效的附着</li>\n<li>GL_FRAMEBUFFER_UNSUPPORTED – 帧缓冲区中的附着使用的内部格式组合造成不可渲染的目标</li>\n<li>GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE – 所有渲染缓冲区附着的GL_RENDERBUFFER_SAMPLES不都相同，或者GL_RENDERBUFFER_SAMPLES在附着是渲染缓冲区和纹理的组合时不为0</li>\n</ul>\n<p>如果当前绑定的帧缓冲区对象不完整，则试图使用该对象读取和写入像素将会失败。接着，绘制图元的调用（如<code>glDrawArrays</code>和<code>glDrawElements</code>）和读取帧缓冲区的命令（如<code>glReadPixels</code>、<code>glCopyTeximage2D</code>、<code>glCopyTexSubimage2D</code>和<code>glCopyTexSubimage3D</code>）将生成一个<code>GL_INVALID_FRAMEBUFFER_OPERATION</code>错误。</p>\n<h1 id=\"帧缓冲区位块传送\">帧缓冲区位块传送</h1>\n<p>帧缓冲区位块传送（Blit）可以高效地将一个矩形区域的像素值从一个帧缓冲区（读帧缓冲区）复制到另一个帧缓冲区（绘图帧缓冲区）。帧缓冲区位块传送的关键应用之一是将一个多重采样渲染缓冲区解析为一个纹理（用一个帧缓冲区对象，纹理绑定为它的颜色附着）。<br>\n可以用如下命令执行上述操作：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 将一个矩形区域的像素从一个帧缓冲区复制到另一个帧缓冲区</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param srcX0，srcY0，srcX1，srcY1#&gt; 指定读缓冲区内的来源矩形的边界 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param dstX0，dstY0，dstX1，dstY1#&gt; 指定写缓冲区内的目标矩形的边界 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param mask#&gt; 指定表示哪些缓冲区被复制的标识的按位或；组成如下：GL_COLOR_BUFFER_BIT，GL_DEPTH_BUFFER_BIT，GL_STENCIL_BUFFER_BIT，GL_DEPTH_STENCIL_ATTACHMENT description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param filter#&gt; 指定图像被拉伸时应用的插值；必须为GL_NEAREST或GL_LINEAR description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glBlitFramebuffer(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);</span><br></pre></td></tr></table></figure>\n<p>举例：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// set the default framebuffer for writing</span></span><br><span class=\"line\">glBindFramebuffer(GL_DRAW_FRAMEBUFFER, defaultFramebuffer);</span><br><span class=\"line\"><span class=\"comment\">// set the fbo with color attachments for reading</span></span><br><span class=\"line\">glBindFramebuffer(GL_READ_FRAMEBUFFER, fbo);</span><br><span class=\"line\"><span class=\"comment\">// copy the output buffer to target</span></span><br><span class=\"line\">glReadBuffer(GL_COLOR_ATTACHMENT0);</span><br><span class=\"line\">glBlitFramebuffer(<span class=\"number\">0</span>, <span class=\"number\">0</span>, width, height, <span class=\"number\">0</span>, <span class=\"number\">0</span>, width/<span class=\"number\">2</span>, height, GL_COLOR_BUFFER_BIT, GL_LINEAR);</span><br><span class=\"line\">glReadBuffer(GL_COLOR_ATTACHMENT1);</span><br><span class=\"line\">glBlitFramebuffer(<span class=\"number\">0</span>, <span class=\"number\">0</span>, width, height, width/<span class=\"number\">2</span>, <span class=\"number\">0</span>, width/<span class=\"number\">2</span>, height, GL_COLOR_BUFFER_BIT, GL_LINEAR);</span><br></pre></td></tr></table></figure>\n<h1 id=\"帧缓冲区失效\">帧缓冲区失效</h1>\n<p>帧缓冲区失效为应用程序提供了一个通知驱动程序不再需要帧缓冲区内容的机制。这使得驱动程序可以采取多种优化步骤：（1）跳过在块状渲染（TBR）架构中为了进一步渲染到帧缓冲区而做的不必要的图块内容恢复，（2）跳过多CPU系统中GPU之间不必要的数据复制，（3）跳过某些实现中为了改进性能而对特定缓存的刷新。这种功能对于许多应用程序中实现峰值性能很重要，特别是那些执行大量屏幕外渲染的应用。<br>\n让我们研究一下TBR GPU的设计，以理解帧缓冲区失效对这些GPU的重要性。TBR GPU尝尝部署在移动设备上，以最小化GPU和系统内存之间的数据传输量，从而减少最大的电力消耗者之一–内存带宽。这通过添加能够保存少量像素数据的芯片内建快速存储器来实现。然后，帧缓冲区被分为许多个图块。对于每个图块，图元被渲染到芯片内建的存储器中，然后结果在完成时被复制到系统内存。因为每个像素的最少量数据（最终像素结果）被复制到系统内存，所以这种方法节约了GPU和系统内存之间的内存带宽。<br>\n有了帧缓冲区失效机制，GPU就可以删除不再需要的帧缓冲区内容，以减少每个帧保留的内容数量。此外，如果图块数据不再有效，GPU还可以消除从芯片内建存储器到系统内存不必要的数据传输，因为GPU和系统内存之间内存带宽需求明显降低，所以电力消耗随之下降，性能则得到改善。<br>\n<code>glInvalidateFramebuffer</code>和<code>glInvalidateSubFramebuffer</code>命令用于使整个帧缓冲区或者帧缓冲区的像素子区域失效：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 使整个帧缓冲区失效</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param target#&gt; 必须设置为GL_READ_FRAMEBUFFER、GL_DRAW_FRAMEBUFFER或GL_FRAMEBUFFER description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param numAttachments#&gt; attachments列表中的附着数量 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param attachments#&gt; 指定包含numAttachments个附着的数组的指针 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glInvalidateFramebuffer(GLenum target, GLsizei numAttachments, <span class=\"keyword\">const</span> GLenum *attachments);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 使帧缓冲区的像素子区域失效</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param target#&gt; 必须设置为GL_READ_FRAMEBUFFER、GL_DRAW_FRAMEBUFFER或GL_FRAMEBUFFER description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param numAttachments#&gt; attachments列表中的附着数量 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param attachments#&gt; 指定包含numAttachments个附着的数组的指针 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param x，y#&gt; 指定要失效的像素矩形的左下角原点（左下角为0，0） description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param width#&gt; 指定要失效的像素矩形宽度 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param height#&gt; 指定要失效的像素矩形高度 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glInvalidateSubFramebuffer(GLenum target, GLsizei numAttachments, <span class=\"keyword\">const</span> GLenum *attachments, GLint x, GLint y, GLsizei width, GLsizei height);</span><br></pre></td></tr></table></figure>\n<h1 id=\"删除帧缓冲区和渲染缓冲区对象\">删除帧缓冲区和渲染缓冲区对象</h1>\n<p>在应用程序结束渲染缓冲区对象的使用之后，可以删除它们。删除渲染缓冲区和帧缓冲区对象与删除纹理对象非常相似。<br>\n渲染缓冲区对象用<code>glDeleteRenderbuffers</code>API删除：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 删除渲染缓冲区对象</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param n#&gt; 要删除的渲染缓冲区对象名称的数量 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param renderbuffers#&gt; 指向包含n个要删除的渲染x缓冲区对象名称的数组的指针 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glDeleteRenderbuffers(GLsizei n, <span class=\"keyword\">const</span> GLuint *renderbuffers);</span><br></pre></td></tr></table></figure>\n<p><code>glDeleteRenderbuffers</code>删除<code>renderbuffers</code>中指定的渲染缓冲区对象。一旦删除了渲染缓冲区对象，就没有任何与之关联，对象被标记为未用，以后可以被重用，作为新的渲染缓冲区对象。删除当前绑定的渲染缓冲区对象时，该对象被删除，当前渲染缓冲区被重置为0。如果<code>renderbuffers</code>中指定的渲染缓冲区对象名称无效或者为0，则它们被忽略（不会生成任何错误）。而且，如果渲染缓冲区连接到当前绑定的帧缓冲区对象，则它首先要与帧缓冲区断开，然后才能被删除。<br>\n帧缓冲区对象用<code>glDeleteFramebuffers</code>API删除：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 删除帧缓冲区对象</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param n#&gt; 要删除的帧缓冲区对象名称的数量 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param framebuffers#&gt; 指向包含n个要删除的帧缓冲区对象名称的数组的指针 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glDeleteFramebuffers(GLsizei n, <span class=\"keyword\">const</span> GLuint *framebuffers);</span><br></pre></td></tr></table></figure>\n<p><code>glDeleteFramebuffers</code>删除<code>framebuffers</code>中指定的帧缓冲区对象。一旦删除了帧缓冲区对象，该对象就不会有任何与之关联的状态，并被标记为未使用，以后可以作为新的帧缓冲区对象重用。删除当前绑定的帧缓冲区对象时，该对象被删除且当前帧缓冲区绑定重置为0。如果<code>framebuffers</code>中指定的帧缓冲区对象名称无效或者为0，则它们被忽略，不会生成任何错误。</p>\n<h1 id=\"删除用作帧缓冲区附着的渲染缓冲区对象\">删除用作帧缓冲区附着的渲染缓冲区对象</h1>\n<p>如果被删除的渲染缓冲区对象作为帧缓冲区对象的一个附着，会发生什么情况？如果要删除的帧缓冲区对象作为当前绑定的帧缓冲区对象中的一个附着，则<code>glDeleteRenderbuffers</code>将附着重置为0。如果要删除的渲染缓冲区对象是当前没有绑定的帧缓冲区对象的一个附着，则<code>glDeleteRenderbuffers</code>不会将这些附着重置为0。将这些被删除的渲染缓冲区对象与对应的帧缓冲区对象断开是应用程序的责任。</p>\n<h2 id=\"读取像素和帧缓冲区对象\">读取像素和帧缓冲区对象</h2>\n<p><code>glReadPixels</code>命令从颜色缓冲区读取像素，并在一个用户分配的缓冲区中返回它们。读取的颜色缓冲区是窗口系统提供的帧缓冲区分配的颜色缓冲区，或者是当前绑定的帧缓冲区对象的颜色附着。当用<code>glBindBuffer</code>将一个非零的缓冲区对象绑定到<code>GL_PIXEL_PACK_BUFFER</code>时，<code>glReadPixels</code>命令可以立即返回，并调用DMA传输从帧缓冲区中读取像素，然后将数据写入像素缓冲区对象。<br>\n<code>glReadPixels</code>支持多种<code>format</code>和<code>type</code>参数组合：<code>format</code>可以是<code>GL_RGBA</code>、<code>GL_RGBA_INTEGER</code>或者由查询<code>GL_IMPLEMENTATION_COLOR_READ_FORMAT</code>返回的特定于实现的值；<code>type</code>可以是<code>GL_UNSIGNED_BYTE</code>、<code>GL_UNSIGNED_INT</code>、<code>GL_INT</code>、<code>GL_FLOAT</code>或者由查询<code>GL_IMPLEMENTATION_COLOR_READ_TYPE</code>返回的特定于实现的值。返回的特定于实现的格式和类型取决于当前连接的颜色缓冲区的格式和类型。如果当前绑定的帧缓冲区改变，则这些值也可能改变。当前绑定的帧缓冲区对象改变时都必须查询这些值，以确定传递给<code>glReadPixels</code>的正确的特定于实现的格式和类型值。</p>\n<h1 id=\"性能提示和技巧\">性能提示和技巧</h1>\n<p>下面，我们讨论开发人员在使用帧缓冲区对象时应该认真考虑的性能提示：</p>\n<ul>\n<li>避免频繁地在渲染到窗口系统提供的帧缓冲区和渲染到帧缓冲区对象之间切换。这对于手持OpenGL ES 3.0实现是一个问题，因为许多这类实现使用块状渲染架构。在块状渲染架构中，使用专用的内部存储器存储帧缓冲区图块（区域）的颜色、深度和模板值。这些内部存储器在电源利用上更为高效，而且与外部内存相比具有更低的内存延迟和更大的带宽。在渲染到图块完成之后，图块被写到设备（系统）内存。每当从一个渲染目标切换到另一个，就需要渲染、保存和恢复对应的纹理和渲染缓冲区附着，这可能带来很大的代价。最佳的方法是首先渲染到场景中合适的帧缓冲区，然后渲染到窗口系统提供的帧缓冲区，最后执行<code>eglSwapBuffers</code>命令切换显示缓冲区。</li>\n<li>不要逐帧创建和删除帧缓冲区和渲染缓冲区对象（或者任何其他大型数据对象）。</li>\n<li>尝试避免修改用作渲染目标的帧缓冲区对象附着的纹理（使用<code>glTexImage2D</code>、<code>glTexSubImage2D</code>、<code>glCopyTexImage2D</code>等）。</li>\n<li>如果整个纹理图像将被渲染，则将<code>glTexImage2D</code>和<code>glTexImage3D</code>中的<code>pixel</code>参数设置为<code>NULL</code>，因为原始数据不会被使用。如果希望图像不包含任何预先定义的像素值，那么在绘制到纹理之前使用<code>glInvalidateFramebuffer</code>清除纹理图像。</li>\n<li>尽可能共享帧缓冲区对象使用的用作附着的深度和模板渲染缓冲区，以保障内存占用需求最小。</li>\n</ul>\n<h1 id=\"总结\">总结</h1>\n<p>这篇文章主要是对用于渲染到屏幕外表面的帧缓冲区对象的使用方法。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>在本篇中我们将描述帧缓冲区对象的概念、应用程序创建它们的方法以及应用程序使用它们渲染到屏幕外缓冲区或者纹理的方法。</p>\n</blockquote>\n<h1>为什么使用帧缓冲区对象</h1>\n<p>在应用程序调用任何OpenGL ES命令之前，需要首先创建一个渲染上下文和绘图表面，并使之成为现行上下文和表面。渲染上下文和绘图表面通常由原生窗口系统通过EGL等API提供。渲染上下文包含正确操作所需的对应状态。由原生窗口系统提供的绘图表面可以是一个在屏幕上显示的表面（称为窗口系统提供的帧缓冲区），也可以是屏幕外表面（称作pbuffer）。创建EGL绘图表面的调用让我们以像素数的形式指定表面的宽度和高度、表面是否使用颜色、深度和模板缓冲区以及这些缓冲区的位深。<br>\n默认情况下，OpenGL ES使用窗口系统提供的帧缓冲区作为绘图表面。如果应用程序只在屏幕上的表面绘图，则窗口系统提供的帧缓冲区通常很高效。但是，许多应用程序需要渲染到纹理，为此，使用窗口系统提供的帧缓冲区作为绘图表面通常不是理想的选择。<br>\n应用程序可以使用以下两种技术之一渲染到纹理：</p>\n<ul>\n<li>通过绘制到窗口系统提供的帧缓冲区，然后将帧缓冲区的对应区域复制到纹理来实现渲染到纹理。这可以用<code>glCopyTexImage2D</code>和<code>glCopyTexSubImage2D</code>API实现。顾名思义，这些API执行从帧缓冲区到纹理缓冲区的复制，这一复制操作往往对性能有不利影响。此外，这种方法只有在纹理的尺寸小于或者等于帧缓冲区尺寸的时候才有效。</li>\n<li>通过使用连接到纹理的pbuffer来实现渲染到纹理。我们知道，窗口系统提供的表面必须连接到一个渲染上下文。这在某些对每个pbuffer和窗口表面需要不同上下文的实现中可能效率低下。此外，在窗口系统提供的可绘制表面之间切换有时候需要OpenGL ES实现清除所有切换之前渲染的图像。这可能在渲染管线中造成代价很高的“起泡效应”（CPU闲置）。在这种系统上，我们建议避免使用pbuffer渲染到纹理，因为与上下文和窗口系统提供的可绘制表面之间的切换相关的开销很大。</li>\n</ul>\n<p>上述两种方法对于渲染到纹理或者其他屏幕外表面来说都不理想。作为替代，我们需要允许应用程序直接渲染到纹理的API，或者在OpenGL ES API中具备创建屏幕外表面的能力，并将它作为渲染目标。帧缓冲区对象和渲染缓冲区对象允许应用程序完成这些操作，不需要额外创建渲染上下文。结果是，我们在使用窗口系统提供的可绘制表面时，不再需要担心上下文和可绘制表面切换的开销。因此，帧缓冲区对象提供了渲染到纹理或者屏幕外表面的更好、更有效的方法。<br>\n帧缓冲区对象API支持如下操作：</p>\n<ul>\n<li>仅适用OpenGL ES命令创建帧缓冲区对象</li>\n<li>在单一EGL上下文中创建和使用多个缓冲区对象–也就是说，不需要每个帧缓冲区都有一个渲染上下文</li>\n<li>创建屏幕外颜色、深度或者模板渲染缓冲区和纹理，并将它们连接到帧缓冲区对象</li>\n<li>在多个帧缓冲区之间共享颜色、深度或者模板缓冲区</li>\n<li>将纹理直接连接到帧缓冲区作为颜色或者深度，从而避免了进行复制操作的必要</li>\n<li>在帧缓冲区之间复制并使帧缓冲区内容失效</li>\n</ul>\n<h1>帧缓冲区和渲染缓冲区对象</h1>\n<p>渲染缓冲区对象是一个由应用程序分配的2D图像缓冲区。渲染缓冲区可以用于分配和存储颜色、深度或者模板值，可以用作帧缓冲区对象中的颜色、深度或者模板附着。渲染缓冲区类似于屏幕外的窗口系统的可绘制表面–如pbuffer。但是，渲染缓冲区不能直接用作GL纹理。<br>\n帧缓冲区对象（FBO）是一组颜色、深度和模板纹理或者渲染目标。各种2D图像可以连接到帧缓冲区对象中的颜色附着点。这些附着点包括一个渲染缓冲区对象，它保存颜色值、2D纹理或者立方图面的mip级别、2D数组纹理的层次甚至3D纹理中一个2D切片的mip级别。同样，包含深度值的各种2D图像可以连接到FBO的深度附着点。这些附着点包括渲染缓冲区、2D纹理的mip级别或者保存深度值的一个立方图面。可以连接到FBO模板附着点的唯一2D图像是保存模板值的渲染缓冲区对象。<br>\n下图展示了帧缓冲区对象、渲染缓冲区对象和纹理之间的关系。注意，一个帧缓冲区对象中只能有一个颜色、深度和模板附着。</p>\n<p><img src=\"/img/article/20190819/1.png\" alt=\"帧缓冲区对象、渲染缓冲区对象和纹理\"></p>\n<h2>选择渲染缓冲区与纹理作为帧缓冲区附着的对比</h2>\n<p>对于渲染到纹理的用例，我们应该将一个纹理对象连接到帧缓冲区对象。这方面的例子包括渲染到一个用作颜色纹理的颜色缓冲区以及渲染到用作阴影的深度纹理的深度缓冲区。<br>\n使用渲染缓冲区代替纹理有以下几种原因：</p>\n<ul>\n<li>渲染缓冲区支持多重采样。</li>\n<li>如果图像没有被当做纹理使用，则使用渲染缓冲区可能带来性能上的好处。出现这种好处是因为OpenGL ES实现可能以更为高效的格式存储渲染缓冲区，比起纹理来说更适合于渲染。但是，如果预先知道图像不被用作纹理，那么OpenGL ES实现所能做的也仅仅如此。</li>\n</ul>\n<h2>帧缓冲区对象与EGL表面的对比</h2>\n<p>FBO和窗口系统提供的可绘制表面之间的区别：</p>\n<ul>\n<li>像素归属测试确定帧缓冲区中(x<sub>w</sub>), y<sub>w</sub>)位置的像素目前是否归OpenGL ES所有，这个测试允许窗口系统控制帧缓冲区中的哪些像素属于OpenGL ES上下文–例如，当OpenGL ES渲染的窗口被遮蔽时。对于应用程序创建的帧缓冲区对象，像素归属测试始终成功，因为帧缓冲区对象拥有所有像素。</li>\n<li>窗口系统可能只支持双缓冲表面。相反，帧缓冲区对象只支持单缓冲区附着。</li>\n<li>使用帧缓冲区对象可以实现帧缓冲区之间模板和深度缓冲区的共享，而窗口系统提供的帧缓冲区通常不能实现这一功能。在窗口系统提供的可绘制表面中，模板和深度缓冲区及其对应的状态通常是隐含分配的，因此，无法在可绘制表面之间共享。对于应用程序创建的帧缓冲区对象，模板和深度缓冲区可以独立创建，然后在必要时通过将这些缓冲区连接到多个缓冲区对象中的对应连接点，实现与帧缓冲区对象的关联。</li>\n</ul>\n<h1>创建帧缓冲区和渲染缓冲区对象</h1>\n<p>创建帧缓冲区和渲染缓冲区对象类似于在OpenGL ES 3.0中创建纹理或者顶点缓冲区对象。<br>\n<code>glGenRenderbuffers</code>API调用用于分配渲染缓冲区对象名称：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 创建渲染缓冲区对象</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param n#&gt; 返回的渲染缓冲区对象名称的数量 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param renderbuffers#&gt; 返回一个有n个元素的数组的指针，分配的渲染缓冲区对象名称将在该数组中返回 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glGenRenderbuffers(GLsizei n, GLuint *renderbuffers);</span><br></pre></td></tr></table></figure>\n<p><code>glGenRenderbuffers</code>分配n个渲染缓冲区对象名称，并在<code>renderbuffers</code>中返回。由<code>glGenRenderbuffers</code>返回的渲染缓冲区对象名称是不为0的无符号整数。这些名称被标记为<code>在用</code>但是没有任何关联的状态。数值0由OpenGL ES保留，不能用于指代一个渲染缓冲区对象。试图修改或者查询帧缓冲区对象0的缓冲区对象状态的应用程序将产生一个对应的错误。<br>\n<code>glGenFramebuffers</code>API调用用于分配帧缓冲区对象名称：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 创建帧缓冲区对象</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param n#&gt; 返回的帧缓冲区对象名称的数量 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param framebuffers#&gt; 指向一个包含n个元素的数组的指针，分配的帧缓冲区对象在该数组中返回 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glGenFramebuffers(GLsizei n, GLuint *framebuffers);</span><br></pre></td></tr></table></figure>\n<p><code>glGenFramebuffers</code>分配n个帧缓冲区对象名称，并在<code>framebuffers</code>中返回它们。由<code>glGenFramebuffers</code>返回的帧缓冲区对象名称是不为0的无符号整数。这些名称被标记为“在用”但是没有任何关联的状态。数值0由OpenGL ES保留，不能用于指代一个窗口系统提供的帧缓冲区。视图修改或者查询帧缓冲区对象0的缓冲区对象状态的应用程序将产生一个对应的错误。</p>\n<h1>使用渲染缓冲区对象</h1>\n<p>要为特定的渲染缓冲区对象指定图像的数据存储、格式和尺寸，需要使该对象成为当前渲染缓冲区对象。<code>glBindRenderbuffer</code>命令用于设置当前渲染缓冲区对象：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 绑定渲染缓冲区对象</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param target#&gt; 必须设置为GL_RENDERBUFFER description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param renderbuffer#&gt; 渲染缓冲区对象名称 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glBindRenderbuffer(GLenum target, GLuint renderbuffer);</span><br></pre></td></tr></table></figure>\n<p>注意，<code>glGenRenderbuffers</code>不一定要在用<code>glBindRenderbuffer</code>绑定之前分配渲染缓冲区对象名称。虽然调用<code>glGenRenderbuffers</code>是一个好的做法，但许多应用程序还是为其缓冲区指定编译时常量。应用程序可以将未使用的渲染缓冲区名称指定到<code>glBindRenderbuffer</code>。但是，我们建议OpenGL ES应用程序调用<code>glGenRenderbuffers</code>，并使用<code>glGenRenderbuffers</code>返回的渲染缓冲区对象名称，而不是指定自己的缓冲区对象名称。<br>\n在第一次通过调用<code>glBindRenderbuffer</code>绑定渲染缓冲区对象名称时，渲染缓冲区对象被分配相应的默认状态。如果分配成功，分配的对象将成为新绑定的渲染缓冲区对象。下面是与渲染缓冲区对象相关的状态和默认值：</p>\n<ul>\n<li>以像素数表示的宽度和高度–默认值为0。</li>\n<li>内部格式–描述了渲染缓冲区中存储的像素格式，必须是颜色、深度或者模板可渲染格式。</li>\n<li>颜色位深–这只有在内部格式是颜色可渲染格式时有效。默认值为0。</li>\n<li>深度位深–这只有在内部格式是深度可渲染格式时有效。默认值为0。</li>\n<li>模板位深–这只有在内部格式是模板可渲染格式时有效。默认值为0。</li>\n</ul>\n<p><code>glBindRenderbuffer</code>也可以用于绑定到现有的渲染缓冲区对象（也就是之前已经分配使用因而有关联有效状态的缓冲区对象）。绑定命令对于新绑定的渲染缓冲区对象的状态不做任何改变。<br>\n一旦绑定渲染缓冲区对象，就可以指定保存在渲染缓冲区中的图像大小和格式。<code>glRenderbufferStorage</code>命令可用于这个目的。<br>\n除了不提供图像数据，<code>glRenderbufferStorage</code>看起来与<code>glTexImage2D</code>很相似。我们也可以使用<code>glRenderbufferStorageMultisample</code>命令创建一个多重采样渲染缓冲区。<code>glRenderbufferStorage</code>等价于样本数设置为0的<code>glRenderStorageMultisample</code>。渲染缓冲区的宽度和高度以像素数指定，其值必须小于OpenGL ES实现所支持的最大渲染缓冲区尺寸。所有OpenGL ES实现都支持的最小尺寸为1，实际支持的最大尺寸可以用如下代码查询：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GLint maxRenderbufferSize = <span class=\"number\">0</span>;</span><br><span class=\"line\">glGetIntegerv(GL_MAX_RENDERBUFFER_SIZE, &amp;maxRenderbufferSize);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 指定渲染缓冲区的图像大小和格式</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param target#&gt; 必须设置为GL_RENDERBUFFER description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param internalformat#&gt; 必须为可用于颜色缓冲区、深度缓冲区或者模板缓冲区的格式 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param width#&gt; 以像素数表示的渲染缓冲区宽度；必须小于或者等于GL_MAX_RENDERBUFFER_SIZE description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param height#&gt; 以像素数表示的渲染缓冲区高度；必须小于或者等于GL_MAX_RENDERBUFFER_SIZE description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glRenderbufferStorage(GLenum target, GLenum internalformat, GLsizei width, GLsizei height);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 创建一个多重采样渲染缓冲区</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param target#&gt; 必须设置为GL_RENDERBUFFER description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param samples#&gt; 用于渲染缓冲区对象存储的样本数。必须小于GL_MAX_SAMPLES description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param internalformat#&gt; 必须为可用于颜色缓冲区、深度缓冲区或者模板缓冲区的格式 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param width#&gt; 以像素数表示的渲染缓冲区宽度；必须小于或者等于GL_MAX_RENDERBUFFER_SIZE description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param height#&gt; 以像素数表示的渲染缓冲区高度；必须小于或者等于GL_MAX_RENDERBUFFER_SIZE description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glRenderbufferStorageMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);</span><br></pre></td></tr></table></figure>\n<p>渲染缓冲区对象可以连接到帧缓冲区对象的颜色、深度或者模板附着，而不需要指定渲染缓冲区存储格式和大小。渲染缓冲区的存储格式和大小可以在渲染缓冲区对象连接到帧缓冲区对象前后指定。但是，这些信息必须在帧缓冲区对象和渲染缓冲区附着用于渲染之前指定。</p>\n<h2>多重采样渲染缓冲区</h2>\n<p>多重采样渲染缓冲区使应用程序可以用多重采样抗锯齿技术渲染到屏幕外帧缓冲区。多重采样渲染缓冲区不能直接绑定到纹理，但是可以用新推出的<a href=\"#%E5%B8%A7%E7%BC%93%E5%86%B2%E5%8C%BA%E4%BD%8D%E5%9D%97%E4%BC%A0%E9%80%81\">帧缓冲区位块传送</a>解析为单采样纹理。</p>\n<h1>使用帧缓冲区对象</h1>\n<p>我们将说明如何使用帧缓冲区对象渲染到一个屏幕外缓冲区（也就是渲染缓冲区）或者渲染到一个纹理。在使用帧缓冲区对象并指定其附着之前，需要使其成为当前帧缓冲区对象。<code>glBindFramebuffer</code>命令用于设置当前帧缓冲区对象：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 设置当前帧缓冲区对象</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param target#&gt; 必须设置为GL_READ_FRAMEBUFFER、GL_DRAW_FRAMEBUFFER或GL_FRAMEBUFFER description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param framebuffer#&gt; 帧缓冲区对象名称 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glBindFramebuffer(GLenum target, GLuint framebuffer);</span><br></pre></td></tr></table></figure>\n<p>注意，对于在用<code>glBindFramebuffer</code>绑定帧缓冲区对象之前指定其名称来说，<code>glGenFramebuffers</code>并不是必需的。应用程序可以将未用的帧缓冲区对象名称指定给<code>glBindFramebuffer</code>。但是，我们建议OpenGL ES应用程序调用<code>glGenFramebuffers</code>，并使用<code>glGenFramebuffers</code>返回的帧缓冲区对象名称，而不是指定自己的缓冲区对象名称。<br>\n在某些OpenGL ES 3.0实现上，当调用<code>glBindFramebuffer</code>首次绑定帧缓冲区对象名称时，为帧缓冲区对象分配对应的默认状态。如果分配成功，分配的对象将作为渲染上下文的当前缓冲区对象进行绑定。<br>\n与帧缓冲区对象相关的状态如下：</p>\n<ul>\n<li>颜色附着点–颜色缓冲区的附着点</li>\n<li>深度附着点–深度缓冲区的附着点</li>\n<li>模板附着点–模板缓冲区的附着点</li>\n<li>帧缓冲区完整性状态–帧缓冲器是否处于完整状态，是否可以用于渲染<br>\n对于每个附着点，指定如下信息：</li>\n<li>对象类型–指定与附着点相关的对象的类型。如果连接一个渲染缓冲区对象，则类型可以是<code>GL_RENDERBUFFER</code>；如果连接一个纹理对象，那么类型可以是<code>GL_TEXTURE</code>。默认值为<code>GL_NONE</code>。</li>\n<li>对象名称–指定连接的对象的名称，可以是渲染缓冲区对象名称或者纹理对象名称。默认值为0。</li>\n<li>纹理级别–如果连接一个纹理对象，则指定了与附着点线管的纹理的mip级别。默认值为0。</li>\n<li>纹理立方图面–如果连接一个纹理对象，切纹理为立方图，则指定了6个立方图面中哪一个用于该附着点。默认值为<code>GL_TEXTURE_CUBE_MAP_POSITIVE_X</code>。</li>\n<li>纹理层次–指定3D纹理中用于该附着点的2D切片。默认值为0。<br>\n<code>glBindFramebuffer</code>也可以用于绑定到现有的帧缓冲区对象（也就是之前已经分配并使用因而有相关的有效状态的对象）。新绑定的帧缓冲区对象的状态没有任何变化。<br>\n一旦绑定了帧缓冲区对象，当前绑定的帧缓冲区对象的颜色、深度和模板附着就可以设置为一个渲染缓冲区对象或者一个纹理。如下图所示，颜色附着可以设置为存储颜色值的渲染缓冲区、2D纹理的一个mip级别或者一个立方图面、2D数组纹理的一个层次或者3D纹理中一个2D切片的mip级别。深度附着可以设置为存储深度值或者经过打包的深度和模板值的渲染缓冲区、2D深度纹理的一个mip级别或者深度立方图面。模板附着必须设置为存储模板值或者打包的深度和模板值的渲染缓冲区。</li>\n</ul>\n<h2>连接渲染缓冲区作为帧缓冲区附着</h2>\n<p><code>glFramebufferRenderbuffer</code>命令用于将一个渲染缓冲区对象连接到帧缓冲区附着点：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 将一个渲染缓冲区对象连接到帧缓冲区附着点</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param target#&gt; 必须设置为GL_READ_FRAMEBUFFER、GL_DRAW_FRAMEBUFFER或GL_FRAMEBUFFER description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param attachment#&gt; 必须为如下枚举值之一：GL_COLOR_ATTACHMENTi、GL_DEPTH_ATTACHMENT、GL_STENCIL_ATTACHMENT、GL_DEPTH_STENCIL_ATTACHMENT description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param renderbuffertarget#&gt; 必须设置为GL_RENDERBUFFER description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param renderbuffer#&gt; 应该用作附着的渲染缓冲区对象；必须为0或者现有渲染缓冲区对象名称 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glFramebufferRenderbuffer(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);</span><br></pre></td></tr></table></figure>\n<p>如果调用<code>glFramebufferRenderbuffer</code>时<code>renderbuffer</code>不为0，这个渲染缓冲区对象将被用作<code>attachment</code>参数值指定的新颜色、深度或者模板附着点。<br>\n附着点的状态将被修改为：</p>\n<ul>\n<li>对象类型 = GL_RENDERBUFFER</li>\n<li>对象名称 = renderbuffer</li>\n<li>纹理级别和纹理层次 = 0</li>\n<li>纹理立方图面 = GL_NONE</li>\n</ul>\n<p>新连接的渲染缓冲区对象状态或者缓冲区内容不做任何修改。<br>\n如果<code>glFramebufferRenderbuffer</code>调用中<code>renderbuffer</code>等于0，则<code>attachment</code>指定的颜色、深度或者模板缓冲区将被断开并重置为0。</p>\n<h2>连接一个2D纹理作为帧缓冲区附着</h2>\n<p><code>glFramebufferTexture2D</code>命令用于将一个2D纹理的某个mip级别或者立方图面连接到帧缓冲区附着点。它可以用来将纹理作为颜色、缓冲区或者模板附着点连接：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 将一个2D纹理的某个mip级别或者立方图面连接到帧缓冲区附着点</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param target#&gt; 必须设置为GL_READ_FRAMEBUFFER、GL_DRAW_FRAMEBUFFER、GL_FRAMEBUFFER description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param attachment#&gt; 必须为如下枚举值之一：GL_COLOR_ATTACHMENTi、GL_DEPTH_ATTACHMENT、GL_STENCIL_ATTACHMENT、GL_DEPTH_STENCIL_ATTACHMENT description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param textarget#&gt; 指定纹理目标；这是glTexImage2D中的target参数指定的值 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param texture#&gt; 指定纹理对象 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param level#&gt; 指定纹理图像的mip级别 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glFramebufferTexture2D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);</span><br></pre></td></tr></table></figure>\n<p>如果<code>glFramebufferTexture2D</code>调用中<code>texture</code>不为0，则颜色、深度或者模板附着将被设置为<code>texture</code>。如果<code>glFramebufferTexture2D</code>发生错误，帧缓冲区的状态将不做修改。<br>\n附着点状态将被修改为：</p>\n<ul>\n<li>对象类型 = GL_TEXTURE</li>\n<li>对象名称 = texture</li>\n<li>纹理级别 = level</li>\n<li>纹理立方图面在纹理附着为立方图时有效，是如下值之一： GL_TEXTURE_CUBE_MAP_POSITIVE_(X | Y | Z)，GL_TEXTURE_CUBE_MAP_NEGATIVE_(X | Y | Z)</li>\n<li>纹理层次 = 0<br>\n<code>glFramebufferTexture2D</code>不修改新连接的纹理对象状态或者图像内容。注意，纹理对象的状态和图像可以连接到帧缓冲区对象之后修改。<br>\n如果<code>glFramebufferTexture2D</code>调用中<code>texture</code>等于0，则颜色、深度或者模板附着将被断开并重置为0。</li>\n</ul>\n<h2>连接3D纹理的一个图像作为帧缓冲区附着</h2>\n<p><code>glFramebufferTextureLayer</code>命令用于将3D纹理的一个2D切片或者某个mip级别或者2D数组纹理的一个级别连接到帧缓冲区附着点。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 将3D纹理的一个2D切片或者某个mip级别或者2D数组纹理的一个级别连接到帧缓冲区附着点</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param target#&gt; 必须设置为GL_READ_FRAMEBUFFER、GL_DRAW_FRAMEBUFFER、GL_FRAMEBUFFER description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param attachment#&gt; 必须为如下枚举值之一：GL_COLOR_ATTACHMENTi、GL_DEPTH_ATTACHMENT、GL_STENCIL_ATTACHMENT、GL_DEPTH_STENCIL_ATTACHMENT description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param texture#&gt; 指定纹理对象 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param level#&gt; 指定纹理图像的mip级别 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param layer#&gt; 指定纹理图像层次。如果texture是GL_TEXTURE_CUBE_MAP_3D，则level必须大于或等于0并且小于或等于GL_MAX3D_TEXTURE_SIZE值以2位底的对数。如果texture是GL_TEXTURE_2D_ARRAY，则level必须大于或等于0且不大于GL_MAX_TEXTURE_SIZE值以2为底的对数 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glFramebufferTextureLayer(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer);</span><br></pre></td></tr></table></figure>\n<p><code>glFramebufferTextureLayer</code>不修改新连接的纹理对象状态或者其图像的内容。注意，纹理对象的状态和图像可以在连接到帧缓冲器对象之后修改。<br>\n附着点的状态被修改为：</p>\n<ul>\n<li>对象类型 = GL_TEXTURE</li>\n<li>对象名称 = texture</li>\n<li>纹理级别 = level</li>\n<li>纹理立方图面 = GL_NONE</li>\n<li>纹理层次 = 0<br>\n如果<code>glFramebufferTextureLayer</code>调用中<code>texture</code>等于0，则附着将被断开并重置为0。</li>\n</ul>\n<h2>检查帧缓冲区完整性</h2>\n<p>帧缓冲区对象必须定义为完整的才能够用作渲染目标。如果当前绑定的帧缓冲区对象不完整，绘制图元或者读取像素的OpenGL ES命令将会失败，并产生表示帧缓冲区不完整原因的对应错误。<br>\n帧缓冲区对象被视为完整的规则如下：</p>\n<ul>\n<li>确保颜色、深度和模板附着有效。帧缓冲区至少有一个有效的附着，如果没有任何附着，帧缓冲区就是不完整的，因为没有可以绘制或者读取的区域。</li>\n<li>与帧缓冲区对象相关的有效附着必须由相同的宽度和高度。</li>\n<li>如果存在深度和模板附着，则它们必须是相同的图像。</li>\n<li>所有渲染缓冲区附着的<code>GL_RENDERBUFFER_SAMPLES</code>值都相同。如果附着是渲染缓冲区和纹理的组合，则<code>GL_RENDERBUFFER_SAMPLES</code>的值为0。</li>\n</ul>\n<p><code>glCheckFramebufferStatus</code>命令可用于验证帧缓冲区对象是否完整：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 验证帧缓冲区对象是否完整</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param target#&gt; 必须设置为GL_READ_FRAMEBUFFER、GL_DRAW_FRMAEBUFFER或GL_FRAMEBUFFER description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glCheckFramebufferStatus(GLenum target);</span><br></pre></td></tr></table></figure>\n<p>如果<code>target</code>不等于<code>GL_FRAMEBUFFER</code>，则<code>glCheckFramebufferStatus</code>返回0。如果<code>target</code>等于<code>GL_FRAMEBUFFER</code>，则返回如下枚举值之一：</p>\n<ul>\n<li>GL_FRAMEBUFFER_COMPLETE – 帧缓冲区完整</li>\n<li>GL_FRAMEBUFFER_UNDEFINED – 如果<code>target</code>是默认的帧缓冲区但是它不存在</li>\n<li>GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT – 帧缓冲区附着点不完整。这可能是因为需要的附着为0，或者不是有效纹理或渲染缓冲区对象</li>\n<li>GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT – 帧缓冲区中没有有效的附着</li>\n<li>GL_FRAMEBUFFER_UNSUPPORTED – 帧缓冲区中的附着使用的内部格式组合造成不可渲染的目标</li>\n<li>GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE – 所有渲染缓冲区附着的GL_RENDERBUFFER_SAMPLES不都相同，或者GL_RENDERBUFFER_SAMPLES在附着是渲染缓冲区和纹理的组合时不为0</li>\n</ul>\n<p>如果当前绑定的帧缓冲区对象不完整，则试图使用该对象读取和写入像素将会失败。接着，绘制图元的调用（如<code>glDrawArrays</code>和<code>glDrawElements</code>）和读取帧缓冲区的命令（如<code>glReadPixels</code>、<code>glCopyTeximage2D</code>、<code>glCopyTexSubimage2D</code>和<code>glCopyTexSubimage3D</code>）将生成一个<code>GL_INVALID_FRAMEBUFFER_OPERATION</code>错误。</p>\n<h1>帧缓冲区位块传送</h1>\n<p>帧缓冲区位块传送（Blit）可以高效地将一个矩形区域的像素值从一个帧缓冲区（读帧缓冲区）复制到另一个帧缓冲区（绘图帧缓冲区）。帧缓冲区位块传送的关键应用之一是将一个多重采样渲染缓冲区解析为一个纹理（用一个帧缓冲区对象，纹理绑定为它的颜色附着）。<br>\n可以用如下命令执行上述操作：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 将一个矩形区域的像素从一个帧缓冲区复制到另一个帧缓冲区</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param srcX0，srcY0，srcX1，srcY1#&gt; 指定读缓冲区内的来源矩形的边界 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param dstX0，dstY0，dstX1，dstY1#&gt; 指定写缓冲区内的目标矩形的边界 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param mask#&gt; 指定表示哪些缓冲区被复制的标识的按位或；组成如下：GL_COLOR_BUFFER_BIT，GL_DEPTH_BUFFER_BIT，GL_STENCIL_BUFFER_BIT，GL_DEPTH_STENCIL_ATTACHMENT description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param filter#&gt; 指定图像被拉伸时应用的插值；必须为GL_NEAREST或GL_LINEAR description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glBlitFramebuffer(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);</span><br></pre></td></tr></table></figure>\n<p>举例：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// set the default framebuffer for writing</span></span><br><span class=\"line\">glBindFramebuffer(GL_DRAW_FRAMEBUFFER, defaultFramebuffer);</span><br><span class=\"line\"><span class=\"comment\">// set the fbo with color attachments for reading</span></span><br><span class=\"line\">glBindFramebuffer(GL_READ_FRAMEBUFFER, fbo);</span><br><span class=\"line\"><span class=\"comment\">// copy the output buffer to target</span></span><br><span class=\"line\">glReadBuffer(GL_COLOR_ATTACHMENT0);</span><br><span class=\"line\">glBlitFramebuffer(<span class=\"number\">0</span>, <span class=\"number\">0</span>, width, height, <span class=\"number\">0</span>, <span class=\"number\">0</span>, width/<span class=\"number\">2</span>, height, GL_COLOR_BUFFER_BIT, GL_LINEAR);</span><br><span class=\"line\">glReadBuffer(GL_COLOR_ATTACHMENT1);</span><br><span class=\"line\">glBlitFramebuffer(<span class=\"number\">0</span>, <span class=\"number\">0</span>, width, height, width/<span class=\"number\">2</span>, <span class=\"number\">0</span>, width/<span class=\"number\">2</span>, height, GL_COLOR_BUFFER_BIT, GL_LINEAR);</span><br></pre></td></tr></table></figure>\n<h1>帧缓冲区失效</h1>\n<p>帧缓冲区失效为应用程序提供了一个通知驱动程序不再需要帧缓冲区内容的机制。这使得驱动程序可以采取多种优化步骤：（1）跳过在块状渲染（TBR）架构中为了进一步渲染到帧缓冲区而做的不必要的图块内容恢复，（2）跳过多CPU系统中GPU之间不必要的数据复制，（3）跳过某些实现中为了改进性能而对特定缓存的刷新。这种功能对于许多应用程序中实现峰值性能很重要，特别是那些执行大量屏幕外渲染的应用。<br>\n让我们研究一下TBR GPU的设计，以理解帧缓冲区失效对这些GPU的重要性。TBR GPU尝尝部署在移动设备上，以最小化GPU和系统内存之间的数据传输量，从而减少最大的电力消耗者之一–内存带宽。这通过添加能够保存少量像素数据的芯片内建快速存储器来实现。然后，帧缓冲区被分为许多个图块。对于每个图块，图元被渲染到芯片内建的存储器中，然后结果在完成时被复制到系统内存。因为每个像素的最少量数据（最终像素结果）被复制到系统内存，所以这种方法节约了GPU和系统内存之间的内存带宽。<br>\n有了帧缓冲区失效机制，GPU就可以删除不再需要的帧缓冲区内容，以减少每个帧保留的内容数量。此外，如果图块数据不再有效，GPU还可以消除从芯片内建存储器到系统内存不必要的数据传输，因为GPU和系统内存之间内存带宽需求明显降低，所以电力消耗随之下降，性能则得到改善。<br>\n<code>glInvalidateFramebuffer</code>和<code>glInvalidateSubFramebuffer</code>命令用于使整个帧缓冲区或者帧缓冲区的像素子区域失效：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 使整个帧缓冲区失效</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param target#&gt; 必须设置为GL_READ_FRAMEBUFFER、GL_DRAW_FRAMEBUFFER或GL_FRAMEBUFFER description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param numAttachments#&gt; attachments列表中的附着数量 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param attachments#&gt; 指定包含numAttachments个附着的数组的指针 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glInvalidateFramebuffer(GLenum target, GLsizei numAttachments, <span class=\"keyword\">const</span> GLenum *attachments);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 使帧缓冲区的像素子区域失效</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param target#&gt; 必须设置为GL_READ_FRAMEBUFFER、GL_DRAW_FRAMEBUFFER或GL_FRAMEBUFFER description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param numAttachments#&gt; attachments列表中的附着数量 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param attachments#&gt; 指定包含numAttachments个附着的数组的指针 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param x，y#&gt; 指定要失效的像素矩形的左下角原点（左下角为0，0） description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param width#&gt; 指定要失效的像素矩形宽度 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param height#&gt; 指定要失效的像素矩形高度 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glInvalidateSubFramebuffer(GLenum target, GLsizei numAttachments, <span class=\"keyword\">const</span> GLenum *attachments, GLint x, GLint y, GLsizei width, GLsizei height);</span><br></pre></td></tr></table></figure>\n<h1>删除帧缓冲区和渲染缓冲区对象</h1>\n<p>在应用程序结束渲染缓冲区对象的使用之后，可以删除它们。删除渲染缓冲区和帧缓冲区对象与删除纹理对象非常相似。<br>\n渲染缓冲区对象用<code>glDeleteRenderbuffers</code>API删除：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 删除渲染缓冲区对象</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param n#&gt; 要删除的渲染缓冲区对象名称的数量 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param renderbuffers#&gt; 指向包含n个要删除的渲染x缓冲区对象名称的数组的指针 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glDeleteRenderbuffers(GLsizei n, <span class=\"keyword\">const</span> GLuint *renderbuffers);</span><br></pre></td></tr></table></figure>\n<p><code>glDeleteRenderbuffers</code>删除<code>renderbuffers</code>中指定的渲染缓冲区对象。一旦删除了渲染缓冲区对象，就没有任何与之关联，对象被标记为未用，以后可以被重用，作为新的渲染缓冲区对象。删除当前绑定的渲染缓冲区对象时，该对象被删除，当前渲染缓冲区被重置为0。如果<code>renderbuffers</code>中指定的渲染缓冲区对象名称无效或者为0，则它们被忽略（不会生成任何错误）。而且，如果渲染缓冲区连接到当前绑定的帧缓冲区对象，则它首先要与帧缓冲区断开，然后才能被删除。<br>\n帧缓冲区对象用<code>glDeleteFramebuffers</code>API删除：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 删除帧缓冲区对象</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param n#&gt; 要删除的帧缓冲区对象名称的数量 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param framebuffers#&gt; 指向包含n个要删除的帧缓冲区对象名称的数组的指针 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glDeleteFramebuffers(GLsizei n, <span class=\"keyword\">const</span> GLuint *framebuffers);</span><br></pre></td></tr></table></figure>\n<p><code>glDeleteFramebuffers</code>删除<code>framebuffers</code>中指定的帧缓冲区对象。一旦删除了帧缓冲区对象，该对象就不会有任何与之关联的状态，并被标记为未使用，以后可以作为新的帧缓冲区对象重用。删除当前绑定的帧缓冲区对象时，该对象被删除且当前帧缓冲区绑定重置为0。如果<code>framebuffers</code>中指定的帧缓冲区对象名称无效或者为0，则它们被忽略，不会生成任何错误。</p>\n<h1>删除用作帧缓冲区附着的渲染缓冲区对象</h1>\n<p>如果被删除的渲染缓冲区对象作为帧缓冲区对象的一个附着，会发生什么情况？如果要删除的帧缓冲区对象作为当前绑定的帧缓冲区对象中的一个附着，则<code>glDeleteRenderbuffers</code>将附着重置为0。如果要删除的渲染缓冲区对象是当前没有绑定的帧缓冲区对象的一个附着，则<code>glDeleteRenderbuffers</code>不会将这些附着重置为0。将这些被删除的渲染缓冲区对象与对应的帧缓冲区对象断开是应用程序的责任。</p>\n<h2>读取像素和帧缓冲区对象</h2>\n<p><code>glReadPixels</code>命令从颜色缓冲区读取像素，并在一个用户分配的缓冲区中返回它们。读取的颜色缓冲区是窗口系统提供的帧缓冲区分配的颜色缓冲区，或者是当前绑定的帧缓冲区对象的颜色附着。当用<code>glBindBuffer</code>将一个非零的缓冲区对象绑定到<code>GL_PIXEL_PACK_BUFFER</code>时，<code>glReadPixels</code>命令可以立即返回，并调用DMA传输从帧缓冲区中读取像素，然后将数据写入像素缓冲区对象。<br>\n<code>glReadPixels</code>支持多种<code>format</code>和<code>type</code>参数组合：<code>format</code>可以是<code>GL_RGBA</code>、<code>GL_RGBA_INTEGER</code>或者由查询<code>GL_IMPLEMENTATION_COLOR_READ_FORMAT</code>返回的特定于实现的值；<code>type</code>可以是<code>GL_UNSIGNED_BYTE</code>、<code>GL_UNSIGNED_INT</code>、<code>GL_INT</code>、<code>GL_FLOAT</code>或者由查询<code>GL_IMPLEMENTATION_COLOR_READ_TYPE</code>返回的特定于实现的值。返回的特定于实现的格式和类型取决于当前连接的颜色缓冲区的格式和类型。如果当前绑定的帧缓冲区改变，则这些值也可能改变。当前绑定的帧缓冲区对象改变时都必须查询这些值，以确定传递给<code>glReadPixels</code>的正确的特定于实现的格式和类型值。</p>\n<h1>性能提示和技巧</h1>\n<p>下面，我们讨论开发人员在使用帧缓冲区对象时应该认真考虑的性能提示：</p>\n<ul>\n<li>避免频繁地在渲染到窗口系统提供的帧缓冲区和渲染到帧缓冲区对象之间切换。这对于手持OpenGL ES 3.0实现是一个问题，因为许多这类实现使用块状渲染架构。在块状渲染架构中，使用专用的内部存储器存储帧缓冲区图块（区域）的颜色、深度和模板值。这些内部存储器在电源利用上更为高效，而且与外部内存相比具有更低的内存延迟和更大的带宽。在渲染到图块完成之后，图块被写到设备（系统）内存。每当从一个渲染目标切换到另一个，就需要渲染、保存和恢复对应的纹理和渲染缓冲区附着，这可能带来很大的代价。最佳的方法是首先渲染到场景中合适的帧缓冲区，然后渲染到窗口系统提供的帧缓冲区，最后执行<code>eglSwapBuffers</code>命令切换显示缓冲区。</li>\n<li>不要逐帧创建和删除帧缓冲区和渲染缓冲区对象（或者任何其他大型数据对象）。</li>\n<li>尝试避免修改用作渲染目标的帧缓冲区对象附着的纹理（使用<code>glTexImage2D</code>、<code>glTexSubImage2D</code>、<code>glCopyTexImage2D</code>等）。</li>\n<li>如果整个纹理图像将被渲染，则将<code>glTexImage2D</code>和<code>glTexImage3D</code>中的<code>pixel</code>参数设置为<code>NULL</code>，因为原始数据不会被使用。如果希望图像不包含任何预先定义的像素值，那么在绘制到纹理之前使用<code>glInvalidateFramebuffer</code>清除纹理图像。</li>\n<li>尽可能共享帧缓冲区对象使用的用作附着的深度和模板渲染缓冲区，以保障内存占用需求最小。</li>\n</ul>\n<h1>总结</h1>\n<p>这篇文章主要是对用于渲染到屏幕外表面的帧缓冲区对象的使用方法。</p>\n"},{"title":"OpenGL ES学习--顶点属性、顶点数组和缓冲区对象","catalog":true,"toc_nav_num":true,"date":"2019-07-20T10:28:11.000Z","subtitle":"About OpenGL ES","header-img":"/img/article_header/article_header.png","busuanzi":true,"_content":"\n> 顶点数据也称作顶点属性，指定每个顶点的数据。这种逐顶点数据可以为每个顶点指定，也可以用于所有顶点的常量。例如，如果想要绘制一个固定颜色的三角形，可以指定一个常量值，用于三角形的全部3个顶点。但是，组成三角形的3个顶点的位置不同，所以我们必须指定一个顶点数组来存储3个位置值。\n\n# 指定顶点属性数据\n\n顶点属性数据可以用一个顶点数组对每个顶点指定，也可以将一个常量值用于一个图元的所有顶点。\n\n所有OpenGL ES 3.0实现必须支持最少16个顶点属性，可以通过`glGet*`函数查询特定支持的顶点属性的准确数量：\n\n``` objc\nGLint maxVertexAttribs; \nglGetIntegerv(GL_MAX_VERTEX_ATTRIBS, &maxVertexAttribs);\n```\n\n## 常量顶点属性\n\n常量顶点属性对于一个图元的所有顶点都相同，所以对一个图元的所有顶点只需指定一个值。\n\n``` objc\n// 加载indx指定的通用顶点属性(x, 0.0, 0.0, 1.0)\nglVertexAttrib1f(GLuint indx, GLfloat x);\nglVertexAttrib1fv(GLuint indx, const GLfloat *values);\n\n// 加载indx指定的通用顶点属性(x, y, 0.0, 1.0)\nglVertexAttrib2f(GLuint indx, GLfloat x, GLfloat y);\nglVertexAttrib2fv(GLuint indx, const GLfloat *values);\n\n// 加载indx指定的通用顶点属性(x, y, z, 1.0)\nglVertexAttrib3f(GLuint indx, GLfloat x, GLfloat y, GLfloat z);\nglVertexAttrib3fv(GLuint indx, const GLfloat *values);\n\n// 加载indx指定的通用顶点属性(x, y, z, w)\nglVertexAttrib4f(GLuint indx, GLfloat x, GLfloat y, GLfloat z, GLfloat w);\nglVertexAttrib4fv(GLuint indx, const GLfloat *values);\n```\n\n## 顶点数组\n\n顶点数组指定每个顶点的属性，是保存在应用程序地址空间的缓冲区。它们作为顶点缓冲对象的基础，提供指定顶点属性数据的一种高效、灵活的手段。\n\n``` objc\n/**\n 指定顶点属性\n\n @param indx#> 指定通用顶点属性索引 description#>\n @param size#> 顶点数组中为索引引用的顶点属性所指定的分量数量，有效值为1~4 description#>\n @param type#> 数据格式 description#>\n @param normalized#> 用于表示非浮点数据格式类型在转换为浮点值时是否应该规范化 description#>\n @param stride#> 每个顶点由size指定的顶点属性分量顺序存储。stride指定顶点索引I和I+1表示的顶点数据之间的位移。如果stride为0，则每个顶点的属性数据顺序存储。如果stride大于0，则使用该值作为获取下一个索引表示的顶点数据的跨距 description#>\n @param ptr#> 如果使用客户端顶点数组，则是保存顶点属性数据的缓冲区指针。如果使用顶点缓冲区对象，则表示该缓冲区内的偏移量 description#>\n @return void\n */\nglVertexAttribPointer(GLuint indx, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid *ptr);\n\n/**\n 指定顶点属性，数据格式类型被当做整数对待\n\n @param index#> 指定通用顶点属性索引 description#>\n @param size#> 顶点数组中为索引引用的顶点属性所指定的分量数量，有效值为1~4 description#>\n @param type#> 数据格式 description#>\n @param stride#> 每个顶点由size指定的顶点属性分量顺序存储。stride指定顶点索引I和I+1表示的顶点数据之间的位移。如果stride为0，则每个顶点的属性数据顺序存储。如果stride大于0，则使用该值作为获取下一个索引表示的顶点数据的跨距 description#>\n @param pointer#> 如果使用客户端顶点数组，则是保存顶点属性数据的缓冲区指针。如果使用顶点缓冲区对象，则表示该缓冲区内的偏移量 description#>\n @return void\n */\nglVertexAttribIPointer(GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);\n```\n\n分配和存储顶点属性数据有两种常用的方法：\n- 在一个缓冲区中存储顶点属性--这种方法称为结构数组。结构表示顶点的所有属性，每个顶点有一个属性的数组。\n- 在单独的缓冲区中保存每个顶点属性--这种方法称为数组结构。\n\n### 哪种存储顶点属性的方法高效\n\n在大部分情况下，答案是结构数组。原因是，每个顶点的属性数据可以顺序方法读取，这最有可能造成高效的内存访问模式。使用结构数组的缺点在应用程序需要修改特定属性时变得很明显。如果顶点属性数据的一个自己需要修改，这将造成顶点缓冲区的跨距更新。当顶点缓冲区以缓冲区对象的形式提供时，需要重新加载整个顶点属性缓冲区。可以通过将动态的顶点属性保存在单独的缓冲区来避免这种效率低下的情况。\n\n### 顶点属性使用哪种数据格式\n\n`glVertexAttribPointer`中的`type`参数指定的顶点属性格式不仅影响顶点属性数据的图形内存存储需求，而且影响整体性能，这是渲染帧所需内存带宽的一个函数。数据空间占用越小，需要的内存带宽越小。OpenGL ES 3.0支持名为`GL_HALF_FLOAT`的16位浮点顶点格式，建议尽可能使用。纹理坐标、法线、副法线、切向量等都是使用`GL_HALF_FLOAT`存储每个分量的候选。颜色可以存储为`GL_UNSIGNED_BYTE`，每个顶点颜色具有4个分量。顶点位置可以存储为`GL_FLOAT`。\n\n### `glVertexAttribPointer`中的规范化标识如何工作\n\n在用于顶点着色器之前，顶点属性在内部保存为单精度浮点数，如果数据类型表示顶点属性不是浮点数，顶点属性将在用于顶点着色器之前转换为单精度浮点数。规范化标志控制非浮点顶点属性数据到单精度浮点值的转换。如果规范化标识为假，则顶点数据被直接转换为浮点数。这类似于将非浮点类型的变量转换为浮点变量。例子：\n\n``` objc\nGLfloat f;\nGLbyte b;\nf = (GLfloat)b;     // f represents values in the range [-128.0, 127.0]\n```\n\n如果规范化标志位真，且如果数据类型为`GL_BYTE`、`GL_SHORT`或者`GL_FIXED`，则顶点数据被映射到[-1.0, 1.0]范围内，如果数据类型为`GL_UNSIGNED_BYTE`或`GL_UNSIGNED_SHORT`，则被映射到[0.0, 1.0]范围内。\n\n下表说明了设置规范化标志时非浮点数据类型的转换，表中第二列的`c`值指的是第一列中指定格式的一个值：\n\n顶点数据格式 | 转换为浮点数\n- | -\nGL_BYTE | max(c/(2<sup>7</sup>-1), -1.0)\nGL_UNSIGNED_BYTE | c/(2<sup>8</sup>-1)\nGL_SHORT | max(c/(2<sup>16</sup>-1), -1.0)\nGL_UNSIGNED_SHORT | c/(2<sup>16</sup>-1)\nGL_FIXED | c/(2<sup>16</sup>)\nGL_FLOAT | c\nGL_HALF_FLOAT_OES | c\n\n在顶点着色器中，也有可能按照整数的形式访问整数型顶点属性数据，而不是将其转换为浮点数，可以使用`glVertexAttribIPointer`函数。\n\n### 在常量顶点属性和顶点数组之间选择\n\n应用程序可以让OpenGL ES使用常量数据或者来自顶点数组的数据。`glEnableVertexAttribArray`和`glDisableVertexAttribArray`命令分别用于启用和禁用通用顶点属性数组。如果某个通用属性索引的顶点属性数组被禁用，将使用为该索引指定的常量顶点属性数据。\n\n``` objc\n// glsl.vsh\n#version 300 es\nlayout(location = 0) in vec4 a_color;\nlayout(location = 1) in vec4 a_position;\nout vec4 v_color;\nvoid mian() {\n    v_color = a_color;\n    gl_Position = a_position;\n}\n```\n\n``` objc\n// glsl.fsh\n#version 300 es\nprecision mudiump float;\nin vec4 v_color;\nout vec4 o_fragColor;\nvoid main() {\n    o_fragColor = v_color;\n}\n```\n\n``` objc\nGLfloat color[4] = {1.0f, 0.0f, 0.0f, 1.0f};\nGLfloat vertexPos[9] = {0.0f, 0.5f, 0.0f,\n                        -0.5f, -0.5f, 0.0f,\n                        0.5f, -0.5f, 0.0f};\nglVertexAttrib4fv(0, color);\nglVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 0, vertexPos);\nglEnableVertexAttribArray(1);\nglDrawArrays(GL_TRIANGLES, 0, 3);\nglDisableVertexAttribArray(1);\n```\n\n代码示例中使用的顶点属性`color`是一个常量，用`glVertexAttrib4fv`指定，不启用顶点属性数组0。`vertexPos`属性用`glVertexAttribPointer`以一个顶点数组指定，并用`glEnableVertexAttribArray`启用数组。`color`值对于所绘制的三角形的所有顶点均相同，而`vertexPos`属性对于三角形的各个顶点可以不同。\n\n# 在顶点着色器中声明顶点属性变量\n\n在顶点着色器中，变量通过使用`in`限定符声明为顶点属性。属性变量也可以包含一个布局限定符，提供属性索引：\n\n``` objc\nlayout(location = 0) in vec4 a_position;\nlayout(location = 1) in vec2 a_texcoord;\nlayout(location - 2) in vec3 a_normal;\n```\n\n属性可以在顶点着色器内部声明--但是如果没有使用，就不会被认为是活动属性，从而不会被计入限制。如果在顶点着色器中使用的属性数量大于`GL_MAX_VERTEX_ATTRIBS`，这个顶点着色器就无法链接。\n\n当程序成功链接，我们就需要找出连接到该程序的顶点着色器使用的活动顶点属性数量。注意：这一步骤只需要在我们对属性不使用布局限定符时才有必要。\n首先通过`glGetProgramiv`函数传入`GL_ACTIVE_ATTRIBUTE`获取活动的属性数量，传入`GL_ACTIVE_ATTRIBUTE_MAX_LENGTH`获取属性的最长字符数量，最后使用`glGetActiveAttrib`函数查询顶点着色器各属性索引点对应的属性变量名称：\n\n``` objc\nGLint attribsCount;\nGLint attribMaxLength;\nglGetProgramiv(program, GL_ACTIVE_ATTRIBUTES, &attribsCount);\nglGetProgramiv(program, GL_ACTIVE_ATTRIBUTE_MAX_LENGTH, &attribMaxLength);\nfor (int i = 0; i < attribsCount; i++) {\n    GLsizei length;\n    GLint size;\n    GLenum type;\n    GLchar *name = malloc(attribMaxLength * sizeof(GLchar));\n    glGetActiveAttrib(program, i, attribMaxLength, &length, &size, &type, name);\n    NSLog(@\"length: %d, size: %d, type: %u, name: %s\", length, size, type, name);\n}\n```\n\n## 将顶点属性绑定到顶点着色器中的属性变量\n\n在OpenGL ES 3.0中，可以使用3种方法将通用顶点属性索引映射到顶点着色器中的一个属性变量名称：\n- 索引可以在顶点着色器源代码中用`layout(location = N)`限定符指定（推荐）；\n- OpenGL ES 3.0将通用顶点属性索引绑定到属性名称；\n- 应用程序可以将顶点属性索引绑定到属性名称；\n\n将属性绑定到一个位置的最简单方法是简单地使用`layout(location = N)`限定符，这种方法需要的代码最少。但是，在某些情况下，其他两个选项可能更合适。`glBindAttribLocation`命令可用于将通用顶点属性索引绑定到顶点着色器中的一个属性变量。这种绑定在下一次程序链接时生效--不会改变当前链接的程序中使用的绑定。\n\n``` objc\n/**\n 将通用顶点属性索引绑定到属性变量\n\n @param program#> 程序对象 description#>\n @param index#> 通用顶点属性索引 description#>\n @param name#> 属性变量名称 description#>\n @return void\n */\nglBindAttribLocation(GLuint program, GLuint index, const GLchar *name);\n```\n\n如果之前绑定了`name`，则它所指定的绑定被索引代替。`glBindAttribLocation`甚至可以在顶点着色器连接到程序对象之前调用，因此，这个调用可以用于绑定任何属性名称。不存在的属性名称或者在连接到程序对象的顶点着色器中不活动的属性将被忽略。\n\n另一个选项是让OpenGL ES 3.0将属性变量名称绑定到一个通用顶点属性索引。这种绑定在程序链接时进行，在链接阶段，OpenGL ES 3.0实现为每个属性变量执行如下操作：对于每个属性变量，检查是否已经通过`glBindAttribLocation`。如果指定了一个绑定，则使用指定的对应属性索引。否则，OpenGL ES实现将分配一个通用顶点属性索引。\n这种分配特定于实现；也就是说，在一个OpenGL ES 3.0实现中和在另一个实现中可能不同。应用程序可以使用`glGetAttribLocation`命令查询分配的绑定。\n\n``` objc\n/**\n 查询属性索引\n\n @param program#> 程序对象 description#>\n @param name#> 属性变量名称 description#>\n @return 属性索引\n */\nglGetAttribLocation(GLuint program, const GLchar *name);\n```\n\n`glGetAttribLocation`返回`program`定义的程序对象最后一次链接时绑定到属性变量`name`的通用属性索引。如果`name`不是一个活动属性变量，或者`program`不是一个有效的程序对象，或者没有链接成功，则返回-1，表示无效的属性索引。\n\n# 顶点缓冲区对象\n\n使用顶点数组指定的顶点数据保存在客户内存中。在进行`glDrawArrays`或者`glDrawElements`等绘图调用时，这些数据必须从客户内存复制到图形内存。但是，如果我们没有必要在每次绘图调用时都复制顶点数据，而是在图形内存中缓存这些数据，那就好得多了。这种方法可以显著地改进渲染性能，也会降低内存带宽和电力消耗序曲，对于手持设备相当重要。这是顶点缓冲区对象发挥的地方。顶点缓冲区对象使OpenGL ES 3.0应用程序可以在高性能的图形内存中分配和缓存顶点数据，并从这个内存进行渲染，从而避免在每次绘制图元的时候重新发送数据。不仅是顶点数据，描述图元顶点索引、作为`glDrawElements`参数传递的元素索引也可以缓存。\n\nOpenGL ES 3.0支持两类缓冲区对象，用于指定顶点和图元数据：数组缓冲区对象和元素数组缓冲区对象。`GL_ARRAY_BUFFER`标志指定的数组缓冲区对象用于创建保存顶点数据的缓冲区对象。`GL_ELEMENT_ARRAY_BUFFER`标志指定的元素数组缓冲区对象用于创建保存图元索引的缓冲区对象。\n\n> 为了得到最佳性能，推荐OpenGL ES 3.0应用程序对顶点属性数据和元素索引使用顶点缓冲区对象。\n\n 在使用缓冲对象渲染之前，需要分配缓冲区对象并将顶点数据和元素索引上传到相应的缓冲区对象。\n\n``` objc\n// vertex_t是自定义顶点数据类型\nvoid initVertexBufferObjects(vertex_t *vertexBuffer,\n                             GLushort *indices,\n                             GLuint numVertices,\n                             GLuint numIndices,\n                             GLuint *vboIds) {\n    glGenBuffers(2, vboIds);\n    \n    glBindBuffer(GL_ARRAY_BUFFER, vboIds[0]);\n    glBufferData(GL_ARRAY_BUFFER, numVertices * sizeof(vertex_t), vertexBuffer, GL_STATIC_DRAW);\n    \n    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vboIds[1]);\n    glBufferData(GL_ELEMENT_ARRAY_BUFFER, numIndices * sizeof(GLushort), indices, GL_STATIC_DRAW);\n}\n```\n\n上述代码创建两个缓冲区对象：一个用于保存实际的顶点属性数据，另一个用于保存组成图元的元素索引。数组缓冲区对象用于保存一个或者多个图元的顶点属性数据，元素数组缓冲区对象保存一个或者多个图元的索引。\n\n``` objc\n/**\n 创建缓冲区对象\n\n @param n#> 返回缓冲区对象名称数量 description#>\n @param buffers#> 指向n个条目的数组指针，该数组是分配的缓冲区对象返回的位置 description#>\n @return void\n */\nglGenBuffers(GLsizei n, GLuint *buffers);\n\n/**\n 指定当前缓冲区对象\n\n @param target#> GL_ARRAY_BUFFER, GL_ELEMENT_ARRAY_BUFFER, GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, GL_PIXEL_PACK_BUFFER, GL_PIXEL_UNPACK_BUFFER, GL_TRANSFROM_FEEDBACK_BUFFER, GL_UNIFORM_BUFFER description#>\n @param buffer#> 分配给目标当做当前对象的缓冲区对象 description#>\n @return void\n */\nglBindBuffer(GLenum target, GLuint buffer);\n\n/**\n 顶点数组数据或者元素数组数据存储创建和初始化\n\n @param target#> GL_ARRAY_BUFFER, GL_ELEMENT_ARRAY_BUFFER, GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, GL_PIXEL_PACK_BUFFER, GL_PIXEL_UNPACK_BUFFER, GL_TRANSFROM_FEEDBACK_BUFFER, GL_UNIFORM_BUFFER description#>\n @param size#> 缓冲区数据存储大小，以字节数表示 description#>\n @param data#> 应用程序提供的缓冲区数据的指针，可为NULL值，表示保留的数据存储不进行初始化。如果是一个有效的指针，则其内容被复制到分配的数据存储 description#>\n @param usage#> 详见下表 description#>\n @return void\n */\nglBufferData(GLenum target, GLsizeiptr size, const GLvoid *data, GLenum usage);\n\n/**\n 顶点数组数据或者元素数组数据存储初始化或者更新\n\n @param target#> GL_ARRAY_BUFFER, GL_ELEMENT_ARRAY_BUFFER, GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, GL_PIXEL_PACK_BUFFER, GL_PIXEL_UNPACK_BUFFER, GL_TRANSFROM_FEEDBACK_BUFFER, GL_UNIFORM_BUFFER description#>\n @param offset#> 缓冲区数据存储中的偏移 description#>\n @param size#> 被修改的数据存储字节数 description#>\n @param data#> 需要被复制到缓冲区对象数据存储的客户数据指针 description#>\n @return void\n */\nglBufferSubData(GLenum target, GLintptr offset, GLsizeiptr size, const GLvoid *data)\n```\n\n缓冲区使用枚举值 | 描述\n- | -\nGL_STATIC_DRAW | 缓冲区对象数据将被修改一次，使用多次，以绘制图元或者指定图像\nGL_STATIC_READ | 缓冲区对象数据将被修改一次，使用多次，以从OpenGL ES读回数据。从OpenGL ES读回的数据将从应用程序中查询\nGL_STATIC_COPY | 缓冲区对象数据将被修改一次，使用多次，以从OpenGL ES读回数据。从OpenGL ES读回的数据将直接用作绘制图元或者修改图像的信息来源\nGL_DYNAMIC_DRAW | 缓冲区对象数据将被重复修改，使用多次，以绘制图元或者指定图像\nGL_DYNAMIC_READ | 缓冲区对象数据将被重复修改，使用多次，以从OpenGL ES读回数据。从OpenGL ES读回的数据中将从应用程序中查询\nGL_DYNAMIC_COPY | 缓冲区对象数据将被重复修改，使用多次，以从OpenGL ES读回数据。从OpenGL ES读回的数据将直接用作绘制图元或者修改图像的信息来源\nGL_STREAM_DRAW | 缓冲区对象数据将被修改一次，只使用少数几次，以绘制图元或者指定图像\nGL_STREAM_READ | 缓冲区对象数据将被修改一次，只使用少数几次，以从OpenGL ES读回数据。从OpenGL ES读回的数据将从应用程序中查询\nGL_STREAM_COPY | 缓冲区对象数据将被修改一次，只使用少数几次，以从OpenGL ES读回数据。从OpenGL ES读回的数据将直接用作绘制图元或者修改图像的信息来源\n\n在用`glBufferData`或者`glBufferSubData`初始化或者更新缓冲区对象数据存储之后，客户数据存储不再需要，可以释放。对于静态的几何形状，应用程序可以释放客户数据存储，减少应用程序消耗的系统内存。对于动态几何形状，这可能无法做到。\n\n下面是个使用和不使用缓冲区对象进行的图元绘制：\n\n``` objc\n// glsl.vsh\n#version 300 es\nlayout(location = 0) in vec4 vPosition;\nlayout(location = 1) in vec4 vColor;\nuniform float offsetLoc;\nout vec4 v_color;\n\nvoid main() {\n    v_color = vColor;\n    gl_Position = vec4(vPosition.x + offsetLoc, vPosition.yzw);\n}\n```\n\n``` objc\n// glsl.fsh\n#version 300 es\nprecision mediump float;\nin vec4 v_color;\nout vec4 fragColor;\n\nvoid main() {\n    fragColor = v_color;\n}\n```\n\n``` objc\nvoid DrawPrimitiveWithoutVBOs() {\n    GLint vertex_position_size = 3;\n    GLint vertex_color_size = 4;\n    GLushort indices[3] = {0, 1, 2};\n    GLfloat vertices[] = {\n        -0.5f, 0.5f, 0.0f,\n        1.0f, 0.0f, 0.0f, 1.0f,\n        -1.0f, -0.5f, 0.0f,\n        0.0f, 1.0f, 0.0f, 1.0f,\n        0.0f, -0.5f, 0.0f,\n        0.0f, 0.0f, 1.0f, 1.0f\n    };\n    GLfloat *vtxBuf = vertices;\n    GLsizei vtxStride = sizeof(GLfloat) * (vertex_color_size + vertex_position_size);\n    \n    glBindBuffer(GL_ARRAY_BUFFER, 0);\n    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);\n    \n    glEnableVertexAttribArray(0);\n    glEnableVertexAttribArray(1);\n    \n    glVertexAttribPointer(0, vertex_position_size, GL_FLOAT, GL_FALSE, vtxStride, vtxBuf);\n    vtxBuf += vertex_position_size;\n    glVertexAttribPointer(1, vertex_color_size, GL_FLOAT, GL_FALSE, vtxStride, vtxBuf);\n    \n    glDrawElements(GL_TRIANGLES, 3, GL_UNSIGNED_SHORT, indices);\n    \n    glDisableVertexAttribArray(0);\n    glDisableVertexAttribArray(1);\n}\n\nvoid DrawPrimitiveWithVBOs() {\n    GLvoid *offset = 0;\n    GLuint vboIds[2];\n    GLint vertex_position_size = 3;\n    GLint vertex_color_size = 4;\n    GLushort indices[3] = {0, 1, 2};\n    GLint vtxStride = sizeof(GLfloat) * (vertex_position_size + vertex_color_size);\n    GLfloat vertices[] = {\n        -0.5f, 0.5f, 0.0f,\n        1.0f, 0.0f, 0.0f, 1.0f,\n        -1.0f, -0.5f, 0.0f,\n        0.0f, 1.0f, 0.0f, 1.0f,\n        0.0f, -0.5f, 0.0f,\n        0.0f, 0.0f, 1.0f, 1.0f\n    };\n    GLfloat *vtxBuf = vertices;\n\n    glGenBuffers(2, vboIds);\n    glBindBuffer(GL_ARRAY_BUFFER, vboIds[0]);\n    glBufferData(GL_ARRAY_BUFFER, vtxStride * 3, vtxBuf, GL_STATIC_DRAW);\n    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vboIds[1]);\n    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(GLushort) * 3, indices, GL_STATIC_DRAW);\n    \n    glEnableVertexAttribArray(0);\n    glEnableVertexAttribArray(1);\n    \n    glVertexAttribPointer(0, vertex_position_size, GL_FLOAT, GL_FALSE, vtxStride, offset);\n    offset += vertex_position_size * sizeof(GLfloat);\n    glVertexAttribPointer(1, vertex_color_size, GL_FLOAT, GL_FALSE, vtxStride, offset);\n    \n    glDrawElements(GL_TRIANGLES, 3, GL_UNSIGNED_SHORT, 0);\n    \n    glDisableVertexAttribArray(0);\n    glDisableVertexAttribArray(1);\n    \n    glBindBuffer(GL_ARRAY_BUFFER, 0);\n    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);\n}\n\n// 调用\nDrawPrimitiveWithoutVBOs();\nglUniform1f(0, 1.0f);\nDrawPrimitiveWithVBOs();\n```\n\n上述代码中，我们对一个顶点的所有属性使用相同的缓冲区对象。使用`GL_ARRAY_BUFFER`缓冲区对象时，`glVertexAttribPointer`的`pointer`参数从指向实际数据的一个指针变成用`glBufferData`分配的顶点缓冲区存储中以字节表示的偏移量。类似地，如果使用有效的`GL_ELEMENT_ARRAY_BUFFER`对象，则`glDrawElements`中的`indices`参数从指向实际元素索引的指针变成用`glBufferData`分配的元素索引缓冲区存储中以字节表示的偏移量。\n\n上述代码描述的存储顶点属性的是结构数组方法，也可以对每个顶点属性使用一个缓冲区对象--数组结构方法：\n\n``` objc\nvoid DrawPrimitiveWithVBOs() {\n    GLuint vboIds[3];\n    GLint vertex_position_size = 3;\n    GLint vertex_color_size = 4;\n    GLfloat position[] = {\n        -0.5f, 0.5f, 0.0f,\n        -1.0f, -0.5f, 0.0f,\n        0.0f, -0.5f, 0.0f\n    };\n    GLfloat color[] = {\n        1.0f, 0.0f, 0.0f, 1.0f,\n        0.0f, 1.0f, 0.0f, 1.0f,\n        0.0f, 0.0f, 1.0f, 1.0f\n    };\n    GLushort indices[3] = {0, 1, 2};\n\n    glGenBuffers(3, vboIds);\n    glBindBuffer(GL_ARRAY_BUFFER, vboIds[0]);\n    glBufferData(GL_ARRAY_BUFFER, sizeof(GLfloat) * vertex_position_size * 3, position, GL_STATIC_DRAW);\n    glBindBuffer(GL_ARRAY_BUFFER, vboIds[1]);\n    glBufferData(GL_ARRAY_BUFFER, sizeof(GLfloat) * vertex_color_size * 4, color, GL_STATIC_DRAW);\n    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vboIds[2]);\n    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(GLushort) * 3, indices, GL_STATIC_DRAW);\n    \n    glBindBuffer(GL_ARRAY_BUFFER, vboIds[0]);\n    glEnableVertexAttribArray(0);\n    glVertexAttribPointer(0, vertex_position_size, GL_FLOAT, GL_FALSE, sizeof(GLfloat) * vertex_position_size, 0);\n    glBindBuffer(GL_ARRAY_BUFFER, vboIds[1]);\n    glEnableVertexAttribArray(1);\n    glVertexAttribPointer(1, vertex_color_size, GL_FLOAT, GL_FALSE, sizeof(GLfloat) * vertex_color_size, 0);\n    glDrawElements(GL_TRIANGLES, 3, GL_UNSIGNED_SHORT, 0);\n    \n    glDisableVertexAttribArray(0);\n    glDisableVertexAttribArray(1);\n    \n    glBindBuffer(GL_ARRAY_BUFFER, 0);\n    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);\n}\n```\n\n在应用程序结束缓冲对象的使用之后，删除它们：\n\n``` objc\n/**\n 删除缓冲区对象\n\n @param n#> 删除的缓冲区对象数量 description#>\n @param buffers#> 包含要删除的缓冲区对象的有n个元素的数组 description#>\n @return void\n */\nglDeleteBuffers(GLsizei n, const GLuint *buffers);\n```\n\n一旦缓冲区对象被删除，它就可以作为新的缓冲区对象重用，存储顶点属性或者不同图元的元素索引。\n\n使用顶点缓冲区对象非常容易，比起顶点数组，所需要的额外工作非常少。考虑到这种功能提供的性能提升，支持顶点缓冲区对象的少量额外工作是值得的。\n\n# 顶点数组对象\n\n上面我们已经介绍了顶点属性加载的两种不同方式：使用客户顶点数组和使用顶点缓冲区对象。顶点缓冲区对象优于客户顶点数组，因为它们能够减少GPU和CPU之间复制的数据量，从而获得更好的性能。在OpenGL ES 3.0中引入了一个新特性，使顶点数组的使用更加高效：顶点数组对象（VAO）。正如上面代码所示，使用顶点缓冲区对象设置绘图操作可能需要多次调用`glBindBuffer`、`glVertexAttribPointer`和`glEnableVertexAttribArray`。为了更快地在顶点数组配置直接切换，OpenGL ES 3.0推出了顶点数组对象。VAO提供包含在顶点数组/顶点缓冲区对象配置之间切换所需要的所有状态的单一对象。\n\n实际上，OpenGL ES 3.0中总是有一个活动的顶点数组对象。目前上述所有例子都在默认的顶点数组对象上操作（默认VAO的ID为0）。要创建新的顶点数组对象，可以使用`glGenVertexArrays`函数：\n\n``` objc\n/**\n 创建顶点数组对象\n\n @param n#> 要返回的顶点数组对象名称的数量 description#>\n @param arrays#> 指向一个n个元素的数组的指针，该数组是分配的顶点数组对象返回的位置 description#>\n @return void\n */\nglGenVertexArrays(GLsizei n, GLuint *arrays);\n```\n\n一旦创建，就可以用`glBindVertexArray`绑定顶点数组对象供以后使用：\n\n``` objc\n/**\n 绑定顶点数组对象\n\n @param array#> 被指定为当前顶点数组对象的对象 description#>\n @return void\n */\nglBindVertexArray(GLuint array);\n```\n\n每个VAO都包含一个完整的状态向量，描述所有顶点缓冲区绑定和启用的顶点客户状态。绑定VAO时，它的状态向量提供顶点缓冲区状态的当前设置。用`glBindVertexArray`绑定顶点数组对象后，更改顶点数组状态的后续调用（`glBindBuffer`、`glVertexAttribPointer`、`glEnableVertexAttribArray`、`glDisableVertexAttribArray`）将影响新的VAO。\n\n这样，应用程序可以通过绑定一个已经设置状态的顶点数组对象快速地在顶点数组配置之间切换。所有变化可以在一个函数调用中完成，没有必要多次调用以更改顶点数组状态。例子：\n\n``` objc\nvoid DrawPrimitiveWithVAOs() {\n    GLuint vboIds[2];\n    GLint vertex_position_size = 3;\n    GLint vertex_color_size = 4;\n    GLfloat vertices[] = {\n        0.0f, 0.5f, 0.0f,\n        1.0f, 0.0f, 0.0f, 1.0f,\n        -0.5f, -0.5f, 0.0f,\n        0.0f, 1.0f, 0.0f, 1.0f,\n        0.5f, -0.5f, 0.0f,\n        0.0f, 0.0f, 1.0f, 1.0f\n    };\n    GLuint vaoId;\n    GLushort indices[3] = { 0, 1, 2 };\n    glGenBuffers(2, vboIds);\n    glBindBuffer(GL_ARRAY_BUFFER, vboIds[0]);\n    glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);\n    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vboIds[1]);\n    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);\n    \n    glGenVertexArrays(1, &vaoId);\n    glBindVertexArray(vaoId);\n    \n    glBindBuffer(GL_ARRAY_BUFFER, vboIds[0]);\n    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vboIds[1]);\n    \n    glEnableVertexAttribArray(0);\n    glEnableVertexAttribArray(1);\n    \n    glVertexAttribPointer(0, vertex_position _size, GL_FLOAT, GL_FALSE, sizeof(GLfloat) * (vertex_position_size + vertex_color_size), 0);\n    glVertexAttribPointer(1, vertex_color_size, GL_FLOAT, GL_FALSE, sizeof(GLfloat) * (vertex_position_size + vertex_color_size), (const void *)(sizeof(GLfloat) * vertex_position_size));\n        \n    glBindVertexArray(0);\n\n    // 绘制\n    glBindVertexArray(vaoId);\n    glDrawElements(GL_TRIANGLES, 3, GL_UNSIGNED_SHORT, 0);\n}\n```\n\n当应用程序结束一个或者多个顶点数组对象的使用时，可以用`glDeleteVertexArrays`删除它们：\n\n``` objc\n/**\n 删除顶点数组对象\n\n @param n#> 要删除的顶点数组对象的数量 description#>\n @param arrays#> 包含需要删除的顶点数组对象的有n个元素的数组 description#>\n @return void\n */\nglDeleteVertexArrays(GLsizei n, const GLuint *arrays);\n```\n\n# 映射缓冲区对象\n\n到目前为止，我们已经使用了`glBufferData`或`glBufferSubData`将数据加载到缓冲区对象。应用程序也可以将缓冲区对象数据存储映射到应用程序的地址空间（也可以解除映射）。应用程序映射缓冲区而不使用`glBufferData`或者`glBufferSubData`加载数据有几个理由：\n- 映射缓冲区可以减少应用程序的内存占用，因为可能只需要存储数据的一个副本；\n- 在使用共享内存的架构上，映射缓冲区返回GPU存储缓冲区的地址空间的直接指针。通过映射缓冲区，应用程序可以避免复制步骤，从而实现更好的更新性能。\n\n`glMapBufferRange`命令返回指向所有或者一部分（范围）缓冲区对象数据存储的指针。这个指针可以供应应用程序使用，以读取或者更新缓冲区对象的内容。`glUnmapBuffer`命令用于指示更新已经完成和释放映射的指针：\n\n``` objc\n/**\n 返回指向所有或者部分缓冲区对象数据存储的指针\n\n @param target#> GL_ARRAY_BUFFER, GL_ELEMENT_ARRAY_BUFFER, GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, GL_PIXEL_PACK_BUFFER, GL_PIXEL_UNPACK_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, GL_UNIFORM_BUFFER description#>\n @param offset#> 缓冲区数据存储中的偏移量，以字节数计算 description#>\n @param length#> 需要映射的缓冲区数据的字节数 description#>\n @param access#> 详见下表 description#>\n @return GLvoid *\n */\nglMapBufferRange(GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access);\n```\n\n访问标志 | 描述\n- | -\nGL_MAP_READ_BIT | 应用程序将从返回的指针读取\nGL_MAP_WRITE_BIT | 应用程序将写入返回的指针\n\n此外，应用程序可以包含如下可选访问标志：\n\n访问标志 | 描述\n- | -\nGL_MAP_INVALIDATAE_RANGE_BIT | 表示指定范围内的缓冲区内容可以在返回指针之前由驱动程序放弃。这个标志不能与GL_MAP_READ_BIT组合使用\nGL_MAP_INVALIDATE_BUFFER_BIT | 表示整个缓冲区的内容可以在返回指针之前由驱动程序放弃。这个标志不能与GL_MAP_READ_BIT组合使用\nGL_MAP_FLUSH_EXPLICIT_BIT | 表示应用程序将明确地用glFlushMappedBufferRange刷新对映射范围子范围的操作。这个标志不能与GL_MAP_WRITE_BIT组合使用\nGL_MAP_UNSYNCHRONIZED_BIT | 表示驱动程序在返回缓冲区范围的指针之前不需要等待缓冲对象上的未决操作。如果有未决的操作，则未决操作的结果和缓冲区对象上的任何未来操作都变为未定义\n\n`glMapBufferRange`返回请求的缓冲区数据存储范围的指针。如果出现错误或者发出无效的请求，该函数将返回NULL。`glUnmapBuffer`命令取消之前的缓冲区映射：\n\n``` objc\n/**\n 取消缓冲区映射\n\n @param target#> 必须设置为GL_ARRAY_BUFFER description#>\n @return GLboolean\n */\nglUnmapBuffer(GLenum target);\n```\n\n如果取消映射操作成功，则`glUnmapBuffer`返回`GL_TRUE`。`glMapBufferRange`返回的指针在成功执行取消映射之后不再可以使用。如果顶点缓冲区对象数据存储中的数据在缓冲区映射之后已经破坏，`glUnmapBuffer`将返回`GL_FALSE`，这可能是因为屏幕分辨率的变化、OpenGL ES上下文使用多个屏幕或者导致映射内存被抛弃的内存不足事件所导致。\n\n写入映射缓冲区对象例子：\n``` objc\nGLfloat *vtxMappedBuf;\nGLushort *idxMappedBuf;\nGLfloat vertices[] = {\n    0.0f, 0.5f, 0.0f,\n    1.0f, 0.0f, 0.0f, 1.0f,\n    -0.5f, -0.5f, 0.0f,\n    0.0f, 1.0f, 0.0f, 1.0f,\n    0.5f, -0.5f, 0.0f,\n    0.0f, 0.0f, 1.0f, 1.0f\n};\nGLushort indices[3] = { 0, 1, 2 };\n\nglGenBuffers(2, vboIds);\nglBindBuffer(GL_ARRAY_BUFFER, vboIds[0]);\nglBufferData(GL_ARRAY_BUFFER, sizeof(vertices), NULL, GL_STATIC_DRAW);\nvtxMappedBuf = (GLfloat *)glMapBufferRange(GL_ARRAY_BUFFER, 0, sizeof(vertices), GL_MAP_WRITE_BIT | GL_MAP_INVALIDATE_BUFFER_BIT);\nif (vtxMappedBuf == NULL) {\n    NSLog(@\"Error mapping vertex buffer object\");\n    return;\n}\nmemcpy(vtxMappedBuf, vertices, sizeof(vertices));\nif (glUnmapBuffer(GL_ARRAY_BUFFER) == GL_FALSE) {\n    NSLog(@\"Error unmapping array buffer object\");\n    return;\n}\n\nglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vboIds[1]);\nglBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), NULL, GL_STATIC_DRAW);\nidxMappedBuf = (GLushort *)glMapBufferRange(GL_ELEMENT_ARRAY_BUFFER, 0, sizeof(indices), GL_MAP_WRITE_BIT | GL_MAP_INVALIDATE_BUFFER_BIT);\nif (idxMappedBuf == NULL) {\n    NSLog(@\"Error mapping element buffer object\");\n    return;\n}\nmemcpy(idxMappedBuf, indices, sizeof(indices));\nif (glUnmapBuffer(GL_ELEMENT_ARRAY_BUFFER) == GL_FALSE) {\n    NSLog(@\"Error unmapping element buffer object\");\n    return;\n}\n```\n\n## 刷新映射的缓冲区\n\n应用程序可能希望用`glMapBufferRange`来映射缓冲区对象的一个范围或者全部，但是只更新映射范围的不同子区域。为了避免调用`glUnmapBuffer`时刷新整个映射范围的潜在性能损失，应用程序可以用`GL_MAP_FLUSH_EXPLICIT_BIT`访问标志（和`GL_MAP_WRITE_BIT`组合）映射。当应用程序完成映射范围一部分的更新时，可以用`glFlushMappedBufferRange`指出这个事实：\n\n``` objc\n/**\n 指出应用程序完成映射范围的部分更新\n\n @param target#> GL_ARRAY_BUFFER, GL_ELEMENT_ARRAY_BUFFER, GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, GL_PIXEL_PACK_BUFFER, GL_PIXEL_UNPACK_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, GL_UNIFORM_BUFFER description#>\n @param offset#> 从映射缓冲区起始点的偏移量，以字节数表示 description#>\n @param length#> 从便宜点开始刷新的缓冲区字节数 description#>\n @return void\n */\nglFlushMappedBufferRange(GLenum target, GLintptr offset, GLsizeiptr length);\n```\n\n如果应用程序用`GL_MAP_FLUSH_EXPLICIT_BIT`映射，但是没有明确用`glFlushMappedBufferRange`刷新修改后的区域，它的内容将是未定义的。\n\n# 复制缓冲区对象\n\n上面我们已经说明如何用`glBufferData`、`glBufferSubData`和`glMapBufferRange`加载缓冲区对象。所有这些技术都涉及从应用程序到设备的数据传输。OpenGL ES 3.0还可以从一个缓冲区对象将数据完全复制到设备：\n\n``` objc\n/**\n 从一个缓冲区对象将数据完全复制到设备\n\n @param readTarget#> 读取的缓冲区对象目标 description#>\n @param writeTarget#> 写入的缓冲区对象目标 description#>\n @param readOffset#> 需要复制的读缓冲数据中的偏移量，以字节表示 description#>\n @param writeOffset#> 需要复制的写缓冲数据中的偏移量，以字节表示 description#>\n @param size#> 从读缓冲区数据复制到写缓冲区数据的字节数 description#>\n @return void\n */\nglCopyBufferSubData(GLenum readTarget, GLenum writeTarget, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size);\n```\n\n调用`glCopyBufferSubData`将从绑定到`readtarget`的缓冲区复制指定的字节到`writetarget`。缓冲区绑定根据每个目标的最后一次`glBindBuffer`确定调用。任何类型的缓冲区对象（数组、元素数组、变换反馈等）都可以绑定到`GL_COPY_READ_BUFFER`或`GL_COPY_WRITE_BUFFER`目标。这两个目标是一种方便的措施，使得应用程序在执行缓冲区间的复制时不必改变任何真正的缓冲区绑定。\n\n# 总结\n\n这篇文章主要介绍了指定顶点属性和数据的方法。","source":"_posts/2019/opengl-es-vertex-0720.md","raw":"---\ntitle: \"OpenGL ES学习--顶点属性、顶点数组和缓冲区对象\"\ncatalog: true\ntoc_nav_num: true\ndate: 2019-07-20 18:28:11\nsubtitle: \"About OpenGL ES\"\nheader-img: \"/img/article_header/article_header.png\"\nbusuanzi: true\ntags:\n- iOS\n\n---\n\n> 顶点数据也称作顶点属性，指定每个顶点的数据。这种逐顶点数据可以为每个顶点指定，也可以用于所有顶点的常量。例如，如果想要绘制一个固定颜色的三角形，可以指定一个常量值，用于三角形的全部3个顶点。但是，组成三角形的3个顶点的位置不同，所以我们必须指定一个顶点数组来存储3个位置值。\n\n# 指定顶点属性数据\n\n顶点属性数据可以用一个顶点数组对每个顶点指定，也可以将一个常量值用于一个图元的所有顶点。\n\n所有OpenGL ES 3.0实现必须支持最少16个顶点属性，可以通过`glGet*`函数查询特定支持的顶点属性的准确数量：\n\n``` objc\nGLint maxVertexAttribs; \nglGetIntegerv(GL_MAX_VERTEX_ATTRIBS, &maxVertexAttribs);\n```\n\n## 常量顶点属性\n\n常量顶点属性对于一个图元的所有顶点都相同，所以对一个图元的所有顶点只需指定一个值。\n\n``` objc\n// 加载indx指定的通用顶点属性(x, 0.0, 0.0, 1.0)\nglVertexAttrib1f(GLuint indx, GLfloat x);\nglVertexAttrib1fv(GLuint indx, const GLfloat *values);\n\n// 加载indx指定的通用顶点属性(x, y, 0.0, 1.0)\nglVertexAttrib2f(GLuint indx, GLfloat x, GLfloat y);\nglVertexAttrib2fv(GLuint indx, const GLfloat *values);\n\n// 加载indx指定的通用顶点属性(x, y, z, 1.0)\nglVertexAttrib3f(GLuint indx, GLfloat x, GLfloat y, GLfloat z);\nglVertexAttrib3fv(GLuint indx, const GLfloat *values);\n\n// 加载indx指定的通用顶点属性(x, y, z, w)\nglVertexAttrib4f(GLuint indx, GLfloat x, GLfloat y, GLfloat z, GLfloat w);\nglVertexAttrib4fv(GLuint indx, const GLfloat *values);\n```\n\n## 顶点数组\n\n顶点数组指定每个顶点的属性，是保存在应用程序地址空间的缓冲区。它们作为顶点缓冲对象的基础，提供指定顶点属性数据的一种高效、灵活的手段。\n\n``` objc\n/**\n 指定顶点属性\n\n @param indx#> 指定通用顶点属性索引 description#>\n @param size#> 顶点数组中为索引引用的顶点属性所指定的分量数量，有效值为1~4 description#>\n @param type#> 数据格式 description#>\n @param normalized#> 用于表示非浮点数据格式类型在转换为浮点值时是否应该规范化 description#>\n @param stride#> 每个顶点由size指定的顶点属性分量顺序存储。stride指定顶点索引I和I+1表示的顶点数据之间的位移。如果stride为0，则每个顶点的属性数据顺序存储。如果stride大于0，则使用该值作为获取下一个索引表示的顶点数据的跨距 description#>\n @param ptr#> 如果使用客户端顶点数组，则是保存顶点属性数据的缓冲区指针。如果使用顶点缓冲区对象，则表示该缓冲区内的偏移量 description#>\n @return void\n */\nglVertexAttribPointer(GLuint indx, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid *ptr);\n\n/**\n 指定顶点属性，数据格式类型被当做整数对待\n\n @param index#> 指定通用顶点属性索引 description#>\n @param size#> 顶点数组中为索引引用的顶点属性所指定的分量数量，有效值为1~4 description#>\n @param type#> 数据格式 description#>\n @param stride#> 每个顶点由size指定的顶点属性分量顺序存储。stride指定顶点索引I和I+1表示的顶点数据之间的位移。如果stride为0，则每个顶点的属性数据顺序存储。如果stride大于0，则使用该值作为获取下一个索引表示的顶点数据的跨距 description#>\n @param pointer#> 如果使用客户端顶点数组，则是保存顶点属性数据的缓冲区指针。如果使用顶点缓冲区对象，则表示该缓冲区内的偏移量 description#>\n @return void\n */\nglVertexAttribIPointer(GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);\n```\n\n分配和存储顶点属性数据有两种常用的方法：\n- 在一个缓冲区中存储顶点属性--这种方法称为结构数组。结构表示顶点的所有属性，每个顶点有一个属性的数组。\n- 在单独的缓冲区中保存每个顶点属性--这种方法称为数组结构。\n\n### 哪种存储顶点属性的方法高效\n\n在大部分情况下，答案是结构数组。原因是，每个顶点的属性数据可以顺序方法读取，这最有可能造成高效的内存访问模式。使用结构数组的缺点在应用程序需要修改特定属性时变得很明显。如果顶点属性数据的一个自己需要修改，这将造成顶点缓冲区的跨距更新。当顶点缓冲区以缓冲区对象的形式提供时，需要重新加载整个顶点属性缓冲区。可以通过将动态的顶点属性保存在单独的缓冲区来避免这种效率低下的情况。\n\n### 顶点属性使用哪种数据格式\n\n`glVertexAttribPointer`中的`type`参数指定的顶点属性格式不仅影响顶点属性数据的图形内存存储需求，而且影响整体性能，这是渲染帧所需内存带宽的一个函数。数据空间占用越小，需要的内存带宽越小。OpenGL ES 3.0支持名为`GL_HALF_FLOAT`的16位浮点顶点格式，建议尽可能使用。纹理坐标、法线、副法线、切向量等都是使用`GL_HALF_FLOAT`存储每个分量的候选。颜色可以存储为`GL_UNSIGNED_BYTE`，每个顶点颜色具有4个分量。顶点位置可以存储为`GL_FLOAT`。\n\n### `glVertexAttribPointer`中的规范化标识如何工作\n\n在用于顶点着色器之前，顶点属性在内部保存为单精度浮点数，如果数据类型表示顶点属性不是浮点数，顶点属性将在用于顶点着色器之前转换为单精度浮点数。规范化标志控制非浮点顶点属性数据到单精度浮点值的转换。如果规范化标识为假，则顶点数据被直接转换为浮点数。这类似于将非浮点类型的变量转换为浮点变量。例子：\n\n``` objc\nGLfloat f;\nGLbyte b;\nf = (GLfloat)b;     // f represents values in the range [-128.0, 127.0]\n```\n\n如果规范化标志位真，且如果数据类型为`GL_BYTE`、`GL_SHORT`或者`GL_FIXED`，则顶点数据被映射到[-1.0, 1.0]范围内，如果数据类型为`GL_UNSIGNED_BYTE`或`GL_UNSIGNED_SHORT`，则被映射到[0.0, 1.0]范围内。\n\n下表说明了设置规范化标志时非浮点数据类型的转换，表中第二列的`c`值指的是第一列中指定格式的一个值：\n\n顶点数据格式 | 转换为浮点数\n- | -\nGL_BYTE | max(c/(2<sup>7</sup>-1), -1.0)\nGL_UNSIGNED_BYTE | c/(2<sup>8</sup>-1)\nGL_SHORT | max(c/(2<sup>16</sup>-1), -1.0)\nGL_UNSIGNED_SHORT | c/(2<sup>16</sup>-1)\nGL_FIXED | c/(2<sup>16</sup>)\nGL_FLOAT | c\nGL_HALF_FLOAT_OES | c\n\n在顶点着色器中，也有可能按照整数的形式访问整数型顶点属性数据，而不是将其转换为浮点数，可以使用`glVertexAttribIPointer`函数。\n\n### 在常量顶点属性和顶点数组之间选择\n\n应用程序可以让OpenGL ES使用常量数据或者来自顶点数组的数据。`glEnableVertexAttribArray`和`glDisableVertexAttribArray`命令分别用于启用和禁用通用顶点属性数组。如果某个通用属性索引的顶点属性数组被禁用，将使用为该索引指定的常量顶点属性数据。\n\n``` objc\n// glsl.vsh\n#version 300 es\nlayout(location = 0) in vec4 a_color;\nlayout(location = 1) in vec4 a_position;\nout vec4 v_color;\nvoid mian() {\n    v_color = a_color;\n    gl_Position = a_position;\n}\n```\n\n``` objc\n// glsl.fsh\n#version 300 es\nprecision mudiump float;\nin vec4 v_color;\nout vec4 o_fragColor;\nvoid main() {\n    o_fragColor = v_color;\n}\n```\n\n``` objc\nGLfloat color[4] = {1.0f, 0.0f, 0.0f, 1.0f};\nGLfloat vertexPos[9] = {0.0f, 0.5f, 0.0f,\n                        -0.5f, -0.5f, 0.0f,\n                        0.5f, -0.5f, 0.0f};\nglVertexAttrib4fv(0, color);\nglVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 0, vertexPos);\nglEnableVertexAttribArray(1);\nglDrawArrays(GL_TRIANGLES, 0, 3);\nglDisableVertexAttribArray(1);\n```\n\n代码示例中使用的顶点属性`color`是一个常量，用`glVertexAttrib4fv`指定，不启用顶点属性数组0。`vertexPos`属性用`glVertexAttribPointer`以一个顶点数组指定，并用`glEnableVertexAttribArray`启用数组。`color`值对于所绘制的三角形的所有顶点均相同，而`vertexPos`属性对于三角形的各个顶点可以不同。\n\n# 在顶点着色器中声明顶点属性变量\n\n在顶点着色器中，变量通过使用`in`限定符声明为顶点属性。属性变量也可以包含一个布局限定符，提供属性索引：\n\n``` objc\nlayout(location = 0) in vec4 a_position;\nlayout(location = 1) in vec2 a_texcoord;\nlayout(location - 2) in vec3 a_normal;\n```\n\n属性可以在顶点着色器内部声明--但是如果没有使用，就不会被认为是活动属性，从而不会被计入限制。如果在顶点着色器中使用的属性数量大于`GL_MAX_VERTEX_ATTRIBS`，这个顶点着色器就无法链接。\n\n当程序成功链接，我们就需要找出连接到该程序的顶点着色器使用的活动顶点属性数量。注意：这一步骤只需要在我们对属性不使用布局限定符时才有必要。\n首先通过`glGetProgramiv`函数传入`GL_ACTIVE_ATTRIBUTE`获取活动的属性数量，传入`GL_ACTIVE_ATTRIBUTE_MAX_LENGTH`获取属性的最长字符数量，最后使用`glGetActiveAttrib`函数查询顶点着色器各属性索引点对应的属性变量名称：\n\n``` objc\nGLint attribsCount;\nGLint attribMaxLength;\nglGetProgramiv(program, GL_ACTIVE_ATTRIBUTES, &attribsCount);\nglGetProgramiv(program, GL_ACTIVE_ATTRIBUTE_MAX_LENGTH, &attribMaxLength);\nfor (int i = 0; i < attribsCount; i++) {\n    GLsizei length;\n    GLint size;\n    GLenum type;\n    GLchar *name = malloc(attribMaxLength * sizeof(GLchar));\n    glGetActiveAttrib(program, i, attribMaxLength, &length, &size, &type, name);\n    NSLog(@\"length: %d, size: %d, type: %u, name: %s\", length, size, type, name);\n}\n```\n\n## 将顶点属性绑定到顶点着色器中的属性变量\n\n在OpenGL ES 3.0中，可以使用3种方法将通用顶点属性索引映射到顶点着色器中的一个属性变量名称：\n- 索引可以在顶点着色器源代码中用`layout(location = N)`限定符指定（推荐）；\n- OpenGL ES 3.0将通用顶点属性索引绑定到属性名称；\n- 应用程序可以将顶点属性索引绑定到属性名称；\n\n将属性绑定到一个位置的最简单方法是简单地使用`layout(location = N)`限定符，这种方法需要的代码最少。但是，在某些情况下，其他两个选项可能更合适。`glBindAttribLocation`命令可用于将通用顶点属性索引绑定到顶点着色器中的一个属性变量。这种绑定在下一次程序链接时生效--不会改变当前链接的程序中使用的绑定。\n\n``` objc\n/**\n 将通用顶点属性索引绑定到属性变量\n\n @param program#> 程序对象 description#>\n @param index#> 通用顶点属性索引 description#>\n @param name#> 属性变量名称 description#>\n @return void\n */\nglBindAttribLocation(GLuint program, GLuint index, const GLchar *name);\n```\n\n如果之前绑定了`name`，则它所指定的绑定被索引代替。`glBindAttribLocation`甚至可以在顶点着色器连接到程序对象之前调用，因此，这个调用可以用于绑定任何属性名称。不存在的属性名称或者在连接到程序对象的顶点着色器中不活动的属性将被忽略。\n\n另一个选项是让OpenGL ES 3.0将属性变量名称绑定到一个通用顶点属性索引。这种绑定在程序链接时进行，在链接阶段，OpenGL ES 3.0实现为每个属性变量执行如下操作：对于每个属性变量，检查是否已经通过`glBindAttribLocation`。如果指定了一个绑定，则使用指定的对应属性索引。否则，OpenGL ES实现将分配一个通用顶点属性索引。\n这种分配特定于实现；也就是说，在一个OpenGL ES 3.0实现中和在另一个实现中可能不同。应用程序可以使用`glGetAttribLocation`命令查询分配的绑定。\n\n``` objc\n/**\n 查询属性索引\n\n @param program#> 程序对象 description#>\n @param name#> 属性变量名称 description#>\n @return 属性索引\n */\nglGetAttribLocation(GLuint program, const GLchar *name);\n```\n\n`glGetAttribLocation`返回`program`定义的程序对象最后一次链接时绑定到属性变量`name`的通用属性索引。如果`name`不是一个活动属性变量，或者`program`不是一个有效的程序对象，或者没有链接成功，则返回-1，表示无效的属性索引。\n\n# 顶点缓冲区对象\n\n使用顶点数组指定的顶点数据保存在客户内存中。在进行`glDrawArrays`或者`glDrawElements`等绘图调用时，这些数据必须从客户内存复制到图形内存。但是，如果我们没有必要在每次绘图调用时都复制顶点数据，而是在图形内存中缓存这些数据，那就好得多了。这种方法可以显著地改进渲染性能，也会降低内存带宽和电力消耗序曲，对于手持设备相当重要。这是顶点缓冲区对象发挥的地方。顶点缓冲区对象使OpenGL ES 3.0应用程序可以在高性能的图形内存中分配和缓存顶点数据，并从这个内存进行渲染，从而避免在每次绘制图元的时候重新发送数据。不仅是顶点数据，描述图元顶点索引、作为`glDrawElements`参数传递的元素索引也可以缓存。\n\nOpenGL ES 3.0支持两类缓冲区对象，用于指定顶点和图元数据：数组缓冲区对象和元素数组缓冲区对象。`GL_ARRAY_BUFFER`标志指定的数组缓冲区对象用于创建保存顶点数据的缓冲区对象。`GL_ELEMENT_ARRAY_BUFFER`标志指定的元素数组缓冲区对象用于创建保存图元索引的缓冲区对象。\n\n> 为了得到最佳性能，推荐OpenGL ES 3.0应用程序对顶点属性数据和元素索引使用顶点缓冲区对象。\n\n 在使用缓冲对象渲染之前，需要分配缓冲区对象并将顶点数据和元素索引上传到相应的缓冲区对象。\n\n``` objc\n// vertex_t是自定义顶点数据类型\nvoid initVertexBufferObjects(vertex_t *vertexBuffer,\n                             GLushort *indices,\n                             GLuint numVertices,\n                             GLuint numIndices,\n                             GLuint *vboIds) {\n    glGenBuffers(2, vboIds);\n    \n    glBindBuffer(GL_ARRAY_BUFFER, vboIds[0]);\n    glBufferData(GL_ARRAY_BUFFER, numVertices * sizeof(vertex_t), vertexBuffer, GL_STATIC_DRAW);\n    \n    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vboIds[1]);\n    glBufferData(GL_ELEMENT_ARRAY_BUFFER, numIndices * sizeof(GLushort), indices, GL_STATIC_DRAW);\n}\n```\n\n上述代码创建两个缓冲区对象：一个用于保存实际的顶点属性数据，另一个用于保存组成图元的元素索引。数组缓冲区对象用于保存一个或者多个图元的顶点属性数据，元素数组缓冲区对象保存一个或者多个图元的索引。\n\n``` objc\n/**\n 创建缓冲区对象\n\n @param n#> 返回缓冲区对象名称数量 description#>\n @param buffers#> 指向n个条目的数组指针，该数组是分配的缓冲区对象返回的位置 description#>\n @return void\n */\nglGenBuffers(GLsizei n, GLuint *buffers);\n\n/**\n 指定当前缓冲区对象\n\n @param target#> GL_ARRAY_BUFFER, GL_ELEMENT_ARRAY_BUFFER, GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, GL_PIXEL_PACK_BUFFER, GL_PIXEL_UNPACK_BUFFER, GL_TRANSFROM_FEEDBACK_BUFFER, GL_UNIFORM_BUFFER description#>\n @param buffer#> 分配给目标当做当前对象的缓冲区对象 description#>\n @return void\n */\nglBindBuffer(GLenum target, GLuint buffer);\n\n/**\n 顶点数组数据或者元素数组数据存储创建和初始化\n\n @param target#> GL_ARRAY_BUFFER, GL_ELEMENT_ARRAY_BUFFER, GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, GL_PIXEL_PACK_BUFFER, GL_PIXEL_UNPACK_BUFFER, GL_TRANSFROM_FEEDBACK_BUFFER, GL_UNIFORM_BUFFER description#>\n @param size#> 缓冲区数据存储大小，以字节数表示 description#>\n @param data#> 应用程序提供的缓冲区数据的指针，可为NULL值，表示保留的数据存储不进行初始化。如果是一个有效的指针，则其内容被复制到分配的数据存储 description#>\n @param usage#> 详见下表 description#>\n @return void\n */\nglBufferData(GLenum target, GLsizeiptr size, const GLvoid *data, GLenum usage);\n\n/**\n 顶点数组数据或者元素数组数据存储初始化或者更新\n\n @param target#> GL_ARRAY_BUFFER, GL_ELEMENT_ARRAY_BUFFER, GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, GL_PIXEL_PACK_BUFFER, GL_PIXEL_UNPACK_BUFFER, GL_TRANSFROM_FEEDBACK_BUFFER, GL_UNIFORM_BUFFER description#>\n @param offset#> 缓冲区数据存储中的偏移 description#>\n @param size#> 被修改的数据存储字节数 description#>\n @param data#> 需要被复制到缓冲区对象数据存储的客户数据指针 description#>\n @return void\n */\nglBufferSubData(GLenum target, GLintptr offset, GLsizeiptr size, const GLvoid *data)\n```\n\n缓冲区使用枚举值 | 描述\n- | -\nGL_STATIC_DRAW | 缓冲区对象数据将被修改一次，使用多次，以绘制图元或者指定图像\nGL_STATIC_READ | 缓冲区对象数据将被修改一次，使用多次，以从OpenGL ES读回数据。从OpenGL ES读回的数据将从应用程序中查询\nGL_STATIC_COPY | 缓冲区对象数据将被修改一次，使用多次，以从OpenGL ES读回数据。从OpenGL ES读回的数据将直接用作绘制图元或者修改图像的信息来源\nGL_DYNAMIC_DRAW | 缓冲区对象数据将被重复修改，使用多次，以绘制图元或者指定图像\nGL_DYNAMIC_READ | 缓冲区对象数据将被重复修改，使用多次，以从OpenGL ES读回数据。从OpenGL ES读回的数据中将从应用程序中查询\nGL_DYNAMIC_COPY | 缓冲区对象数据将被重复修改，使用多次，以从OpenGL ES读回数据。从OpenGL ES读回的数据将直接用作绘制图元或者修改图像的信息来源\nGL_STREAM_DRAW | 缓冲区对象数据将被修改一次，只使用少数几次，以绘制图元或者指定图像\nGL_STREAM_READ | 缓冲区对象数据将被修改一次，只使用少数几次，以从OpenGL ES读回数据。从OpenGL ES读回的数据将从应用程序中查询\nGL_STREAM_COPY | 缓冲区对象数据将被修改一次，只使用少数几次，以从OpenGL ES读回数据。从OpenGL ES读回的数据将直接用作绘制图元或者修改图像的信息来源\n\n在用`glBufferData`或者`glBufferSubData`初始化或者更新缓冲区对象数据存储之后，客户数据存储不再需要，可以释放。对于静态的几何形状，应用程序可以释放客户数据存储，减少应用程序消耗的系统内存。对于动态几何形状，这可能无法做到。\n\n下面是个使用和不使用缓冲区对象进行的图元绘制：\n\n``` objc\n// glsl.vsh\n#version 300 es\nlayout(location = 0) in vec4 vPosition;\nlayout(location = 1) in vec4 vColor;\nuniform float offsetLoc;\nout vec4 v_color;\n\nvoid main() {\n    v_color = vColor;\n    gl_Position = vec4(vPosition.x + offsetLoc, vPosition.yzw);\n}\n```\n\n``` objc\n// glsl.fsh\n#version 300 es\nprecision mediump float;\nin vec4 v_color;\nout vec4 fragColor;\n\nvoid main() {\n    fragColor = v_color;\n}\n```\n\n``` objc\nvoid DrawPrimitiveWithoutVBOs() {\n    GLint vertex_position_size = 3;\n    GLint vertex_color_size = 4;\n    GLushort indices[3] = {0, 1, 2};\n    GLfloat vertices[] = {\n        -0.5f, 0.5f, 0.0f,\n        1.0f, 0.0f, 0.0f, 1.0f,\n        -1.0f, -0.5f, 0.0f,\n        0.0f, 1.0f, 0.0f, 1.0f,\n        0.0f, -0.5f, 0.0f,\n        0.0f, 0.0f, 1.0f, 1.0f\n    };\n    GLfloat *vtxBuf = vertices;\n    GLsizei vtxStride = sizeof(GLfloat) * (vertex_color_size + vertex_position_size);\n    \n    glBindBuffer(GL_ARRAY_BUFFER, 0);\n    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);\n    \n    glEnableVertexAttribArray(0);\n    glEnableVertexAttribArray(1);\n    \n    glVertexAttribPointer(0, vertex_position_size, GL_FLOAT, GL_FALSE, vtxStride, vtxBuf);\n    vtxBuf += vertex_position_size;\n    glVertexAttribPointer(1, vertex_color_size, GL_FLOAT, GL_FALSE, vtxStride, vtxBuf);\n    \n    glDrawElements(GL_TRIANGLES, 3, GL_UNSIGNED_SHORT, indices);\n    \n    glDisableVertexAttribArray(0);\n    glDisableVertexAttribArray(1);\n}\n\nvoid DrawPrimitiveWithVBOs() {\n    GLvoid *offset = 0;\n    GLuint vboIds[2];\n    GLint vertex_position_size = 3;\n    GLint vertex_color_size = 4;\n    GLushort indices[3] = {0, 1, 2};\n    GLint vtxStride = sizeof(GLfloat) * (vertex_position_size + vertex_color_size);\n    GLfloat vertices[] = {\n        -0.5f, 0.5f, 0.0f,\n        1.0f, 0.0f, 0.0f, 1.0f,\n        -1.0f, -0.5f, 0.0f,\n        0.0f, 1.0f, 0.0f, 1.0f,\n        0.0f, -0.5f, 0.0f,\n        0.0f, 0.0f, 1.0f, 1.0f\n    };\n    GLfloat *vtxBuf = vertices;\n\n    glGenBuffers(2, vboIds);\n    glBindBuffer(GL_ARRAY_BUFFER, vboIds[0]);\n    glBufferData(GL_ARRAY_BUFFER, vtxStride * 3, vtxBuf, GL_STATIC_DRAW);\n    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vboIds[1]);\n    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(GLushort) * 3, indices, GL_STATIC_DRAW);\n    \n    glEnableVertexAttribArray(0);\n    glEnableVertexAttribArray(1);\n    \n    glVertexAttribPointer(0, vertex_position_size, GL_FLOAT, GL_FALSE, vtxStride, offset);\n    offset += vertex_position_size * sizeof(GLfloat);\n    glVertexAttribPointer(1, vertex_color_size, GL_FLOAT, GL_FALSE, vtxStride, offset);\n    \n    glDrawElements(GL_TRIANGLES, 3, GL_UNSIGNED_SHORT, 0);\n    \n    glDisableVertexAttribArray(0);\n    glDisableVertexAttribArray(1);\n    \n    glBindBuffer(GL_ARRAY_BUFFER, 0);\n    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);\n}\n\n// 调用\nDrawPrimitiveWithoutVBOs();\nglUniform1f(0, 1.0f);\nDrawPrimitiveWithVBOs();\n```\n\n上述代码中，我们对一个顶点的所有属性使用相同的缓冲区对象。使用`GL_ARRAY_BUFFER`缓冲区对象时，`glVertexAttribPointer`的`pointer`参数从指向实际数据的一个指针变成用`glBufferData`分配的顶点缓冲区存储中以字节表示的偏移量。类似地，如果使用有效的`GL_ELEMENT_ARRAY_BUFFER`对象，则`glDrawElements`中的`indices`参数从指向实际元素索引的指针变成用`glBufferData`分配的元素索引缓冲区存储中以字节表示的偏移量。\n\n上述代码描述的存储顶点属性的是结构数组方法，也可以对每个顶点属性使用一个缓冲区对象--数组结构方法：\n\n``` objc\nvoid DrawPrimitiveWithVBOs() {\n    GLuint vboIds[3];\n    GLint vertex_position_size = 3;\n    GLint vertex_color_size = 4;\n    GLfloat position[] = {\n        -0.5f, 0.5f, 0.0f,\n        -1.0f, -0.5f, 0.0f,\n        0.0f, -0.5f, 0.0f\n    };\n    GLfloat color[] = {\n        1.0f, 0.0f, 0.0f, 1.0f,\n        0.0f, 1.0f, 0.0f, 1.0f,\n        0.0f, 0.0f, 1.0f, 1.0f\n    };\n    GLushort indices[3] = {0, 1, 2};\n\n    glGenBuffers(3, vboIds);\n    glBindBuffer(GL_ARRAY_BUFFER, vboIds[0]);\n    glBufferData(GL_ARRAY_BUFFER, sizeof(GLfloat) * vertex_position_size * 3, position, GL_STATIC_DRAW);\n    glBindBuffer(GL_ARRAY_BUFFER, vboIds[1]);\n    glBufferData(GL_ARRAY_BUFFER, sizeof(GLfloat) * vertex_color_size * 4, color, GL_STATIC_DRAW);\n    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vboIds[2]);\n    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(GLushort) * 3, indices, GL_STATIC_DRAW);\n    \n    glBindBuffer(GL_ARRAY_BUFFER, vboIds[0]);\n    glEnableVertexAttribArray(0);\n    glVertexAttribPointer(0, vertex_position_size, GL_FLOAT, GL_FALSE, sizeof(GLfloat) * vertex_position_size, 0);\n    glBindBuffer(GL_ARRAY_BUFFER, vboIds[1]);\n    glEnableVertexAttribArray(1);\n    glVertexAttribPointer(1, vertex_color_size, GL_FLOAT, GL_FALSE, sizeof(GLfloat) * vertex_color_size, 0);\n    glDrawElements(GL_TRIANGLES, 3, GL_UNSIGNED_SHORT, 0);\n    \n    glDisableVertexAttribArray(0);\n    glDisableVertexAttribArray(1);\n    \n    glBindBuffer(GL_ARRAY_BUFFER, 0);\n    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);\n}\n```\n\n在应用程序结束缓冲对象的使用之后，删除它们：\n\n``` objc\n/**\n 删除缓冲区对象\n\n @param n#> 删除的缓冲区对象数量 description#>\n @param buffers#> 包含要删除的缓冲区对象的有n个元素的数组 description#>\n @return void\n */\nglDeleteBuffers(GLsizei n, const GLuint *buffers);\n```\n\n一旦缓冲区对象被删除，它就可以作为新的缓冲区对象重用，存储顶点属性或者不同图元的元素索引。\n\n使用顶点缓冲区对象非常容易，比起顶点数组，所需要的额外工作非常少。考虑到这种功能提供的性能提升，支持顶点缓冲区对象的少量额外工作是值得的。\n\n# 顶点数组对象\n\n上面我们已经介绍了顶点属性加载的两种不同方式：使用客户顶点数组和使用顶点缓冲区对象。顶点缓冲区对象优于客户顶点数组，因为它们能够减少GPU和CPU之间复制的数据量，从而获得更好的性能。在OpenGL ES 3.0中引入了一个新特性，使顶点数组的使用更加高效：顶点数组对象（VAO）。正如上面代码所示，使用顶点缓冲区对象设置绘图操作可能需要多次调用`glBindBuffer`、`glVertexAttribPointer`和`glEnableVertexAttribArray`。为了更快地在顶点数组配置直接切换，OpenGL ES 3.0推出了顶点数组对象。VAO提供包含在顶点数组/顶点缓冲区对象配置之间切换所需要的所有状态的单一对象。\n\n实际上，OpenGL ES 3.0中总是有一个活动的顶点数组对象。目前上述所有例子都在默认的顶点数组对象上操作（默认VAO的ID为0）。要创建新的顶点数组对象，可以使用`glGenVertexArrays`函数：\n\n``` objc\n/**\n 创建顶点数组对象\n\n @param n#> 要返回的顶点数组对象名称的数量 description#>\n @param arrays#> 指向一个n个元素的数组的指针，该数组是分配的顶点数组对象返回的位置 description#>\n @return void\n */\nglGenVertexArrays(GLsizei n, GLuint *arrays);\n```\n\n一旦创建，就可以用`glBindVertexArray`绑定顶点数组对象供以后使用：\n\n``` objc\n/**\n 绑定顶点数组对象\n\n @param array#> 被指定为当前顶点数组对象的对象 description#>\n @return void\n */\nglBindVertexArray(GLuint array);\n```\n\n每个VAO都包含一个完整的状态向量，描述所有顶点缓冲区绑定和启用的顶点客户状态。绑定VAO时，它的状态向量提供顶点缓冲区状态的当前设置。用`glBindVertexArray`绑定顶点数组对象后，更改顶点数组状态的后续调用（`glBindBuffer`、`glVertexAttribPointer`、`glEnableVertexAttribArray`、`glDisableVertexAttribArray`）将影响新的VAO。\n\n这样，应用程序可以通过绑定一个已经设置状态的顶点数组对象快速地在顶点数组配置之间切换。所有变化可以在一个函数调用中完成，没有必要多次调用以更改顶点数组状态。例子：\n\n``` objc\nvoid DrawPrimitiveWithVAOs() {\n    GLuint vboIds[2];\n    GLint vertex_position_size = 3;\n    GLint vertex_color_size = 4;\n    GLfloat vertices[] = {\n        0.0f, 0.5f, 0.0f,\n        1.0f, 0.0f, 0.0f, 1.0f,\n        -0.5f, -0.5f, 0.0f,\n        0.0f, 1.0f, 0.0f, 1.0f,\n        0.5f, -0.5f, 0.0f,\n        0.0f, 0.0f, 1.0f, 1.0f\n    };\n    GLuint vaoId;\n    GLushort indices[3] = { 0, 1, 2 };\n    glGenBuffers(2, vboIds);\n    glBindBuffer(GL_ARRAY_BUFFER, vboIds[0]);\n    glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);\n    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vboIds[1]);\n    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);\n    \n    glGenVertexArrays(1, &vaoId);\n    glBindVertexArray(vaoId);\n    \n    glBindBuffer(GL_ARRAY_BUFFER, vboIds[0]);\n    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vboIds[1]);\n    \n    glEnableVertexAttribArray(0);\n    glEnableVertexAttribArray(1);\n    \n    glVertexAttribPointer(0, vertex_position _size, GL_FLOAT, GL_FALSE, sizeof(GLfloat) * (vertex_position_size + vertex_color_size), 0);\n    glVertexAttribPointer(1, vertex_color_size, GL_FLOAT, GL_FALSE, sizeof(GLfloat) * (vertex_position_size + vertex_color_size), (const void *)(sizeof(GLfloat) * vertex_position_size));\n        \n    glBindVertexArray(0);\n\n    // 绘制\n    glBindVertexArray(vaoId);\n    glDrawElements(GL_TRIANGLES, 3, GL_UNSIGNED_SHORT, 0);\n}\n```\n\n当应用程序结束一个或者多个顶点数组对象的使用时，可以用`glDeleteVertexArrays`删除它们：\n\n``` objc\n/**\n 删除顶点数组对象\n\n @param n#> 要删除的顶点数组对象的数量 description#>\n @param arrays#> 包含需要删除的顶点数组对象的有n个元素的数组 description#>\n @return void\n */\nglDeleteVertexArrays(GLsizei n, const GLuint *arrays);\n```\n\n# 映射缓冲区对象\n\n到目前为止，我们已经使用了`glBufferData`或`glBufferSubData`将数据加载到缓冲区对象。应用程序也可以将缓冲区对象数据存储映射到应用程序的地址空间（也可以解除映射）。应用程序映射缓冲区而不使用`glBufferData`或者`glBufferSubData`加载数据有几个理由：\n- 映射缓冲区可以减少应用程序的内存占用，因为可能只需要存储数据的一个副本；\n- 在使用共享内存的架构上，映射缓冲区返回GPU存储缓冲区的地址空间的直接指针。通过映射缓冲区，应用程序可以避免复制步骤，从而实现更好的更新性能。\n\n`glMapBufferRange`命令返回指向所有或者一部分（范围）缓冲区对象数据存储的指针。这个指针可以供应应用程序使用，以读取或者更新缓冲区对象的内容。`glUnmapBuffer`命令用于指示更新已经完成和释放映射的指针：\n\n``` objc\n/**\n 返回指向所有或者部分缓冲区对象数据存储的指针\n\n @param target#> GL_ARRAY_BUFFER, GL_ELEMENT_ARRAY_BUFFER, GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, GL_PIXEL_PACK_BUFFER, GL_PIXEL_UNPACK_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, GL_UNIFORM_BUFFER description#>\n @param offset#> 缓冲区数据存储中的偏移量，以字节数计算 description#>\n @param length#> 需要映射的缓冲区数据的字节数 description#>\n @param access#> 详见下表 description#>\n @return GLvoid *\n */\nglMapBufferRange(GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access);\n```\n\n访问标志 | 描述\n- | -\nGL_MAP_READ_BIT | 应用程序将从返回的指针读取\nGL_MAP_WRITE_BIT | 应用程序将写入返回的指针\n\n此外，应用程序可以包含如下可选访问标志：\n\n访问标志 | 描述\n- | -\nGL_MAP_INVALIDATAE_RANGE_BIT | 表示指定范围内的缓冲区内容可以在返回指针之前由驱动程序放弃。这个标志不能与GL_MAP_READ_BIT组合使用\nGL_MAP_INVALIDATE_BUFFER_BIT | 表示整个缓冲区的内容可以在返回指针之前由驱动程序放弃。这个标志不能与GL_MAP_READ_BIT组合使用\nGL_MAP_FLUSH_EXPLICIT_BIT | 表示应用程序将明确地用glFlushMappedBufferRange刷新对映射范围子范围的操作。这个标志不能与GL_MAP_WRITE_BIT组合使用\nGL_MAP_UNSYNCHRONIZED_BIT | 表示驱动程序在返回缓冲区范围的指针之前不需要等待缓冲对象上的未决操作。如果有未决的操作，则未决操作的结果和缓冲区对象上的任何未来操作都变为未定义\n\n`glMapBufferRange`返回请求的缓冲区数据存储范围的指针。如果出现错误或者发出无效的请求，该函数将返回NULL。`glUnmapBuffer`命令取消之前的缓冲区映射：\n\n``` objc\n/**\n 取消缓冲区映射\n\n @param target#> 必须设置为GL_ARRAY_BUFFER description#>\n @return GLboolean\n */\nglUnmapBuffer(GLenum target);\n```\n\n如果取消映射操作成功，则`glUnmapBuffer`返回`GL_TRUE`。`glMapBufferRange`返回的指针在成功执行取消映射之后不再可以使用。如果顶点缓冲区对象数据存储中的数据在缓冲区映射之后已经破坏，`glUnmapBuffer`将返回`GL_FALSE`，这可能是因为屏幕分辨率的变化、OpenGL ES上下文使用多个屏幕或者导致映射内存被抛弃的内存不足事件所导致。\n\n写入映射缓冲区对象例子：\n``` objc\nGLfloat *vtxMappedBuf;\nGLushort *idxMappedBuf;\nGLfloat vertices[] = {\n    0.0f, 0.5f, 0.0f,\n    1.0f, 0.0f, 0.0f, 1.0f,\n    -0.5f, -0.5f, 0.0f,\n    0.0f, 1.0f, 0.0f, 1.0f,\n    0.5f, -0.5f, 0.0f,\n    0.0f, 0.0f, 1.0f, 1.0f\n};\nGLushort indices[3] = { 0, 1, 2 };\n\nglGenBuffers(2, vboIds);\nglBindBuffer(GL_ARRAY_BUFFER, vboIds[0]);\nglBufferData(GL_ARRAY_BUFFER, sizeof(vertices), NULL, GL_STATIC_DRAW);\nvtxMappedBuf = (GLfloat *)glMapBufferRange(GL_ARRAY_BUFFER, 0, sizeof(vertices), GL_MAP_WRITE_BIT | GL_MAP_INVALIDATE_BUFFER_BIT);\nif (vtxMappedBuf == NULL) {\n    NSLog(@\"Error mapping vertex buffer object\");\n    return;\n}\nmemcpy(vtxMappedBuf, vertices, sizeof(vertices));\nif (glUnmapBuffer(GL_ARRAY_BUFFER) == GL_FALSE) {\n    NSLog(@\"Error unmapping array buffer object\");\n    return;\n}\n\nglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vboIds[1]);\nglBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), NULL, GL_STATIC_DRAW);\nidxMappedBuf = (GLushort *)glMapBufferRange(GL_ELEMENT_ARRAY_BUFFER, 0, sizeof(indices), GL_MAP_WRITE_BIT | GL_MAP_INVALIDATE_BUFFER_BIT);\nif (idxMappedBuf == NULL) {\n    NSLog(@\"Error mapping element buffer object\");\n    return;\n}\nmemcpy(idxMappedBuf, indices, sizeof(indices));\nif (glUnmapBuffer(GL_ELEMENT_ARRAY_BUFFER) == GL_FALSE) {\n    NSLog(@\"Error unmapping element buffer object\");\n    return;\n}\n```\n\n## 刷新映射的缓冲区\n\n应用程序可能希望用`glMapBufferRange`来映射缓冲区对象的一个范围或者全部，但是只更新映射范围的不同子区域。为了避免调用`glUnmapBuffer`时刷新整个映射范围的潜在性能损失，应用程序可以用`GL_MAP_FLUSH_EXPLICIT_BIT`访问标志（和`GL_MAP_WRITE_BIT`组合）映射。当应用程序完成映射范围一部分的更新时，可以用`glFlushMappedBufferRange`指出这个事实：\n\n``` objc\n/**\n 指出应用程序完成映射范围的部分更新\n\n @param target#> GL_ARRAY_BUFFER, GL_ELEMENT_ARRAY_BUFFER, GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, GL_PIXEL_PACK_BUFFER, GL_PIXEL_UNPACK_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, GL_UNIFORM_BUFFER description#>\n @param offset#> 从映射缓冲区起始点的偏移量，以字节数表示 description#>\n @param length#> 从便宜点开始刷新的缓冲区字节数 description#>\n @return void\n */\nglFlushMappedBufferRange(GLenum target, GLintptr offset, GLsizeiptr length);\n```\n\n如果应用程序用`GL_MAP_FLUSH_EXPLICIT_BIT`映射，但是没有明确用`glFlushMappedBufferRange`刷新修改后的区域，它的内容将是未定义的。\n\n# 复制缓冲区对象\n\n上面我们已经说明如何用`glBufferData`、`glBufferSubData`和`glMapBufferRange`加载缓冲区对象。所有这些技术都涉及从应用程序到设备的数据传输。OpenGL ES 3.0还可以从一个缓冲区对象将数据完全复制到设备：\n\n``` objc\n/**\n 从一个缓冲区对象将数据完全复制到设备\n\n @param readTarget#> 读取的缓冲区对象目标 description#>\n @param writeTarget#> 写入的缓冲区对象目标 description#>\n @param readOffset#> 需要复制的读缓冲数据中的偏移量，以字节表示 description#>\n @param writeOffset#> 需要复制的写缓冲数据中的偏移量，以字节表示 description#>\n @param size#> 从读缓冲区数据复制到写缓冲区数据的字节数 description#>\n @return void\n */\nglCopyBufferSubData(GLenum readTarget, GLenum writeTarget, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size);\n```\n\n调用`glCopyBufferSubData`将从绑定到`readtarget`的缓冲区复制指定的字节到`writetarget`。缓冲区绑定根据每个目标的最后一次`glBindBuffer`确定调用。任何类型的缓冲区对象（数组、元素数组、变换反馈等）都可以绑定到`GL_COPY_READ_BUFFER`或`GL_COPY_WRITE_BUFFER`目标。这两个目标是一种方便的措施，使得应用程序在执行缓冲区间的复制时不必改变任何真正的缓冲区绑定。\n\n# 总结\n\n这篇文章主要介绍了指定顶点属性和数据的方法。","slug":"2019/opengl-es-vertex-0720","published":1,"updated":"2022-01-10T09:04:52.809Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cky8gmc4f0019d1qhip9kvw15","content":"<blockquote>\n<p>顶点数据也称作顶点属性，指定每个顶点的数据。这种逐顶点数据可以为每个顶点指定，也可以用于所有顶点的常量。例如，如果想要绘制一个固定颜色的三角形，可以指定一个常量值，用于三角形的全部3个顶点。但是，组成三角形的3个顶点的位置不同，所以我们必须指定一个顶点数组来存储3个位置值。</p>\n</blockquote>\n<h1 id=\"指定顶点属性数据\">指定顶点属性数据</h1>\n<p>顶点属性数据可以用一个顶点数组对每个顶点指定，也可以将一个常量值用于一个图元的所有顶点。</p>\n<p>所有OpenGL ES 3.0实现必须支持最少16个顶点属性，可以通过<code>glGet*</code>函数查询特定支持的顶点属性的准确数量：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GLint maxVertexAttribs; </span><br><span class=\"line\">glGetIntegerv(GL_MAX_VERTEX_ATTRIBS, &amp;maxVertexAttribs);</span><br></pre></td></tr></table></figure>\n<h2 id=\"常量顶点属性\">常量顶点属性</h2>\n<p>常量顶点属性对于一个图元的所有顶点都相同，所以对一个图元的所有顶点只需指定一个值。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 加载indx指定的通用顶点属性(x, 0.0, 0.0, 1.0)</span></span><br><span class=\"line\">glVertexAttrib1f(GLuint indx, GLfloat x);</span><br><span class=\"line\">glVertexAttrib1fv(GLuint indx, <span class=\"keyword\">const</span> GLfloat *values);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 加载indx指定的通用顶点属性(x, y, 0.0, 1.0)</span></span><br><span class=\"line\">glVertexAttrib2f(GLuint indx, GLfloat x, GLfloat y);</span><br><span class=\"line\">glVertexAttrib2fv(GLuint indx, <span class=\"keyword\">const</span> GLfloat *values);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 加载indx指定的通用顶点属性(x, y, z, 1.0)</span></span><br><span class=\"line\">glVertexAttrib3f(GLuint indx, GLfloat x, GLfloat y, GLfloat z);</span><br><span class=\"line\">glVertexAttrib3fv(GLuint indx, <span class=\"keyword\">const</span> GLfloat *values);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 加载indx指定的通用顶点属性(x, y, z, w)</span></span><br><span class=\"line\">glVertexAttrib4f(GLuint indx, GLfloat x, GLfloat y, GLfloat z, GLfloat w);</span><br><span class=\"line\">glVertexAttrib4fv(GLuint indx, <span class=\"keyword\">const</span> GLfloat *values);</span><br></pre></td></tr></table></figure>\n<h2 id=\"顶点数组\">顶点数组</h2>\n<p>顶点数组指定每个顶点的属性，是保存在应用程序地址空间的缓冲区。它们作为顶点缓冲对象的基础，提供指定顶点属性数据的一种高效、灵活的手段。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 指定顶点属性</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param indx#&gt; 指定通用顶点属性索引 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param size#&gt; 顶点数组中为索引引用的顶点属性所指定的分量数量，有效值为1~4 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param type#&gt; 数据格式 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param normalized#&gt; 用于表示非浮点数据格式类型在转换为浮点值时是否应该规范化 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param stride#&gt; 每个顶点由size指定的顶点属性分量顺序存储。stride指定顶点索引I和I+1表示的顶点数据之间的位移。如果stride为0，则每个顶点的属性数据顺序存储。如果stride大于0，则使用该值作为获取下一个索引表示的顶点数据的跨距 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param ptr#&gt; 如果使用客户端顶点数组，则是保存顶点属性数据的缓冲区指针。如果使用顶点缓冲区对象，则表示该缓冲区内的偏移量 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glVertexAttribPointer(GLuint indx, GLint size, GLenum type, GLboolean normalized, GLsizei stride, <span class=\"keyword\">const</span> GLvoid *ptr);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 指定顶点属性，数据格式类型被当做整数对待</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param index#&gt; 指定通用顶点属性索引 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param size#&gt; 顶点数组中为索引引用的顶点属性所指定的分量数量，有效值为1~4 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param type#&gt; 数据格式 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param stride#&gt; 每个顶点由size指定的顶点属性分量顺序存储。stride指定顶点索引I和I+1表示的顶点数据之间的位移。如果stride为0，则每个顶点的属性数据顺序存储。如果stride大于0，则使用该值作为获取下一个索引表示的顶点数据的跨距 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param pointer#&gt; 如果使用客户端顶点数组，则是保存顶点属性数据的缓冲区指针。如果使用顶点缓冲区对象，则表示该缓冲区内的偏移量 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glVertexAttribIPointer(GLuint index, GLint size, GLenum type, GLsizei stride, <span class=\"keyword\">const</span> GLvoid *pointer);</span><br></pre></td></tr></table></figure>\n<p>分配和存储顶点属性数据有两种常用的方法：</p>\n<ul>\n<li>在一个缓冲区中存储顶点属性–这种方法称为结构数组。结构表示顶点的所有属性，每个顶点有一个属性的数组。</li>\n<li>在单独的缓冲区中保存每个顶点属性–这种方法称为数组结构。</li>\n</ul>\n<h3 id=\"哪种存储顶点属性的方法高效\">哪种存储顶点属性的方法高效</h3>\n<p>在大部分情况下，答案是结构数组。原因是，每个顶点的属性数据可以顺序方法读取，这最有可能造成高效的内存访问模式。使用结构数组的缺点在应用程序需要修改特定属性时变得很明显。如果顶点属性数据的一个自己需要修改，这将造成顶点缓冲区的跨距更新。当顶点缓冲区以缓冲区对象的形式提供时，需要重新加载整个顶点属性缓冲区。可以通过将动态的顶点属性保存在单独的缓冲区来避免这种效率低下的情况。</p>\n<h3 id=\"顶点属性使用哪种数据格式\">顶点属性使用哪种数据格式</h3>\n<p><code>glVertexAttribPointer</code>中的<code>type</code>参数指定的顶点属性格式不仅影响顶点属性数据的图形内存存储需求，而且影响整体性能，这是渲染帧所需内存带宽的一个函数。数据空间占用越小，需要的内存带宽越小。OpenGL ES 3.0支持名为<code>GL_HALF_FLOAT</code>的16位浮点顶点格式，建议尽可能使用。纹理坐标、法线、副法线、切向量等都是使用<code>GL_HALF_FLOAT</code>存储每个分量的候选。颜色可以存储为<code>GL_UNSIGNED_BYTE</code>，每个顶点颜色具有4个分量。顶点位置可以存储为<code>GL_FLOAT</code>。</p>\n<h3 id=\"glvertexattribpointer中的规范化标识如何工作\"><code>glVertexAttribPointer</code>中的规范化标识如何工作</h3>\n<p>在用于顶点着色器之前，顶点属性在内部保存为单精度浮点数，如果数据类型表示顶点属性不是浮点数，顶点属性将在用于顶点着色器之前转换为单精度浮点数。规范化标志控制非浮点顶点属性数据到单精度浮点值的转换。如果规范化标识为假，则顶点数据被直接转换为浮点数。这类似于将非浮点类型的变量转换为浮点变量。例子：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GLfloat f;</span><br><span class=\"line\">GLbyte b;</span><br><span class=\"line\">f = (GLfloat)b;     <span class=\"comment\">// f represents values in the range [-128.0, 127.0]</span></span><br></pre></td></tr></table></figure>\n<p>如果规范化标志位真，且如果数据类型为<code>GL_BYTE</code>、<code>GL_SHORT</code>或者<code>GL_FIXED</code>，则顶点数据被映射到[-1.0, 1.0]范围内，如果数据类型为<code>GL_UNSIGNED_BYTE</code>或<code>GL_UNSIGNED_SHORT</code>，则被映射到[0.0, 1.0]范围内。</p>\n<p>下表说明了设置规范化标志时非浮点数据类型的转换，表中第二列的<code>c</code>值指的是第一列中指定格式的一个值：</p>\n<table>\n<thead>\n<tr>\n<th>顶点数据格式</th>\n<th>转换为浮点数</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>GL_BYTE</td>\n<td>max(c/(2<sup>7</sup>-1), -1.0)</td>\n</tr>\n<tr>\n<td>GL_UNSIGNED_BYTE</td>\n<td>c/(2<sup>8</sup>-1)</td>\n</tr>\n<tr>\n<td>GL_SHORT</td>\n<td>max(c/(2<sup>16</sup>-1), -1.0)</td>\n</tr>\n<tr>\n<td>GL_UNSIGNED_SHORT</td>\n<td>c/(2<sup>16</sup>-1)</td>\n</tr>\n<tr>\n<td>GL_FIXED</td>\n<td>c/(2<sup>16</sup>)</td>\n</tr>\n<tr>\n<td>GL_FLOAT</td>\n<td>c</td>\n</tr>\n<tr>\n<td>GL_HALF_FLOAT_OES</td>\n<td>c</td>\n</tr>\n</tbody>\n</table>\n<p>在顶点着色器中，也有可能按照整数的形式访问整数型顶点属性数据，而不是将其转换为浮点数，可以使用<code>glVertexAttribIPointer</code>函数。</p>\n<h3 id=\"在常量顶点属性和顶点数组之间选择\">在常量顶点属性和顶点数组之间选择</h3>\n<p>应用程序可以让OpenGL ES使用常量数据或者来自顶点数组的数据。<code>glEnableVertexAttribArray</code>和<code>glDisableVertexAttribArray</code>命令分别用于启用和禁用通用顶点属性数组。如果某个通用属性索引的顶点属性数组被禁用，将使用为该索引指定的常量顶点属性数据。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// glsl.vsh</span></span><br><span class=\"line\"><span class=\"meta\">#version 300 es</span></span><br><span class=\"line\">layout(location = <span class=\"number\">0</span>) <span class=\"keyword\">in</span> vec4 a_color;</span><br><span class=\"line\">layout(location = <span class=\"number\">1</span>) <span class=\"keyword\">in</span> vec4 a_position;</span><br><span class=\"line\"><span class=\"keyword\">out</span> vec4 v_color;</span><br><span class=\"line\"><span class=\"keyword\">void</span> mian() &#123;</span><br><span class=\"line\">    v_color = a_color;</span><br><span class=\"line\">    gl_Position = a_position;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// glsl.fsh</span></span><br><span class=\"line\"><span class=\"meta\">#version 300 es</span></span><br><span class=\"line\">precision mudiump <span class=\"keyword\">float</span>;</span><br><span class=\"line\"><span class=\"keyword\">in</span> vec4 v_color;</span><br><span class=\"line\"><span class=\"keyword\">out</span> vec4 o_fragColor;</span><br><span class=\"line\"><span class=\"keyword\">void</span> main() &#123;</span><br><span class=\"line\">    o_fragColor = v_color;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GLfloat color[<span class=\"number\">4</span>] = &#123;<span class=\"number\">1.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f&#125;;</span><br><span class=\"line\">GLfloat vertexPos[<span class=\"number\">9</span>] = &#123;<span class=\"number\">0.0</span>f, <span class=\"number\">0.5</span>f, <span class=\"number\">0.0</span>f,</span><br><span class=\"line\">                        <span class=\"number\">-0.5</span>f, <span class=\"number\">-0.5</span>f, <span class=\"number\">0.0</span>f,</span><br><span class=\"line\">                        <span class=\"number\">0.5</span>f, <span class=\"number\">-0.5</span>f, <span class=\"number\">0.0</span>f&#125;;</span><br><span class=\"line\">glVertexAttrib4fv(<span class=\"number\">0</span>, color);</span><br><span class=\"line\">glVertexAttribPointer(<span class=\"number\">1</span>, <span class=\"number\">3</span>, GL_FLOAT, GL_FALSE, <span class=\"number\">0</span>, vertexPos);</span><br><span class=\"line\">glEnableVertexAttribArray(<span class=\"number\">1</span>);</span><br><span class=\"line\">glDrawArrays(GL_TRIANGLES, <span class=\"number\">0</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">glDisableVertexAttribArray(<span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure>\n<p>代码示例中使用的顶点属性<code>color</code>是一个常量，用<code>glVertexAttrib4fv</code>指定，不启用顶点属性数组0。<code>vertexPos</code>属性用<code>glVertexAttribPointer</code>以一个顶点数组指定，并用<code>glEnableVertexAttribArray</code>启用数组。<code>color</code>值对于所绘制的三角形的所有顶点均相同，而<code>vertexPos</code>属性对于三角形的各个顶点可以不同。</p>\n<h1 id=\"在顶点着色器中声明顶点属性变量\">在顶点着色器中声明顶点属性变量</h1>\n<p>在顶点着色器中，变量通过使用<code>in</code>限定符声明为顶点属性。属性变量也可以包含一个布局限定符，提供属性索引：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">layout(location = <span class=\"number\">0</span>) <span class=\"keyword\">in</span> vec4 a_position;</span><br><span class=\"line\">layout(location = <span class=\"number\">1</span>) <span class=\"keyword\">in</span> vec2 a_texcoord;</span><br><span class=\"line\">layout(location - <span class=\"number\">2</span>) <span class=\"keyword\">in</span> vec3 a_normal;</span><br></pre></td></tr></table></figure>\n<p>属性可以在顶点着色器内部声明–但是如果没有使用，就不会被认为是活动属性，从而不会被计入限制。如果在顶点着色器中使用的属性数量大于<code>GL_MAX_VERTEX_ATTRIBS</code>，这个顶点着色器就无法链接。</p>\n<p>当程序成功链接，我们就需要找出连接到该程序的顶点着色器使用的活动顶点属性数量。注意：这一步骤只需要在我们对属性不使用布局限定符时才有必要。<br>\n首先通过<code>glGetProgramiv</code>函数传入<code>GL_ACTIVE_ATTRIBUTE</code>获取活动的属性数量，传入<code>GL_ACTIVE_ATTRIBUTE_MAX_LENGTH</code>获取属性的最长字符数量，最后使用<code>glGetActiveAttrib</code>函数查询顶点着色器各属性索引点对应的属性变量名称：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GLint attribsCount;</span><br><span class=\"line\">GLint attribMaxLength;</span><br><span class=\"line\">glGetProgramiv(program, GL_ACTIVE_ATTRIBUTES, &amp;attribsCount);</span><br><span class=\"line\">glGetProgramiv(program, GL_ACTIVE_ATTRIBUTE_MAX_LENGTH, &amp;attribMaxLength);</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; attribsCount; i++) &#123;</span><br><span class=\"line\">    GLsizei length;</span><br><span class=\"line\">    GLint size;</span><br><span class=\"line\">    GLenum type;</span><br><span class=\"line\">    GLchar *name = malloc(attribMaxLength * <span class=\"keyword\">sizeof</span>(GLchar));</span><br><span class=\"line\">    glGetActiveAttrib(program, i, attribMaxLength, &amp;length, &amp;size, &amp;type, name);</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"length: %d, size: %d, type: %u, name: %s\"</span>, length, size, type, name);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"将顶点属性绑定到顶点着色器中的属性变量\">将顶点属性绑定到顶点着色器中的属性变量</h2>\n<p>在OpenGL ES 3.0中，可以使用3种方法将通用顶点属性索引映射到顶点着色器中的一个属性变量名称：</p>\n<ul>\n<li>索引可以在顶点着色器源代码中用<code>layout(location = N)</code>限定符指定（推荐）；</li>\n<li>OpenGL ES 3.0将通用顶点属性索引绑定到属性名称；</li>\n<li>应用程序可以将顶点属性索引绑定到属性名称；</li>\n</ul>\n<p>将属性绑定到一个位置的最简单方法是简单地使用<code>layout(location = N)</code>限定符，这种方法需要的代码最少。但是，在某些情况下，其他两个选项可能更合适。<code>glBindAttribLocation</code>命令可用于将通用顶点属性索引绑定到顶点着色器中的一个属性变量。这种绑定在下一次程序链接时生效–不会改变当前链接的程序中使用的绑定。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 将通用顶点属性索引绑定到属性变量</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param program#&gt; 程序对象 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param index#&gt; 通用顶点属性索引 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param name#&gt; 属性变量名称 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glBindAttribLocation(GLuint program, GLuint index, <span class=\"keyword\">const</span> GLchar *name);</span><br></pre></td></tr></table></figure>\n<p>如果之前绑定了<code>name</code>，则它所指定的绑定被索引代替。<code>glBindAttribLocation</code>甚至可以在顶点着色器连接到程序对象之前调用，因此，这个调用可以用于绑定任何属性名称。不存在的属性名称或者在连接到程序对象的顶点着色器中不活动的属性将被忽略。</p>\n<p>另一个选项是让OpenGL ES 3.0将属性变量名称绑定到一个通用顶点属性索引。这种绑定在程序链接时进行，在链接阶段，OpenGL ES 3.0实现为每个属性变量执行如下操作：对于每个属性变量，检查是否已经通过<code>glBindAttribLocation</code>。如果指定了一个绑定，则使用指定的对应属性索引。否则，OpenGL ES实现将分配一个通用顶点属性索引。<br>\n这种分配特定于实现；也就是说，在一个OpenGL ES 3.0实现中和在另一个实现中可能不同。应用程序可以使用<code>glGetAttribLocation</code>命令查询分配的绑定。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 查询属性索引</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param program#&gt; 程序对象 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param name#&gt; 属性变量名称 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return 属性索引</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glGetAttribLocation(GLuint program, <span class=\"keyword\">const</span> GLchar *name);</span><br></pre></td></tr></table></figure>\n<p><code>glGetAttribLocation</code>返回<code>program</code>定义的程序对象最后一次链接时绑定到属性变量<code>name</code>的通用属性索引。如果<code>name</code>不是一个活动属性变量，或者<code>program</code>不是一个有效的程序对象，或者没有链接成功，则返回-1，表示无效的属性索引。</p>\n<h1 id=\"顶点缓冲区对象\">顶点缓冲区对象</h1>\n<p>使用顶点数组指定的顶点数据保存在客户内存中。在进行<code>glDrawArrays</code>或者<code>glDrawElements</code>等绘图调用时，这些数据必须从客户内存复制到图形内存。但是，如果我们没有必要在每次绘图调用时都复制顶点数据，而是在图形内存中缓存这些数据，那就好得多了。这种方法可以显著地改进渲染性能，也会降低内存带宽和电力消耗序曲，对于手持设备相当重要。这是顶点缓冲区对象发挥的地方。顶点缓冲区对象使OpenGL ES 3.0应用程序可以在高性能的图形内存中分配和缓存顶点数据，并从这个内存进行渲染，从而避免在每次绘制图元的时候重新发送数据。不仅是顶点数据，描述图元顶点索引、作为<code>glDrawElements</code>参数传递的元素索引也可以缓存。</p>\n<p>OpenGL ES 3.0支持两类缓冲区对象，用于指定顶点和图元数据：数组缓冲区对象和元素数组缓冲区对象。<code>GL_ARRAY_BUFFER</code>标志指定的数组缓冲区对象用于创建保存顶点数据的缓冲区对象。<code>GL_ELEMENT_ARRAY_BUFFER</code>标志指定的元素数组缓冲区对象用于创建保存图元索引的缓冲区对象。</p>\n<blockquote>\n<p>为了得到最佳性能，推荐OpenGL ES 3.0应用程序对顶点属性数据和元素索引使用顶点缓冲区对象。</p>\n</blockquote>\n<p>在使用缓冲对象渲染之前，需要分配缓冲区对象并将顶点数据和元素索引上传到相应的缓冲区对象。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// vertex_t是自定义顶点数据类型</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> initVertexBufferObjects(vertex_t *vertexBuffer,</span><br><span class=\"line\">                             GLushort *indices,</span><br><span class=\"line\">                             GLuint numVertices,</span><br><span class=\"line\">                             GLuint numIndices,</span><br><span class=\"line\">                             GLuint *vboIds) &#123;</span><br><span class=\"line\">    glGenBuffers(<span class=\"number\">2</span>, vboIds);</span><br><span class=\"line\">    </span><br><span class=\"line\">    glBindBuffer(GL_ARRAY_BUFFER, vboIds[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    glBufferData(GL_ARRAY_BUFFER, numVertices * <span class=\"keyword\">sizeof</span>(vertex_t), vertexBuffer, GL_STATIC_DRAW);</span><br><span class=\"line\">    </span><br><span class=\"line\">    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vboIds[<span class=\"number\">1</span>]);</span><br><span class=\"line\">    glBufferData(GL_ELEMENT_ARRAY_BUFFER, numIndices * <span class=\"keyword\">sizeof</span>(GLushort), indices, GL_STATIC_DRAW);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述代码创建两个缓冲区对象：一个用于保存实际的顶点属性数据，另一个用于保存组成图元的元素索引。数组缓冲区对象用于保存一个或者多个图元的顶点属性数据，元素数组缓冲区对象保存一个或者多个图元的索引。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 创建缓冲区对象</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param n#&gt; 返回缓冲区对象名称数量 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param buffers#&gt; 指向n个条目的数组指针，该数组是分配的缓冲区对象返回的位置 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glGenBuffers(GLsizei n, GLuint *buffers);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 指定当前缓冲区对象</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param target#&gt; GL_ARRAY_BUFFER, GL_ELEMENT_ARRAY_BUFFER, GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, GL_PIXEL_PACK_BUFFER, GL_PIXEL_UNPACK_BUFFER, GL_TRANSFROM_FEEDBACK_BUFFER, GL_UNIFORM_BUFFER description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param buffer#&gt; 分配给目标当做当前对象的缓冲区对象 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glBindBuffer(GLenum target, GLuint buffer);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 顶点数组数据或者元素数组数据存储创建和初始化</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param target#&gt; GL_ARRAY_BUFFER, GL_ELEMENT_ARRAY_BUFFER, GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, GL_PIXEL_PACK_BUFFER, GL_PIXEL_UNPACK_BUFFER, GL_TRANSFROM_FEEDBACK_BUFFER, GL_UNIFORM_BUFFER description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param size#&gt; 缓冲区数据存储大小，以字节数表示 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param data#&gt; 应用程序提供的缓冲区数据的指针，可为NULL值，表示保留的数据存储不进行初始化。如果是一个有效的指针，则其内容被复制到分配的数据存储 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param usage#&gt; 详见下表 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glBufferData(GLenum target, GLsizeiptr size, <span class=\"keyword\">const</span> GLvoid *data, GLenum usage);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 顶点数组数据或者元素数组数据存储初始化或者更新</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param target#&gt; GL_ARRAY_BUFFER, GL_ELEMENT_ARRAY_BUFFER, GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, GL_PIXEL_PACK_BUFFER, GL_PIXEL_UNPACK_BUFFER, GL_TRANSFROM_FEEDBACK_BUFFER, GL_UNIFORM_BUFFER description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param offset#&gt; 缓冲区数据存储中的偏移 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param size#&gt; 被修改的数据存储字节数 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param data#&gt; 需要被复制到缓冲区对象数据存储的客户数据指针 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glBufferSubData(GLenum target, GLintptr offset, GLsizeiptr size, <span class=\"keyword\">const</span> GLvoid *data)</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>缓冲区使用枚举值</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>GL_STATIC_DRAW</td>\n<td>缓冲区对象数据将被修改一次，使用多次，以绘制图元或者指定图像</td>\n</tr>\n<tr>\n<td>GL_STATIC_READ</td>\n<td>缓冲区对象数据将被修改一次，使用多次，以从OpenGL ES读回数据。从OpenGL ES读回的数据将从应用程序中查询</td>\n</tr>\n<tr>\n<td>GL_STATIC_COPY</td>\n<td>缓冲区对象数据将被修改一次，使用多次，以从OpenGL ES读回数据。从OpenGL ES读回的数据将直接用作绘制图元或者修改图像的信息来源</td>\n</tr>\n<tr>\n<td>GL_DYNAMIC_DRAW</td>\n<td>缓冲区对象数据将被重复修改，使用多次，以绘制图元或者指定图像</td>\n</tr>\n<tr>\n<td>GL_DYNAMIC_READ</td>\n<td>缓冲区对象数据将被重复修改，使用多次，以从OpenGL ES读回数据。从OpenGL ES读回的数据中将从应用程序中查询</td>\n</tr>\n<tr>\n<td>GL_DYNAMIC_COPY</td>\n<td>缓冲区对象数据将被重复修改，使用多次，以从OpenGL ES读回数据。从OpenGL ES读回的数据将直接用作绘制图元或者修改图像的信息来源</td>\n</tr>\n<tr>\n<td>GL_STREAM_DRAW</td>\n<td>缓冲区对象数据将被修改一次，只使用少数几次，以绘制图元或者指定图像</td>\n</tr>\n<tr>\n<td>GL_STREAM_READ</td>\n<td>缓冲区对象数据将被修改一次，只使用少数几次，以从OpenGL ES读回数据。从OpenGL ES读回的数据将从应用程序中查询</td>\n</tr>\n<tr>\n<td>GL_STREAM_COPY</td>\n<td>缓冲区对象数据将被修改一次，只使用少数几次，以从OpenGL ES读回数据。从OpenGL ES读回的数据将直接用作绘制图元或者修改图像的信息来源</td>\n</tr>\n</tbody>\n</table>\n<p>在用<code>glBufferData</code>或者<code>glBufferSubData</code>初始化或者更新缓冲区对象数据存储之后，客户数据存储不再需要，可以释放。对于静态的几何形状，应用程序可以释放客户数据存储，减少应用程序消耗的系统内存。对于动态几何形状，这可能无法做到。</p>\n<p>下面是个使用和不使用缓冲区对象进行的图元绘制：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// glsl.vsh</span></span><br><span class=\"line\"><span class=\"meta\">#version 300 es</span></span><br><span class=\"line\">layout(location = <span class=\"number\">0</span>) <span class=\"keyword\">in</span> vec4 vPosition;</span><br><span class=\"line\">layout(location = <span class=\"number\">1</span>) <span class=\"keyword\">in</span> vec4 vColor;</span><br><span class=\"line\">uniform <span class=\"keyword\">float</span> offsetLoc;</span><br><span class=\"line\"><span class=\"keyword\">out</span> vec4 v_color;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> main() &#123;</span><br><span class=\"line\">    v_color = vColor;</span><br><span class=\"line\">    gl_Position = vec4(vPosition.x + offsetLoc, vPosition.yzw);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// glsl.fsh</span></span><br><span class=\"line\"><span class=\"meta\">#version 300 es</span></span><br><span class=\"line\">precision mediump <span class=\"keyword\">float</span>;</span><br><span class=\"line\"><span class=\"keyword\">in</span> vec4 v_color;</span><br><span class=\"line\"><span class=\"keyword\">out</span> vec4 fragColor;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> main() &#123;</span><br><span class=\"line\">    fragColor = v_color;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> DrawPrimitiveWithoutVBOs() &#123;</span><br><span class=\"line\">    GLint vertex_position_size = <span class=\"number\">3</span>;</span><br><span class=\"line\">    GLint vertex_color_size = <span class=\"number\">4</span>;</span><br><span class=\"line\">    GLushort indices[<span class=\"number\">3</span>] = &#123;<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>&#125;;</span><br><span class=\"line\">    GLfloat vertices[] = &#123;</span><br><span class=\"line\">        <span class=\"number\">-0.5</span>f, <span class=\"number\">0.5</span>f, <span class=\"number\">0.0</span>f,</span><br><span class=\"line\">        <span class=\"number\">1.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f,</span><br><span class=\"line\">        <span class=\"number\">-1.0</span>f, <span class=\"number\">-0.5</span>f, <span class=\"number\">0.0</span>f,</span><br><span class=\"line\">        <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f,</span><br><span class=\"line\">        <span class=\"number\">0.0</span>f, <span class=\"number\">-0.5</span>f, <span class=\"number\">0.0</span>f,</span><br><span class=\"line\">        <span class=\"number\">0.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f, <span class=\"number\">1.0</span>f</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    GLfloat *vtxBuf = vertices;</span><br><span class=\"line\">    GLsizei vtxStride = <span class=\"keyword\">sizeof</span>(GLfloat) * (vertex_color_size + vertex_position_size);</span><br><span class=\"line\">    </span><br><span class=\"line\">    glBindBuffer(GL_ARRAY_BUFFER, <span class=\"number\">0</span>);</span><br><span class=\"line\">    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, <span class=\"number\">0</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    glEnableVertexAttribArray(<span class=\"number\">0</span>);</span><br><span class=\"line\">    glEnableVertexAttribArray(<span class=\"number\">1</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    glVertexAttribPointer(<span class=\"number\">0</span>, vertex_position_size, GL_FLOAT, GL_FALSE, vtxStride, vtxBuf);</span><br><span class=\"line\">    vtxBuf += vertex_position_size;</span><br><span class=\"line\">    glVertexAttribPointer(<span class=\"number\">1</span>, vertex_color_size, GL_FLOAT, GL_FALSE, vtxStride, vtxBuf);</span><br><span class=\"line\">    </span><br><span class=\"line\">    glDrawElements(GL_TRIANGLES, <span class=\"number\">3</span>, GL_UNSIGNED_SHORT, indices);</span><br><span class=\"line\">    </span><br><span class=\"line\">    glDisableVertexAttribArray(<span class=\"number\">0</span>);</span><br><span class=\"line\">    glDisableVertexAttribArray(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> DrawPrimitiveWithVBOs() &#123;</span><br><span class=\"line\">    GLvoid *offset = <span class=\"number\">0</span>;</span><br><span class=\"line\">    GLuint vboIds[<span class=\"number\">2</span>];</span><br><span class=\"line\">    GLint vertex_position_size = <span class=\"number\">3</span>;</span><br><span class=\"line\">    GLint vertex_color_size = <span class=\"number\">4</span>;</span><br><span class=\"line\">    GLushort indices[<span class=\"number\">3</span>] = &#123;<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>&#125;;</span><br><span class=\"line\">    GLint vtxStride = <span class=\"keyword\">sizeof</span>(GLfloat) * (vertex_position_size + vertex_color_size);</span><br><span class=\"line\">    GLfloat vertices[] = &#123;</span><br><span class=\"line\">        <span class=\"number\">-0.5</span>f, <span class=\"number\">0.5</span>f, <span class=\"number\">0.0</span>f,</span><br><span class=\"line\">        <span class=\"number\">1.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f,</span><br><span class=\"line\">        <span class=\"number\">-1.0</span>f, <span class=\"number\">-0.5</span>f, <span class=\"number\">0.0</span>f,</span><br><span class=\"line\">        <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f,</span><br><span class=\"line\">        <span class=\"number\">0.0</span>f, <span class=\"number\">-0.5</span>f, <span class=\"number\">0.0</span>f,</span><br><span class=\"line\">        <span class=\"number\">0.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f, <span class=\"number\">1.0</span>f</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    GLfloat *vtxBuf = vertices;</span><br><span class=\"line\"></span><br><span class=\"line\">    glGenBuffers(<span class=\"number\">2</span>, vboIds);</span><br><span class=\"line\">    glBindBuffer(GL_ARRAY_BUFFER, vboIds[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    glBufferData(GL_ARRAY_BUFFER, vtxStride * <span class=\"number\">3</span>, vtxBuf, GL_STATIC_DRAW);</span><br><span class=\"line\">    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vboIds[<span class=\"number\">1</span>]);</span><br><span class=\"line\">    glBufferData(GL_ELEMENT_ARRAY_BUFFER, <span class=\"keyword\">sizeof</span>(GLushort) * <span class=\"number\">3</span>, indices, GL_STATIC_DRAW);</span><br><span class=\"line\">    </span><br><span class=\"line\">    glEnableVertexAttribArray(<span class=\"number\">0</span>);</span><br><span class=\"line\">    glEnableVertexAttribArray(<span class=\"number\">1</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    glVertexAttribPointer(<span class=\"number\">0</span>, vertex_position_size, GL_FLOAT, GL_FALSE, vtxStride, offset);</span><br><span class=\"line\">    offset += vertex_position_size * <span class=\"keyword\">sizeof</span>(GLfloat);</span><br><span class=\"line\">    glVertexAttribPointer(<span class=\"number\">1</span>, vertex_color_size, GL_FLOAT, GL_FALSE, vtxStride, offset);</span><br><span class=\"line\">    </span><br><span class=\"line\">    glDrawElements(GL_TRIANGLES, <span class=\"number\">3</span>, GL_UNSIGNED_SHORT, <span class=\"number\">0</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    glDisableVertexAttribArray(<span class=\"number\">0</span>);</span><br><span class=\"line\">    glDisableVertexAttribArray(<span class=\"number\">1</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    glBindBuffer(GL_ARRAY_BUFFER, <span class=\"number\">0</span>);</span><br><span class=\"line\">    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 调用</span></span><br><span class=\"line\">DrawPrimitiveWithoutVBOs();</span><br><span class=\"line\">glUniform1f(<span class=\"number\">0</span>, <span class=\"number\">1.0</span>f);</span><br><span class=\"line\">DrawPrimitiveWithVBOs();</span><br></pre></td></tr></table></figure>\n<p>上述代码中，我们对一个顶点的所有属性使用相同的缓冲区对象。使用<code>GL_ARRAY_BUFFER</code>缓冲区对象时，<code>glVertexAttribPointer</code>的<code>pointer</code>参数从指向实际数据的一个指针变成用<code>glBufferData</code>分配的顶点缓冲区存储中以字节表示的偏移量。类似地，如果使用有效的<code>GL_ELEMENT_ARRAY_BUFFER</code>对象，则<code>glDrawElements</code>中的<code>indices</code>参数从指向实际元素索引的指针变成用<code>glBufferData</code>分配的元素索引缓冲区存储中以字节表示的偏移量。</p>\n<p>上述代码描述的存储顶点属性的是结构数组方法，也可以对每个顶点属性使用一个缓冲区对象–数组结构方法：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> DrawPrimitiveWithVBOs() &#123;</span><br><span class=\"line\">    GLuint vboIds[<span class=\"number\">3</span>];</span><br><span class=\"line\">    GLint vertex_position_size = <span class=\"number\">3</span>;</span><br><span class=\"line\">    GLint vertex_color_size = <span class=\"number\">4</span>;</span><br><span class=\"line\">    GLfloat position[] = &#123;</span><br><span class=\"line\">        <span class=\"number\">-0.5</span>f, <span class=\"number\">0.5</span>f, <span class=\"number\">0.0</span>f,</span><br><span class=\"line\">        <span class=\"number\">-1.0</span>f, <span class=\"number\">-0.5</span>f, <span class=\"number\">0.0</span>f,</span><br><span class=\"line\">        <span class=\"number\">0.0</span>f, <span class=\"number\">-0.5</span>f, <span class=\"number\">0.0</span>f</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    GLfloat color[] = &#123;</span><br><span class=\"line\">        <span class=\"number\">1.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f,</span><br><span class=\"line\">        <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f,</span><br><span class=\"line\">        <span class=\"number\">0.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f, <span class=\"number\">1.0</span>f</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    GLushort indices[<span class=\"number\">3</span>] = &#123;<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    glGenBuffers(<span class=\"number\">3</span>, vboIds);</span><br><span class=\"line\">    glBindBuffer(GL_ARRAY_BUFFER, vboIds[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    glBufferData(GL_ARRAY_BUFFER, <span class=\"keyword\">sizeof</span>(GLfloat) * vertex_position_size * <span class=\"number\">3</span>, position, GL_STATIC_DRAW);</span><br><span class=\"line\">    glBindBuffer(GL_ARRAY_BUFFER, vboIds[<span class=\"number\">1</span>]);</span><br><span class=\"line\">    glBufferData(GL_ARRAY_BUFFER, <span class=\"keyword\">sizeof</span>(GLfloat) * vertex_color_size * <span class=\"number\">4</span>, color, GL_STATIC_DRAW);</span><br><span class=\"line\">    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vboIds[<span class=\"number\">2</span>]);</span><br><span class=\"line\">    glBufferData(GL_ELEMENT_ARRAY_BUFFER, <span class=\"keyword\">sizeof</span>(GLushort) * <span class=\"number\">3</span>, indices, GL_STATIC_DRAW);</span><br><span class=\"line\">    </span><br><span class=\"line\">    glBindBuffer(GL_ARRAY_BUFFER, vboIds[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    glEnableVertexAttribArray(<span class=\"number\">0</span>);</span><br><span class=\"line\">    glVertexAttribPointer(<span class=\"number\">0</span>, vertex_position_size, GL_FLOAT, GL_FALSE, <span class=\"keyword\">sizeof</span>(GLfloat) * vertex_position_size, <span class=\"number\">0</span>);</span><br><span class=\"line\">    glBindBuffer(GL_ARRAY_BUFFER, vboIds[<span class=\"number\">1</span>]);</span><br><span class=\"line\">    glEnableVertexAttribArray(<span class=\"number\">1</span>);</span><br><span class=\"line\">    glVertexAttribPointer(<span class=\"number\">1</span>, vertex_color_size, GL_FLOAT, GL_FALSE, <span class=\"keyword\">sizeof</span>(GLfloat) * vertex_color_size, <span class=\"number\">0</span>);</span><br><span class=\"line\">    glDrawElements(GL_TRIANGLES, <span class=\"number\">3</span>, GL_UNSIGNED_SHORT, <span class=\"number\">0</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    glDisableVertexAttribArray(<span class=\"number\">0</span>);</span><br><span class=\"line\">    glDisableVertexAttribArray(<span class=\"number\">1</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    glBindBuffer(GL_ARRAY_BUFFER, <span class=\"number\">0</span>);</span><br><span class=\"line\">    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在应用程序结束缓冲对象的使用之后，删除它们：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 删除缓冲区对象</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param n#&gt; 删除的缓冲区对象数量 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param buffers#&gt; 包含要删除的缓冲区对象的有n个元素的数组 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glDeleteBuffers(GLsizei n, <span class=\"keyword\">const</span> GLuint *buffers);</span><br></pre></td></tr></table></figure>\n<p>一旦缓冲区对象被删除，它就可以作为新的缓冲区对象重用，存储顶点属性或者不同图元的元素索引。</p>\n<p>使用顶点缓冲区对象非常容易，比起顶点数组，所需要的额外工作非常少。考虑到这种功能提供的性能提升，支持顶点缓冲区对象的少量额外工作是值得的。</p>\n<h1 id=\"顶点数组对象\">顶点数组对象</h1>\n<p>上面我们已经介绍了顶点属性加载的两种不同方式：使用客户顶点数组和使用顶点缓冲区对象。顶点缓冲区对象优于客户顶点数组，因为它们能够减少GPU和CPU之间复制的数据量，从而获得更好的性能。在OpenGL ES 3.0中引入了一个新特性，使顶点数组的使用更加高效：顶点数组对象（VAO）。正如上面代码所示，使用顶点缓冲区对象设置绘图操作可能需要多次调用<code>glBindBuffer</code>、<code>glVertexAttribPointer</code>和<code>glEnableVertexAttribArray</code>。为了更快地在顶点数组配置直接切换，OpenGL ES 3.0推出了顶点数组对象。VAO提供包含在顶点数组/顶点缓冲区对象配置之间切换所需要的所有状态的单一对象。</p>\n<p>实际上，OpenGL ES 3.0中总是有一个活动的顶点数组对象。目前上述所有例子都在默认的顶点数组对象上操作（默认VAO的ID为0）。要创建新的顶点数组对象，可以使用<code>glGenVertexArrays</code>函数：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 创建顶点数组对象</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param n#&gt; 要返回的顶点数组对象名称的数量 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param arrays#&gt; 指向一个n个元素的数组的指针，该数组是分配的顶点数组对象返回的位置 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glGenVertexArrays(GLsizei n, GLuint *arrays);</span><br></pre></td></tr></table></figure>\n<p>一旦创建，就可以用<code>glBindVertexArray</code>绑定顶点数组对象供以后使用：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 绑定顶点数组对象</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param array#&gt; 被指定为当前顶点数组对象的对象 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glBindVertexArray(GLuint array);</span><br></pre></td></tr></table></figure>\n<p>每个VAO都包含一个完整的状态向量，描述所有顶点缓冲区绑定和启用的顶点客户状态。绑定VAO时，它的状态向量提供顶点缓冲区状态的当前设置。用<code>glBindVertexArray</code>绑定顶点数组对象后，更改顶点数组状态的后续调用（<code>glBindBuffer</code>、<code>glVertexAttribPointer</code>、<code>glEnableVertexAttribArray</code>、<code>glDisableVertexAttribArray</code>）将影响新的VAO。</p>\n<p>这样，应用程序可以通过绑定一个已经设置状态的顶点数组对象快速地在顶点数组配置之间切换。所有变化可以在一个函数调用中完成，没有必要多次调用以更改顶点数组状态。例子：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> DrawPrimitiveWithVAOs() &#123;</span><br><span class=\"line\">    GLuint vboIds[<span class=\"number\">2</span>];</span><br><span class=\"line\">    GLint vertex_position_size = <span class=\"number\">3</span>;</span><br><span class=\"line\">    GLint vertex_color_size = <span class=\"number\">4</span>;</span><br><span class=\"line\">    GLfloat vertices[] = &#123;</span><br><span class=\"line\">        <span class=\"number\">0.0</span>f, <span class=\"number\">0.5</span>f, <span class=\"number\">0.0</span>f,</span><br><span class=\"line\">        <span class=\"number\">1.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f,</span><br><span class=\"line\">        <span class=\"number\">-0.5</span>f, <span class=\"number\">-0.5</span>f, <span class=\"number\">0.0</span>f,</span><br><span class=\"line\">        <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f,</span><br><span class=\"line\">        <span class=\"number\">0.5</span>f, <span class=\"number\">-0.5</span>f, <span class=\"number\">0.0</span>f,</span><br><span class=\"line\">        <span class=\"number\">0.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f, <span class=\"number\">1.0</span>f</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    GLuint vaoId;</span><br><span class=\"line\">    GLushort indices[<span class=\"number\">3</span>] = &#123; <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span> &#125;;</span><br><span class=\"line\">    glGenBuffers(<span class=\"number\">2</span>, vboIds);</span><br><span class=\"line\">    glBindBuffer(GL_ARRAY_BUFFER, vboIds[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    glBufferData(GL_ARRAY_BUFFER, <span class=\"keyword\">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class=\"line\">    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vboIds[<span class=\"number\">1</span>]);</span><br><span class=\"line\">    glBufferData(GL_ELEMENT_ARRAY_BUFFER, <span class=\"keyword\">sizeof</span>(indices), indices, GL_STATIC_DRAW);</span><br><span class=\"line\">    </span><br><span class=\"line\">    glGenVertexArrays(<span class=\"number\">1</span>, &amp;vaoId);</span><br><span class=\"line\">    glBindVertexArray(vaoId);</span><br><span class=\"line\">    </span><br><span class=\"line\">    glBindBuffer(GL_ARRAY_BUFFER, vboIds[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vboIds[<span class=\"number\">1</span>]);</span><br><span class=\"line\">    </span><br><span class=\"line\">    glEnableVertexAttribArray(<span class=\"number\">0</span>);</span><br><span class=\"line\">    glEnableVertexAttribArray(<span class=\"number\">1</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    glVertexAttribPointer(<span class=\"number\">0</span>, vertex_position _size, GL_FLOAT, GL_FALSE, <span class=\"keyword\">sizeof</span>(GLfloat) * (vertex_position_size + vertex_color_size), <span class=\"number\">0</span>);</span><br><span class=\"line\">    glVertexAttribPointer(<span class=\"number\">1</span>, vertex_color_size, GL_FLOAT, GL_FALSE, <span class=\"keyword\">sizeof</span>(GLfloat) * (vertex_position_size + vertex_color_size), (<span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *)(<span class=\"keyword\">sizeof</span>(GLfloat) * vertex_position_size));</span><br><span class=\"line\">        </span><br><span class=\"line\">    glBindVertexArray(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 绘制</span></span><br><span class=\"line\">    glBindVertexArray(vaoId);</span><br><span class=\"line\">    glDrawElements(GL_TRIANGLES, <span class=\"number\">3</span>, GL_UNSIGNED_SHORT, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当应用程序结束一个或者多个顶点数组对象的使用时，可以用<code>glDeleteVertexArrays</code>删除它们：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 删除顶点数组对象</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param n#&gt; 要删除的顶点数组对象的数量 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param arrays#&gt; 包含需要删除的顶点数组对象的有n个元素的数组 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glDeleteVertexArrays(GLsizei n, <span class=\"keyword\">const</span> GLuint *arrays);</span><br></pre></td></tr></table></figure>\n<h1 id=\"映射缓冲区对象\">映射缓冲区对象</h1>\n<p>到目前为止，我们已经使用了<code>glBufferData</code>或<code>glBufferSubData</code>将数据加载到缓冲区对象。应用程序也可以将缓冲区对象数据存储映射到应用程序的地址空间（也可以解除映射）。应用程序映射缓冲区而不使用<code>glBufferData</code>或者<code>glBufferSubData</code>加载数据有几个理由：</p>\n<ul>\n<li>映射缓冲区可以减少应用程序的内存占用，因为可能只需要存储数据的一个副本；</li>\n<li>在使用共享内存的架构上，映射缓冲区返回GPU存储缓冲区的地址空间的直接指针。通过映射缓冲区，应用程序可以避免复制步骤，从而实现更好的更新性能。</li>\n</ul>\n<p><code>glMapBufferRange</code>命令返回指向所有或者一部分（范围）缓冲区对象数据存储的指针。这个指针可以供应应用程序使用，以读取或者更新缓冲区对象的内容。<code>glUnmapBuffer</code>命令用于指示更新已经完成和释放映射的指针：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 返回指向所有或者部分缓冲区对象数据存储的指针</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param target#&gt; GL_ARRAY_BUFFER, GL_ELEMENT_ARRAY_BUFFER, GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, GL_PIXEL_PACK_BUFFER, GL_PIXEL_UNPACK_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, GL_UNIFORM_BUFFER description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param offset#&gt; 缓冲区数据存储中的偏移量，以字节数计算 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param length#&gt; 需要映射的缓冲区数据的字节数 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param access#&gt; 详见下表 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return GLvoid *</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glMapBufferRange(GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access);</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>访问标志</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>GL_MAP_READ_BIT</td>\n<td>应用程序将从返回的指针读取</td>\n</tr>\n<tr>\n<td>GL_MAP_WRITE_BIT</td>\n<td>应用程序将写入返回的指针</td>\n</tr>\n</tbody>\n</table>\n<p>此外，应用程序可以包含如下可选访问标志：</p>\n<table>\n<thead>\n<tr>\n<th>访问标志</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>GL_MAP_INVALIDATAE_RANGE_BIT</td>\n<td>表示指定范围内的缓冲区内容可以在返回指针之前由驱动程序放弃。这个标志不能与GL_MAP_READ_BIT组合使用</td>\n</tr>\n<tr>\n<td>GL_MAP_INVALIDATE_BUFFER_BIT</td>\n<td>表示整个缓冲区的内容可以在返回指针之前由驱动程序放弃。这个标志不能与GL_MAP_READ_BIT组合使用</td>\n</tr>\n<tr>\n<td>GL_MAP_FLUSH_EXPLICIT_BIT</td>\n<td>表示应用程序将明确地用glFlushMappedBufferRange刷新对映射范围子范围的操作。这个标志不能与GL_MAP_WRITE_BIT组合使用</td>\n</tr>\n<tr>\n<td>GL_MAP_UNSYNCHRONIZED_BIT</td>\n<td>表示驱动程序在返回缓冲区范围的指针之前不需要等待缓冲对象上的未决操作。如果有未决的操作，则未决操作的结果和缓冲区对象上的任何未来操作都变为未定义</td>\n</tr>\n</tbody>\n</table>\n<p><code>glMapBufferRange</code>返回请求的缓冲区数据存储范围的指针。如果出现错误或者发出无效的请求，该函数将返回NULL。<code>glUnmapBuffer</code>命令取消之前的缓冲区映射：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 取消缓冲区映射</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param target#&gt; 必须设置为GL_ARRAY_BUFFER description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return GLboolean</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glUnmapBuffer(GLenum target);</span><br></pre></td></tr></table></figure>\n<p>如果取消映射操作成功，则<code>glUnmapBuffer</code>返回<code>GL_TRUE</code>。<code>glMapBufferRange</code>返回的指针在成功执行取消映射之后不再可以使用。如果顶点缓冲区对象数据存储中的数据在缓冲区映射之后已经破坏，<code>glUnmapBuffer</code>将返回<code>GL_FALSE</code>，这可能是因为屏幕分辨率的变化、OpenGL ES上下文使用多个屏幕或者导致映射内存被抛弃的内存不足事件所导致。</p>\n<p>写入映射缓冲区对象例子：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GLfloat *vtxMappedBuf;</span><br><span class=\"line\">GLushort *idxMappedBuf;</span><br><span class=\"line\">GLfloat vertices[] = &#123;</span><br><span class=\"line\">    <span class=\"number\">0.0</span>f, <span class=\"number\">0.5</span>f, <span class=\"number\">0.0</span>f,</span><br><span class=\"line\">    <span class=\"number\">1.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f,</span><br><span class=\"line\">    <span class=\"number\">-0.5</span>f, <span class=\"number\">-0.5</span>f, <span class=\"number\">0.0</span>f,</span><br><span class=\"line\">    <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f,</span><br><span class=\"line\">    <span class=\"number\">0.5</span>f, <span class=\"number\">-0.5</span>f, <span class=\"number\">0.0</span>f,</span><br><span class=\"line\">    <span class=\"number\">0.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f, <span class=\"number\">1.0</span>f</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">GLushort indices[<span class=\"number\">3</span>] = &#123; <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">glGenBuffers(<span class=\"number\">2</span>, vboIds);</span><br><span class=\"line\">glBindBuffer(GL_ARRAY_BUFFER, vboIds[<span class=\"number\">0</span>]);</span><br><span class=\"line\">glBufferData(GL_ARRAY_BUFFER, <span class=\"keyword\">sizeof</span>(vertices), <span class=\"literal\">NULL</span>, GL_STATIC_DRAW);</span><br><span class=\"line\">vtxMappedBuf = (GLfloat *)glMapBufferRange(GL_ARRAY_BUFFER, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(vertices), GL_MAP_WRITE_BIT | GL_MAP_INVALIDATE_BUFFER_BIT);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (vtxMappedBuf == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Error mapping vertex buffer object\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">memcpy(vtxMappedBuf, vertices, <span class=\"keyword\">sizeof</span>(vertices));</span><br><span class=\"line\"><span class=\"keyword\">if</span> (glUnmapBuffer(GL_ARRAY_BUFFER) == GL_FALSE) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Error unmapping array buffer object\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vboIds[<span class=\"number\">1</span>]);</span><br><span class=\"line\">glBufferData(GL_ELEMENT_ARRAY_BUFFER, <span class=\"keyword\">sizeof</span>(indices), <span class=\"literal\">NULL</span>, GL_STATIC_DRAW);</span><br><span class=\"line\">idxMappedBuf = (GLushort *)glMapBufferRange(GL_ELEMENT_ARRAY_BUFFER, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(indices), GL_MAP_WRITE_BIT | GL_MAP_INVALIDATE_BUFFER_BIT);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (idxMappedBuf == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Error mapping element buffer object\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">memcpy(idxMappedBuf, indices, <span class=\"keyword\">sizeof</span>(indices));</span><br><span class=\"line\"><span class=\"keyword\">if</span> (glUnmapBuffer(GL_ELEMENT_ARRAY_BUFFER) == GL_FALSE) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Error unmapping element buffer object\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"刷新映射的缓冲区\">刷新映射的缓冲区</h2>\n<p>应用程序可能希望用<code>glMapBufferRange</code>来映射缓冲区对象的一个范围或者全部，但是只更新映射范围的不同子区域。为了避免调用<code>glUnmapBuffer</code>时刷新整个映射范围的潜在性能损失，应用程序可以用<code>GL_MAP_FLUSH_EXPLICIT_BIT</code>访问标志（和<code>GL_MAP_WRITE_BIT</code>组合）映射。当应用程序完成映射范围一部分的更新时，可以用<code>glFlushMappedBufferRange</code>指出这个事实：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 指出应用程序完成映射范围的部分更新</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param target#&gt; GL_ARRAY_BUFFER, GL_ELEMENT_ARRAY_BUFFER, GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, GL_PIXEL_PACK_BUFFER, GL_PIXEL_UNPACK_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, GL_UNIFORM_BUFFER description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param offset#&gt; 从映射缓冲区起始点的偏移量，以字节数表示 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param length#&gt; 从便宜点开始刷新的缓冲区字节数 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glFlushMappedBufferRange(GLenum target, GLintptr offset, GLsizeiptr length);</span><br></pre></td></tr></table></figure>\n<p>如果应用程序用<code>GL_MAP_FLUSH_EXPLICIT_BIT</code>映射，但是没有明确用<code>glFlushMappedBufferRange</code>刷新修改后的区域，它的内容将是未定义的。</p>\n<h1 id=\"复制缓冲区对象\">复制缓冲区对象</h1>\n<p>上面我们已经说明如何用<code>glBufferData</code>、<code>glBufferSubData</code>和<code>glMapBufferRange</code>加载缓冲区对象。所有这些技术都涉及从应用程序到设备的数据传输。OpenGL ES 3.0还可以从一个缓冲区对象将数据完全复制到设备：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 从一个缓冲区对象将数据完全复制到设备</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param readTarget#&gt; 读取的缓冲区对象目标 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param writeTarget#&gt; 写入的缓冲区对象目标 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param readOffset#&gt; 需要复制的读缓冲数据中的偏移量，以字节表示 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param writeOffset#&gt; 需要复制的写缓冲数据中的偏移量，以字节表示 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param size#&gt; 从读缓冲区数据复制到写缓冲区数据的字节数 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glCopyBufferSubData(GLenum readTarget, GLenum writeTarget, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size);</span><br></pre></td></tr></table></figure>\n<p>调用<code>glCopyBufferSubData</code>将从绑定到<code>readtarget</code>的缓冲区复制指定的字节到<code>writetarget</code>。缓冲区绑定根据每个目标的最后一次<code>glBindBuffer</code>确定调用。任何类型的缓冲区对象（数组、元素数组、变换反馈等）都可以绑定到<code>GL_COPY_READ_BUFFER</code>或<code>GL_COPY_WRITE_BUFFER</code>目标。这两个目标是一种方便的措施，使得应用程序在执行缓冲区间的复制时不必改变任何真正的缓冲区绑定。</p>\n<h1 id=\"总结\">总结</h1>\n<p>这篇文章主要介绍了指定顶点属性和数据的方法。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>顶点数据也称作顶点属性，指定每个顶点的数据。这种逐顶点数据可以为每个顶点指定，也可以用于所有顶点的常量。例如，如果想要绘制一个固定颜色的三角形，可以指定一个常量值，用于三角形的全部3个顶点。但是，组成三角形的3个顶点的位置不同，所以我们必须指定一个顶点数组来存储3个位置值。</p>\n</blockquote>\n<h1>指定顶点属性数据</h1>\n<p>顶点属性数据可以用一个顶点数组对每个顶点指定，也可以将一个常量值用于一个图元的所有顶点。</p>\n<p>所有OpenGL ES 3.0实现必须支持最少16个顶点属性，可以通过<code>glGet*</code>函数查询特定支持的顶点属性的准确数量：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GLint maxVertexAttribs; </span><br><span class=\"line\">glGetIntegerv(GL_MAX_VERTEX_ATTRIBS, &amp;maxVertexAttribs);</span><br></pre></td></tr></table></figure>\n<h2>常量顶点属性</h2>\n<p>常量顶点属性对于一个图元的所有顶点都相同，所以对一个图元的所有顶点只需指定一个值。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 加载indx指定的通用顶点属性(x, 0.0, 0.0, 1.0)</span></span><br><span class=\"line\">glVertexAttrib1f(GLuint indx, GLfloat x);</span><br><span class=\"line\">glVertexAttrib1fv(GLuint indx, <span class=\"keyword\">const</span> GLfloat *values);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 加载indx指定的通用顶点属性(x, y, 0.0, 1.0)</span></span><br><span class=\"line\">glVertexAttrib2f(GLuint indx, GLfloat x, GLfloat y);</span><br><span class=\"line\">glVertexAttrib2fv(GLuint indx, <span class=\"keyword\">const</span> GLfloat *values);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 加载indx指定的通用顶点属性(x, y, z, 1.0)</span></span><br><span class=\"line\">glVertexAttrib3f(GLuint indx, GLfloat x, GLfloat y, GLfloat z);</span><br><span class=\"line\">glVertexAttrib3fv(GLuint indx, <span class=\"keyword\">const</span> GLfloat *values);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 加载indx指定的通用顶点属性(x, y, z, w)</span></span><br><span class=\"line\">glVertexAttrib4f(GLuint indx, GLfloat x, GLfloat y, GLfloat z, GLfloat w);</span><br><span class=\"line\">glVertexAttrib4fv(GLuint indx, <span class=\"keyword\">const</span> GLfloat *values);</span><br></pre></td></tr></table></figure>\n<h2>顶点数组</h2>\n<p>顶点数组指定每个顶点的属性，是保存在应用程序地址空间的缓冲区。它们作为顶点缓冲对象的基础，提供指定顶点属性数据的一种高效、灵活的手段。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 指定顶点属性</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param indx#&gt; 指定通用顶点属性索引 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param size#&gt; 顶点数组中为索引引用的顶点属性所指定的分量数量，有效值为1~4 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param type#&gt; 数据格式 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param normalized#&gt; 用于表示非浮点数据格式类型在转换为浮点值时是否应该规范化 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param stride#&gt; 每个顶点由size指定的顶点属性分量顺序存储。stride指定顶点索引I和I+1表示的顶点数据之间的位移。如果stride为0，则每个顶点的属性数据顺序存储。如果stride大于0，则使用该值作为获取下一个索引表示的顶点数据的跨距 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param ptr#&gt; 如果使用客户端顶点数组，则是保存顶点属性数据的缓冲区指针。如果使用顶点缓冲区对象，则表示该缓冲区内的偏移量 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glVertexAttribPointer(GLuint indx, GLint size, GLenum type, GLboolean normalized, GLsizei stride, <span class=\"keyword\">const</span> GLvoid *ptr);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 指定顶点属性，数据格式类型被当做整数对待</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param index#&gt; 指定通用顶点属性索引 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param size#&gt; 顶点数组中为索引引用的顶点属性所指定的分量数量，有效值为1~4 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param type#&gt; 数据格式 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param stride#&gt; 每个顶点由size指定的顶点属性分量顺序存储。stride指定顶点索引I和I+1表示的顶点数据之间的位移。如果stride为0，则每个顶点的属性数据顺序存储。如果stride大于0，则使用该值作为获取下一个索引表示的顶点数据的跨距 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param pointer#&gt; 如果使用客户端顶点数组，则是保存顶点属性数据的缓冲区指针。如果使用顶点缓冲区对象，则表示该缓冲区内的偏移量 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glVertexAttribIPointer(GLuint index, GLint size, GLenum type, GLsizei stride, <span class=\"keyword\">const</span> GLvoid *pointer);</span><br></pre></td></tr></table></figure>\n<p>分配和存储顶点属性数据有两种常用的方法：</p>\n<ul>\n<li>在一个缓冲区中存储顶点属性–这种方法称为结构数组。结构表示顶点的所有属性，每个顶点有一个属性的数组。</li>\n<li>在单独的缓冲区中保存每个顶点属性–这种方法称为数组结构。</li>\n</ul>\n<h3>哪种存储顶点属性的方法高效</h3>\n<p>在大部分情况下，答案是结构数组。原因是，每个顶点的属性数据可以顺序方法读取，这最有可能造成高效的内存访问模式。使用结构数组的缺点在应用程序需要修改特定属性时变得很明显。如果顶点属性数据的一个自己需要修改，这将造成顶点缓冲区的跨距更新。当顶点缓冲区以缓冲区对象的形式提供时，需要重新加载整个顶点属性缓冲区。可以通过将动态的顶点属性保存在单独的缓冲区来避免这种效率低下的情况。</p>\n<h3>顶点属性使用哪种数据格式</h3>\n<p><code>glVertexAttribPointer</code>中的<code>type</code>参数指定的顶点属性格式不仅影响顶点属性数据的图形内存存储需求，而且影响整体性能，这是渲染帧所需内存带宽的一个函数。数据空间占用越小，需要的内存带宽越小。OpenGL ES 3.0支持名为<code>GL_HALF_FLOAT</code>的16位浮点顶点格式，建议尽可能使用。纹理坐标、法线、副法线、切向量等都是使用<code>GL_HALF_FLOAT</code>存储每个分量的候选。颜色可以存储为<code>GL_UNSIGNED_BYTE</code>，每个顶点颜色具有4个分量。顶点位置可以存储为<code>GL_FLOAT</code>。</p>\n<h3><code>glVertexAttribPointer</code>中的规范化标识如何工作</h3>\n<p>在用于顶点着色器之前，顶点属性在内部保存为单精度浮点数，如果数据类型表示顶点属性不是浮点数，顶点属性将在用于顶点着色器之前转换为单精度浮点数。规范化标志控制非浮点顶点属性数据到单精度浮点值的转换。如果规范化标识为假，则顶点数据被直接转换为浮点数。这类似于将非浮点类型的变量转换为浮点变量。例子：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GLfloat f;</span><br><span class=\"line\">GLbyte b;</span><br><span class=\"line\">f = (GLfloat)b;     <span class=\"comment\">// f represents values in the range [-128.0, 127.0]</span></span><br></pre></td></tr></table></figure>\n<p>如果规范化标志位真，且如果数据类型为<code>GL_BYTE</code>、<code>GL_SHORT</code>或者<code>GL_FIXED</code>，则顶点数据被映射到[-1.0, 1.0]范围内，如果数据类型为<code>GL_UNSIGNED_BYTE</code>或<code>GL_UNSIGNED_SHORT</code>，则被映射到[0.0, 1.0]范围内。</p>\n<p>下表说明了设置规范化标志时非浮点数据类型的转换，表中第二列的<code>c</code>值指的是第一列中指定格式的一个值：</p>\n<table>\n<thead>\n<tr>\n<th>顶点数据格式</th>\n<th>转换为浮点数</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>GL_BYTE</td>\n<td>max(c/(2<sup>7</sup>-1), -1.0)</td>\n</tr>\n<tr>\n<td>GL_UNSIGNED_BYTE</td>\n<td>c/(2<sup>8</sup>-1)</td>\n</tr>\n<tr>\n<td>GL_SHORT</td>\n<td>max(c/(2<sup>16</sup>-1), -1.0)</td>\n</tr>\n<tr>\n<td>GL_UNSIGNED_SHORT</td>\n<td>c/(2<sup>16</sup>-1)</td>\n</tr>\n<tr>\n<td>GL_FIXED</td>\n<td>c/(2<sup>16</sup>)</td>\n</tr>\n<tr>\n<td>GL_FLOAT</td>\n<td>c</td>\n</tr>\n<tr>\n<td>GL_HALF_FLOAT_OES</td>\n<td>c</td>\n</tr>\n</tbody>\n</table>\n<p>在顶点着色器中，也有可能按照整数的形式访问整数型顶点属性数据，而不是将其转换为浮点数，可以使用<code>glVertexAttribIPointer</code>函数。</p>\n<h3>在常量顶点属性和顶点数组之间选择</h3>\n<p>应用程序可以让OpenGL ES使用常量数据或者来自顶点数组的数据。<code>glEnableVertexAttribArray</code>和<code>glDisableVertexAttribArray</code>命令分别用于启用和禁用通用顶点属性数组。如果某个通用属性索引的顶点属性数组被禁用，将使用为该索引指定的常量顶点属性数据。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// glsl.vsh</span></span><br><span class=\"line\"><span class=\"meta\">#version 300 es</span></span><br><span class=\"line\">layout(location = <span class=\"number\">0</span>) <span class=\"keyword\">in</span> vec4 a_color;</span><br><span class=\"line\">layout(location = <span class=\"number\">1</span>) <span class=\"keyword\">in</span> vec4 a_position;</span><br><span class=\"line\"><span class=\"keyword\">out</span> vec4 v_color;</span><br><span class=\"line\"><span class=\"keyword\">void</span> mian() &#123;</span><br><span class=\"line\">    v_color = a_color;</span><br><span class=\"line\">    gl_Position = a_position;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// glsl.fsh</span></span><br><span class=\"line\"><span class=\"meta\">#version 300 es</span></span><br><span class=\"line\">precision mudiump <span class=\"keyword\">float</span>;</span><br><span class=\"line\"><span class=\"keyword\">in</span> vec4 v_color;</span><br><span class=\"line\"><span class=\"keyword\">out</span> vec4 o_fragColor;</span><br><span class=\"line\"><span class=\"keyword\">void</span> main() &#123;</span><br><span class=\"line\">    o_fragColor = v_color;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GLfloat color[<span class=\"number\">4</span>] = &#123;<span class=\"number\">1.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f&#125;;</span><br><span class=\"line\">GLfloat vertexPos[<span class=\"number\">9</span>] = &#123;<span class=\"number\">0.0</span>f, <span class=\"number\">0.5</span>f, <span class=\"number\">0.0</span>f,</span><br><span class=\"line\">                        <span class=\"number\">-0.5</span>f, <span class=\"number\">-0.5</span>f, <span class=\"number\">0.0</span>f,</span><br><span class=\"line\">                        <span class=\"number\">0.5</span>f, <span class=\"number\">-0.5</span>f, <span class=\"number\">0.0</span>f&#125;;</span><br><span class=\"line\">glVertexAttrib4fv(<span class=\"number\">0</span>, color);</span><br><span class=\"line\">glVertexAttribPointer(<span class=\"number\">1</span>, <span class=\"number\">3</span>, GL_FLOAT, GL_FALSE, <span class=\"number\">0</span>, vertexPos);</span><br><span class=\"line\">glEnableVertexAttribArray(<span class=\"number\">1</span>);</span><br><span class=\"line\">glDrawArrays(GL_TRIANGLES, <span class=\"number\">0</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">glDisableVertexAttribArray(<span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure>\n<p>代码示例中使用的顶点属性<code>color</code>是一个常量，用<code>glVertexAttrib4fv</code>指定，不启用顶点属性数组0。<code>vertexPos</code>属性用<code>glVertexAttribPointer</code>以一个顶点数组指定，并用<code>glEnableVertexAttribArray</code>启用数组。<code>color</code>值对于所绘制的三角形的所有顶点均相同，而<code>vertexPos</code>属性对于三角形的各个顶点可以不同。</p>\n<h1>在顶点着色器中声明顶点属性变量</h1>\n<p>在顶点着色器中，变量通过使用<code>in</code>限定符声明为顶点属性。属性变量也可以包含一个布局限定符，提供属性索引：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">layout(location = <span class=\"number\">0</span>) <span class=\"keyword\">in</span> vec4 a_position;</span><br><span class=\"line\">layout(location = <span class=\"number\">1</span>) <span class=\"keyword\">in</span> vec2 a_texcoord;</span><br><span class=\"line\">layout(location - <span class=\"number\">2</span>) <span class=\"keyword\">in</span> vec3 a_normal;</span><br></pre></td></tr></table></figure>\n<p>属性可以在顶点着色器内部声明–但是如果没有使用，就不会被认为是活动属性，从而不会被计入限制。如果在顶点着色器中使用的属性数量大于<code>GL_MAX_VERTEX_ATTRIBS</code>，这个顶点着色器就无法链接。</p>\n<p>当程序成功链接，我们就需要找出连接到该程序的顶点着色器使用的活动顶点属性数量。注意：这一步骤只需要在我们对属性不使用布局限定符时才有必要。<br>\n首先通过<code>glGetProgramiv</code>函数传入<code>GL_ACTIVE_ATTRIBUTE</code>获取活动的属性数量，传入<code>GL_ACTIVE_ATTRIBUTE_MAX_LENGTH</code>获取属性的最长字符数量，最后使用<code>glGetActiveAttrib</code>函数查询顶点着色器各属性索引点对应的属性变量名称：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GLint attribsCount;</span><br><span class=\"line\">GLint attribMaxLength;</span><br><span class=\"line\">glGetProgramiv(program, GL_ACTIVE_ATTRIBUTES, &amp;attribsCount);</span><br><span class=\"line\">glGetProgramiv(program, GL_ACTIVE_ATTRIBUTE_MAX_LENGTH, &amp;attribMaxLength);</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; attribsCount; i++) &#123;</span><br><span class=\"line\">    GLsizei length;</span><br><span class=\"line\">    GLint size;</span><br><span class=\"line\">    GLenum type;</span><br><span class=\"line\">    GLchar *name = malloc(attribMaxLength * <span class=\"keyword\">sizeof</span>(GLchar));</span><br><span class=\"line\">    glGetActiveAttrib(program, i, attribMaxLength, &amp;length, &amp;size, &amp;type, name);</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"length: %d, size: %d, type: %u, name: %s\"</span>, length, size, type, name);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2>将顶点属性绑定到顶点着色器中的属性变量</h2>\n<p>在OpenGL ES 3.0中，可以使用3种方法将通用顶点属性索引映射到顶点着色器中的一个属性变量名称：</p>\n<ul>\n<li>索引可以在顶点着色器源代码中用<code>layout(location = N)</code>限定符指定（推荐）；</li>\n<li>OpenGL ES 3.0将通用顶点属性索引绑定到属性名称；</li>\n<li>应用程序可以将顶点属性索引绑定到属性名称；</li>\n</ul>\n<p>将属性绑定到一个位置的最简单方法是简单地使用<code>layout(location = N)</code>限定符，这种方法需要的代码最少。但是，在某些情况下，其他两个选项可能更合适。<code>glBindAttribLocation</code>命令可用于将通用顶点属性索引绑定到顶点着色器中的一个属性变量。这种绑定在下一次程序链接时生效–不会改变当前链接的程序中使用的绑定。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 将通用顶点属性索引绑定到属性变量</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param program#&gt; 程序对象 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param index#&gt; 通用顶点属性索引 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param name#&gt; 属性变量名称 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glBindAttribLocation(GLuint program, GLuint index, <span class=\"keyword\">const</span> GLchar *name);</span><br></pre></td></tr></table></figure>\n<p>如果之前绑定了<code>name</code>，则它所指定的绑定被索引代替。<code>glBindAttribLocation</code>甚至可以在顶点着色器连接到程序对象之前调用，因此，这个调用可以用于绑定任何属性名称。不存在的属性名称或者在连接到程序对象的顶点着色器中不活动的属性将被忽略。</p>\n<p>另一个选项是让OpenGL ES 3.0将属性变量名称绑定到一个通用顶点属性索引。这种绑定在程序链接时进行，在链接阶段，OpenGL ES 3.0实现为每个属性变量执行如下操作：对于每个属性变量，检查是否已经通过<code>glBindAttribLocation</code>。如果指定了一个绑定，则使用指定的对应属性索引。否则，OpenGL ES实现将分配一个通用顶点属性索引。<br>\n这种分配特定于实现；也就是说，在一个OpenGL ES 3.0实现中和在另一个实现中可能不同。应用程序可以使用<code>glGetAttribLocation</code>命令查询分配的绑定。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 查询属性索引</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param program#&gt; 程序对象 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param name#&gt; 属性变量名称 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return 属性索引</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glGetAttribLocation(GLuint program, <span class=\"keyword\">const</span> GLchar *name);</span><br></pre></td></tr></table></figure>\n<p><code>glGetAttribLocation</code>返回<code>program</code>定义的程序对象最后一次链接时绑定到属性变量<code>name</code>的通用属性索引。如果<code>name</code>不是一个活动属性变量，或者<code>program</code>不是一个有效的程序对象，或者没有链接成功，则返回-1，表示无效的属性索引。</p>\n<h1>顶点缓冲区对象</h1>\n<p>使用顶点数组指定的顶点数据保存在客户内存中。在进行<code>glDrawArrays</code>或者<code>glDrawElements</code>等绘图调用时，这些数据必须从客户内存复制到图形内存。但是，如果我们没有必要在每次绘图调用时都复制顶点数据，而是在图形内存中缓存这些数据，那就好得多了。这种方法可以显著地改进渲染性能，也会降低内存带宽和电力消耗序曲，对于手持设备相当重要。这是顶点缓冲区对象发挥的地方。顶点缓冲区对象使OpenGL ES 3.0应用程序可以在高性能的图形内存中分配和缓存顶点数据，并从这个内存进行渲染，从而避免在每次绘制图元的时候重新发送数据。不仅是顶点数据，描述图元顶点索引、作为<code>glDrawElements</code>参数传递的元素索引也可以缓存。</p>\n<p>OpenGL ES 3.0支持两类缓冲区对象，用于指定顶点和图元数据：数组缓冲区对象和元素数组缓冲区对象。<code>GL_ARRAY_BUFFER</code>标志指定的数组缓冲区对象用于创建保存顶点数据的缓冲区对象。<code>GL_ELEMENT_ARRAY_BUFFER</code>标志指定的元素数组缓冲区对象用于创建保存图元索引的缓冲区对象。</p>\n<blockquote>\n<p>为了得到最佳性能，推荐OpenGL ES 3.0应用程序对顶点属性数据和元素索引使用顶点缓冲区对象。</p>\n</blockquote>\n<p>在使用缓冲对象渲染之前，需要分配缓冲区对象并将顶点数据和元素索引上传到相应的缓冲区对象。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// vertex_t是自定义顶点数据类型</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> initVertexBufferObjects(vertex_t *vertexBuffer,</span><br><span class=\"line\">                             GLushort *indices,</span><br><span class=\"line\">                             GLuint numVertices,</span><br><span class=\"line\">                             GLuint numIndices,</span><br><span class=\"line\">                             GLuint *vboIds) &#123;</span><br><span class=\"line\">    glGenBuffers(<span class=\"number\">2</span>, vboIds);</span><br><span class=\"line\">    </span><br><span class=\"line\">    glBindBuffer(GL_ARRAY_BUFFER, vboIds[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    glBufferData(GL_ARRAY_BUFFER, numVertices * <span class=\"keyword\">sizeof</span>(vertex_t), vertexBuffer, GL_STATIC_DRAW);</span><br><span class=\"line\">    </span><br><span class=\"line\">    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vboIds[<span class=\"number\">1</span>]);</span><br><span class=\"line\">    glBufferData(GL_ELEMENT_ARRAY_BUFFER, numIndices * <span class=\"keyword\">sizeof</span>(GLushort), indices, GL_STATIC_DRAW);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述代码创建两个缓冲区对象：一个用于保存实际的顶点属性数据，另一个用于保存组成图元的元素索引。数组缓冲区对象用于保存一个或者多个图元的顶点属性数据，元素数组缓冲区对象保存一个或者多个图元的索引。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 创建缓冲区对象</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param n#&gt; 返回缓冲区对象名称数量 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param buffers#&gt; 指向n个条目的数组指针，该数组是分配的缓冲区对象返回的位置 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glGenBuffers(GLsizei n, GLuint *buffers);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 指定当前缓冲区对象</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param target#&gt; GL_ARRAY_BUFFER, GL_ELEMENT_ARRAY_BUFFER, GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, GL_PIXEL_PACK_BUFFER, GL_PIXEL_UNPACK_BUFFER, GL_TRANSFROM_FEEDBACK_BUFFER, GL_UNIFORM_BUFFER description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param buffer#&gt; 分配给目标当做当前对象的缓冲区对象 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glBindBuffer(GLenum target, GLuint buffer);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 顶点数组数据或者元素数组数据存储创建和初始化</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param target#&gt; GL_ARRAY_BUFFER, GL_ELEMENT_ARRAY_BUFFER, GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, GL_PIXEL_PACK_BUFFER, GL_PIXEL_UNPACK_BUFFER, GL_TRANSFROM_FEEDBACK_BUFFER, GL_UNIFORM_BUFFER description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param size#&gt; 缓冲区数据存储大小，以字节数表示 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param data#&gt; 应用程序提供的缓冲区数据的指针，可为NULL值，表示保留的数据存储不进行初始化。如果是一个有效的指针，则其内容被复制到分配的数据存储 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param usage#&gt; 详见下表 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glBufferData(GLenum target, GLsizeiptr size, <span class=\"keyword\">const</span> GLvoid *data, GLenum usage);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 顶点数组数据或者元素数组数据存储初始化或者更新</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param target#&gt; GL_ARRAY_BUFFER, GL_ELEMENT_ARRAY_BUFFER, GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, GL_PIXEL_PACK_BUFFER, GL_PIXEL_UNPACK_BUFFER, GL_TRANSFROM_FEEDBACK_BUFFER, GL_UNIFORM_BUFFER description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param offset#&gt; 缓冲区数据存储中的偏移 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param size#&gt; 被修改的数据存储字节数 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param data#&gt; 需要被复制到缓冲区对象数据存储的客户数据指针 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glBufferSubData(GLenum target, GLintptr offset, GLsizeiptr size, <span class=\"keyword\">const</span> GLvoid *data)</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>缓冲区使用枚举值</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>GL_STATIC_DRAW</td>\n<td>缓冲区对象数据将被修改一次，使用多次，以绘制图元或者指定图像</td>\n</tr>\n<tr>\n<td>GL_STATIC_READ</td>\n<td>缓冲区对象数据将被修改一次，使用多次，以从OpenGL ES读回数据。从OpenGL ES读回的数据将从应用程序中查询</td>\n</tr>\n<tr>\n<td>GL_STATIC_COPY</td>\n<td>缓冲区对象数据将被修改一次，使用多次，以从OpenGL ES读回数据。从OpenGL ES读回的数据将直接用作绘制图元或者修改图像的信息来源</td>\n</tr>\n<tr>\n<td>GL_DYNAMIC_DRAW</td>\n<td>缓冲区对象数据将被重复修改，使用多次，以绘制图元或者指定图像</td>\n</tr>\n<tr>\n<td>GL_DYNAMIC_READ</td>\n<td>缓冲区对象数据将被重复修改，使用多次，以从OpenGL ES读回数据。从OpenGL ES读回的数据中将从应用程序中查询</td>\n</tr>\n<tr>\n<td>GL_DYNAMIC_COPY</td>\n<td>缓冲区对象数据将被重复修改，使用多次，以从OpenGL ES读回数据。从OpenGL ES读回的数据将直接用作绘制图元或者修改图像的信息来源</td>\n</tr>\n<tr>\n<td>GL_STREAM_DRAW</td>\n<td>缓冲区对象数据将被修改一次，只使用少数几次，以绘制图元或者指定图像</td>\n</tr>\n<tr>\n<td>GL_STREAM_READ</td>\n<td>缓冲区对象数据将被修改一次，只使用少数几次，以从OpenGL ES读回数据。从OpenGL ES读回的数据将从应用程序中查询</td>\n</tr>\n<tr>\n<td>GL_STREAM_COPY</td>\n<td>缓冲区对象数据将被修改一次，只使用少数几次，以从OpenGL ES读回数据。从OpenGL ES读回的数据将直接用作绘制图元或者修改图像的信息来源</td>\n</tr>\n</tbody>\n</table>\n<p>在用<code>glBufferData</code>或者<code>glBufferSubData</code>初始化或者更新缓冲区对象数据存储之后，客户数据存储不再需要，可以释放。对于静态的几何形状，应用程序可以释放客户数据存储，减少应用程序消耗的系统内存。对于动态几何形状，这可能无法做到。</p>\n<p>下面是个使用和不使用缓冲区对象进行的图元绘制：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// glsl.vsh</span></span><br><span class=\"line\"><span class=\"meta\">#version 300 es</span></span><br><span class=\"line\">layout(location = <span class=\"number\">0</span>) <span class=\"keyword\">in</span> vec4 vPosition;</span><br><span class=\"line\">layout(location = <span class=\"number\">1</span>) <span class=\"keyword\">in</span> vec4 vColor;</span><br><span class=\"line\">uniform <span class=\"keyword\">float</span> offsetLoc;</span><br><span class=\"line\"><span class=\"keyword\">out</span> vec4 v_color;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> main() &#123;</span><br><span class=\"line\">    v_color = vColor;</span><br><span class=\"line\">    gl_Position = vec4(vPosition.x + offsetLoc, vPosition.yzw);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// glsl.fsh</span></span><br><span class=\"line\"><span class=\"meta\">#version 300 es</span></span><br><span class=\"line\">precision mediump <span class=\"keyword\">float</span>;</span><br><span class=\"line\"><span class=\"keyword\">in</span> vec4 v_color;</span><br><span class=\"line\"><span class=\"keyword\">out</span> vec4 fragColor;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> main() &#123;</span><br><span class=\"line\">    fragColor = v_color;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> DrawPrimitiveWithoutVBOs() &#123;</span><br><span class=\"line\">    GLint vertex_position_size = <span class=\"number\">3</span>;</span><br><span class=\"line\">    GLint vertex_color_size = <span class=\"number\">4</span>;</span><br><span class=\"line\">    GLushort indices[<span class=\"number\">3</span>] = &#123;<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>&#125;;</span><br><span class=\"line\">    GLfloat vertices[] = &#123;</span><br><span class=\"line\">        <span class=\"number\">-0.5</span>f, <span class=\"number\">0.5</span>f, <span class=\"number\">0.0</span>f,</span><br><span class=\"line\">        <span class=\"number\">1.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f,</span><br><span class=\"line\">        <span class=\"number\">-1.0</span>f, <span class=\"number\">-0.5</span>f, <span class=\"number\">0.0</span>f,</span><br><span class=\"line\">        <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f,</span><br><span class=\"line\">        <span class=\"number\">0.0</span>f, <span class=\"number\">-0.5</span>f, <span class=\"number\">0.0</span>f,</span><br><span class=\"line\">        <span class=\"number\">0.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f, <span class=\"number\">1.0</span>f</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    GLfloat *vtxBuf = vertices;</span><br><span class=\"line\">    GLsizei vtxStride = <span class=\"keyword\">sizeof</span>(GLfloat) * (vertex_color_size + vertex_position_size);</span><br><span class=\"line\">    </span><br><span class=\"line\">    glBindBuffer(GL_ARRAY_BUFFER, <span class=\"number\">0</span>);</span><br><span class=\"line\">    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, <span class=\"number\">0</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    glEnableVertexAttribArray(<span class=\"number\">0</span>);</span><br><span class=\"line\">    glEnableVertexAttribArray(<span class=\"number\">1</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    glVertexAttribPointer(<span class=\"number\">0</span>, vertex_position_size, GL_FLOAT, GL_FALSE, vtxStride, vtxBuf);</span><br><span class=\"line\">    vtxBuf += vertex_position_size;</span><br><span class=\"line\">    glVertexAttribPointer(<span class=\"number\">1</span>, vertex_color_size, GL_FLOAT, GL_FALSE, vtxStride, vtxBuf);</span><br><span class=\"line\">    </span><br><span class=\"line\">    glDrawElements(GL_TRIANGLES, <span class=\"number\">3</span>, GL_UNSIGNED_SHORT, indices);</span><br><span class=\"line\">    </span><br><span class=\"line\">    glDisableVertexAttribArray(<span class=\"number\">0</span>);</span><br><span class=\"line\">    glDisableVertexAttribArray(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> DrawPrimitiveWithVBOs() &#123;</span><br><span class=\"line\">    GLvoid *offset = <span class=\"number\">0</span>;</span><br><span class=\"line\">    GLuint vboIds[<span class=\"number\">2</span>];</span><br><span class=\"line\">    GLint vertex_position_size = <span class=\"number\">3</span>;</span><br><span class=\"line\">    GLint vertex_color_size = <span class=\"number\">4</span>;</span><br><span class=\"line\">    GLushort indices[<span class=\"number\">3</span>] = &#123;<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>&#125;;</span><br><span class=\"line\">    GLint vtxStride = <span class=\"keyword\">sizeof</span>(GLfloat) * (vertex_position_size + vertex_color_size);</span><br><span class=\"line\">    GLfloat vertices[] = &#123;</span><br><span class=\"line\">        <span class=\"number\">-0.5</span>f, <span class=\"number\">0.5</span>f, <span class=\"number\">0.0</span>f,</span><br><span class=\"line\">        <span class=\"number\">1.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f,</span><br><span class=\"line\">        <span class=\"number\">-1.0</span>f, <span class=\"number\">-0.5</span>f, <span class=\"number\">0.0</span>f,</span><br><span class=\"line\">        <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f,</span><br><span class=\"line\">        <span class=\"number\">0.0</span>f, <span class=\"number\">-0.5</span>f, <span class=\"number\">0.0</span>f,</span><br><span class=\"line\">        <span class=\"number\">0.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f, <span class=\"number\">1.0</span>f</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    GLfloat *vtxBuf = vertices;</span><br><span class=\"line\"></span><br><span class=\"line\">    glGenBuffers(<span class=\"number\">2</span>, vboIds);</span><br><span class=\"line\">    glBindBuffer(GL_ARRAY_BUFFER, vboIds[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    glBufferData(GL_ARRAY_BUFFER, vtxStride * <span class=\"number\">3</span>, vtxBuf, GL_STATIC_DRAW);</span><br><span class=\"line\">    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vboIds[<span class=\"number\">1</span>]);</span><br><span class=\"line\">    glBufferData(GL_ELEMENT_ARRAY_BUFFER, <span class=\"keyword\">sizeof</span>(GLushort) * <span class=\"number\">3</span>, indices, GL_STATIC_DRAW);</span><br><span class=\"line\">    </span><br><span class=\"line\">    glEnableVertexAttribArray(<span class=\"number\">0</span>);</span><br><span class=\"line\">    glEnableVertexAttribArray(<span class=\"number\">1</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    glVertexAttribPointer(<span class=\"number\">0</span>, vertex_position_size, GL_FLOAT, GL_FALSE, vtxStride, offset);</span><br><span class=\"line\">    offset += vertex_position_size * <span class=\"keyword\">sizeof</span>(GLfloat);</span><br><span class=\"line\">    glVertexAttribPointer(<span class=\"number\">1</span>, vertex_color_size, GL_FLOAT, GL_FALSE, vtxStride, offset);</span><br><span class=\"line\">    </span><br><span class=\"line\">    glDrawElements(GL_TRIANGLES, <span class=\"number\">3</span>, GL_UNSIGNED_SHORT, <span class=\"number\">0</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    glDisableVertexAttribArray(<span class=\"number\">0</span>);</span><br><span class=\"line\">    glDisableVertexAttribArray(<span class=\"number\">1</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    glBindBuffer(GL_ARRAY_BUFFER, <span class=\"number\">0</span>);</span><br><span class=\"line\">    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 调用</span></span><br><span class=\"line\">DrawPrimitiveWithoutVBOs();</span><br><span class=\"line\">glUniform1f(<span class=\"number\">0</span>, <span class=\"number\">1.0</span>f);</span><br><span class=\"line\">DrawPrimitiveWithVBOs();</span><br></pre></td></tr></table></figure>\n<p>上述代码中，我们对一个顶点的所有属性使用相同的缓冲区对象。使用<code>GL_ARRAY_BUFFER</code>缓冲区对象时，<code>glVertexAttribPointer</code>的<code>pointer</code>参数从指向实际数据的一个指针变成用<code>glBufferData</code>分配的顶点缓冲区存储中以字节表示的偏移量。类似地，如果使用有效的<code>GL_ELEMENT_ARRAY_BUFFER</code>对象，则<code>glDrawElements</code>中的<code>indices</code>参数从指向实际元素索引的指针变成用<code>glBufferData</code>分配的元素索引缓冲区存储中以字节表示的偏移量。</p>\n<p>上述代码描述的存储顶点属性的是结构数组方法，也可以对每个顶点属性使用一个缓冲区对象–数组结构方法：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> DrawPrimitiveWithVBOs() &#123;</span><br><span class=\"line\">    GLuint vboIds[<span class=\"number\">3</span>];</span><br><span class=\"line\">    GLint vertex_position_size = <span class=\"number\">3</span>;</span><br><span class=\"line\">    GLint vertex_color_size = <span class=\"number\">4</span>;</span><br><span class=\"line\">    GLfloat position[] = &#123;</span><br><span class=\"line\">        <span class=\"number\">-0.5</span>f, <span class=\"number\">0.5</span>f, <span class=\"number\">0.0</span>f,</span><br><span class=\"line\">        <span class=\"number\">-1.0</span>f, <span class=\"number\">-0.5</span>f, <span class=\"number\">0.0</span>f,</span><br><span class=\"line\">        <span class=\"number\">0.0</span>f, <span class=\"number\">-0.5</span>f, <span class=\"number\">0.0</span>f</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    GLfloat color[] = &#123;</span><br><span class=\"line\">        <span class=\"number\">1.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f,</span><br><span class=\"line\">        <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f,</span><br><span class=\"line\">        <span class=\"number\">0.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f, <span class=\"number\">1.0</span>f</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    GLushort indices[<span class=\"number\">3</span>] = &#123;<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    glGenBuffers(<span class=\"number\">3</span>, vboIds);</span><br><span class=\"line\">    glBindBuffer(GL_ARRAY_BUFFER, vboIds[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    glBufferData(GL_ARRAY_BUFFER, <span class=\"keyword\">sizeof</span>(GLfloat) * vertex_position_size * <span class=\"number\">3</span>, position, GL_STATIC_DRAW);</span><br><span class=\"line\">    glBindBuffer(GL_ARRAY_BUFFER, vboIds[<span class=\"number\">1</span>]);</span><br><span class=\"line\">    glBufferData(GL_ARRAY_BUFFER, <span class=\"keyword\">sizeof</span>(GLfloat) * vertex_color_size * <span class=\"number\">4</span>, color, GL_STATIC_DRAW);</span><br><span class=\"line\">    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vboIds[<span class=\"number\">2</span>]);</span><br><span class=\"line\">    glBufferData(GL_ELEMENT_ARRAY_BUFFER, <span class=\"keyword\">sizeof</span>(GLushort) * <span class=\"number\">3</span>, indices, GL_STATIC_DRAW);</span><br><span class=\"line\">    </span><br><span class=\"line\">    glBindBuffer(GL_ARRAY_BUFFER, vboIds[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    glEnableVertexAttribArray(<span class=\"number\">0</span>);</span><br><span class=\"line\">    glVertexAttribPointer(<span class=\"number\">0</span>, vertex_position_size, GL_FLOAT, GL_FALSE, <span class=\"keyword\">sizeof</span>(GLfloat) * vertex_position_size, <span class=\"number\">0</span>);</span><br><span class=\"line\">    glBindBuffer(GL_ARRAY_BUFFER, vboIds[<span class=\"number\">1</span>]);</span><br><span class=\"line\">    glEnableVertexAttribArray(<span class=\"number\">1</span>);</span><br><span class=\"line\">    glVertexAttribPointer(<span class=\"number\">1</span>, vertex_color_size, GL_FLOAT, GL_FALSE, <span class=\"keyword\">sizeof</span>(GLfloat) * vertex_color_size, <span class=\"number\">0</span>);</span><br><span class=\"line\">    glDrawElements(GL_TRIANGLES, <span class=\"number\">3</span>, GL_UNSIGNED_SHORT, <span class=\"number\">0</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    glDisableVertexAttribArray(<span class=\"number\">0</span>);</span><br><span class=\"line\">    glDisableVertexAttribArray(<span class=\"number\">1</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    glBindBuffer(GL_ARRAY_BUFFER, <span class=\"number\">0</span>);</span><br><span class=\"line\">    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在应用程序结束缓冲对象的使用之后，删除它们：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 删除缓冲区对象</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param n#&gt; 删除的缓冲区对象数量 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param buffers#&gt; 包含要删除的缓冲区对象的有n个元素的数组 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glDeleteBuffers(GLsizei n, <span class=\"keyword\">const</span> GLuint *buffers);</span><br></pre></td></tr></table></figure>\n<p>一旦缓冲区对象被删除，它就可以作为新的缓冲区对象重用，存储顶点属性或者不同图元的元素索引。</p>\n<p>使用顶点缓冲区对象非常容易，比起顶点数组，所需要的额外工作非常少。考虑到这种功能提供的性能提升，支持顶点缓冲区对象的少量额外工作是值得的。</p>\n<h1>顶点数组对象</h1>\n<p>上面我们已经介绍了顶点属性加载的两种不同方式：使用客户顶点数组和使用顶点缓冲区对象。顶点缓冲区对象优于客户顶点数组，因为它们能够减少GPU和CPU之间复制的数据量，从而获得更好的性能。在OpenGL ES 3.0中引入了一个新特性，使顶点数组的使用更加高效：顶点数组对象（VAO）。正如上面代码所示，使用顶点缓冲区对象设置绘图操作可能需要多次调用<code>glBindBuffer</code>、<code>glVertexAttribPointer</code>和<code>glEnableVertexAttribArray</code>。为了更快地在顶点数组配置直接切换，OpenGL ES 3.0推出了顶点数组对象。VAO提供包含在顶点数组/顶点缓冲区对象配置之间切换所需要的所有状态的单一对象。</p>\n<p>实际上，OpenGL ES 3.0中总是有一个活动的顶点数组对象。目前上述所有例子都在默认的顶点数组对象上操作（默认VAO的ID为0）。要创建新的顶点数组对象，可以使用<code>glGenVertexArrays</code>函数：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 创建顶点数组对象</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param n#&gt; 要返回的顶点数组对象名称的数量 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param arrays#&gt; 指向一个n个元素的数组的指针，该数组是分配的顶点数组对象返回的位置 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glGenVertexArrays(GLsizei n, GLuint *arrays);</span><br></pre></td></tr></table></figure>\n<p>一旦创建，就可以用<code>glBindVertexArray</code>绑定顶点数组对象供以后使用：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 绑定顶点数组对象</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param array#&gt; 被指定为当前顶点数组对象的对象 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glBindVertexArray(GLuint array);</span><br></pre></td></tr></table></figure>\n<p>每个VAO都包含一个完整的状态向量，描述所有顶点缓冲区绑定和启用的顶点客户状态。绑定VAO时，它的状态向量提供顶点缓冲区状态的当前设置。用<code>glBindVertexArray</code>绑定顶点数组对象后，更改顶点数组状态的后续调用（<code>glBindBuffer</code>、<code>glVertexAttribPointer</code>、<code>glEnableVertexAttribArray</code>、<code>glDisableVertexAttribArray</code>）将影响新的VAO。</p>\n<p>这样，应用程序可以通过绑定一个已经设置状态的顶点数组对象快速地在顶点数组配置之间切换。所有变化可以在一个函数调用中完成，没有必要多次调用以更改顶点数组状态。例子：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> DrawPrimitiveWithVAOs() &#123;</span><br><span class=\"line\">    GLuint vboIds[<span class=\"number\">2</span>];</span><br><span class=\"line\">    GLint vertex_position_size = <span class=\"number\">3</span>;</span><br><span class=\"line\">    GLint vertex_color_size = <span class=\"number\">4</span>;</span><br><span class=\"line\">    GLfloat vertices[] = &#123;</span><br><span class=\"line\">        <span class=\"number\">0.0</span>f, <span class=\"number\">0.5</span>f, <span class=\"number\">0.0</span>f,</span><br><span class=\"line\">        <span class=\"number\">1.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f,</span><br><span class=\"line\">        <span class=\"number\">-0.5</span>f, <span class=\"number\">-0.5</span>f, <span class=\"number\">0.0</span>f,</span><br><span class=\"line\">        <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f,</span><br><span class=\"line\">        <span class=\"number\">0.5</span>f, <span class=\"number\">-0.5</span>f, <span class=\"number\">0.0</span>f,</span><br><span class=\"line\">        <span class=\"number\">0.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f, <span class=\"number\">1.0</span>f</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    GLuint vaoId;</span><br><span class=\"line\">    GLushort indices[<span class=\"number\">3</span>] = &#123; <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span> &#125;;</span><br><span class=\"line\">    glGenBuffers(<span class=\"number\">2</span>, vboIds);</span><br><span class=\"line\">    glBindBuffer(GL_ARRAY_BUFFER, vboIds[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    glBufferData(GL_ARRAY_BUFFER, <span class=\"keyword\">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class=\"line\">    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vboIds[<span class=\"number\">1</span>]);</span><br><span class=\"line\">    glBufferData(GL_ELEMENT_ARRAY_BUFFER, <span class=\"keyword\">sizeof</span>(indices), indices, GL_STATIC_DRAW);</span><br><span class=\"line\">    </span><br><span class=\"line\">    glGenVertexArrays(<span class=\"number\">1</span>, &amp;vaoId);</span><br><span class=\"line\">    glBindVertexArray(vaoId);</span><br><span class=\"line\">    </span><br><span class=\"line\">    glBindBuffer(GL_ARRAY_BUFFER, vboIds[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vboIds[<span class=\"number\">1</span>]);</span><br><span class=\"line\">    </span><br><span class=\"line\">    glEnableVertexAttribArray(<span class=\"number\">0</span>);</span><br><span class=\"line\">    glEnableVertexAttribArray(<span class=\"number\">1</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    glVertexAttribPointer(<span class=\"number\">0</span>, vertex_position _size, GL_FLOAT, GL_FALSE, <span class=\"keyword\">sizeof</span>(GLfloat) * (vertex_position_size + vertex_color_size), <span class=\"number\">0</span>);</span><br><span class=\"line\">    glVertexAttribPointer(<span class=\"number\">1</span>, vertex_color_size, GL_FLOAT, GL_FALSE, <span class=\"keyword\">sizeof</span>(GLfloat) * (vertex_position_size + vertex_color_size), (<span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *)(<span class=\"keyword\">sizeof</span>(GLfloat) * vertex_position_size));</span><br><span class=\"line\">        </span><br><span class=\"line\">    glBindVertexArray(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 绘制</span></span><br><span class=\"line\">    glBindVertexArray(vaoId);</span><br><span class=\"line\">    glDrawElements(GL_TRIANGLES, <span class=\"number\">3</span>, GL_UNSIGNED_SHORT, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当应用程序结束一个或者多个顶点数组对象的使用时，可以用<code>glDeleteVertexArrays</code>删除它们：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 删除顶点数组对象</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param n#&gt; 要删除的顶点数组对象的数量 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param arrays#&gt; 包含需要删除的顶点数组对象的有n个元素的数组 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glDeleteVertexArrays(GLsizei n, <span class=\"keyword\">const</span> GLuint *arrays);</span><br></pre></td></tr></table></figure>\n<h1>映射缓冲区对象</h1>\n<p>到目前为止，我们已经使用了<code>glBufferData</code>或<code>glBufferSubData</code>将数据加载到缓冲区对象。应用程序也可以将缓冲区对象数据存储映射到应用程序的地址空间（也可以解除映射）。应用程序映射缓冲区而不使用<code>glBufferData</code>或者<code>glBufferSubData</code>加载数据有几个理由：</p>\n<ul>\n<li>映射缓冲区可以减少应用程序的内存占用，因为可能只需要存储数据的一个副本；</li>\n<li>在使用共享内存的架构上，映射缓冲区返回GPU存储缓冲区的地址空间的直接指针。通过映射缓冲区，应用程序可以避免复制步骤，从而实现更好的更新性能。</li>\n</ul>\n<p><code>glMapBufferRange</code>命令返回指向所有或者一部分（范围）缓冲区对象数据存储的指针。这个指针可以供应应用程序使用，以读取或者更新缓冲区对象的内容。<code>glUnmapBuffer</code>命令用于指示更新已经完成和释放映射的指针：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 返回指向所有或者部分缓冲区对象数据存储的指针</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param target#&gt; GL_ARRAY_BUFFER, GL_ELEMENT_ARRAY_BUFFER, GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, GL_PIXEL_PACK_BUFFER, GL_PIXEL_UNPACK_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, GL_UNIFORM_BUFFER description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param offset#&gt; 缓冲区数据存储中的偏移量，以字节数计算 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param length#&gt; 需要映射的缓冲区数据的字节数 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param access#&gt; 详见下表 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return GLvoid *</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glMapBufferRange(GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access);</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>访问标志</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>GL_MAP_READ_BIT</td>\n<td>应用程序将从返回的指针读取</td>\n</tr>\n<tr>\n<td>GL_MAP_WRITE_BIT</td>\n<td>应用程序将写入返回的指针</td>\n</tr>\n</tbody>\n</table>\n<p>此外，应用程序可以包含如下可选访问标志：</p>\n<table>\n<thead>\n<tr>\n<th>访问标志</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>GL_MAP_INVALIDATAE_RANGE_BIT</td>\n<td>表示指定范围内的缓冲区内容可以在返回指针之前由驱动程序放弃。这个标志不能与GL_MAP_READ_BIT组合使用</td>\n</tr>\n<tr>\n<td>GL_MAP_INVALIDATE_BUFFER_BIT</td>\n<td>表示整个缓冲区的内容可以在返回指针之前由驱动程序放弃。这个标志不能与GL_MAP_READ_BIT组合使用</td>\n</tr>\n<tr>\n<td>GL_MAP_FLUSH_EXPLICIT_BIT</td>\n<td>表示应用程序将明确地用glFlushMappedBufferRange刷新对映射范围子范围的操作。这个标志不能与GL_MAP_WRITE_BIT组合使用</td>\n</tr>\n<tr>\n<td>GL_MAP_UNSYNCHRONIZED_BIT</td>\n<td>表示驱动程序在返回缓冲区范围的指针之前不需要等待缓冲对象上的未决操作。如果有未决的操作，则未决操作的结果和缓冲区对象上的任何未来操作都变为未定义</td>\n</tr>\n</tbody>\n</table>\n<p><code>glMapBufferRange</code>返回请求的缓冲区数据存储范围的指针。如果出现错误或者发出无效的请求，该函数将返回NULL。<code>glUnmapBuffer</code>命令取消之前的缓冲区映射：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 取消缓冲区映射</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param target#&gt; 必须设置为GL_ARRAY_BUFFER description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return GLboolean</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glUnmapBuffer(GLenum target);</span><br></pre></td></tr></table></figure>\n<p>如果取消映射操作成功，则<code>glUnmapBuffer</code>返回<code>GL_TRUE</code>。<code>glMapBufferRange</code>返回的指针在成功执行取消映射之后不再可以使用。如果顶点缓冲区对象数据存储中的数据在缓冲区映射之后已经破坏，<code>glUnmapBuffer</code>将返回<code>GL_FALSE</code>，这可能是因为屏幕分辨率的变化、OpenGL ES上下文使用多个屏幕或者导致映射内存被抛弃的内存不足事件所导致。</p>\n<p>写入映射缓冲区对象例子：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GLfloat *vtxMappedBuf;</span><br><span class=\"line\">GLushort *idxMappedBuf;</span><br><span class=\"line\">GLfloat vertices[] = &#123;</span><br><span class=\"line\">    <span class=\"number\">0.0</span>f, <span class=\"number\">0.5</span>f, <span class=\"number\">0.0</span>f,</span><br><span class=\"line\">    <span class=\"number\">1.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f,</span><br><span class=\"line\">    <span class=\"number\">-0.5</span>f, <span class=\"number\">-0.5</span>f, <span class=\"number\">0.0</span>f,</span><br><span class=\"line\">    <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f,</span><br><span class=\"line\">    <span class=\"number\">0.5</span>f, <span class=\"number\">-0.5</span>f, <span class=\"number\">0.0</span>f,</span><br><span class=\"line\">    <span class=\"number\">0.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f, <span class=\"number\">1.0</span>f</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">GLushort indices[<span class=\"number\">3</span>] = &#123; <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">glGenBuffers(<span class=\"number\">2</span>, vboIds);</span><br><span class=\"line\">glBindBuffer(GL_ARRAY_BUFFER, vboIds[<span class=\"number\">0</span>]);</span><br><span class=\"line\">glBufferData(GL_ARRAY_BUFFER, <span class=\"keyword\">sizeof</span>(vertices), <span class=\"literal\">NULL</span>, GL_STATIC_DRAW);</span><br><span class=\"line\">vtxMappedBuf = (GLfloat *)glMapBufferRange(GL_ARRAY_BUFFER, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(vertices), GL_MAP_WRITE_BIT | GL_MAP_INVALIDATE_BUFFER_BIT);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (vtxMappedBuf == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Error mapping vertex buffer object\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">memcpy(vtxMappedBuf, vertices, <span class=\"keyword\">sizeof</span>(vertices));</span><br><span class=\"line\"><span class=\"keyword\">if</span> (glUnmapBuffer(GL_ARRAY_BUFFER) == GL_FALSE) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Error unmapping array buffer object\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vboIds[<span class=\"number\">1</span>]);</span><br><span class=\"line\">glBufferData(GL_ELEMENT_ARRAY_BUFFER, <span class=\"keyword\">sizeof</span>(indices), <span class=\"literal\">NULL</span>, GL_STATIC_DRAW);</span><br><span class=\"line\">idxMappedBuf = (GLushort *)glMapBufferRange(GL_ELEMENT_ARRAY_BUFFER, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(indices), GL_MAP_WRITE_BIT | GL_MAP_INVALIDATE_BUFFER_BIT);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (idxMappedBuf == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Error mapping element buffer object\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">memcpy(idxMappedBuf, indices, <span class=\"keyword\">sizeof</span>(indices));</span><br><span class=\"line\"><span class=\"keyword\">if</span> (glUnmapBuffer(GL_ELEMENT_ARRAY_BUFFER) == GL_FALSE) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Error unmapping element buffer object\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2>刷新映射的缓冲区</h2>\n<p>应用程序可能希望用<code>glMapBufferRange</code>来映射缓冲区对象的一个范围或者全部，但是只更新映射范围的不同子区域。为了避免调用<code>glUnmapBuffer</code>时刷新整个映射范围的潜在性能损失，应用程序可以用<code>GL_MAP_FLUSH_EXPLICIT_BIT</code>访问标志（和<code>GL_MAP_WRITE_BIT</code>组合）映射。当应用程序完成映射范围一部分的更新时，可以用<code>glFlushMappedBufferRange</code>指出这个事实：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 指出应用程序完成映射范围的部分更新</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param target#&gt; GL_ARRAY_BUFFER, GL_ELEMENT_ARRAY_BUFFER, GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, GL_PIXEL_PACK_BUFFER, GL_PIXEL_UNPACK_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, GL_UNIFORM_BUFFER description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param offset#&gt; 从映射缓冲区起始点的偏移量，以字节数表示 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param length#&gt; 从便宜点开始刷新的缓冲区字节数 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glFlushMappedBufferRange(GLenum target, GLintptr offset, GLsizeiptr length);</span><br></pre></td></tr></table></figure>\n<p>如果应用程序用<code>GL_MAP_FLUSH_EXPLICIT_BIT</code>映射，但是没有明确用<code>glFlushMappedBufferRange</code>刷新修改后的区域，它的内容将是未定义的。</p>\n<h1>复制缓冲区对象</h1>\n<p>上面我们已经说明如何用<code>glBufferData</code>、<code>glBufferSubData</code>和<code>glMapBufferRange</code>加载缓冲区对象。所有这些技术都涉及从应用程序到设备的数据传输。OpenGL ES 3.0还可以从一个缓冲区对象将数据完全复制到设备：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 从一个缓冲区对象将数据完全复制到设备</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param readTarget#&gt; 读取的缓冲区对象目标 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param writeTarget#&gt; 写入的缓冲区对象目标 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param readOffset#&gt; 需要复制的读缓冲数据中的偏移量，以字节表示 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param writeOffset#&gt; 需要复制的写缓冲数据中的偏移量，以字节表示 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param size#&gt; 从读缓冲区数据复制到写缓冲区数据的字节数 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glCopyBufferSubData(GLenum readTarget, GLenum writeTarget, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size);</span><br></pre></td></tr></table></figure>\n<p>调用<code>glCopyBufferSubData</code>将从绑定到<code>readtarget</code>的缓冲区复制指定的字节到<code>writetarget</code>。缓冲区绑定根据每个目标的最后一次<code>glBindBuffer</code>确定调用。任何类型的缓冲区对象（数组、元素数组、变换反馈等）都可以绑定到<code>GL_COPY_READ_BUFFER</code>或<code>GL_COPY_WRITE_BUFFER</code>目标。这两个目标是一种方便的措施，使得应用程序在执行缓冲区间的复制时不必改变任何真正的缓冲区绑定。</p>\n<h1>总结</h1>\n<p>这篇文章主要介绍了指定顶点属性和数据的方法。</p>\n"},{"title":"OpenGL ES学习--顶点着色器","catalog":true,"toc_nav_num":true,"date":"2019-08-03T07:45:11.000Z","subtitle":"About OpenGL ES","header-img":"/img/article_header/article_header.png","busuanzi":true,"_content":"\n> 本章首先概述顶点着色器，包括其输入和输出。然后，讨论几个例子，说明如何编写顶点着色器。\n\n# 顶点着色器概述\n\n顶点着色器提供顶点操作的通用可编程方法。下图展示了顶点着色器的输入和输出，顶点着色器的输入包括：\n- 属性--用于顶点数组提供的逐顶点数据；\n- 统一变量和统一变量缓冲区--顶点着色器使用的不变数据；\n- 采样器--代表顶点着色器使用的纹理的特殊统一变量类型；\n- 着色器程序--顶点着色器程序源代码或者描述在操作顶点的可执行文件。\n\n顶点着色器的输出称作顶点着色器输出变量。在图元光栅化阶段，为每个生成的片段计算这些变量，并作为片段着色器的输入传入。\n\n![OpenGL ES 3.0顶点着色器](/img/article/20190803/1.png)\n\n## 顶点着色器内建变量\n\n顶点着色器的内建变量可以分为特殊变量（顶点着色器的输入输出）、统一状态（如深度范围）以及规定最大值（如属性数量、顶点着色器输出变量数量和统一变量数量）的常量。\n\n### 内建特殊变量\n\nOpenGL ES 3.0有内建的特殊变量，它们可以作为顶点着色器的输入或者在之后成为片段着色器输入的顶点着色器输出，或者片段着色器的输出。顶点着色器可用的内建特殊变量如下：\n- `gl_VertexID`是一个输入变量，用于保存顶点的整数索引。这个整数型变量用`highp`精度限定符声明；\n- `gl_InstanceID`是一个输入变量，用于保存实例化绘图调用中图元的实例编号。对于常规的绘图调用，该值为0。`gl_InstanceID`是一个整数型变量，用`highp`精度限定符声明；\n- `gl_Position`用于输出顶点位置的裁剪坐标。该值在裁剪和视口阶段用于执行相应的图元裁剪以及从裁剪坐标到屏幕坐标的顶点位置转换。如果顶点着色器未写入`gl_Position`，则`gl_Position`的值未定义。`gl_Position`是一个浮点变量，用`highp`精度限定符表明；\n- `gl_PointSize`用于写入以像素表示的点精灵尺寸，在渲染点精灵时使用。顶点着色器输出的`gl_PointSize`值被限定在OpenGL ES 3.0实现支持的非平滑点大小范围之内。`gl_PointSize`是一个浮点变量，用`highp`精度限定符声明；\n- `gl_FrontFacing`是一个特殊变量，但不是由顶点着色器直接写入的，而是根据顶点着色器生成的位置值和渲染的图元类型生成的。它是一个布尔变量。\n\n### 内建统一状态\n\n顶点着色器内可用的唯一内建统一状态是窗口坐标中的深度范围。这由内建统一变量名`gl_DepthRange`给出，该变量声明为`gl_DepthRangeParameters`类型的统一变量。\n\n``` objc\nstruct gl_DepthRangeParameters {\n    highp float near; // near Z\n    highp float far;  // far Z\n    highp float diff; // far - near\n}\n\nuniform gl_DepthRangeParameters gl_DepthRange;\n```\n\n### 内建常量\n\n顶点着色器内还有如下内建常量：\n\n``` objc\nconst mediump int gl_MaxVertexAttribs = 16;\nconst mediump int gl_MaxVertexUniformVectors = 256;\nconst mediump int gl_MaxVertexOutputVectors = 16;\nconst mediump int gl_MaxVertexTextureImageUnits = 16;\nconst mediump int gl_MaxCombinedTextureImageUnits = 32;\n```\n\n内建常量描述如下最大项：\n- `gl_MaxVertexAttribs`是可以指定的顶点属性的最大数量，所有ES 3.0实现都支持的最小值为16；\n- `gl_MaxVertexUniformVectors`是顶点着色器中可以使用的`vec4`统一变量项目的最大数量。所有ES 3.0实现都支持的最小值为256。开发人员可以使用的`vec4`统一变量项目数量在不同实现和不同顶点着色器中可能不同。例如，有些实现可能将顶点着色器中使用的用户指定字面值计入统一变量限制内。在其他情况下，根据顶点着色器是否使用内建的超越函数，可能需要包含特定于实现的统一变量（或者常量）。目前没有应用程序可以用于找出在特定顶点着色器中可使用的统一变量项目数量的机制。顶点着色器编译失败时，编译日志可能提供关于使用的统一变量项目数量的相关信息。但是，编译日志返回的信息是特定于实现的；\n- `gl_MaxVertexOutputVectors`是输出向量的最大数量--也就是顶点着色器可以输出的`vec4`项目数量。所有ES 3.0实现都支持的最小值是16个`vec4`项目；\n- `gl_MaxVertexTextureImageUnits`是顶点着色器中可用的纹理单元的最大数量，最小值为16；\n- `gl_MaxCombinedTextureImageUnits`是顶点和片段着色器中可用纹理单元最大数量的总和，最小值为32.\n\n每个内建常量指定的值是所有OpenGL ES 3.0实现必须支持的最小值，各种实现可能支持超过上面所述的最小值的常量值。实际支持的值可以用`glGetIntegerv`函数查询，查询参数为`GL_MAX_VERTEX_ATTRIBS`，`GL_MAX_VERTEX_UNIFORM_VECTORS`，`GL_MAX_VARYING_VECTORS`，`GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS`，`GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS`。\n\n## 顶点着色器中的统一变量限制数量\n\n`gl_MaxVertexUniformVectors`描述了可以用于顶点着色器的统一变量的最大数量。任何兼容的OpenGL ES 3.0实现必须支持的`gl_MaxVertexUnifromVectors`最小值为256个`vec4`项目。统一变量存储用于存储如下变量：\n- 用统一变量限定符声明的变量\n- 常数变量\n- 字面值\n- 特定于实现的常量\n\n顶点着色器中使用的统一变量和用`const`限定符声明的变量、字面值和特定于实现的常量必须按照之前描述的打包规则与`gl_MaxVertexUniformVectors`相匹配。如果不匹配，顶点着色器就无法编译。开发人员可以应用打包规则，确定存储统一变量、常数变量和字面值所需的统一变量存储总数。然而，确定特定于实现的常量数量是不可能的，因为这个值不仅在不同实现中不同，而且取决于顶点着色器使用的内建着色器语言函数。通常，特定于实现的常量在使用内建超越函数时是必需的。\n\n至于字面值，OpenGL ES 3.0着色语言规范不做任何常量传播。结果是，同一个字面值的多个实例将被多次计算。可以理解的是，在顶点着色器中使用字面值（如0.0或者1.0）更容易，但是我们建议尽可能避免采用这种技术，应该声明相应的常数变量代替字面值。这种方法避免将同一个字面值计算多次，在那种情况下，如果顶点统一变量存储需求超过了实现所能支持的存储量，可能导致顶点着色器无法编译。\n\n# 顶点着色器实例\n\n在iOS中，需要用`GLKViewController`创建动画渲染循环，以指定的帧速率重新绘制视图的内容。\n\n## 矩阵变换\n\n设计一个顶点着色器获取一个位置和其相关的颜色数据作为输入或者属性，用一个4x4矩阵变换位置，并输出变换后的位置和颜色。\n\n``` objc\n// glsl.vsh\n#version 300 es\n\nuniform mat4 u_mvpMatrix;\n\nlayout(location = 0) in vec4 a_position;\nlayout(location = 1) in vec4 a_color;\n\nout vec4 v_color;\n\nvoid main() {\n    v_color = a_color;\n    gl_Position = u_mvpMatrix * a_position;\n}\n```\n\n变换矩阵：\n\n``` objc\nself.elapsedTime += self.timeSinceLastUpdate;\nfloat varyingFactor = sin(self.elapsedTime);\n// 缩放矩阵\nGLKMatrix4 scaleMatrix = GLKMatrix4MakeScale(varyingFactor, varyingFactor, 1.0);\n// 旋转矩阵\nGLKMatrix4 rotateMatrix = GLKMatrix4MakeRotation(varyingFactor, 0, 0, 1.0);\n// 平移矩阵\nGLKMatrix4 translateMatrix = GLKMatrix4MakeTranslation(varyingFactor, 0, 0);\n// 矩阵相乘\nself.transformMatrix = GLKMatrix4Multiply(translateMatrix, rotateMatrix);\nself.transformMatrix = GLKMatrix4Multiply(self.transformMatrix, scaleMatrix);\n```\n\n# 待续。。。","source":"_posts/2019/opengl-es-vertex-shader-0803.md","raw":"---\ntitle: \"OpenGL ES学习--顶点着色器\"\ncatalog: true\ntoc_nav_num: true\ndate: 2019-08-03 15:45:11\nsubtitle: \"About OpenGL ES\"\nheader-img: \"/img/article_header/article_header.png\"\nbusuanzi: true\ntags:\n- iOS\n\n---\n\n> 本章首先概述顶点着色器，包括其输入和输出。然后，讨论几个例子，说明如何编写顶点着色器。\n\n# 顶点着色器概述\n\n顶点着色器提供顶点操作的通用可编程方法。下图展示了顶点着色器的输入和输出，顶点着色器的输入包括：\n- 属性--用于顶点数组提供的逐顶点数据；\n- 统一变量和统一变量缓冲区--顶点着色器使用的不变数据；\n- 采样器--代表顶点着色器使用的纹理的特殊统一变量类型；\n- 着色器程序--顶点着色器程序源代码或者描述在操作顶点的可执行文件。\n\n顶点着色器的输出称作顶点着色器输出变量。在图元光栅化阶段，为每个生成的片段计算这些变量，并作为片段着色器的输入传入。\n\n![OpenGL ES 3.0顶点着色器](/img/article/20190803/1.png)\n\n## 顶点着色器内建变量\n\n顶点着色器的内建变量可以分为特殊变量（顶点着色器的输入输出）、统一状态（如深度范围）以及规定最大值（如属性数量、顶点着色器输出变量数量和统一变量数量）的常量。\n\n### 内建特殊变量\n\nOpenGL ES 3.0有内建的特殊变量，它们可以作为顶点着色器的输入或者在之后成为片段着色器输入的顶点着色器输出，或者片段着色器的输出。顶点着色器可用的内建特殊变量如下：\n- `gl_VertexID`是一个输入变量，用于保存顶点的整数索引。这个整数型变量用`highp`精度限定符声明；\n- `gl_InstanceID`是一个输入变量，用于保存实例化绘图调用中图元的实例编号。对于常规的绘图调用，该值为0。`gl_InstanceID`是一个整数型变量，用`highp`精度限定符声明；\n- `gl_Position`用于输出顶点位置的裁剪坐标。该值在裁剪和视口阶段用于执行相应的图元裁剪以及从裁剪坐标到屏幕坐标的顶点位置转换。如果顶点着色器未写入`gl_Position`，则`gl_Position`的值未定义。`gl_Position`是一个浮点变量，用`highp`精度限定符表明；\n- `gl_PointSize`用于写入以像素表示的点精灵尺寸，在渲染点精灵时使用。顶点着色器输出的`gl_PointSize`值被限定在OpenGL ES 3.0实现支持的非平滑点大小范围之内。`gl_PointSize`是一个浮点变量，用`highp`精度限定符声明；\n- `gl_FrontFacing`是一个特殊变量，但不是由顶点着色器直接写入的，而是根据顶点着色器生成的位置值和渲染的图元类型生成的。它是一个布尔变量。\n\n### 内建统一状态\n\n顶点着色器内可用的唯一内建统一状态是窗口坐标中的深度范围。这由内建统一变量名`gl_DepthRange`给出，该变量声明为`gl_DepthRangeParameters`类型的统一变量。\n\n``` objc\nstruct gl_DepthRangeParameters {\n    highp float near; // near Z\n    highp float far;  // far Z\n    highp float diff; // far - near\n}\n\nuniform gl_DepthRangeParameters gl_DepthRange;\n```\n\n### 内建常量\n\n顶点着色器内还有如下内建常量：\n\n``` objc\nconst mediump int gl_MaxVertexAttribs = 16;\nconst mediump int gl_MaxVertexUniformVectors = 256;\nconst mediump int gl_MaxVertexOutputVectors = 16;\nconst mediump int gl_MaxVertexTextureImageUnits = 16;\nconst mediump int gl_MaxCombinedTextureImageUnits = 32;\n```\n\n内建常量描述如下最大项：\n- `gl_MaxVertexAttribs`是可以指定的顶点属性的最大数量，所有ES 3.0实现都支持的最小值为16；\n- `gl_MaxVertexUniformVectors`是顶点着色器中可以使用的`vec4`统一变量项目的最大数量。所有ES 3.0实现都支持的最小值为256。开发人员可以使用的`vec4`统一变量项目数量在不同实现和不同顶点着色器中可能不同。例如，有些实现可能将顶点着色器中使用的用户指定字面值计入统一变量限制内。在其他情况下，根据顶点着色器是否使用内建的超越函数，可能需要包含特定于实现的统一变量（或者常量）。目前没有应用程序可以用于找出在特定顶点着色器中可使用的统一变量项目数量的机制。顶点着色器编译失败时，编译日志可能提供关于使用的统一变量项目数量的相关信息。但是，编译日志返回的信息是特定于实现的；\n- `gl_MaxVertexOutputVectors`是输出向量的最大数量--也就是顶点着色器可以输出的`vec4`项目数量。所有ES 3.0实现都支持的最小值是16个`vec4`项目；\n- `gl_MaxVertexTextureImageUnits`是顶点着色器中可用的纹理单元的最大数量，最小值为16；\n- `gl_MaxCombinedTextureImageUnits`是顶点和片段着色器中可用纹理单元最大数量的总和，最小值为32.\n\n每个内建常量指定的值是所有OpenGL ES 3.0实现必须支持的最小值，各种实现可能支持超过上面所述的最小值的常量值。实际支持的值可以用`glGetIntegerv`函数查询，查询参数为`GL_MAX_VERTEX_ATTRIBS`，`GL_MAX_VERTEX_UNIFORM_VECTORS`，`GL_MAX_VARYING_VECTORS`，`GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS`，`GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS`。\n\n## 顶点着色器中的统一变量限制数量\n\n`gl_MaxVertexUniformVectors`描述了可以用于顶点着色器的统一变量的最大数量。任何兼容的OpenGL ES 3.0实现必须支持的`gl_MaxVertexUnifromVectors`最小值为256个`vec4`项目。统一变量存储用于存储如下变量：\n- 用统一变量限定符声明的变量\n- 常数变量\n- 字面值\n- 特定于实现的常量\n\n顶点着色器中使用的统一变量和用`const`限定符声明的变量、字面值和特定于实现的常量必须按照之前描述的打包规则与`gl_MaxVertexUniformVectors`相匹配。如果不匹配，顶点着色器就无法编译。开发人员可以应用打包规则，确定存储统一变量、常数变量和字面值所需的统一变量存储总数。然而，确定特定于实现的常量数量是不可能的，因为这个值不仅在不同实现中不同，而且取决于顶点着色器使用的内建着色器语言函数。通常，特定于实现的常量在使用内建超越函数时是必需的。\n\n至于字面值，OpenGL ES 3.0着色语言规范不做任何常量传播。结果是，同一个字面值的多个实例将被多次计算。可以理解的是，在顶点着色器中使用字面值（如0.0或者1.0）更容易，但是我们建议尽可能避免采用这种技术，应该声明相应的常数变量代替字面值。这种方法避免将同一个字面值计算多次，在那种情况下，如果顶点统一变量存储需求超过了实现所能支持的存储量，可能导致顶点着色器无法编译。\n\n# 顶点着色器实例\n\n在iOS中，需要用`GLKViewController`创建动画渲染循环，以指定的帧速率重新绘制视图的内容。\n\n## 矩阵变换\n\n设计一个顶点着色器获取一个位置和其相关的颜色数据作为输入或者属性，用一个4x4矩阵变换位置，并输出变换后的位置和颜色。\n\n``` objc\n// glsl.vsh\n#version 300 es\n\nuniform mat4 u_mvpMatrix;\n\nlayout(location = 0) in vec4 a_position;\nlayout(location = 1) in vec4 a_color;\n\nout vec4 v_color;\n\nvoid main() {\n    v_color = a_color;\n    gl_Position = u_mvpMatrix * a_position;\n}\n```\n\n变换矩阵：\n\n``` objc\nself.elapsedTime += self.timeSinceLastUpdate;\nfloat varyingFactor = sin(self.elapsedTime);\n// 缩放矩阵\nGLKMatrix4 scaleMatrix = GLKMatrix4MakeScale(varyingFactor, varyingFactor, 1.0);\n// 旋转矩阵\nGLKMatrix4 rotateMatrix = GLKMatrix4MakeRotation(varyingFactor, 0, 0, 1.0);\n// 平移矩阵\nGLKMatrix4 translateMatrix = GLKMatrix4MakeTranslation(varyingFactor, 0, 0);\n// 矩阵相乘\nself.transformMatrix = GLKMatrix4Multiply(translateMatrix, rotateMatrix);\nself.transformMatrix = GLKMatrix4Multiply(self.transformMatrix, scaleMatrix);\n```\n\n# 待续。。。","slug":"2019/opengl-es-vertex-shader-0803","published":1,"updated":"2022-01-10T09:04:52.809Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cky8gmc4g001bd1qh49nugp2s","content":"<blockquote>\n<p>本章首先概述顶点着色器，包括其输入和输出。然后，讨论几个例子，说明如何编写顶点着色器。</p>\n</blockquote>\n<h1 id=\"顶点着色器概述\">顶点着色器概述</h1>\n<p>顶点着色器提供顶点操作的通用可编程方法。下图展示了顶点着色器的输入和输出，顶点着色器的输入包括：</p>\n<ul>\n<li>属性–用于顶点数组提供的逐顶点数据；</li>\n<li>统一变量和统一变量缓冲区–顶点着色器使用的不变数据；</li>\n<li>采样器–代表顶点着色器使用的纹理的特殊统一变量类型；</li>\n<li>着色器程序–顶点着色器程序源代码或者描述在操作顶点的可执行文件。</li>\n</ul>\n<p>顶点着色器的输出称作顶点着色器输出变量。在图元光栅化阶段，为每个生成的片段计算这些变量，并作为片段着色器的输入传入。</p>\n<p><img src=\"/img/article/20190803/1.png\" alt=\"OpenGL ES 3.0顶点着色器\"></p>\n<h2 id=\"顶点着色器内建变量\">顶点着色器内建变量</h2>\n<p>顶点着色器的内建变量可以分为特殊变量（顶点着色器的输入输出）、统一状态（如深度范围）以及规定最大值（如属性数量、顶点着色器输出变量数量和统一变量数量）的常量。</p>\n<h3 id=\"内建特殊变量\">内建特殊变量</h3>\n<p>OpenGL ES 3.0有内建的特殊变量，它们可以作为顶点着色器的输入或者在之后成为片段着色器输入的顶点着色器输出，或者片段着色器的输出。顶点着色器可用的内建特殊变量如下：</p>\n<ul>\n<li><code>gl_VertexID</code>是一个输入变量，用于保存顶点的整数索引。这个整数型变量用<code>highp</code>精度限定符声明；</li>\n<li><code>gl_InstanceID</code>是一个输入变量，用于保存实例化绘图调用中图元的实例编号。对于常规的绘图调用，该值为0。<code>gl_InstanceID</code>是一个整数型变量，用<code>highp</code>精度限定符声明；</li>\n<li><code>gl_Position</code>用于输出顶点位置的裁剪坐标。该值在裁剪和视口阶段用于执行相应的图元裁剪以及从裁剪坐标到屏幕坐标的顶点位置转换。如果顶点着色器未写入<code>gl_Position</code>，则<code>gl_Position</code>的值未定义。<code>gl_Position</code>是一个浮点变量，用<code>highp</code>精度限定符表明；</li>\n<li><code>gl_PointSize</code>用于写入以像素表示的点精灵尺寸，在渲染点精灵时使用。顶点着色器输出的<code>gl_PointSize</code>值被限定在OpenGL ES 3.0实现支持的非平滑点大小范围之内。<code>gl_PointSize</code>是一个浮点变量，用<code>highp</code>精度限定符声明；</li>\n<li><code>gl_FrontFacing</code>是一个特殊变量，但不是由顶点着色器直接写入的，而是根据顶点着色器生成的位置值和渲染的图元类型生成的。它是一个布尔变量。</li>\n</ul>\n<h3 id=\"内建统一状态\">内建统一状态</h3>\n<p>顶点着色器内可用的唯一内建统一状态是窗口坐标中的深度范围。这由内建统一变量名<code>gl_DepthRange</code>给出，该变量声明为<code>gl_DepthRangeParameters</code>类型的统一变量。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> gl_DepthRangeParameters &#123;</span><br><span class=\"line\">    highp <span class=\"keyword\">float</span> near; <span class=\"comment\">// near Z</span></span><br><span class=\"line\">    highp <span class=\"keyword\">float</span> far;  <span class=\"comment\">// far Z</span></span><br><span class=\"line\">    highp <span class=\"keyword\">float</span> diff; <span class=\"comment\">// far - near</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">uniform gl_DepthRangeParameters gl_DepthRange;</span><br></pre></td></tr></table></figure>\n<h3 id=\"内建常量\">内建常量</h3>\n<p>顶点着色器内还有如下内建常量：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> mediump <span class=\"keyword\">int</span> gl_MaxVertexAttribs = <span class=\"number\">16</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> mediump <span class=\"keyword\">int</span> gl_MaxVertexUniformVectors = <span class=\"number\">256</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> mediump <span class=\"keyword\">int</span> gl_MaxVertexOutputVectors = <span class=\"number\">16</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> mediump <span class=\"keyword\">int</span> gl_MaxVertexTextureImageUnits = <span class=\"number\">16</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> mediump <span class=\"keyword\">int</span> gl_MaxCombinedTextureImageUnits = <span class=\"number\">32</span>;</span><br></pre></td></tr></table></figure>\n<p>内建常量描述如下最大项：</p>\n<ul>\n<li><code>gl_MaxVertexAttribs</code>是可以指定的顶点属性的最大数量，所有ES 3.0实现都支持的最小值为16；</li>\n<li><code>gl_MaxVertexUniformVectors</code>是顶点着色器中可以使用的<code>vec4</code>统一变量项目的最大数量。所有ES 3.0实现都支持的最小值为256。开发人员可以使用的<code>vec4</code>统一变量项目数量在不同实现和不同顶点着色器中可能不同。例如，有些实现可能将顶点着色器中使用的用户指定字面值计入统一变量限制内。在其他情况下，根据顶点着色器是否使用内建的超越函数，可能需要包含特定于实现的统一变量（或者常量）。目前没有应用程序可以用于找出在特定顶点着色器中可使用的统一变量项目数量的机制。顶点着色器编译失败时，编译日志可能提供关于使用的统一变量项目数量的相关信息。但是，编译日志返回的信息是特定于实现的；</li>\n<li><code>gl_MaxVertexOutputVectors</code>是输出向量的最大数量–也就是顶点着色器可以输出的<code>vec4</code>项目数量。所有ES 3.0实现都支持的最小值是16个<code>vec4</code>项目；</li>\n<li><code>gl_MaxVertexTextureImageUnits</code>是顶点着色器中可用的纹理单元的最大数量，最小值为16；</li>\n<li><code>gl_MaxCombinedTextureImageUnits</code>是顶点和片段着色器中可用纹理单元最大数量的总和，最小值为32.</li>\n</ul>\n<p>每个内建常量指定的值是所有OpenGL ES 3.0实现必须支持的最小值，各种实现可能支持超过上面所述的最小值的常量值。实际支持的值可以用<code>glGetIntegerv</code>函数查询，查询参数为<code>GL_MAX_VERTEX_ATTRIBS</code>，<code>GL_MAX_VERTEX_UNIFORM_VECTORS</code>，<code>GL_MAX_VARYING_VECTORS</code>，<code>GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS</code>，<code>GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS</code>。</p>\n<h2 id=\"顶点着色器中的统一变量限制数量\">顶点着色器中的统一变量限制数量</h2>\n<p><code>gl_MaxVertexUniformVectors</code>描述了可以用于顶点着色器的统一变量的最大数量。任何兼容的OpenGL ES 3.0实现必须支持的<code>gl_MaxVertexUnifromVectors</code>最小值为256个<code>vec4</code>项目。统一变量存储用于存储如下变量：</p>\n<ul>\n<li>用统一变量限定符声明的变量</li>\n<li>常数变量</li>\n<li>字面值</li>\n<li>特定于实现的常量</li>\n</ul>\n<p>顶点着色器中使用的统一变量和用<code>const</code>限定符声明的变量、字面值和特定于实现的常量必须按照之前描述的打包规则与<code>gl_MaxVertexUniformVectors</code>相匹配。如果不匹配，顶点着色器就无法编译。开发人员可以应用打包规则，确定存储统一变量、常数变量和字面值所需的统一变量存储总数。然而，确定特定于实现的常量数量是不可能的，因为这个值不仅在不同实现中不同，而且取决于顶点着色器使用的内建着色器语言函数。通常，特定于实现的常量在使用内建超越函数时是必需的。</p>\n<p>至于字面值，OpenGL ES 3.0着色语言规范不做任何常量传播。结果是，同一个字面值的多个实例将被多次计算。可以理解的是，在顶点着色器中使用字面值（如0.0或者1.0）更容易，但是我们建议尽可能避免采用这种技术，应该声明相应的常数变量代替字面值。这种方法避免将同一个字面值计算多次，在那种情况下，如果顶点统一变量存储需求超过了实现所能支持的存储量，可能导致顶点着色器无法编译。</p>\n<h1 id=\"顶点着色器实例\">顶点着色器实例</h1>\n<p>在iOS中，需要用<code>GLKViewController</code>创建动画渲染循环，以指定的帧速率重新绘制视图的内容。</p>\n<h2 id=\"矩阵变换\">矩阵变换</h2>\n<p>设计一个顶点着色器获取一个位置和其相关的颜色数据作为输入或者属性，用一个4x4矩阵变换位置，并输出变换后的位置和颜色。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// glsl.vsh</span></span><br><span class=\"line\"><span class=\"meta\">#version 300 es</span></span><br><span class=\"line\"></span><br><span class=\"line\">uniform mat4 u_mvpMatrix;</span><br><span class=\"line\"></span><br><span class=\"line\">layout(location = <span class=\"number\">0</span>) <span class=\"keyword\">in</span> vec4 a_position;</span><br><span class=\"line\">layout(location = <span class=\"number\">1</span>) <span class=\"keyword\">in</span> vec4 a_color;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">out</span> vec4 v_color;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> main() &#123;</span><br><span class=\"line\">    v_color = a_color;</span><br><span class=\"line\">    gl_Position = u_mvpMatrix * a_position;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>变换矩阵：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">self</span>.elapsedTime += <span class=\"keyword\">self</span>.timeSinceLastUpdate;</span><br><span class=\"line\"><span class=\"keyword\">float</span> varyingFactor = sin(<span class=\"keyword\">self</span>.elapsedTime);</span><br><span class=\"line\"><span class=\"comment\">// 缩放矩阵</span></span><br><span class=\"line\">GLKMatrix4 scaleMatrix = GLKMatrix4MakeScale(varyingFactor, varyingFactor, <span class=\"number\">1.0</span>);</span><br><span class=\"line\"><span class=\"comment\">// 旋转矩阵</span></span><br><span class=\"line\">GLKMatrix4 rotateMatrix = GLKMatrix4MakeRotation(varyingFactor, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1.0</span>);</span><br><span class=\"line\"><span class=\"comment\">// 平移矩阵</span></span><br><span class=\"line\">GLKMatrix4 translateMatrix = GLKMatrix4MakeTranslation(varyingFactor, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"comment\">// 矩阵相乘</span></span><br><span class=\"line\"><span class=\"keyword\">self</span>.transformMatrix = GLKMatrix4Multiply(translateMatrix, rotateMatrix);</span><br><span class=\"line\"><span class=\"keyword\">self</span>.transformMatrix = GLKMatrix4Multiply(<span class=\"keyword\">self</span>.transformMatrix, scaleMatrix);</span><br></pre></td></tr></table></figure>\n<h1 id=\"待续\">待续。。。</h1>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>本章首先概述顶点着色器，包括其输入和输出。然后，讨论几个例子，说明如何编写顶点着色器。</p>\n</blockquote>\n<h1>顶点着色器概述</h1>\n<p>顶点着色器提供顶点操作的通用可编程方法。下图展示了顶点着色器的输入和输出，顶点着色器的输入包括：</p>\n<ul>\n<li>属性–用于顶点数组提供的逐顶点数据；</li>\n<li>统一变量和统一变量缓冲区–顶点着色器使用的不变数据；</li>\n<li>采样器–代表顶点着色器使用的纹理的特殊统一变量类型；</li>\n<li>着色器程序–顶点着色器程序源代码或者描述在操作顶点的可执行文件。</li>\n</ul>\n<p>顶点着色器的输出称作顶点着色器输出变量。在图元光栅化阶段，为每个生成的片段计算这些变量，并作为片段着色器的输入传入。</p>\n<p><img src=\"/img/article/20190803/1.png\" alt=\"OpenGL ES 3.0顶点着色器\"></p>\n<h2>顶点着色器内建变量</h2>\n<p>顶点着色器的内建变量可以分为特殊变量（顶点着色器的输入输出）、统一状态（如深度范围）以及规定最大值（如属性数量、顶点着色器输出变量数量和统一变量数量）的常量。</p>\n<h3>内建特殊变量</h3>\n<p>OpenGL ES 3.0有内建的特殊变量，它们可以作为顶点着色器的输入或者在之后成为片段着色器输入的顶点着色器输出，或者片段着色器的输出。顶点着色器可用的内建特殊变量如下：</p>\n<ul>\n<li><code>gl_VertexID</code>是一个输入变量，用于保存顶点的整数索引。这个整数型变量用<code>highp</code>精度限定符声明；</li>\n<li><code>gl_InstanceID</code>是一个输入变量，用于保存实例化绘图调用中图元的实例编号。对于常规的绘图调用，该值为0。<code>gl_InstanceID</code>是一个整数型变量，用<code>highp</code>精度限定符声明；</li>\n<li><code>gl_Position</code>用于输出顶点位置的裁剪坐标。该值在裁剪和视口阶段用于执行相应的图元裁剪以及从裁剪坐标到屏幕坐标的顶点位置转换。如果顶点着色器未写入<code>gl_Position</code>，则<code>gl_Position</code>的值未定义。<code>gl_Position</code>是一个浮点变量，用<code>highp</code>精度限定符表明；</li>\n<li><code>gl_PointSize</code>用于写入以像素表示的点精灵尺寸，在渲染点精灵时使用。顶点着色器输出的<code>gl_PointSize</code>值被限定在OpenGL ES 3.0实现支持的非平滑点大小范围之内。<code>gl_PointSize</code>是一个浮点变量，用<code>highp</code>精度限定符声明；</li>\n<li><code>gl_FrontFacing</code>是一个特殊变量，但不是由顶点着色器直接写入的，而是根据顶点着色器生成的位置值和渲染的图元类型生成的。它是一个布尔变量。</li>\n</ul>\n<h3>内建统一状态</h3>\n<p>顶点着色器内可用的唯一内建统一状态是窗口坐标中的深度范围。这由内建统一变量名<code>gl_DepthRange</code>给出，该变量声明为<code>gl_DepthRangeParameters</code>类型的统一变量。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> gl_DepthRangeParameters &#123;</span><br><span class=\"line\">    highp <span class=\"keyword\">float</span> near; <span class=\"comment\">// near Z</span></span><br><span class=\"line\">    highp <span class=\"keyword\">float</span> far;  <span class=\"comment\">// far Z</span></span><br><span class=\"line\">    highp <span class=\"keyword\">float</span> diff; <span class=\"comment\">// far - near</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">uniform gl_DepthRangeParameters gl_DepthRange;</span><br></pre></td></tr></table></figure>\n<h3>内建常量</h3>\n<p>顶点着色器内还有如下内建常量：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> mediump <span class=\"keyword\">int</span> gl_MaxVertexAttribs = <span class=\"number\">16</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> mediump <span class=\"keyword\">int</span> gl_MaxVertexUniformVectors = <span class=\"number\">256</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> mediump <span class=\"keyword\">int</span> gl_MaxVertexOutputVectors = <span class=\"number\">16</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> mediump <span class=\"keyword\">int</span> gl_MaxVertexTextureImageUnits = <span class=\"number\">16</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> mediump <span class=\"keyword\">int</span> gl_MaxCombinedTextureImageUnits = <span class=\"number\">32</span>;</span><br></pre></td></tr></table></figure>\n<p>内建常量描述如下最大项：</p>\n<ul>\n<li><code>gl_MaxVertexAttribs</code>是可以指定的顶点属性的最大数量，所有ES 3.0实现都支持的最小值为16；</li>\n<li><code>gl_MaxVertexUniformVectors</code>是顶点着色器中可以使用的<code>vec4</code>统一变量项目的最大数量。所有ES 3.0实现都支持的最小值为256。开发人员可以使用的<code>vec4</code>统一变量项目数量在不同实现和不同顶点着色器中可能不同。例如，有些实现可能将顶点着色器中使用的用户指定字面值计入统一变量限制内。在其他情况下，根据顶点着色器是否使用内建的超越函数，可能需要包含特定于实现的统一变量（或者常量）。目前没有应用程序可以用于找出在特定顶点着色器中可使用的统一变量项目数量的机制。顶点着色器编译失败时，编译日志可能提供关于使用的统一变量项目数量的相关信息。但是，编译日志返回的信息是特定于实现的；</li>\n<li><code>gl_MaxVertexOutputVectors</code>是输出向量的最大数量–也就是顶点着色器可以输出的<code>vec4</code>项目数量。所有ES 3.0实现都支持的最小值是16个<code>vec4</code>项目；</li>\n<li><code>gl_MaxVertexTextureImageUnits</code>是顶点着色器中可用的纹理单元的最大数量，最小值为16；</li>\n<li><code>gl_MaxCombinedTextureImageUnits</code>是顶点和片段着色器中可用纹理单元最大数量的总和，最小值为32.</li>\n</ul>\n<p>每个内建常量指定的值是所有OpenGL ES 3.0实现必须支持的最小值，各种实现可能支持超过上面所述的最小值的常量值。实际支持的值可以用<code>glGetIntegerv</code>函数查询，查询参数为<code>GL_MAX_VERTEX_ATTRIBS</code>，<code>GL_MAX_VERTEX_UNIFORM_VECTORS</code>，<code>GL_MAX_VARYING_VECTORS</code>，<code>GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS</code>，<code>GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS</code>。</p>\n<h2>顶点着色器中的统一变量限制数量</h2>\n<p><code>gl_MaxVertexUniformVectors</code>描述了可以用于顶点着色器的统一变量的最大数量。任何兼容的OpenGL ES 3.0实现必须支持的<code>gl_MaxVertexUnifromVectors</code>最小值为256个<code>vec4</code>项目。统一变量存储用于存储如下变量：</p>\n<ul>\n<li>用统一变量限定符声明的变量</li>\n<li>常数变量</li>\n<li>字面值</li>\n<li>特定于实现的常量</li>\n</ul>\n<p>顶点着色器中使用的统一变量和用<code>const</code>限定符声明的变量、字面值和特定于实现的常量必须按照之前描述的打包规则与<code>gl_MaxVertexUniformVectors</code>相匹配。如果不匹配，顶点着色器就无法编译。开发人员可以应用打包规则，确定存储统一变量、常数变量和字面值所需的统一变量存储总数。然而，确定特定于实现的常量数量是不可能的，因为这个值不仅在不同实现中不同，而且取决于顶点着色器使用的内建着色器语言函数。通常，特定于实现的常量在使用内建超越函数时是必需的。</p>\n<p>至于字面值，OpenGL ES 3.0着色语言规范不做任何常量传播。结果是，同一个字面值的多个实例将被多次计算。可以理解的是，在顶点着色器中使用字面值（如0.0或者1.0）更容易，但是我们建议尽可能避免采用这种技术，应该声明相应的常数变量代替字面值。这种方法避免将同一个字面值计算多次，在那种情况下，如果顶点统一变量存储需求超过了实现所能支持的存储量，可能导致顶点着色器无法编译。</p>\n<h1>顶点着色器实例</h1>\n<p>在iOS中，需要用<code>GLKViewController</code>创建动画渲染循环，以指定的帧速率重新绘制视图的内容。</p>\n<h2>矩阵变换</h2>\n<p>设计一个顶点着色器获取一个位置和其相关的颜色数据作为输入或者属性，用一个4x4矩阵变换位置，并输出变换后的位置和颜色。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// glsl.vsh</span></span><br><span class=\"line\"><span class=\"meta\">#version 300 es</span></span><br><span class=\"line\"></span><br><span class=\"line\">uniform mat4 u_mvpMatrix;</span><br><span class=\"line\"></span><br><span class=\"line\">layout(location = <span class=\"number\">0</span>) <span class=\"keyword\">in</span> vec4 a_position;</span><br><span class=\"line\">layout(location = <span class=\"number\">1</span>) <span class=\"keyword\">in</span> vec4 a_color;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">out</span> vec4 v_color;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> main() &#123;</span><br><span class=\"line\">    v_color = a_color;</span><br><span class=\"line\">    gl_Position = u_mvpMatrix * a_position;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>变换矩阵：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">self</span>.elapsedTime += <span class=\"keyword\">self</span>.timeSinceLastUpdate;</span><br><span class=\"line\"><span class=\"keyword\">float</span> varyingFactor = sin(<span class=\"keyword\">self</span>.elapsedTime);</span><br><span class=\"line\"><span class=\"comment\">// 缩放矩阵</span></span><br><span class=\"line\">GLKMatrix4 scaleMatrix = GLKMatrix4MakeScale(varyingFactor, varyingFactor, <span class=\"number\">1.0</span>);</span><br><span class=\"line\"><span class=\"comment\">// 旋转矩阵</span></span><br><span class=\"line\">GLKMatrix4 rotateMatrix = GLKMatrix4MakeRotation(varyingFactor, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1.0</span>);</span><br><span class=\"line\"><span class=\"comment\">// 平移矩阵</span></span><br><span class=\"line\">GLKMatrix4 translateMatrix = GLKMatrix4MakeTranslation(varyingFactor, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"comment\">// 矩阵相乘</span></span><br><span class=\"line\"><span class=\"keyword\">self</span>.transformMatrix = GLKMatrix4Multiply(translateMatrix, rotateMatrix);</span><br><span class=\"line\"><span class=\"keyword\">self</span>.transformMatrix = GLKMatrix4Multiply(<span class=\"keyword\">self</span>.transformMatrix, scaleMatrix);</span><br></pre></td></tr></table></figure>\n<h1>待续。。。</h1>\n"},{"title":"使用Swift Package Manager管理依赖项","catalog":true,"toc_nav_num":true,"date":"2019-11-22T11:23:09.000Z","subtitle":"Swift Package Manager","header-img":"/img/article_header/article_header.png","busuanzi":true,"_content":"\n# 前言\n\n上一篇文章讲解了使用Cocoapods进行包管理的一些基本操作，讲到这里就不得不说刚刚集成于Xcode 11中支持iOS平台等多平台的包管理工具--Swift Package Manager。\n\n# 在项目中使用加载\n\n进入添加包依赖界面有两种方式，如下图：\n\n![添加包依赖1](/img/article/20191122/1.png)\n![添加包依赖2](/img/article/20191122/2.png)\n\n然后可以进行包搜索，需要登录Git账号，可以在`Accounts`中进行设置。\n\n搜索完成后可以进行版本选择（版本号、分支、Commit）：\n\n![添加包依赖3](/img/article/20191122/3.png)\n\n安装完成后就可以在项目中使用，非常方便。\n\n# 上传自己的SPM库\n\n先进行包初始化，创建并进入文件夹`mkdir ProjName && cd ProjName`，使用`swift package init`命令进行包初始化。\n\n初始化后会生成一系列文件：\n- README.md：不用解释，用于展示并介绍包的文件；\n- Package.swift：包配置文件，后面会详细讲解；\n- Sources文件夹：存放具体代码的文件夹；\n- Tests文件夹：存放各测试用例的文件夹。\n\n包配置文件：\n``` swift\n// swift-tools-version:5.1\n// The swift-tools-version declares the minimum version of Swift required to build this package.\n\nimport PackageDescription\n\nlet package = Package(\n    name: \"MyCategory\",\n    platforms: [\n        .macOS(.v10_13), .iOS(.v11), .tvOS(.v11),\n    ],\n    products: [\n        // Products define the executables and libraries produced by a package, and make them visible to other packages.\n        .library(\n            name: \"MyCategory\",\n            targets: [\"MyCategory\"]),\n    ],\n    dependencies: [\n        // Dependencies declare other packages that this package depends on.\n        // .package(url: /* package url */, from: \"1.0.0\"),\n        .package(url: \"https://github.com/onevcat/Kingfisher.git\", from: \"5.8.3\")\n    ],\n    targets: [\n        // Targets are the basic building blocks of a package. A target can define a module or a test suite.\n        // Targets can depend on other targets in this package, and on products in packages which this package depends on.\n        .target(\n            name: \"MyCategory\",\n            dependencies: [\"Kingfisher\"]),\n        .testTarget(\n            name: \"MyCategoryTests\",\n            dependencies: [\"MyCategory\"]),\n    ]\n)\n```\n中间的很多内容与Cocoapods配置文件相同，也有对应的参数，非常容易理解。\n添加外部依赖在`dependencies`添加对应的Git路径，并在`targets`中声明。\n\n对于`Sources`文件夹下的代码文件，有一点要说一下。因为SPM是跨平台包管理器，所以在引入系统库时需要进行平台判断，否则会在编译时无法通过：\n``` swift\n#if os(Linux)\n\n// Code specific to Linux\n\n#elseif os(macOS)\n\n// Code specific to macOS\n\n#endif\n\n#if canImport(UIKit)\n\n// Code specific to platforms where UIKit is available\n\n#endif\n```\n\n上述文件配置结束后，和Cocoapods一样上传到Git并打Tag生成最终的Release包，然后就可以在SPM中搜索到我们的包啦。\n\n# 对于已有项目\n\n对于已有项目，或者说是Cocoapods生成的包管理文件，我们可以同样创建SPM，在目录中添加`Package.swift`和`Sources`文件即可。\n\n# 总结\n\n总的来说，Swift Package Manager还是非常方便的，就这样。","source":"_posts/2019/swift-package-manager-1122.md","raw":"---\ntitle: \"使用Swift Package Manager管理依赖项\"\ncatalog: true\ntoc_nav_num: true\ndate: 2019-11-22 19:23:09\nsubtitle: \"Swift Package Manager\"\nheader-img: \"/img/article_header/article_header.png\"\nbusuanzi: true\ntags:\n- iOS\n\n---\n\n# 前言\n\n上一篇文章讲解了使用Cocoapods进行包管理的一些基本操作，讲到这里就不得不说刚刚集成于Xcode 11中支持iOS平台等多平台的包管理工具--Swift Package Manager。\n\n# 在项目中使用加载\n\n进入添加包依赖界面有两种方式，如下图：\n\n![添加包依赖1](/img/article/20191122/1.png)\n![添加包依赖2](/img/article/20191122/2.png)\n\n然后可以进行包搜索，需要登录Git账号，可以在`Accounts`中进行设置。\n\n搜索完成后可以进行版本选择（版本号、分支、Commit）：\n\n![添加包依赖3](/img/article/20191122/3.png)\n\n安装完成后就可以在项目中使用，非常方便。\n\n# 上传自己的SPM库\n\n先进行包初始化，创建并进入文件夹`mkdir ProjName && cd ProjName`，使用`swift package init`命令进行包初始化。\n\n初始化后会生成一系列文件：\n- README.md：不用解释，用于展示并介绍包的文件；\n- Package.swift：包配置文件，后面会详细讲解；\n- Sources文件夹：存放具体代码的文件夹；\n- Tests文件夹：存放各测试用例的文件夹。\n\n包配置文件：\n``` swift\n// swift-tools-version:5.1\n// The swift-tools-version declares the minimum version of Swift required to build this package.\n\nimport PackageDescription\n\nlet package = Package(\n    name: \"MyCategory\",\n    platforms: [\n        .macOS(.v10_13), .iOS(.v11), .tvOS(.v11),\n    ],\n    products: [\n        // Products define the executables and libraries produced by a package, and make them visible to other packages.\n        .library(\n            name: \"MyCategory\",\n            targets: [\"MyCategory\"]),\n    ],\n    dependencies: [\n        // Dependencies declare other packages that this package depends on.\n        // .package(url: /* package url */, from: \"1.0.0\"),\n        .package(url: \"https://github.com/onevcat/Kingfisher.git\", from: \"5.8.3\")\n    ],\n    targets: [\n        // Targets are the basic building blocks of a package. A target can define a module or a test suite.\n        // Targets can depend on other targets in this package, and on products in packages which this package depends on.\n        .target(\n            name: \"MyCategory\",\n            dependencies: [\"Kingfisher\"]),\n        .testTarget(\n            name: \"MyCategoryTests\",\n            dependencies: [\"MyCategory\"]),\n    ]\n)\n```\n中间的很多内容与Cocoapods配置文件相同，也有对应的参数，非常容易理解。\n添加外部依赖在`dependencies`添加对应的Git路径，并在`targets`中声明。\n\n对于`Sources`文件夹下的代码文件，有一点要说一下。因为SPM是跨平台包管理器，所以在引入系统库时需要进行平台判断，否则会在编译时无法通过：\n``` swift\n#if os(Linux)\n\n// Code specific to Linux\n\n#elseif os(macOS)\n\n// Code specific to macOS\n\n#endif\n\n#if canImport(UIKit)\n\n// Code specific to platforms where UIKit is available\n\n#endif\n```\n\n上述文件配置结束后，和Cocoapods一样上传到Git并打Tag生成最终的Release包，然后就可以在SPM中搜索到我们的包啦。\n\n# 对于已有项目\n\n对于已有项目，或者说是Cocoapods生成的包管理文件，我们可以同样创建SPM，在目录中添加`Package.swift`和`Sources`文件即可。\n\n# 总结\n\n总的来说，Swift Package Manager还是非常方便的，就这样。","slug":"2019/swift-package-manager-1122","published":1,"updated":"2022-01-10T09:04:52.810Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cky8gmc4i001dd1qhfct4wvy3","content":"<h1 id=\"前言\">前言</h1>\n<p>上一篇文章讲解了使用Cocoapods进行包管理的一些基本操作，讲到这里就不得不说刚刚集成于Xcode 11中支持iOS平台等多平台的包管理工具–Swift Package Manager。</p>\n<h1 id=\"在项目中使用加载\">在项目中使用加载</h1>\n<p>进入添加包依赖界面有两种方式，如下图：</p>\n<p><img src=\"/img/article/20191122/1.png\" alt=\"添加包依赖1\"><br>\n<img src=\"/img/article/20191122/2.png\" alt=\"添加包依赖2\"></p>\n<p>然后可以进行包搜索，需要登录Git账号，可以在<code>Accounts</code>中进行设置。</p>\n<p>搜索完成后可以进行版本选择（版本号、分支、Commit）：</p>\n<p><img src=\"/img/article/20191122/3.png\" alt=\"添加包依赖3\"></p>\n<p>安装完成后就可以在项目中使用，非常方便。</p>\n<h1 id=\"上传自己的spm库\">上传自己的SPM库</h1>\n<p>先进行包初始化，创建并进入文件夹<code>mkdir ProjName &amp;&amp; cd ProjName</code>，使用<code>swift package init</code>命令进行包初始化。</p>\n<p>初始化后会生成一系列文件：</p>\n<ul>\n<li><a href=\"http://README.md\" target=\"_blank\" rel=\"noopener\">README.md</a>：不用解释，用于展示并介绍包的文件；</li>\n<li>Package.swift：包配置文件，后面会详细讲解；</li>\n<li>Sources文件夹：存放具体代码的文件夹；</li>\n<li>Tests文件夹：存放各测试用例的文件夹。</li>\n</ul>\n<p>包配置文件：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// swift-tools-version:5.1</span></span><br><span class=\"line\"><span class=\"comment\">// The swift-tools-version declares the minimum version of Swift required to build this package.</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> PackageDescription</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> package = <span class=\"type\">Package</span>(</span><br><span class=\"line\">    name: <span class=\"string\">\"MyCategory\"</span>,</span><br><span class=\"line\">    platforms: [</span><br><span class=\"line\">        .macOS(.v10_13), .iOS(.v11), .tvOS(.v11),</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    products: [</span><br><span class=\"line\">        <span class=\"comment\">// Products define the executables and libraries produced by a package, and make them visible to other packages.</span></span><br><span class=\"line\">        .library(</span><br><span class=\"line\">            name: <span class=\"string\">\"MyCategory\"</span>,</span><br><span class=\"line\">            targets: [<span class=\"string\">\"MyCategory\"</span>]),</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    dependencies: [</span><br><span class=\"line\">        <span class=\"comment\">// Dependencies declare other packages that this package depends on.</span></span><br><span class=\"line\">        <span class=\"comment\">// .package(url: /* package url */, from: \"1.0.0\"),</span></span><br><span class=\"line\">        .package(url: <span class=\"string\">\"https://github.com/onevcat/Kingfisher.git\"</span>, from: <span class=\"string\">\"5.8.3\"</span>)</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    targets: [</span><br><span class=\"line\">        <span class=\"comment\">// Targets are the basic building blocks of a package. A target can define a module or a test suite.</span></span><br><span class=\"line\">        <span class=\"comment\">// Targets can depend on other targets in this package, and on products in packages which this package depends on.</span></span><br><span class=\"line\">        .target(</span><br><span class=\"line\">            name: <span class=\"string\">\"MyCategory\"</span>,</span><br><span class=\"line\">            dependencies: [<span class=\"string\">\"Kingfisher\"</span>]),</span><br><span class=\"line\">        .testTarget(</span><br><span class=\"line\">            name: <span class=\"string\">\"MyCategoryTests\"</span>,</span><br><span class=\"line\">            dependencies: [<span class=\"string\">\"MyCategory\"</span>]),</span><br><span class=\"line\">    ]</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>中间的很多内容与Cocoapods配置文件相同，也有对应的参数，非常容易理解。<br>\n添加外部依赖在<code>dependencies</code>添加对应的Git路径，并在<code>targets</code>中声明。</p>\n<p>对于<code>Sources</code>文件夹下的代码文件，有一点要说一下。因为SPM是跨平台包管理器，所以在引入系统库时需要进行平台判断，否则会在编译时无法通过：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#<span class=\"keyword\">if</span> os(<span class=\"type\">Linux</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Code specific to Linux</span></span><br><span class=\"line\"></span><br><span class=\"line\">#elseif os(macOS)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Code specific to macOS</span></span><br><span class=\"line\"></span><br><span class=\"line\">#endif</span><br><span class=\"line\"></span><br><span class=\"line\">#<span class=\"keyword\">if</span> canImport(<span class=\"type\">UIKit</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Code specific to platforms where UIKit is available</span></span><br><span class=\"line\"></span><br><span class=\"line\">#endif</span><br></pre></td></tr></table></figure>\n<p>上述文件配置结束后，和Cocoapods一样上传到Git并打Tag生成最终的Release包，然后就可以在SPM中搜索到我们的包啦。</p>\n<h1 id=\"对于已有项目\">对于已有项目</h1>\n<p>对于已有项目，或者说是Cocoapods生成的包管理文件，我们可以同样创建SPM，在目录中添加<code>Package.swift</code>和<code>Sources</code>文件即可。</p>\n<h1 id=\"总结\">总结</h1>\n<p>总的来说，Swift Package Manager还是非常方便的，就这样。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1>前言</h1>\n<p>上一篇文章讲解了使用Cocoapods进行包管理的一些基本操作，讲到这里就不得不说刚刚集成于Xcode 11中支持iOS平台等多平台的包管理工具–Swift Package Manager。</p>\n<h1>在项目中使用加载</h1>\n<p>进入添加包依赖界面有两种方式，如下图：</p>\n<p><img src=\"/img/article/20191122/1.png\" alt=\"添加包依赖1\"><br>\n<img src=\"/img/article/20191122/2.png\" alt=\"添加包依赖2\"></p>\n<p>然后可以进行包搜索，需要登录Git账号，可以在<code>Accounts</code>中进行设置。</p>\n<p>搜索完成后可以进行版本选择（版本号、分支、Commit）：</p>\n<p><img src=\"/img/article/20191122/3.png\" alt=\"添加包依赖3\"></p>\n<p>安装完成后就可以在项目中使用，非常方便。</p>\n<h1>上传自己的SPM库</h1>\n<p>先进行包初始化，创建并进入文件夹<code>mkdir ProjName &amp;&amp; cd ProjName</code>，使用<code>swift package init</code>命令进行包初始化。</p>\n<p>初始化后会生成一系列文件：</p>\n<ul>\n<li><a href=\"http://README.md\" target=\"_blank\" rel=\"noopener\">README.md</a>：不用解释，用于展示并介绍包的文件；</li>\n<li>Package.swift：包配置文件，后面会详细讲解；</li>\n<li>Sources文件夹：存放具体代码的文件夹；</li>\n<li>Tests文件夹：存放各测试用例的文件夹。</li>\n</ul>\n<p>包配置文件：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// swift-tools-version:5.1</span></span><br><span class=\"line\"><span class=\"comment\">// The swift-tools-version declares the minimum version of Swift required to build this package.</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> PackageDescription</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> package = <span class=\"type\">Package</span>(</span><br><span class=\"line\">    name: <span class=\"string\">\"MyCategory\"</span>,</span><br><span class=\"line\">    platforms: [</span><br><span class=\"line\">        .macOS(.v10_13), .iOS(.v11), .tvOS(.v11),</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    products: [</span><br><span class=\"line\">        <span class=\"comment\">// Products define the executables and libraries produced by a package, and make them visible to other packages.</span></span><br><span class=\"line\">        .library(</span><br><span class=\"line\">            name: <span class=\"string\">\"MyCategory\"</span>,</span><br><span class=\"line\">            targets: [<span class=\"string\">\"MyCategory\"</span>]),</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    dependencies: [</span><br><span class=\"line\">        <span class=\"comment\">// Dependencies declare other packages that this package depends on.</span></span><br><span class=\"line\">        <span class=\"comment\">// .package(url: /* package url */, from: \"1.0.0\"),</span></span><br><span class=\"line\">        .package(url: <span class=\"string\">\"https://github.com/onevcat/Kingfisher.git\"</span>, from: <span class=\"string\">\"5.8.3\"</span>)</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    targets: [</span><br><span class=\"line\">        <span class=\"comment\">// Targets are the basic building blocks of a package. A target can define a module or a test suite.</span></span><br><span class=\"line\">        <span class=\"comment\">// Targets can depend on other targets in this package, and on products in packages which this package depends on.</span></span><br><span class=\"line\">        .target(</span><br><span class=\"line\">            name: <span class=\"string\">\"MyCategory\"</span>,</span><br><span class=\"line\">            dependencies: [<span class=\"string\">\"Kingfisher\"</span>]),</span><br><span class=\"line\">        .testTarget(</span><br><span class=\"line\">            name: <span class=\"string\">\"MyCategoryTests\"</span>,</span><br><span class=\"line\">            dependencies: [<span class=\"string\">\"MyCategory\"</span>]),</span><br><span class=\"line\">    ]</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>中间的很多内容与Cocoapods配置文件相同，也有对应的参数，非常容易理解。<br>\n添加外部依赖在<code>dependencies</code>添加对应的Git路径，并在<code>targets</code>中声明。</p>\n<p>对于<code>Sources</code>文件夹下的代码文件，有一点要说一下。因为SPM是跨平台包管理器，所以在引入系统库时需要进行平台判断，否则会在编译时无法通过：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#<span class=\"keyword\">if</span> os(<span class=\"type\">Linux</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Code specific to Linux</span></span><br><span class=\"line\"></span><br><span class=\"line\">#elseif os(macOS)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Code specific to macOS</span></span><br><span class=\"line\"></span><br><span class=\"line\">#endif</span><br><span class=\"line\"></span><br><span class=\"line\">#<span class=\"keyword\">if</span> canImport(<span class=\"type\">UIKit</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Code specific to platforms where UIKit is available</span></span><br><span class=\"line\"></span><br><span class=\"line\">#endif</span><br></pre></td></tr></table></figure>\n<p>上述文件配置结束后，和Cocoapods一样上传到Git并打Tag生成最终的Release包，然后就可以在SPM中搜索到我们的包啦。</p>\n<h1>对于已有项目</h1>\n<p>对于已有项目，或者说是Cocoapods生成的包管理文件，我们可以同样创建SPM，在目录中添加<code>Package.swift</code>和<code>Sources</code>文件即可。</p>\n<h1>总结</h1>\n<p>总的来说，Swift Package Manager还是非常方便的，就这样。</p>\n"},{"title":"重构 AppDelegate","catalog":true,"toc_nav_num":true,"date":"2019-02-15T10:40:24.000Z","subtitle":"Refactoring Massive App Delegate","header-img":"/img/article_header/article_header.png","busuanzi":true,"_content":"\n> 之前曾经阅读过一篇基于 Swift 重构 AppDelegate 的文章， 现在把他整理搬到自己的博客，翻译自 [@V8tr](http://www.vadimbulavin.com/refactoring-massive-app-delegate/)，[Demo](https://github.com/Quincy-QC/MassiveAppDelegate)\n\n# Introduction\n\nAppDelegate 连接着我们的应用与系统，通常被认为是每个 iOS 工程的核心。正常趋势是随着开发逐渐变大，逐渐添加新的功能与职责，然后到处被调用，最终变成一团乱码。\n把所有东西都放在 AppDelegate 的代价是巨大的，会影响应用的流畅性，所以，保证这个类简单明了对一个健康的应用是非常重要的。\n本文将介绍几种不同的方式帮助我们如何使 AppDelegates 更加简单，可复用，可测试。\n\n# Problem Statement\n\nAppDelegate 是应用的根对象，他保证了应用与正确的与系统或其他应用的对接，所以 AppDelegate 有更加繁重的任务使得它难以修改，扩展，测试。\n甚至[苹果](https://developer.apple.com/documentation/uikit/uiapplicationdelegate?language=objc)都推荐你在 AppDelegate 添加三个以上的任务。\n通过调查[open-source-ios-apps](https://github.com/dkhamsing/open-source-ios-apps)我制作了一份经常会被放在 AppDelegates 里面任务的列表，我很确定我们会写同样的代码或在项目中有着相同的混乱。\n- 初始化三方类库\n- 初始化或操作数据存储系统\n- 用于单元测试或 UI 测试的应用状态配置\n- 配置 UserDefaults：设置首次启动的标识，加载存储数据\n- 配置通知：请求权限，存储 token，处理自定义事件，通知到应用的其他部分\n- 配置 UIAppearance\n- 配置应用角标\n- 配置后台任务\n- 配置界面：初始化控制器选择与跳转\n- 播放音频\n- 配置统计分析\n- 打印调试日志\n- 配置设备旋转方向\n- 实现代理方法，尤其是来自三方类库的代理\n- 弹窗\n\n我敢肯定这个列表还不够完整。\n显然，如此臃肿的 AppDelegate 作为这篇博客的反面教材，难以支持扩展和测试，我们把它称为 Massive App Delegates。\n\n# Solution\n\n在我们意识到 AppDelegate 的臃肿后，我们来看下几种可能的解决方案或者叫他 ’recipes‘。\n每个 recipe 必须满足下面条件：\n- 遵循 [sigle responsibility principle](https://en.wikipedia.org/wiki/Single_responsibility_principle)\n- 易于扩展\n- 易于测试\n\n## Recipe #1: Command Design Pattern\n\n命令设计模式（command Design pattern）指多个代表单一事件功能的对象集，这些对象把触发自己事件所需的所有参数封装，因此命令的调用者不知道这个命令的实现和响应者。\n为每个 AppDelegate 职责定义一个命令，名字根据功能决定。\n\n``` Swift\nprotocol Command {\n    func execute()\n}\n\nstruct InitializeThirdPartiesCommand: Command {\n    func execute() {\n        print(\"Third parties are initialized\")\n    }\n}\n\nstruct InitialViewControllerCommand: Command {\n    let keyWindow: UIWindow\n    \n    func execute() {\n        print(\"Pick root view controller here\")\n        keyWindow.frame = UIScreen.main.bounds\n        keyWindow.backgroundColor = UIColor.white\n        keyWindow.makeKeyAndVisible()\n        keyWindow.rootViewController = ViewController()\n    }\n}\n\nstruct InitializeAppearanceCommand: Command {\n    func execute() {\n        print(\"Setup UIAppearance\")\n    }\n}\n\nstruct RegisterToRemoteNotificationsCommand: Command {\n    func execute() {\n        print(\"Register for remote notifications here\")\n    }\n}\n```\n然后我们定义**StartupCommandsBuilder**把命令的创建细节封装，AppDelegate 调用这个类初始化对应的命令然后调用，\n``` Swift\n// MARK: -------- StartupCommandsBuilder --------\n\nfinal class StartupCommandsBuilder {\n    private var window: UIWindow!\n    \n    func setKeyWindow(_ window: UIWindow) -> StartupCommandsBuilder {\n        self.window = window\n        return self\n    }\n    \n    func build() -> [Command] {\n        return [InitializeThirdPartiesCommand(),\n                InitialViewControllerCommand(keyWindow: window),\n                InitializeAppearanceCommand(),\n                RegisterToRemoteNotificationsCommand()]\n    }\n}\n\n// MARK: -------- AppDelegate --------\n\n@UIApplicationMain\nclass AppDelegate: UIResponder, UIApplicationDelegate {\n\n    var window: UIWindow?\n\n\n    func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {\n        \n        StartupCommandsBuilder()\n            .setKeyWindow(window!)\n            .build()\n            .forEach { $0.execute() }\n        \n        return true\n    }\n}\n```\n新命令可以不需要修改 AppDelegate 直接添加到**StartupCommandsBuilder**。\n这个解决方案满足定义的条件：\n- 每个命令有自己的职责\n- 无需修改 AppDelegate 的代码就可以方便添加新命令\n- 命令易于测试\n\n## Recipe #2: Composite Design Pattern\n\n复合设计模式（Composite Design Pattern）允许将对象的层级结构视为单例。举个例子就像 iOS 里的**UIView**和它的子类视图。\n主体思想是复合类和子 AppDelegate 各自拥有职责，同时复合类将所有方法传递到子类。\n``` Swift\ntypealias AppDelegateType = UIResponder & UIApplicationDelegate\n\nclass CompositeAppDelegate: AppDelegateType {\n    private let appDelegates: [AppDelegateType]\n    \n    init(appDelegates: [AppDelegateType]) {\n        self.appDelegates = appDelegates\n    }\n    \n    func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey : Any]? = nil) -> Bool {\n        appDelegates.forEach { _ = $0.application?(application, didFinishLaunchingWithOptions: launchOptions) }\n        return true\n    }\n    \n    func application(_ application: UIApplication, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data) {\n        appDelegates.forEach { $0.application?(application, didRegisterForRemoteNotificationsWithDeviceToken: deviceToken) }\n    }\n}\n```\n然后，子 AppDelegates 实现真正的任务，\n``` Swift\nclass PushNotificationAppDelegate: AppDelegateType {\n    func application(_ application: UIApplication, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data) {\n        print(\"Registed successfully\")\n    }\n}\n\nclass StartupConfiguratorAppDelegate: AppDelegateType {\n    func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey : Any]? = nil) -> Bool {\n        print(\"Perform startup configurations, e.g. build UI stack, setup UIAppearance\")\n        return true\n    }\n}\n\nclass ThirdPartiesConfiguratorAppDelegate: AppDelegateType {\n    func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey : Any]? = nil) -> Bool {\n        print(\"Setup third parties\")\n        return true\n    }\n}\n```\n我们定义**AppDelegateFactory**封装创建逻辑，主 AppDelegate 通过这个工厂类创建组合代理，调用所有的方法，\n``` Swift\nenum AppDelegateFactory {\n    static func makeDefault() -> AppDelegateType {\n        return CompositeAppDelegate(appDelegates: [PushNotificationAppDelegate(), StartupConfiguratorAppDelegate(), ThirdPartiesConfiguratorAppDelegate()])\n    }\n}\n\n@UIApplicationMain\nclass AppDelegate: UIResponder, UIApplicationDelegate {\n\n    var window: UIWindow?\n    let appDelegate = AppDelegateFactory.makeDefault()\n\n    func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {\n        \n        _ = appDelegate.application?(application, didFinishLaunchingWithOptions: launchOptions)\n        \n        return true\n    }\n    \n    func application(_ application: UIApplication, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data) {\n        \n        appDelegate.application?(application, didRegisterForRemoteNotificationsWithDeviceToken: deviceToken)\n    }\n}\n```\n这个方法实现了我们开始定义的条件：\n- 每个子 AppDelegate 有个自己的职责\n- 无需修改 AppDelegate 的代码就可以方便添加新代理\n- 易于测试\n\n## Recipe #3: Mediator Design Pattern\n\n中介者设计模式（Mediator Design Pattern）通过一个隐蔽无约束的方法封装交互策略。对象被中介者无意识操作，无需他们的许可情况下就可以在幕后默默地推行自己的政策。\n如果你想要更多学习这个模式，推荐你阅读 [Mediator Pattern Case Study](http://www.vadimbulavin.com/mediator-pattern-case-study/)\n定义**AppLifecycleMediator**将**UIApplication**生命周期活动传递到底层监听器，监听器必须遵循必要时可被扩展的**AppLifecycleListener**协议\n``` Swift\nprotocol AppLifecycleListener {\n    func onAppWillEnterForeground()\n    func onAppDidEnterBackground()\n    func onAppDidFinishLaunching()\n}\n\nextension AppLifecycleListener {\n    func onAppWillEnterForeground() {}\n    func onAppDidEnterBackground() {}\n    func onAppDidFinishLaunching() {}\n}\n\nstruct listen1: AppLifecycleListener {\n    func onAppDidFinishLaunching() {\n        print(\"app did finish launching1\")\n    }\n    \n    func onAppWillEnterForeground() {\n        print(\"app will enter foreground\")\n    }\n}\n\nstruct listen2: AppLifecycleListener {\n    func onAppDidEnterBackground() {\n        print(\"app did enter background\")\n    }\n}\n\nstruct listen3: AppLifecycleListener {\n    func onAppDidFinishLaunching() {\n        print(\"app did finish launching2\")\n    }\n}\n\nclass AppLifecycleMediator: NSObject {\n    private let listeners: [AppLifecycleListener]\n    \n    init(listeners: [AppLifecycleListener]) {\n        self.listeners = listeners\n        super.init()\n        subscribe()\n    }\n    \n    deinit {\n        NotificationCenter.default.removeObserver(self)\n    }\n    \n    private func subscribe() {\n        NotificationCenter.default.addObserver(self, selector: #selector(onAppWillEnterForeground), name: UIApplication.willEnterForegroundNotification, object: nil)\n        NotificationCenter.default.addObserver(self, selector: #selector(onAppDidEnterBackground), name: UIApplication.didEnterBackgroundNotification, object: nil)\n        NotificationCenter.default.addObserver(self, selector: #selector(onAppDidFinishLaunching), name: UIApplication.didFinishLaunchingNotification, object: nil)\n    }\n    \n    @objc func onAppWillEnterForeground() {\n        listeners.forEach { $0.onAppWillEnterForeground() }\n    }\n    \n    @objc func onAppDidEnterBackground() {\n        listeners.forEach { $0.onAppDidEnterBackground() }\n    }\n    \n    @objc func onAppDidFinishLaunching() {\n        listeners.forEach { $0.onAppDidFinishLaunching() }\n    }\n}\n\nextension AppLifecycleMediator {\n    static func makeDefaultMediator() -> AppLifecycleMediator {\n        return AppLifecycleMediator(listeners: [listen1(), listen2(), listen3()])\n    }\n}\n```\n现在就可以通过一行代码添加到**AppDelegate**\n``` Swift\n@UIApplicationMain\nclass AppDelegate: UIResponder, UIApplicationDelegate {\n\n    var window: UIWindow?\n\n    let mediator = AppLifecycleMediator.makeDefaultMediator()\n\n    func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {\n\n        return true\n    }\n}\n```\n中介者自动订阅所有事件，**AppDelegate**仅需要初始化让他工作。\n这种方式满足我们开始定义的条件：\n- 每个监听者有自己的职责\n- 无需修改 AppDelegate 代码就可以添加新监听者\n- 每个模块都易于测试\n\n# Summary\n大多数**AppDelegate**都过于庞大，过于复杂，担有太多职责，通过软件设计模式，**AppDelegate**可以被划分为多个类，各自拥有各自的职责，同时方便测试。这样的代码非常容易修改，而且非常灵活，可以在将来提取和复用。\n\n# Reference\n[Refactoring Massive App Delegate](http://www.vadimbulavin.com/refactoring-massive-app-delegate/)","source":"_posts/2019/refactoring-massive-app-delegate-0215.md","raw":"---\ntitle: \"重构 AppDelegate\"\ncatalog: true\ntoc_nav_num: true\ndate: 2019-02-15 18:40:24\nsubtitle: \"Refactoring Massive App Delegate\"\nheader-img: \"/img/article_header/article_header.png\"\nbusuanzi: true\ntags:\n- iOS - Swift\n\n---\n\n> 之前曾经阅读过一篇基于 Swift 重构 AppDelegate 的文章， 现在把他整理搬到自己的博客，翻译自 [@V8tr](http://www.vadimbulavin.com/refactoring-massive-app-delegate/)，[Demo](https://github.com/Quincy-QC/MassiveAppDelegate)\n\n# Introduction\n\nAppDelegate 连接着我们的应用与系统，通常被认为是每个 iOS 工程的核心。正常趋势是随着开发逐渐变大，逐渐添加新的功能与职责，然后到处被调用，最终变成一团乱码。\n把所有东西都放在 AppDelegate 的代价是巨大的，会影响应用的流畅性，所以，保证这个类简单明了对一个健康的应用是非常重要的。\n本文将介绍几种不同的方式帮助我们如何使 AppDelegates 更加简单，可复用，可测试。\n\n# Problem Statement\n\nAppDelegate 是应用的根对象，他保证了应用与正确的与系统或其他应用的对接，所以 AppDelegate 有更加繁重的任务使得它难以修改，扩展，测试。\n甚至[苹果](https://developer.apple.com/documentation/uikit/uiapplicationdelegate?language=objc)都推荐你在 AppDelegate 添加三个以上的任务。\n通过调查[open-source-ios-apps](https://github.com/dkhamsing/open-source-ios-apps)我制作了一份经常会被放在 AppDelegates 里面任务的列表，我很确定我们会写同样的代码或在项目中有着相同的混乱。\n- 初始化三方类库\n- 初始化或操作数据存储系统\n- 用于单元测试或 UI 测试的应用状态配置\n- 配置 UserDefaults：设置首次启动的标识，加载存储数据\n- 配置通知：请求权限，存储 token，处理自定义事件，通知到应用的其他部分\n- 配置 UIAppearance\n- 配置应用角标\n- 配置后台任务\n- 配置界面：初始化控制器选择与跳转\n- 播放音频\n- 配置统计分析\n- 打印调试日志\n- 配置设备旋转方向\n- 实现代理方法，尤其是来自三方类库的代理\n- 弹窗\n\n我敢肯定这个列表还不够完整。\n显然，如此臃肿的 AppDelegate 作为这篇博客的反面教材，难以支持扩展和测试，我们把它称为 Massive App Delegates。\n\n# Solution\n\n在我们意识到 AppDelegate 的臃肿后，我们来看下几种可能的解决方案或者叫他 ’recipes‘。\n每个 recipe 必须满足下面条件：\n- 遵循 [sigle responsibility principle](https://en.wikipedia.org/wiki/Single_responsibility_principle)\n- 易于扩展\n- 易于测试\n\n## Recipe #1: Command Design Pattern\n\n命令设计模式（command Design pattern）指多个代表单一事件功能的对象集，这些对象把触发自己事件所需的所有参数封装，因此命令的调用者不知道这个命令的实现和响应者。\n为每个 AppDelegate 职责定义一个命令，名字根据功能决定。\n\n``` Swift\nprotocol Command {\n    func execute()\n}\n\nstruct InitializeThirdPartiesCommand: Command {\n    func execute() {\n        print(\"Third parties are initialized\")\n    }\n}\n\nstruct InitialViewControllerCommand: Command {\n    let keyWindow: UIWindow\n    \n    func execute() {\n        print(\"Pick root view controller here\")\n        keyWindow.frame = UIScreen.main.bounds\n        keyWindow.backgroundColor = UIColor.white\n        keyWindow.makeKeyAndVisible()\n        keyWindow.rootViewController = ViewController()\n    }\n}\n\nstruct InitializeAppearanceCommand: Command {\n    func execute() {\n        print(\"Setup UIAppearance\")\n    }\n}\n\nstruct RegisterToRemoteNotificationsCommand: Command {\n    func execute() {\n        print(\"Register for remote notifications here\")\n    }\n}\n```\n然后我们定义**StartupCommandsBuilder**把命令的创建细节封装，AppDelegate 调用这个类初始化对应的命令然后调用，\n``` Swift\n// MARK: -------- StartupCommandsBuilder --------\n\nfinal class StartupCommandsBuilder {\n    private var window: UIWindow!\n    \n    func setKeyWindow(_ window: UIWindow) -> StartupCommandsBuilder {\n        self.window = window\n        return self\n    }\n    \n    func build() -> [Command] {\n        return [InitializeThirdPartiesCommand(),\n                InitialViewControllerCommand(keyWindow: window),\n                InitializeAppearanceCommand(),\n                RegisterToRemoteNotificationsCommand()]\n    }\n}\n\n// MARK: -------- AppDelegate --------\n\n@UIApplicationMain\nclass AppDelegate: UIResponder, UIApplicationDelegate {\n\n    var window: UIWindow?\n\n\n    func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {\n        \n        StartupCommandsBuilder()\n            .setKeyWindow(window!)\n            .build()\n            .forEach { $0.execute() }\n        \n        return true\n    }\n}\n```\n新命令可以不需要修改 AppDelegate 直接添加到**StartupCommandsBuilder**。\n这个解决方案满足定义的条件：\n- 每个命令有自己的职责\n- 无需修改 AppDelegate 的代码就可以方便添加新命令\n- 命令易于测试\n\n## Recipe #2: Composite Design Pattern\n\n复合设计模式（Composite Design Pattern）允许将对象的层级结构视为单例。举个例子就像 iOS 里的**UIView**和它的子类视图。\n主体思想是复合类和子 AppDelegate 各自拥有职责，同时复合类将所有方法传递到子类。\n``` Swift\ntypealias AppDelegateType = UIResponder & UIApplicationDelegate\n\nclass CompositeAppDelegate: AppDelegateType {\n    private let appDelegates: [AppDelegateType]\n    \n    init(appDelegates: [AppDelegateType]) {\n        self.appDelegates = appDelegates\n    }\n    \n    func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey : Any]? = nil) -> Bool {\n        appDelegates.forEach { _ = $0.application?(application, didFinishLaunchingWithOptions: launchOptions) }\n        return true\n    }\n    \n    func application(_ application: UIApplication, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data) {\n        appDelegates.forEach { $0.application?(application, didRegisterForRemoteNotificationsWithDeviceToken: deviceToken) }\n    }\n}\n```\n然后，子 AppDelegates 实现真正的任务，\n``` Swift\nclass PushNotificationAppDelegate: AppDelegateType {\n    func application(_ application: UIApplication, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data) {\n        print(\"Registed successfully\")\n    }\n}\n\nclass StartupConfiguratorAppDelegate: AppDelegateType {\n    func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey : Any]? = nil) -> Bool {\n        print(\"Perform startup configurations, e.g. build UI stack, setup UIAppearance\")\n        return true\n    }\n}\n\nclass ThirdPartiesConfiguratorAppDelegate: AppDelegateType {\n    func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey : Any]? = nil) -> Bool {\n        print(\"Setup third parties\")\n        return true\n    }\n}\n```\n我们定义**AppDelegateFactory**封装创建逻辑，主 AppDelegate 通过这个工厂类创建组合代理，调用所有的方法，\n``` Swift\nenum AppDelegateFactory {\n    static func makeDefault() -> AppDelegateType {\n        return CompositeAppDelegate(appDelegates: [PushNotificationAppDelegate(), StartupConfiguratorAppDelegate(), ThirdPartiesConfiguratorAppDelegate()])\n    }\n}\n\n@UIApplicationMain\nclass AppDelegate: UIResponder, UIApplicationDelegate {\n\n    var window: UIWindow?\n    let appDelegate = AppDelegateFactory.makeDefault()\n\n    func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {\n        \n        _ = appDelegate.application?(application, didFinishLaunchingWithOptions: launchOptions)\n        \n        return true\n    }\n    \n    func application(_ application: UIApplication, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data) {\n        \n        appDelegate.application?(application, didRegisterForRemoteNotificationsWithDeviceToken: deviceToken)\n    }\n}\n```\n这个方法实现了我们开始定义的条件：\n- 每个子 AppDelegate 有个自己的职责\n- 无需修改 AppDelegate 的代码就可以方便添加新代理\n- 易于测试\n\n## Recipe #3: Mediator Design Pattern\n\n中介者设计模式（Mediator Design Pattern）通过一个隐蔽无约束的方法封装交互策略。对象被中介者无意识操作，无需他们的许可情况下就可以在幕后默默地推行自己的政策。\n如果你想要更多学习这个模式，推荐你阅读 [Mediator Pattern Case Study](http://www.vadimbulavin.com/mediator-pattern-case-study/)\n定义**AppLifecycleMediator**将**UIApplication**生命周期活动传递到底层监听器，监听器必须遵循必要时可被扩展的**AppLifecycleListener**协议\n``` Swift\nprotocol AppLifecycleListener {\n    func onAppWillEnterForeground()\n    func onAppDidEnterBackground()\n    func onAppDidFinishLaunching()\n}\n\nextension AppLifecycleListener {\n    func onAppWillEnterForeground() {}\n    func onAppDidEnterBackground() {}\n    func onAppDidFinishLaunching() {}\n}\n\nstruct listen1: AppLifecycleListener {\n    func onAppDidFinishLaunching() {\n        print(\"app did finish launching1\")\n    }\n    \n    func onAppWillEnterForeground() {\n        print(\"app will enter foreground\")\n    }\n}\n\nstruct listen2: AppLifecycleListener {\n    func onAppDidEnterBackground() {\n        print(\"app did enter background\")\n    }\n}\n\nstruct listen3: AppLifecycleListener {\n    func onAppDidFinishLaunching() {\n        print(\"app did finish launching2\")\n    }\n}\n\nclass AppLifecycleMediator: NSObject {\n    private let listeners: [AppLifecycleListener]\n    \n    init(listeners: [AppLifecycleListener]) {\n        self.listeners = listeners\n        super.init()\n        subscribe()\n    }\n    \n    deinit {\n        NotificationCenter.default.removeObserver(self)\n    }\n    \n    private func subscribe() {\n        NotificationCenter.default.addObserver(self, selector: #selector(onAppWillEnterForeground), name: UIApplication.willEnterForegroundNotification, object: nil)\n        NotificationCenter.default.addObserver(self, selector: #selector(onAppDidEnterBackground), name: UIApplication.didEnterBackgroundNotification, object: nil)\n        NotificationCenter.default.addObserver(self, selector: #selector(onAppDidFinishLaunching), name: UIApplication.didFinishLaunchingNotification, object: nil)\n    }\n    \n    @objc func onAppWillEnterForeground() {\n        listeners.forEach { $0.onAppWillEnterForeground() }\n    }\n    \n    @objc func onAppDidEnterBackground() {\n        listeners.forEach { $0.onAppDidEnterBackground() }\n    }\n    \n    @objc func onAppDidFinishLaunching() {\n        listeners.forEach { $0.onAppDidFinishLaunching() }\n    }\n}\n\nextension AppLifecycleMediator {\n    static func makeDefaultMediator() -> AppLifecycleMediator {\n        return AppLifecycleMediator(listeners: [listen1(), listen2(), listen3()])\n    }\n}\n```\n现在就可以通过一行代码添加到**AppDelegate**\n``` Swift\n@UIApplicationMain\nclass AppDelegate: UIResponder, UIApplicationDelegate {\n\n    var window: UIWindow?\n\n    let mediator = AppLifecycleMediator.makeDefaultMediator()\n\n    func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {\n\n        return true\n    }\n}\n```\n中介者自动订阅所有事件，**AppDelegate**仅需要初始化让他工作。\n这种方式满足我们开始定义的条件：\n- 每个监听者有自己的职责\n- 无需修改 AppDelegate 代码就可以添加新监听者\n- 每个模块都易于测试\n\n# Summary\n大多数**AppDelegate**都过于庞大，过于复杂，担有太多职责，通过软件设计模式，**AppDelegate**可以被划分为多个类，各自拥有各自的职责，同时方便测试。这样的代码非常容易修改，而且非常灵活，可以在将来提取和复用。\n\n# Reference\n[Refactoring Massive App Delegate](http://www.vadimbulavin.com/refactoring-massive-app-delegate/)","slug":"2019/refactoring-massive-app-delegate-0215","published":1,"updated":"2022-01-10T09:04:52.809Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cky8gmc4i001fd1qhuudr61kn","content":"<blockquote>\n<p>之前曾经阅读过一篇基于 Swift 重构 AppDelegate 的文章， 现在把他整理搬到自己的博客，翻译自 <a href=\"http://www.vadimbulavin.com/refactoring-massive-app-delegate/\" target=\"_blank\" rel=\"noopener\">@V8tr</a>，<a href=\"https://github.com/Quincy-QC/MassiveAppDelegate\" target=\"_blank\" rel=\"noopener\">Demo</a></p>\n</blockquote>\n<h1 id=\"introduction\">Introduction</h1>\n<p>AppDelegate 连接着我们的应用与系统，通常被认为是每个 iOS 工程的核心。正常趋势是随着开发逐渐变大，逐渐添加新的功能与职责，然后到处被调用，最终变成一团乱码。<br>\n把所有东西都放在 AppDelegate 的代价是巨大的，会影响应用的流畅性，所以，保证这个类简单明了对一个健康的应用是非常重要的。<br>\n本文将介绍几种不同的方式帮助我们如何使 AppDelegates 更加简单，可复用，可测试。</p>\n<h1 id=\"problem-statement\">Problem Statement</h1>\n<p>AppDelegate 是应用的根对象，他保证了应用与正确的与系统或其他应用的对接，所以 AppDelegate 有更加繁重的任务使得它难以修改，扩展，测试。<br>\n甚至<a href=\"https://developer.apple.com/documentation/uikit/uiapplicationdelegate?language=objc\" target=\"_blank\" rel=\"noopener\">苹果</a>都推荐你在 AppDelegate 添加三个以上的任务。<br>\n通过调查<a href=\"https://github.com/dkhamsing/open-source-ios-apps\" target=\"_blank\" rel=\"noopener\">open-source-ios-apps</a>我制作了一份经常会被放在 AppDelegates 里面任务的列表，我很确定我们会写同样的代码或在项目中有着相同的混乱。</p>\n<ul>\n<li>初始化三方类库</li>\n<li>初始化或操作数据存储系统</li>\n<li>用于单元测试或 UI 测试的应用状态配置</li>\n<li>配置 UserDefaults：设置首次启动的标识，加载存储数据</li>\n<li>配置通知：请求权限，存储 token，处理自定义事件，通知到应用的其他部分</li>\n<li>配置 UIAppearance</li>\n<li>配置应用角标</li>\n<li>配置后台任务</li>\n<li>配置界面：初始化控制器选择与跳转</li>\n<li>播放音频</li>\n<li>配置统计分析</li>\n<li>打印调试日志</li>\n<li>配置设备旋转方向</li>\n<li>实现代理方法，尤其是来自三方类库的代理</li>\n<li>弹窗</li>\n</ul>\n<p>我敢肯定这个列表还不够完整。<br>\n显然，如此臃肿的 AppDelegate 作为这篇博客的反面教材，难以支持扩展和测试，我们把它称为 Massive App Delegates。</p>\n<h1 id=\"solution\">Solution</h1>\n<p>在我们意识到 AppDelegate 的臃肿后，我们来看下几种可能的解决方案或者叫他 ’recipes‘。<br>\n每个 recipe 必须满足下面条件：</p>\n<ul>\n<li>遵循 <a href=\"https://en.wikipedia.org/wiki/Single_responsibility_principle\" target=\"_blank\" rel=\"noopener\">sigle responsibility principle</a></li>\n<li>易于扩展</li>\n<li>易于测试</li>\n</ul>\n<h2 id=\"recipe-1-command-design-pattern\">Recipe #1: Command Design Pattern</h2>\n<p>命令设计模式（command Design pattern）指多个代表单一事件功能的对象集，这些对象把触发自己事件所需的所有参数封装，因此命令的调用者不知道这个命令的实现和响应者。<br>\n为每个 AppDelegate 职责定义一个命令，名字根据功能决定。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">Command</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">execute</span><span class=\"params\">()</span></span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">InitializeThirdPartiesCommand</span>: <span class=\"title\">Command</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">execute</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"Third parties are initialized\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">InitialViewControllerCommand</span>: <span class=\"title\">Command</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> keyWindow: <span class=\"type\">UIWindow</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">execute</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"Pick root view controller here\"</span>)</span><br><span class=\"line\">        keyWindow.frame = <span class=\"type\">UIScreen</span>.main.bounds</span><br><span class=\"line\">        keyWindow.backgroundColor = <span class=\"type\">UIColor</span>.white</span><br><span class=\"line\">        keyWindow.makeKeyAndVisible()</span><br><span class=\"line\">        keyWindow.rootViewController = <span class=\"type\">ViewController</span>()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">InitializeAppearanceCommand</span>: <span class=\"title\">Command</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">execute</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"Setup UIAppearance\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">RegisterToRemoteNotificationsCommand</span>: <span class=\"title\">Command</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">execute</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"Register for remote notifications here\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后我们定义<strong>StartupCommandsBuilder</strong>把命令的创建细节封装，AppDelegate 调用这个类初始化对应的命令然后调用，</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// MARK: -------- StartupCommandsBuilder --------</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StartupCommandsBuilder</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> window: <span class=\"type\">UIWindow</span>!</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">setKeyWindow</span><span class=\"params\">(<span class=\"number\">_</span> window: UIWindow)</span></span> -&gt; <span class=\"type\">StartupCommandsBuilder</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.window = window</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">self</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">build</span><span class=\"params\">()</span></span> -&gt; [<span class=\"type\">Command</span>] &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> [<span class=\"type\">InitializeThirdPartiesCommand</span>(),</span><br><span class=\"line\">                <span class=\"type\">InitialViewControllerCommand</span>(keyWindow: window),</span><br><span class=\"line\">                <span class=\"type\">InitializeAppearanceCommand</span>(),</span><br><span class=\"line\">                <span class=\"type\">RegisterToRemoteNotificationsCommand</span>()]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// MARK: -------- AppDelegate --------</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@UIApplicationMain</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AppDelegate</span>: <span class=\"title\">UIResponder</span>, <span class=\"title\">UIApplicationDelegate</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> window: <span class=\"type\">UIWindow</span>?</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">application</span><span class=\"params\">(<span class=\"number\">_</span> application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?)</span></span> -&gt; <span class=\"type\">Bool</span> &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"type\">StartupCommandsBuilder</span>()</span><br><span class=\"line\">            .setKeyWindow(window!)</span><br><span class=\"line\">            .build()</span><br><span class=\"line\">            .forEach &#123; $<span class=\"number\">0</span>.execute() &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>新命令可以不需要修改 AppDelegate 直接添加到<strong>StartupCommandsBuilder</strong>。<br>\n这个解决方案满足定义的条件：</p>\n<ul>\n<li>每个命令有自己的职责</li>\n<li>无需修改 AppDelegate 的代码就可以方便添加新命令</li>\n<li>命令易于测试</li>\n</ul>\n<h2 id=\"recipe-2-composite-design-pattern\">Recipe #2: Composite Design Pattern</h2>\n<p>复合设计模式（Composite Design Pattern）允许将对象的层级结构视为单例。举个例子就像 iOS 里的<strong>UIView</strong>和它的子类视图。<br>\n主体思想是复合类和子 AppDelegate 各自拥有职责，同时复合类将所有方法传递到子类。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typealias</span> <span class=\"type\">AppDelegateType</span> = <span class=\"type\">UIResponder</span> &amp; <span class=\"type\">UIApplicationDelegate</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CompositeAppDelegate</span>: <span class=\"title\">AppDelegateType</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">let</span> appDelegates: [<span class=\"type\">AppDelegateType</span>]</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">init</span>(appDelegates: [<span class=\"type\">AppDelegateType</span>]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.appDelegates = appDelegates</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">application</span><span class=\"params\">(<span class=\"number\">_</span> application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey : Any]? = <span class=\"literal\">nil</span>)</span></span> -&gt; <span class=\"type\">Bool</span> &#123;</span><br><span class=\"line\">        appDelegates.forEach &#123; <span class=\"number\">_</span> = $<span class=\"number\">0</span>.application?(application, didFinishLaunchingWithOptions: launchOptions) &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">application</span><span class=\"params\">(<span class=\"number\">_</span> application: UIApplication, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data)</span></span> &#123;</span><br><span class=\"line\">        appDelegates.forEach &#123; $<span class=\"number\">0</span>.application?(application, didRegisterForRemoteNotificationsWithDeviceToken: deviceToken) &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后，子 AppDelegates 实现真正的任务，</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PushNotificationAppDelegate</span>: <span class=\"title\">AppDelegateType</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">application</span><span class=\"params\">(<span class=\"number\">_</span> application: UIApplication, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"Registed successfully\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StartupConfiguratorAppDelegate</span>: <span class=\"title\">AppDelegateType</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">application</span><span class=\"params\">(<span class=\"number\">_</span> application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey : Any]? = <span class=\"literal\">nil</span>)</span></span> -&gt; <span class=\"type\">Bool</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"Perform startup configurations, e.g. build UI stack, setup UIAppearance\"</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ThirdPartiesConfiguratorAppDelegate</span>: <span class=\"title\">AppDelegateType</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">application</span><span class=\"params\">(<span class=\"number\">_</span> application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey : Any]? = <span class=\"literal\">nil</span>)</span></span> -&gt; <span class=\"type\">Bool</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"Setup third parties\"</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们定义<strong>AppDelegateFactory</strong>封装创建逻辑，主 AppDelegate 通过这个工厂类创建组合代理，调用所有的方法，</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">AppDelegateFactory</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">makeDefault</span><span class=\"params\">()</span></span> -&gt; <span class=\"type\">AppDelegateType</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"type\">CompositeAppDelegate</span>(appDelegates: [<span class=\"type\">PushNotificationAppDelegate</span>(), <span class=\"type\">StartupConfiguratorAppDelegate</span>(), <span class=\"type\">ThirdPartiesConfiguratorAppDelegate</span>()])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@UIApplicationMain</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AppDelegate</span>: <span class=\"title\">UIResponder</span>, <span class=\"title\">UIApplicationDelegate</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> window: <span class=\"type\">UIWindow</span>?</span><br><span class=\"line\">    <span class=\"keyword\">let</span> appDelegate = <span class=\"type\">AppDelegateFactory</span>.makeDefault()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">application</span><span class=\"params\">(<span class=\"number\">_</span> application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?)</span></span> -&gt; <span class=\"type\">Bool</span> &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"number\">_</span> = appDelegate.application?(application, didFinishLaunchingWithOptions: launchOptions)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">application</span><span class=\"params\">(<span class=\"number\">_</span> application: UIApplication, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data)</span></span> &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        appDelegate.application?(application, didRegisterForRemoteNotificationsWithDeviceToken: deviceToken)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个方法实现了我们开始定义的条件：</p>\n<ul>\n<li>每个子 AppDelegate 有个自己的职责</li>\n<li>无需修改 AppDelegate 的代码就可以方便添加新代理</li>\n<li>易于测试</li>\n</ul>\n<h2 id=\"recipe-3-mediator-design-pattern\">Recipe #3: Mediator Design Pattern</h2>\n<p>中介者设计模式（Mediator Design Pattern）通过一个隐蔽无约束的方法封装交互策略。对象被中介者无意识操作，无需他们的许可情况下就可以在幕后默默地推行自己的政策。<br>\n如果你想要更多学习这个模式，推荐你阅读 <a href=\"http://www.vadimbulavin.com/mediator-pattern-case-study/\" target=\"_blank\" rel=\"noopener\">Mediator Pattern Case Study</a><br>\n定义<strong>AppLifecycleMediator</strong>将<strong>UIApplication</strong>生命周期活动传递到底层监听器，监听器必须遵循必要时可被扩展的<strong>AppLifecycleListener</strong>协议</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">AppLifecycleListener</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">onAppWillEnterForeground</span><span class=\"params\">()</span></span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">onAppDidEnterBackground</span><span class=\"params\">()</span></span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">onAppDidFinishLaunching</span><span class=\"params\">()</span></span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">AppLifecycleListener</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">onAppWillEnterForeground</span><span class=\"params\">()</span></span> &#123;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">onAppDidEnterBackground</span><span class=\"params\">()</span></span> &#123;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">onAppDidFinishLaunching</span><span class=\"params\">()</span></span> &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">listen1</span>: <span class=\"title\">AppLifecycleListener</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">onAppDidFinishLaunching</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"app did finish launching1\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">onAppWillEnterForeground</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"app will enter foreground\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">listen2</span>: <span class=\"title\">AppLifecycleListener</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">onAppDidEnterBackground</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"app did enter background\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">listen3</span>: <span class=\"title\">AppLifecycleListener</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">onAppDidFinishLaunching</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"app did finish launching2\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AppLifecycleMediator</span>: <span class=\"title\">NSObject</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">let</span> listeners: [<span class=\"type\">AppLifecycleListener</span>]</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">init</span>(listeners: [<span class=\"type\">AppLifecycleListener</span>]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.listeners = listeners</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.<span class=\"keyword\">init</span>()</span><br><span class=\"line\">        subscribe()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">deinit</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">NotificationCenter</span>.<span class=\"keyword\">default</span>.removeObserver(<span class=\"keyword\">self</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">subscribe</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"type\">NotificationCenter</span>.<span class=\"keyword\">default</span>.addObserver(<span class=\"keyword\">self</span>, selector: #selector(onAppWillEnterForeground), name: <span class=\"type\">UIApplication</span>.willEnterForegroundNotification, object: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">        <span class=\"type\">NotificationCenter</span>.<span class=\"keyword\">default</span>.addObserver(<span class=\"keyword\">self</span>, selector: #selector(onAppDidEnterBackground), name: <span class=\"type\">UIApplication</span>.didEnterBackgroundNotification, object: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">        <span class=\"type\">NotificationCenter</span>.<span class=\"keyword\">default</span>.addObserver(<span class=\"keyword\">self</span>, selector: #selector(onAppDidFinishLaunching), name: <span class=\"type\">UIApplication</span>.didFinishLaunchingNotification, object: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@objc</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">onAppWillEnterForeground</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        listeners.forEach &#123; $<span class=\"number\">0</span>.onAppWillEnterForeground() &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@objc</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">onAppDidEnterBackground</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        listeners.forEach &#123; $<span class=\"number\">0</span>.onAppDidEnterBackground() &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@objc</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">onAppDidFinishLaunching</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        listeners.forEach &#123; $<span class=\"number\">0</span>.onAppDidFinishLaunching() &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">AppLifecycleMediator</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">makeDefaultMediator</span><span class=\"params\">()</span></span> -&gt; <span class=\"type\">AppLifecycleMediator</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"type\">AppLifecycleMediator</span>(listeners: [listen1(), listen2(), listen3()])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在就可以通过一行代码添加到<strong>AppDelegate</strong></p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@UIApplicationMain</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AppDelegate</span>: <span class=\"title\">UIResponder</span>, <span class=\"title\">UIApplicationDelegate</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> window: <span class=\"type\">UIWindow</span>?</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> mediator = <span class=\"type\">AppLifecycleMediator</span>.makeDefaultMediator()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">application</span><span class=\"params\">(<span class=\"number\">_</span> application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?)</span></span> -&gt; <span class=\"type\">Bool</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>中介者自动订阅所有事件，<strong>AppDelegate</strong>仅需要初始化让他工作。<br>\n这种方式满足我们开始定义的条件：</p>\n<ul>\n<li>每个监听者有自己的职责</li>\n<li>无需修改 AppDelegate 代码就可以添加新监听者</li>\n<li>每个模块都易于测试</li>\n</ul>\n<h1 id=\"summary\">Summary</h1>\n<p>大多数<strong>AppDelegate</strong>都过于庞大，过于复杂，担有太多职责，通过软件设计模式，<strong>AppDelegate</strong>可以被划分为多个类，各自拥有各自的职责，同时方便测试。这样的代码非常容易修改，而且非常灵活，可以在将来提取和复用。</p>\n<h1 id=\"reference\">Reference</h1>\n<p><a href=\"http://www.vadimbulavin.com/refactoring-massive-app-delegate/\" target=\"_blank\" rel=\"noopener\">Refactoring Massive App Delegate</a></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>之前曾经阅读过一篇基于 Swift 重构 AppDelegate 的文章， 现在把他整理搬到自己的博客，翻译自 <a href=\"http://www.vadimbulavin.com/refactoring-massive-app-delegate/\" target=\"_blank\" rel=\"noopener\">@V8tr</a>，<a href=\"https://github.com/Quincy-QC/MassiveAppDelegate\" target=\"_blank\" rel=\"noopener\">Demo</a></p>\n</blockquote>\n<h1>Introduction</h1>\n<p>AppDelegate 连接着我们的应用与系统，通常被认为是每个 iOS 工程的核心。正常趋势是随着开发逐渐变大，逐渐添加新的功能与职责，然后到处被调用，最终变成一团乱码。<br>\n把所有东西都放在 AppDelegate 的代价是巨大的，会影响应用的流畅性，所以，保证这个类简单明了对一个健康的应用是非常重要的。<br>\n本文将介绍几种不同的方式帮助我们如何使 AppDelegates 更加简单，可复用，可测试。</p>\n<h1>Problem Statement</h1>\n<p>AppDelegate 是应用的根对象，他保证了应用与正确的与系统或其他应用的对接，所以 AppDelegate 有更加繁重的任务使得它难以修改，扩展，测试。<br>\n甚至<a href=\"https://developer.apple.com/documentation/uikit/uiapplicationdelegate?language=objc\" target=\"_blank\" rel=\"noopener\">苹果</a>都推荐你在 AppDelegate 添加三个以上的任务。<br>\n通过调查<a href=\"https://github.com/dkhamsing/open-source-ios-apps\" target=\"_blank\" rel=\"noopener\">open-source-ios-apps</a>我制作了一份经常会被放在 AppDelegates 里面任务的列表，我很确定我们会写同样的代码或在项目中有着相同的混乱。</p>\n<ul>\n<li>初始化三方类库</li>\n<li>初始化或操作数据存储系统</li>\n<li>用于单元测试或 UI 测试的应用状态配置</li>\n<li>配置 UserDefaults：设置首次启动的标识，加载存储数据</li>\n<li>配置通知：请求权限，存储 token，处理自定义事件，通知到应用的其他部分</li>\n<li>配置 UIAppearance</li>\n<li>配置应用角标</li>\n<li>配置后台任务</li>\n<li>配置界面：初始化控制器选择与跳转</li>\n<li>播放音频</li>\n<li>配置统计分析</li>\n<li>打印调试日志</li>\n<li>配置设备旋转方向</li>\n<li>实现代理方法，尤其是来自三方类库的代理</li>\n<li>弹窗</li>\n</ul>\n<p>我敢肯定这个列表还不够完整。<br>\n显然，如此臃肿的 AppDelegate 作为这篇博客的反面教材，难以支持扩展和测试，我们把它称为 Massive App Delegates。</p>\n<h1>Solution</h1>\n<p>在我们意识到 AppDelegate 的臃肿后，我们来看下几种可能的解决方案或者叫他 ’recipes‘。<br>\n每个 recipe 必须满足下面条件：</p>\n<ul>\n<li>遵循 <a href=\"https://en.wikipedia.org/wiki/Single_responsibility_principle\" target=\"_blank\" rel=\"noopener\">sigle responsibility principle</a></li>\n<li>易于扩展</li>\n<li>易于测试</li>\n</ul>\n<h2>Recipe #1: Command Design Pattern</h2>\n<p>命令设计模式（command Design pattern）指多个代表单一事件功能的对象集，这些对象把触发自己事件所需的所有参数封装，因此命令的调用者不知道这个命令的实现和响应者。<br>\n为每个 AppDelegate 职责定义一个命令，名字根据功能决定。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">Command</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">execute</span><span class=\"params\">()</span></span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">InitializeThirdPartiesCommand</span>: <span class=\"title\">Command</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">execute</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"Third parties are initialized\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">InitialViewControllerCommand</span>: <span class=\"title\">Command</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> keyWindow: <span class=\"type\">UIWindow</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">execute</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"Pick root view controller here\"</span>)</span><br><span class=\"line\">        keyWindow.frame = <span class=\"type\">UIScreen</span>.main.bounds</span><br><span class=\"line\">        keyWindow.backgroundColor = <span class=\"type\">UIColor</span>.white</span><br><span class=\"line\">        keyWindow.makeKeyAndVisible()</span><br><span class=\"line\">        keyWindow.rootViewController = <span class=\"type\">ViewController</span>()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">InitializeAppearanceCommand</span>: <span class=\"title\">Command</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">execute</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"Setup UIAppearance\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">RegisterToRemoteNotificationsCommand</span>: <span class=\"title\">Command</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">execute</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"Register for remote notifications here\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后我们定义<strong>StartupCommandsBuilder</strong>把命令的创建细节封装，AppDelegate 调用这个类初始化对应的命令然后调用，</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// MARK: -------- StartupCommandsBuilder --------</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StartupCommandsBuilder</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> window: <span class=\"type\">UIWindow</span>!</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">setKeyWindow</span><span class=\"params\">(<span class=\"number\">_</span> window: UIWindow)</span></span> -&gt; <span class=\"type\">StartupCommandsBuilder</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.window = window</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">self</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">build</span><span class=\"params\">()</span></span> -&gt; [<span class=\"type\">Command</span>] &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> [<span class=\"type\">InitializeThirdPartiesCommand</span>(),</span><br><span class=\"line\">                <span class=\"type\">InitialViewControllerCommand</span>(keyWindow: window),</span><br><span class=\"line\">                <span class=\"type\">InitializeAppearanceCommand</span>(),</span><br><span class=\"line\">                <span class=\"type\">RegisterToRemoteNotificationsCommand</span>()]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// MARK: -------- AppDelegate --------</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@UIApplicationMain</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AppDelegate</span>: <span class=\"title\">UIResponder</span>, <span class=\"title\">UIApplicationDelegate</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> window: <span class=\"type\">UIWindow</span>?</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">application</span><span class=\"params\">(<span class=\"number\">_</span> application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?)</span></span> -&gt; <span class=\"type\">Bool</span> &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"type\">StartupCommandsBuilder</span>()</span><br><span class=\"line\">            .setKeyWindow(window!)</span><br><span class=\"line\">            .build()</span><br><span class=\"line\">            .forEach &#123; $<span class=\"number\">0</span>.execute() &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>新命令可以不需要修改 AppDelegate 直接添加到<strong>StartupCommandsBuilder</strong>。<br>\n这个解决方案满足定义的条件：</p>\n<ul>\n<li>每个命令有自己的职责</li>\n<li>无需修改 AppDelegate 的代码就可以方便添加新命令</li>\n<li>命令易于测试</li>\n</ul>\n<h2>Recipe #2: Composite Design Pattern</h2>\n<p>复合设计模式（Composite Design Pattern）允许将对象的层级结构视为单例。举个例子就像 iOS 里的<strong>UIView</strong>和它的子类视图。<br>\n主体思想是复合类和子 AppDelegate 各自拥有职责，同时复合类将所有方法传递到子类。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typealias</span> <span class=\"type\">AppDelegateType</span> = <span class=\"type\">UIResponder</span> &amp; <span class=\"type\">UIApplicationDelegate</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CompositeAppDelegate</span>: <span class=\"title\">AppDelegateType</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">let</span> appDelegates: [<span class=\"type\">AppDelegateType</span>]</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">init</span>(appDelegates: [<span class=\"type\">AppDelegateType</span>]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.appDelegates = appDelegates</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">application</span><span class=\"params\">(<span class=\"number\">_</span> application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey : Any]? = <span class=\"literal\">nil</span>)</span></span> -&gt; <span class=\"type\">Bool</span> &#123;</span><br><span class=\"line\">        appDelegates.forEach &#123; <span class=\"number\">_</span> = $<span class=\"number\">0</span>.application?(application, didFinishLaunchingWithOptions: launchOptions) &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">application</span><span class=\"params\">(<span class=\"number\">_</span> application: UIApplication, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data)</span></span> &#123;</span><br><span class=\"line\">        appDelegates.forEach &#123; $<span class=\"number\">0</span>.application?(application, didRegisterForRemoteNotificationsWithDeviceToken: deviceToken) &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后，子 AppDelegates 实现真正的任务，</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PushNotificationAppDelegate</span>: <span class=\"title\">AppDelegateType</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">application</span><span class=\"params\">(<span class=\"number\">_</span> application: UIApplication, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"Registed successfully\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StartupConfiguratorAppDelegate</span>: <span class=\"title\">AppDelegateType</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">application</span><span class=\"params\">(<span class=\"number\">_</span> application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey : Any]? = <span class=\"literal\">nil</span>)</span></span> -&gt; <span class=\"type\">Bool</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"Perform startup configurations, e.g. build UI stack, setup UIAppearance\"</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ThirdPartiesConfiguratorAppDelegate</span>: <span class=\"title\">AppDelegateType</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">application</span><span class=\"params\">(<span class=\"number\">_</span> application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey : Any]? = <span class=\"literal\">nil</span>)</span></span> -&gt; <span class=\"type\">Bool</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"Setup third parties\"</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们定义<strong>AppDelegateFactory</strong>封装创建逻辑，主 AppDelegate 通过这个工厂类创建组合代理，调用所有的方法，</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">AppDelegateFactory</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">makeDefault</span><span class=\"params\">()</span></span> -&gt; <span class=\"type\">AppDelegateType</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"type\">CompositeAppDelegate</span>(appDelegates: [<span class=\"type\">PushNotificationAppDelegate</span>(), <span class=\"type\">StartupConfiguratorAppDelegate</span>(), <span class=\"type\">ThirdPartiesConfiguratorAppDelegate</span>()])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@UIApplicationMain</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AppDelegate</span>: <span class=\"title\">UIResponder</span>, <span class=\"title\">UIApplicationDelegate</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> window: <span class=\"type\">UIWindow</span>?</span><br><span class=\"line\">    <span class=\"keyword\">let</span> appDelegate = <span class=\"type\">AppDelegateFactory</span>.makeDefault()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">application</span><span class=\"params\">(<span class=\"number\">_</span> application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?)</span></span> -&gt; <span class=\"type\">Bool</span> &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"number\">_</span> = appDelegate.application?(application, didFinishLaunchingWithOptions: launchOptions)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">application</span><span class=\"params\">(<span class=\"number\">_</span> application: UIApplication, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data)</span></span> &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        appDelegate.application?(application, didRegisterForRemoteNotificationsWithDeviceToken: deviceToken)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个方法实现了我们开始定义的条件：</p>\n<ul>\n<li>每个子 AppDelegate 有个自己的职责</li>\n<li>无需修改 AppDelegate 的代码就可以方便添加新代理</li>\n<li>易于测试</li>\n</ul>\n<h2>Recipe #3: Mediator Design Pattern</h2>\n<p>中介者设计模式（Mediator Design Pattern）通过一个隐蔽无约束的方法封装交互策略。对象被中介者无意识操作，无需他们的许可情况下就可以在幕后默默地推行自己的政策。<br>\n如果你想要更多学习这个模式，推荐你阅读 <a href=\"http://www.vadimbulavin.com/mediator-pattern-case-study/\" target=\"_blank\" rel=\"noopener\">Mediator Pattern Case Study</a><br>\n定义<strong>AppLifecycleMediator</strong>将<strong>UIApplication</strong>生命周期活动传递到底层监听器，监听器必须遵循必要时可被扩展的<strong>AppLifecycleListener</strong>协议</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">AppLifecycleListener</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">onAppWillEnterForeground</span><span class=\"params\">()</span></span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">onAppDidEnterBackground</span><span class=\"params\">()</span></span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">onAppDidFinishLaunching</span><span class=\"params\">()</span></span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">AppLifecycleListener</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">onAppWillEnterForeground</span><span class=\"params\">()</span></span> &#123;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">onAppDidEnterBackground</span><span class=\"params\">()</span></span> &#123;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">onAppDidFinishLaunching</span><span class=\"params\">()</span></span> &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">listen1</span>: <span class=\"title\">AppLifecycleListener</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">onAppDidFinishLaunching</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"app did finish launching1\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">onAppWillEnterForeground</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"app will enter foreground\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">listen2</span>: <span class=\"title\">AppLifecycleListener</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">onAppDidEnterBackground</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"app did enter background\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">listen3</span>: <span class=\"title\">AppLifecycleListener</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">onAppDidFinishLaunching</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"app did finish launching2\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AppLifecycleMediator</span>: <span class=\"title\">NSObject</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">let</span> listeners: [<span class=\"type\">AppLifecycleListener</span>]</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">init</span>(listeners: [<span class=\"type\">AppLifecycleListener</span>]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.listeners = listeners</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.<span class=\"keyword\">init</span>()</span><br><span class=\"line\">        subscribe()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">deinit</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">NotificationCenter</span>.<span class=\"keyword\">default</span>.removeObserver(<span class=\"keyword\">self</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">subscribe</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"type\">NotificationCenter</span>.<span class=\"keyword\">default</span>.addObserver(<span class=\"keyword\">self</span>, selector: #selector(onAppWillEnterForeground), name: <span class=\"type\">UIApplication</span>.willEnterForegroundNotification, object: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">        <span class=\"type\">NotificationCenter</span>.<span class=\"keyword\">default</span>.addObserver(<span class=\"keyword\">self</span>, selector: #selector(onAppDidEnterBackground), name: <span class=\"type\">UIApplication</span>.didEnterBackgroundNotification, object: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">        <span class=\"type\">NotificationCenter</span>.<span class=\"keyword\">default</span>.addObserver(<span class=\"keyword\">self</span>, selector: #selector(onAppDidFinishLaunching), name: <span class=\"type\">UIApplication</span>.didFinishLaunchingNotification, object: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@objc</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">onAppWillEnterForeground</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        listeners.forEach &#123; $<span class=\"number\">0</span>.onAppWillEnterForeground() &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@objc</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">onAppDidEnterBackground</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        listeners.forEach &#123; $<span class=\"number\">0</span>.onAppDidEnterBackground() &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@objc</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">onAppDidFinishLaunching</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        listeners.forEach &#123; $<span class=\"number\">0</span>.onAppDidFinishLaunching() &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">AppLifecycleMediator</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">makeDefaultMediator</span><span class=\"params\">()</span></span> -&gt; <span class=\"type\">AppLifecycleMediator</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"type\">AppLifecycleMediator</span>(listeners: [listen1(), listen2(), listen3()])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在就可以通过一行代码添加到<strong>AppDelegate</strong></p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@UIApplicationMain</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AppDelegate</span>: <span class=\"title\">UIResponder</span>, <span class=\"title\">UIApplicationDelegate</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> window: <span class=\"type\">UIWindow</span>?</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> mediator = <span class=\"type\">AppLifecycleMediator</span>.makeDefaultMediator()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">application</span><span class=\"params\">(<span class=\"number\">_</span> application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?)</span></span> -&gt; <span class=\"type\">Bool</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>中介者自动订阅所有事件，<strong>AppDelegate</strong>仅需要初始化让他工作。<br>\n这种方式满足我们开始定义的条件：</p>\n<ul>\n<li>每个监听者有自己的职责</li>\n<li>无需修改 AppDelegate 代码就可以添加新监听者</li>\n<li>每个模块都易于测试</li>\n</ul>\n<h1>Summary</h1>\n<p>大多数<strong>AppDelegate</strong>都过于庞大，过于复杂，担有太多职责，通过软件设计模式，<strong>AppDelegate</strong>可以被划分为多个类，各自拥有各自的职责，同时方便测试。这样的代码非常容易修改，而且非常灵活，可以在将来提取和复用。</p>\n<h1>Reference</h1>\n<p><a href=\"http://www.vadimbulavin.com/refactoring-massive-app-delegate/\" target=\"_blank\" rel=\"noopener\">Refactoring Massive App Delegate</a></p>\n"},{"title":"设计模式那点事","catalog":true,"toc_nav_num":true,"date":"2019-03-26T03:19:05.000Z","subtitle":"Talk About Design Pattern","header-img":"/img/article_header/article_header.png","busuanzi":true,"_content":"\n> 设计模式 Design Pattern 是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结，使用设计模式是为了代码可重用性、让代码更容易被理解、保证代码可靠性。\n\n# 为什么要学习设计模式\n\n- 设计模式来源于众多专家的经验和智慧，是从许多优秀的软件系统中总结出的成功的、能够实现可维护性复用的设计方案，使用这些方案将可以避免让我们做一些重复性的工作\n\n- 设计模式提供了一条通用的设计词汇和一种通用的形式来方便开发人员之间的沟通和交流，是的设计方案更加通俗易懂\n\n- 大部分设计模式都兼顾了系统的可重用性和可扩展性，这使得我们可以更好地重用一些已有的设计方案、功能模块甚至一个完整的软件系统，避免我们经常做一系重复的设计、编写一些重复的代码\n\n- 合理使用设计模式并对设计模式的使用情况进行文档化，将有助于别人更快的理解系统\n\n- 将有助于初学者更加深入地理解面向对象思想\n\n# 六大设计原则\n\n## 单一职责原则\n\n一个类只负责一件事。\n比如说系统为我们实现的 UIView 与 CALayer 这两个类，UIView 专门负责事件传递和事件响应，而 CALayer 专门负责动画以及视图的显现。\n\n## 依赖倒置原则\n\n抽象不应该依赖于具体实现，具体实现可以依赖于抽象。\n换言之，要针对接口编程，而不是针对实现编程。在程序代码中传递参数时或在关联关系时，尽量引用层次高的抽象层类，即使用接口和抽象类进行变量声明、参数类型声明、方法返回类型声明，以及数据类型的转换等，而不要用具体类来做这些事情。\n\n## 开闭原则\n\n对修改关闭，对扩展开放。\n当我们定义一个类时，应该尽量考虑到这个类的可扩展性和灵活性，在考虑到当前需求的同时需要考虑后续多个版本迭代需求，需要对类的成员变量以及数据结构尽可能在不改动的情况下通过扩展的方式或者提供接口的方式解决后续的需求问题。\n\n## 里氏替换原则\n\n父类可以被子类无缝替换，且原有功能不受任何影响。\n比如 KVO 实现原理，当我们对一个对象进行 addObserver 观察的时候，系统为我们在动态运行时创建一个子类，当我们以为我们观察的是我们的父类，其实已经被悄无声息的替换成对应的子类。\n\n## 接口隔离原则\n\n使用多个专门的协议、而不是一个庞大臃肿的协议。\n比如我们经常使用的 UITableViewDelegate 与 UITableViewDataSource 这两个协议，UITableViewDelegate 专门负责 UITableView 的代理回调事件，而 UITableViewDataSource 专门负责数据源的获取，协议中的方法应当尽量少，从而避免一个庞大臃肿的协议。\n\n## 迪米特法则\n\n一个对象应当对其他对象有尽可能少的了解。\n高内聚，低耦合。通过降低类与类之间的耦合，减少类与类之间的关联程度，可以让类与类之间的协作更加直接，更容易修改和复用。\n\n# 设计模式分类\n\n## 创建型\n\n创建型模式(Creational Pattern)对类的实例化过程进行了抽象，能够将木块中对象的创建和对象的使用分离。为了是结构更加清晰，外界对于这些对象只需要知道它们的共同接口，而不需要知道具体的实现细节，使整个系统的设计更加符合单一职责原则。\n\n- 简单工厂模式\n- 工厂方法模式\n- 抽象工厂模式\n- 单例模式\n- 生成器模式\n- 原型模式\n\n### 单例\n\n单例模式需要确保某个类有且仅有一个实例，并提供一个访问它的全局访问点。\n注意点主要就是他的唯一性。\n\n```objectivec\n#pragma mark ----- SingleInstance.h -----\n\n@interface SingleInstance : NSObject\n\n+ (id)sharedInstance;\n\n@end\n```\n\n```objectivec\n#pragma mark ----- SingleInstance.m -----\n\n@implementation SingleInstance\n\n+ (id)sharedInstance\n{\n    // 静态局部变量\n    static Mooc *instance = nil;\n    \n    // 通过dispatch_once方式 确保instance在多线程环境下只被创建一次\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        // 创建实例\n        instance = [[super allocWithZone:NULL] init];\n    });\n    return instance;\n}\n\n// 重写方法【必不可少】\n+ (id)allocWithZone:(struct _NSZone *)zone{\n    return [self sharedInstance];\n}\n\n// 重写方法【必不可少】\n- (id)copyWithZone:(nullable NSZone *)zone{\n    return self;\n}\n\n@end\n```\n\n## 结构型\n\n结构型模式(Structural Pattern)描述如何将类或者对象结合在一起形成更大的结构，可以分为类结构型模式和对象结构性模式：\n- 类结构型模式关心类的组合，由多个类可以组合成一个更大的系统，在类机构型模式中一般只存在继承和实现关系。\n- 对象结构型模式关心类与对象的组合，通过关联关系使得在一个类中定义另一个类的实例对象，然后通过该对象调用其方法。\n结构型模式有以下几类：\n- 外观模式\n- 适配器模式\n- 桥接模式\n- 代理模式\n- 装饰者模式\n- 享元模式\n\n### 桥接\n\n举例：一个关于业务解耦的问题，一个列表需要分别适配几种网络数据类型。\n方案：创建两个抽象类 BaseObjectA 与 BaseObjectB，分别解决数据获取和逻辑处理，通过子类(BaseObjectA1..., BaseObjectB1...)完成具体实现，然后将两个类组装，完成业务解耦，同时可以实现多种业务场景需求。\n```objectivec\n#pragma mark ----- BaseObjectA.h -----\n\n@interface BaseObjectA : NSObject\n\n// 桥接模式的核心实现\n@property (nonatomic, strong) BaseObjectB *objB;\n\n// 获取数据\n- (void)handle;\n\n@end\n```\n\n```objectivec\n#pragma mark ----- BaseObjectA.m -----\n\n@implementation BaseObjectA\n\n /*\n    A1 --> B1、B2、B3         3种\n    A2 --> B1、B2、B3         3种\n    A3 --> B1、B2、B3         3种\n  */\n- (void)handle\n{\n    // override to subclass\n    \n    [self.objB fetchData];\n}\n\n@end\n```\n\n```objectivec\n#pragma mark ----- BaseObjectB.h -----\n\n@interface BaseObjectB : NSObject\n\n- (void)fetchData;\n\n@end\n```\n\n```objectivec\n#pragma mark ----- BaseObjectB.m -----\n\n@implementation BaseObjectB\n\n- (void)fetchData\n{\n    // override to subclass\n}\n\n@end\n```\n\n调用桥接类\n```objectivec\n#pragma mark ----- BridgeDemo.h -----\n\n@interface BridgeDemo : NSObject\n\n- (void)fetch;\n\n@end\n```\n\n```objectivec\n#pragma mark ----- BridgeDemo.m -----\n\n@interface BridgeDemo()\n\n@property (nonatomic, strong) BaseObjectA *objA;\n\n@end\n\n@implementation BridgeDemo\n\n/*\n 根据实际业务判断使用那套具体数据\n A1 --> B1、B2、B3         3种\n A2 --> B1、B2、B3         3种\n A3 --> B1、B2、B3         3种\n */\n- (void)fetch\n{\n    // 创建一个具体的ClassA\n    _objA = [[ObjectA1 alloc] init];\n    \n    // 创建一个具体的ClassB\n    BaseObjectB *b1 = [[ObjectB1 alloc] init];\n    // 将一个具体的ClassB1 指定给抽象的ClassB\n    _objA.objB = b1;\n    \n    // 获取数据\n    [_objA handle];\n}\n\n@end\n```\n\n### 适配器\n\n\n\n被适配类（不应修改的类）\n```objectivec\n#pragma mark ----- Target.h -----\n\n@interface Target : NSObject\n\n- (void)operation;\n\n@end\n```\n\n```objectivec\n#pragma mark ----- Target.m -----\n\n@implementation Target\n\n- (void)operation\n{\n    // 原有的具体业务逻辑\n}\n\n@end\n```\n\n适配类\n```objectivec\n#pragma mark ----- CoolTarget.h -----\n\n// 适配对象\n@interface CoolTarget : NSObject\n\n// 被适配对象\n@property (nonatomic, strong) Target *target;\n\n// 对原有方法包装\n- (void)request;\n\n@end\n```\n\n```objectivec\n#pragma mark ----- CoolTarget.m -----\n\n@implementation CoolTarget\n\n- (void)request\n{\n    // 额外处理\n    \n    [self.target operation];\n    \n    // 额外处理\n}\n\n@end\n```\n\n## 行为型\n\n行为型模式(Behavioral Pattern)是对在不同对象之间划分责任和算法的抽象化，更加清晰地划分类与对象的职责，并研究系统在运行时实例对象之间的交互。\n\n- 责任链模式\n- 命令模式\n- 解释器模式\n- 迭代器模式\n- 中介者模式\n- 备忘录模式\n- 观察者模式\n- 状态模式\n- 策略模式\n- 模板方法模式\n- 访问者模式\n\n### 责任链\n\n一个类的成员变量中包含这个类（同类型）构成了责任链的基础数据类型。\n\n```objectivec\n#pragma mark ----- BusinessObject.h -----\n\n@class BusinessObject;\n\ntypedef void (^CompletionBlock)(BOOL handled);\ntypedef void (^ResultBlock)(BusinessObject * __nullable handler, BOOL handled);\n\n@interface BusinessObject : NSObject\n\n// 下一个响应者\n@property (nonatomic, strong) BusinessObject *nextBusiness;\n\n// 响应者的处理\n- (void)handle:(ResultBlock)result;\n\n// 各个业务中的具体处理\n- (void)handleBusiness:(CompletionBlock)completion;\n\n@end\n```\n\n```objectivec\n#pragma mark ----- BusinessObject.m -----\n\n@implementation BusinessObject\n\n- (void)handle:(ResultBlock)result {\n    CompletionBlock completion = ^(BOOL handled) {\n        if (handled) {\n            result(self, handled);\n        } else {\n            if (self.nextBusiness) {\n                [self.nextBusiness handle:result];\n            } else {\n                result(nil, NO);\n            }\n        }\n    };\n    [self handleBusiness:completion];\n}\n\n\n- (void)handleBusiness:(CompletionBlock)completion {\n    // 业务逻辑处理\n}\n\n@end\n```\n\n通过对下一个响应者(nextBusiness)的赋值，实现具体职责的实现顺序。我们可以通过后台服务器配置对应的职责顺序，同时代码中通过类名分别对应相应的业务，实现动态控制相应职责的执行顺序。\n\n### 命令\n\n命令模式可以将行为参数化，降低代码重合度。\n\n声明一个抽象命令类，子类可以继承该类实现具体的业务逻辑行为。\n```objectivec\n#pragma mark ----- Command.h -----\n\n@class Command;\ntypedef void(^CommandCompletionCallBack)(Command* cmd);\n\n@interface Command : NSObject\n@property (nonatomic, copy) CommandCompletionCallBack completion;\n\n- (void)execute;\n- (void)cancel;\n\n- (void)done;\n\n@end\n```\n\n```objectivec\n#pragma mark ----- Command.m -----\n\n@implementation Command\n\n- (void)execute{\n    //override to subclass;\n    [self done];\n}\n\n- (void)cancel {\n    self.completion = nil;\n}\n\n- (void)done {\n    dispatch_async(dispatch_get_main_queue(), ^{\n        if (_completion) {\n            _completion(self);\n        }\n        //释放\n        self.completion = nil;\n        [[CommandManager sharedInstance].arrayCommands removeObject:self];\n    });\n}\n\n@end\n```\n\n再声明一个管理命令的单例类，允许全局控制命令的实行、取消实行。\n\n```objectivec\n#pragma mark ----- CommandManager.h -----\n\n@interface CommandManager : NSObject\n\n// 命令管理容器\n@property (nonatomic, strong) NSMutableArray <Command*> *arrayCommands;\n\n// 命令管理者以单例方式呈现\n+ (instancetype)sharedInstance;\n\n// 执行命令\n+ (void)executeCommand:(Command *)cmd completion:(CommandCompletionCallBack)completion;\n\n// 取消命令\n+ (void)cancelCommand:(Command *)cmd;\n\n@end\n```\n\n```objectivec\n@implementation CommandManager\n\n// 命令管理者以单例方式呈现\n+ (instancetype)sharedInstance {\n    static CommandManager *instance = nil;\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        instance = [[super allocWithZone:NULL] init];\n    });\n    return instance;\n}\n\n// 【必不可少】\n+ (id)allocWithZone:(struct _NSZone *)zone {\n    return [self sharedInstance];\n}\n\n// 【必不可少】\n- (id)copyWithZone:(nullable NSZone *)zone {\n    return self;\n}\n\n// 初始化方法\n- (id)init {\n    self = [super init];\n    if (self) {\n        // 初始化命令容器\n        _arrayCommands = [NSMutableArray array];\n    }\n    return self;\n}\n\n+ (void)executeCommand:(Command *)cmd completion:(CommandCompletionCallBack)completion {\n    if (cmd) {\n        // 如果命令正在执行不做处理，否则添加并执行命令\n        if (![self _isExecutingCommand:cmd]) {\n            // 添加到命令容器当中\n            [[[self sharedInstance] arrayCommands] addObject:cmd];\n            // 设置命令执行完成的回调\n            cmd.completion = completion;\n            //执行命令\n            [cmd execute];\n        }\n    }\n}\n\n// 取消命令\n+ (void)cancelCommand:(Command *)cmd {\n    if (cmd) {\n        // 从命令容器当中移除\n        [[[self sharedInstance] arrayCommands] removeObject:cmd];\n        // 取消命令执行\n        [cmd cancel];\n    }\n}\n\n// 判断当前命令是否正在执行\n+ (BOOL)_isExecutingCommand:(Command *)cmd {\n    if (cmd) {\n        NSArray *cmds = [[self sharedInstance] arrayCommands];\n        for (Command *aCmd in cmds) {\n            // 当前命令正在执行\n            if (cmd == aCmd) {\n                return YES;\n            }\n        }\n    }\n    return NO;\n}\n\n@end\n```\n\n# 结语\n\n设计模式主要就分析这么多，主要需要记住六大设计原则和一些主要的设计模式，能够在遇到问题时灵活运用才是关键。\n\n# 引用\n\n[学习并理解 23 种设计模式](https://github.com/xietao3/Study-Plan/blob/master/DesignPatterns/README.md)","source":"_posts/2019/talk-about-design-pattern-0326.md","raw":"---\ntitle: 设计模式那点事\ncatalog: true\ntoc_nav_num: true\ndate: 2019-03-26 11:19:05\nsubtitle: \"Talk About Design Pattern\"\nheader-img: \"/img/article_header/article_header.png\"\nbusuanzi: true\ntags:\n- iOS - Objective-C\n\n---\n\n> 设计模式 Design Pattern 是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结，使用设计模式是为了代码可重用性、让代码更容易被理解、保证代码可靠性。\n\n# 为什么要学习设计模式\n\n- 设计模式来源于众多专家的经验和智慧，是从许多优秀的软件系统中总结出的成功的、能够实现可维护性复用的设计方案，使用这些方案将可以避免让我们做一些重复性的工作\n\n- 设计模式提供了一条通用的设计词汇和一种通用的形式来方便开发人员之间的沟通和交流，是的设计方案更加通俗易懂\n\n- 大部分设计模式都兼顾了系统的可重用性和可扩展性，这使得我们可以更好地重用一些已有的设计方案、功能模块甚至一个完整的软件系统，避免我们经常做一系重复的设计、编写一些重复的代码\n\n- 合理使用设计模式并对设计模式的使用情况进行文档化，将有助于别人更快的理解系统\n\n- 将有助于初学者更加深入地理解面向对象思想\n\n# 六大设计原则\n\n## 单一职责原则\n\n一个类只负责一件事。\n比如说系统为我们实现的 UIView 与 CALayer 这两个类，UIView 专门负责事件传递和事件响应，而 CALayer 专门负责动画以及视图的显现。\n\n## 依赖倒置原则\n\n抽象不应该依赖于具体实现，具体实现可以依赖于抽象。\n换言之，要针对接口编程，而不是针对实现编程。在程序代码中传递参数时或在关联关系时，尽量引用层次高的抽象层类，即使用接口和抽象类进行变量声明、参数类型声明、方法返回类型声明，以及数据类型的转换等，而不要用具体类来做这些事情。\n\n## 开闭原则\n\n对修改关闭，对扩展开放。\n当我们定义一个类时，应该尽量考虑到这个类的可扩展性和灵活性，在考虑到当前需求的同时需要考虑后续多个版本迭代需求，需要对类的成员变量以及数据结构尽可能在不改动的情况下通过扩展的方式或者提供接口的方式解决后续的需求问题。\n\n## 里氏替换原则\n\n父类可以被子类无缝替换，且原有功能不受任何影响。\n比如 KVO 实现原理，当我们对一个对象进行 addObserver 观察的时候，系统为我们在动态运行时创建一个子类，当我们以为我们观察的是我们的父类，其实已经被悄无声息的替换成对应的子类。\n\n## 接口隔离原则\n\n使用多个专门的协议、而不是一个庞大臃肿的协议。\n比如我们经常使用的 UITableViewDelegate 与 UITableViewDataSource 这两个协议，UITableViewDelegate 专门负责 UITableView 的代理回调事件，而 UITableViewDataSource 专门负责数据源的获取，协议中的方法应当尽量少，从而避免一个庞大臃肿的协议。\n\n## 迪米特法则\n\n一个对象应当对其他对象有尽可能少的了解。\n高内聚，低耦合。通过降低类与类之间的耦合，减少类与类之间的关联程度，可以让类与类之间的协作更加直接，更容易修改和复用。\n\n# 设计模式分类\n\n## 创建型\n\n创建型模式(Creational Pattern)对类的实例化过程进行了抽象，能够将木块中对象的创建和对象的使用分离。为了是结构更加清晰，外界对于这些对象只需要知道它们的共同接口，而不需要知道具体的实现细节，使整个系统的设计更加符合单一职责原则。\n\n- 简单工厂模式\n- 工厂方法模式\n- 抽象工厂模式\n- 单例模式\n- 生成器模式\n- 原型模式\n\n### 单例\n\n单例模式需要确保某个类有且仅有一个实例，并提供一个访问它的全局访问点。\n注意点主要就是他的唯一性。\n\n```objectivec\n#pragma mark ----- SingleInstance.h -----\n\n@interface SingleInstance : NSObject\n\n+ (id)sharedInstance;\n\n@end\n```\n\n```objectivec\n#pragma mark ----- SingleInstance.m -----\n\n@implementation SingleInstance\n\n+ (id)sharedInstance\n{\n    // 静态局部变量\n    static Mooc *instance = nil;\n    \n    // 通过dispatch_once方式 确保instance在多线程环境下只被创建一次\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        // 创建实例\n        instance = [[super allocWithZone:NULL] init];\n    });\n    return instance;\n}\n\n// 重写方法【必不可少】\n+ (id)allocWithZone:(struct _NSZone *)zone{\n    return [self sharedInstance];\n}\n\n// 重写方法【必不可少】\n- (id)copyWithZone:(nullable NSZone *)zone{\n    return self;\n}\n\n@end\n```\n\n## 结构型\n\n结构型模式(Structural Pattern)描述如何将类或者对象结合在一起形成更大的结构，可以分为类结构型模式和对象结构性模式：\n- 类结构型模式关心类的组合，由多个类可以组合成一个更大的系统，在类机构型模式中一般只存在继承和实现关系。\n- 对象结构型模式关心类与对象的组合，通过关联关系使得在一个类中定义另一个类的实例对象，然后通过该对象调用其方法。\n结构型模式有以下几类：\n- 外观模式\n- 适配器模式\n- 桥接模式\n- 代理模式\n- 装饰者模式\n- 享元模式\n\n### 桥接\n\n举例：一个关于业务解耦的问题，一个列表需要分别适配几种网络数据类型。\n方案：创建两个抽象类 BaseObjectA 与 BaseObjectB，分别解决数据获取和逻辑处理，通过子类(BaseObjectA1..., BaseObjectB1...)完成具体实现，然后将两个类组装，完成业务解耦，同时可以实现多种业务场景需求。\n```objectivec\n#pragma mark ----- BaseObjectA.h -----\n\n@interface BaseObjectA : NSObject\n\n// 桥接模式的核心实现\n@property (nonatomic, strong) BaseObjectB *objB;\n\n// 获取数据\n- (void)handle;\n\n@end\n```\n\n```objectivec\n#pragma mark ----- BaseObjectA.m -----\n\n@implementation BaseObjectA\n\n /*\n    A1 --> B1、B2、B3         3种\n    A2 --> B1、B2、B3         3种\n    A3 --> B1、B2、B3         3种\n  */\n- (void)handle\n{\n    // override to subclass\n    \n    [self.objB fetchData];\n}\n\n@end\n```\n\n```objectivec\n#pragma mark ----- BaseObjectB.h -----\n\n@interface BaseObjectB : NSObject\n\n- (void)fetchData;\n\n@end\n```\n\n```objectivec\n#pragma mark ----- BaseObjectB.m -----\n\n@implementation BaseObjectB\n\n- (void)fetchData\n{\n    // override to subclass\n}\n\n@end\n```\n\n调用桥接类\n```objectivec\n#pragma mark ----- BridgeDemo.h -----\n\n@interface BridgeDemo : NSObject\n\n- (void)fetch;\n\n@end\n```\n\n```objectivec\n#pragma mark ----- BridgeDemo.m -----\n\n@interface BridgeDemo()\n\n@property (nonatomic, strong) BaseObjectA *objA;\n\n@end\n\n@implementation BridgeDemo\n\n/*\n 根据实际业务判断使用那套具体数据\n A1 --> B1、B2、B3         3种\n A2 --> B1、B2、B3         3种\n A3 --> B1、B2、B3         3种\n */\n- (void)fetch\n{\n    // 创建一个具体的ClassA\n    _objA = [[ObjectA1 alloc] init];\n    \n    // 创建一个具体的ClassB\n    BaseObjectB *b1 = [[ObjectB1 alloc] init];\n    // 将一个具体的ClassB1 指定给抽象的ClassB\n    _objA.objB = b1;\n    \n    // 获取数据\n    [_objA handle];\n}\n\n@end\n```\n\n### 适配器\n\n\n\n被适配类（不应修改的类）\n```objectivec\n#pragma mark ----- Target.h -----\n\n@interface Target : NSObject\n\n- (void)operation;\n\n@end\n```\n\n```objectivec\n#pragma mark ----- Target.m -----\n\n@implementation Target\n\n- (void)operation\n{\n    // 原有的具体业务逻辑\n}\n\n@end\n```\n\n适配类\n```objectivec\n#pragma mark ----- CoolTarget.h -----\n\n// 适配对象\n@interface CoolTarget : NSObject\n\n// 被适配对象\n@property (nonatomic, strong) Target *target;\n\n// 对原有方法包装\n- (void)request;\n\n@end\n```\n\n```objectivec\n#pragma mark ----- CoolTarget.m -----\n\n@implementation CoolTarget\n\n- (void)request\n{\n    // 额外处理\n    \n    [self.target operation];\n    \n    // 额外处理\n}\n\n@end\n```\n\n## 行为型\n\n行为型模式(Behavioral Pattern)是对在不同对象之间划分责任和算法的抽象化，更加清晰地划分类与对象的职责，并研究系统在运行时实例对象之间的交互。\n\n- 责任链模式\n- 命令模式\n- 解释器模式\n- 迭代器模式\n- 中介者模式\n- 备忘录模式\n- 观察者模式\n- 状态模式\n- 策略模式\n- 模板方法模式\n- 访问者模式\n\n### 责任链\n\n一个类的成员变量中包含这个类（同类型）构成了责任链的基础数据类型。\n\n```objectivec\n#pragma mark ----- BusinessObject.h -----\n\n@class BusinessObject;\n\ntypedef void (^CompletionBlock)(BOOL handled);\ntypedef void (^ResultBlock)(BusinessObject * __nullable handler, BOOL handled);\n\n@interface BusinessObject : NSObject\n\n// 下一个响应者\n@property (nonatomic, strong) BusinessObject *nextBusiness;\n\n// 响应者的处理\n- (void)handle:(ResultBlock)result;\n\n// 各个业务中的具体处理\n- (void)handleBusiness:(CompletionBlock)completion;\n\n@end\n```\n\n```objectivec\n#pragma mark ----- BusinessObject.m -----\n\n@implementation BusinessObject\n\n- (void)handle:(ResultBlock)result {\n    CompletionBlock completion = ^(BOOL handled) {\n        if (handled) {\n            result(self, handled);\n        } else {\n            if (self.nextBusiness) {\n                [self.nextBusiness handle:result];\n            } else {\n                result(nil, NO);\n            }\n        }\n    };\n    [self handleBusiness:completion];\n}\n\n\n- (void)handleBusiness:(CompletionBlock)completion {\n    // 业务逻辑处理\n}\n\n@end\n```\n\n通过对下一个响应者(nextBusiness)的赋值，实现具体职责的实现顺序。我们可以通过后台服务器配置对应的职责顺序，同时代码中通过类名分别对应相应的业务，实现动态控制相应职责的执行顺序。\n\n### 命令\n\n命令模式可以将行为参数化，降低代码重合度。\n\n声明一个抽象命令类，子类可以继承该类实现具体的业务逻辑行为。\n```objectivec\n#pragma mark ----- Command.h -----\n\n@class Command;\ntypedef void(^CommandCompletionCallBack)(Command* cmd);\n\n@interface Command : NSObject\n@property (nonatomic, copy) CommandCompletionCallBack completion;\n\n- (void)execute;\n- (void)cancel;\n\n- (void)done;\n\n@end\n```\n\n```objectivec\n#pragma mark ----- Command.m -----\n\n@implementation Command\n\n- (void)execute{\n    //override to subclass;\n    [self done];\n}\n\n- (void)cancel {\n    self.completion = nil;\n}\n\n- (void)done {\n    dispatch_async(dispatch_get_main_queue(), ^{\n        if (_completion) {\n            _completion(self);\n        }\n        //释放\n        self.completion = nil;\n        [[CommandManager sharedInstance].arrayCommands removeObject:self];\n    });\n}\n\n@end\n```\n\n再声明一个管理命令的单例类，允许全局控制命令的实行、取消实行。\n\n```objectivec\n#pragma mark ----- CommandManager.h -----\n\n@interface CommandManager : NSObject\n\n// 命令管理容器\n@property (nonatomic, strong) NSMutableArray <Command*> *arrayCommands;\n\n// 命令管理者以单例方式呈现\n+ (instancetype)sharedInstance;\n\n// 执行命令\n+ (void)executeCommand:(Command *)cmd completion:(CommandCompletionCallBack)completion;\n\n// 取消命令\n+ (void)cancelCommand:(Command *)cmd;\n\n@end\n```\n\n```objectivec\n@implementation CommandManager\n\n// 命令管理者以单例方式呈现\n+ (instancetype)sharedInstance {\n    static CommandManager *instance = nil;\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        instance = [[super allocWithZone:NULL] init];\n    });\n    return instance;\n}\n\n// 【必不可少】\n+ (id)allocWithZone:(struct _NSZone *)zone {\n    return [self sharedInstance];\n}\n\n// 【必不可少】\n- (id)copyWithZone:(nullable NSZone *)zone {\n    return self;\n}\n\n// 初始化方法\n- (id)init {\n    self = [super init];\n    if (self) {\n        // 初始化命令容器\n        _arrayCommands = [NSMutableArray array];\n    }\n    return self;\n}\n\n+ (void)executeCommand:(Command *)cmd completion:(CommandCompletionCallBack)completion {\n    if (cmd) {\n        // 如果命令正在执行不做处理，否则添加并执行命令\n        if (![self _isExecutingCommand:cmd]) {\n            // 添加到命令容器当中\n            [[[self sharedInstance] arrayCommands] addObject:cmd];\n            // 设置命令执行完成的回调\n            cmd.completion = completion;\n            //执行命令\n            [cmd execute];\n        }\n    }\n}\n\n// 取消命令\n+ (void)cancelCommand:(Command *)cmd {\n    if (cmd) {\n        // 从命令容器当中移除\n        [[[self sharedInstance] arrayCommands] removeObject:cmd];\n        // 取消命令执行\n        [cmd cancel];\n    }\n}\n\n// 判断当前命令是否正在执行\n+ (BOOL)_isExecutingCommand:(Command *)cmd {\n    if (cmd) {\n        NSArray *cmds = [[self sharedInstance] arrayCommands];\n        for (Command *aCmd in cmds) {\n            // 当前命令正在执行\n            if (cmd == aCmd) {\n                return YES;\n            }\n        }\n    }\n    return NO;\n}\n\n@end\n```\n\n# 结语\n\n设计模式主要就分析这么多，主要需要记住六大设计原则和一些主要的设计模式，能够在遇到问题时灵活运用才是关键。\n\n# 引用\n\n[学习并理解 23 种设计模式](https://github.com/xietao3/Study-Plan/blob/master/DesignPatterns/README.md)","slug":"2019/talk-about-design-pattern-0326","published":1,"updated":"2022-01-10T09:04:52.810Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cky8gmc4j001hd1qh9h9su95q","content":"<blockquote>\n<p>设计模式 Design Pattern 是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结，使用设计模式是为了代码可重用性、让代码更容易被理解、保证代码可靠性。</p>\n</blockquote>\n<h1 id=\"为什么要学习设计模式\">为什么要学习设计模式</h1>\n<ul>\n<li>\n<p>设计模式来源于众多专家的经验和智慧，是从许多优秀的软件系统中总结出的成功的、能够实现可维护性复用的设计方案，使用这些方案将可以避免让我们做一些重复性的工作</p>\n</li>\n<li>\n<p>设计模式提供了一条通用的设计词汇和一种通用的形式来方便开发人员之间的沟通和交流，是的设计方案更加通俗易懂</p>\n</li>\n<li>\n<p>大部分设计模式都兼顾了系统的可重用性和可扩展性，这使得我们可以更好地重用一些已有的设计方案、功能模块甚至一个完整的软件系统，避免我们经常做一系重复的设计、编写一些重复的代码</p>\n</li>\n<li>\n<p>合理使用设计模式并对设计模式的使用情况进行文档化，将有助于别人更快的理解系统</p>\n</li>\n<li>\n<p>将有助于初学者更加深入地理解面向对象思想</p>\n</li>\n</ul>\n<h1 id=\"六大设计原则\">六大设计原则</h1>\n<h2 id=\"单一职责原则\">单一职责原则</h2>\n<p>一个类只负责一件事。<br>\n比如说系统为我们实现的 UIView 与 CALayer 这两个类，UIView 专门负责事件传递和事件响应，而 CALayer 专门负责动画以及视图的显现。</p>\n<h2 id=\"依赖倒置原则\">依赖倒置原则</h2>\n<p>抽象不应该依赖于具体实现，具体实现可以依赖于抽象。<br>\n换言之，要针对接口编程，而不是针对实现编程。在程序代码中传递参数时或在关联关系时，尽量引用层次高的抽象层类，即使用接口和抽象类进行变量声明、参数类型声明、方法返回类型声明，以及数据类型的转换等，而不要用具体类来做这些事情。</p>\n<h2 id=\"开闭原则\">开闭原则</h2>\n<p>对修改关闭，对扩展开放。<br>\n当我们定义一个类时，应该尽量考虑到这个类的可扩展性和灵活性，在考虑到当前需求的同时需要考虑后续多个版本迭代需求，需要对类的成员变量以及数据结构尽可能在不改动的情况下通过扩展的方式或者提供接口的方式解决后续的需求问题。</p>\n<h2 id=\"里氏替换原则\">里氏替换原则</h2>\n<p>父类可以被子类无缝替换，且原有功能不受任何影响。<br>\n比如 KVO 实现原理，当我们对一个对象进行 addObserver 观察的时候，系统为我们在动态运行时创建一个子类，当我们以为我们观察的是我们的父类，其实已经被悄无声息的替换成对应的子类。</p>\n<h2 id=\"接口隔离原则\">接口隔离原则</h2>\n<p>使用多个专门的协议、而不是一个庞大臃肿的协议。<br>\n比如我们经常使用的 UITableViewDelegate 与 UITableViewDataSource 这两个协议，UITableViewDelegate 专门负责 UITableView 的代理回调事件，而 UITableViewDataSource 专门负责数据源的获取，协议中的方法应当尽量少，从而避免一个庞大臃肿的协议。</p>\n<h2 id=\"迪米特法则\">迪米特法则</h2>\n<p>一个对象应当对其他对象有尽可能少的了解。<br>\n高内聚，低耦合。通过降低类与类之间的耦合，减少类与类之间的关联程度，可以让类与类之间的协作更加直接，更容易修改和复用。</p>\n<h1 id=\"设计模式分类\">设计模式分类</h1>\n<h2 id=\"创建型\">创建型</h2>\n<p>创建型模式(Creational Pattern)对类的实例化过程进行了抽象，能够将木块中对象的创建和对象的使用分离。为了是结构更加清晰，外界对于这些对象只需要知道它们的共同接口，而不需要知道具体的实现细节，使整个系统的设计更加符合单一职责原则。</p>\n<ul>\n<li>简单工厂模式</li>\n<li>工厂方法模式</li>\n<li>抽象工厂模式</li>\n<li>单例模式</li>\n<li>生成器模式</li>\n<li>原型模式</li>\n</ul>\n<h3 id=\"单例\">单例</h3>\n<p>单例模式需要确保某个类有且仅有一个实例，并提供一个访问它的全局访问点。<br>\n注意点主要就是他的唯一性。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#pragma mark ----- SingleInstance.h -----</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">SingleInstance</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">+ (<span class=\"keyword\">id</span>)sharedInstance;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#pragma mark ----- SingleInstance.m -----</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">SingleInstance</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">+ (<span class=\"keyword\">id</span>)sharedInstance</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 静态局部变量</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> Mooc *instance = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 通过dispatch_once方式 确保instance在多线程环境下只被创建一次</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"built_in\">dispatch_once_t</span> onceToken;</span><br><span class=\"line\">    <span class=\"built_in\">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 创建实例</span></span><br><span class=\"line\">        instance = [[<span class=\"keyword\">super</span> allocWithZone:<span class=\"literal\">NULL</span>] init];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 重写方法【必不可少】</span></span><br><span class=\"line\">+ (<span class=\"keyword\">id</span>)allocWithZone:(<span class=\"keyword\">struct</span> _NSZone *)zone&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"keyword\">self</span> sharedInstance];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 重写方法【必不可少】</span></span><br><span class=\"line\">- (<span class=\"keyword\">id</span>)copyWithZone:(<span class=\"keyword\">nullable</span> <span class=\"built_in\">NSZone</span> *)zone&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"结构型\">结构型</h2>\n<p>结构型模式(Structural Pattern)描述如何将类或者对象结合在一起形成更大的结构，可以分为类结构型模式和对象结构性模式：</p>\n<ul>\n<li>类结构型模式关心类的组合，由多个类可以组合成一个更大的系统，在类机构型模式中一般只存在继承和实现关系。</li>\n<li>对象结构型模式关心类与对象的组合，通过关联关系使得在一个类中定义另一个类的实例对象，然后通过该对象调用其方法。<br>\n结构型模式有以下几类：</li>\n<li>外观模式</li>\n<li>适配器模式</li>\n<li>桥接模式</li>\n<li>代理模式</li>\n<li>装饰者模式</li>\n<li>享元模式</li>\n</ul>\n<h3 id=\"桥接\">桥接</h3>\n<p>举例：一个关于业务解耦的问题，一个列表需要分别适配几种网络数据类型。<br>\n方案：创建两个抽象类 BaseObjectA 与 BaseObjectB，分别解决数据获取和逻辑处理，通过子类(BaseObjectA1…, BaseObjectB1…)完成具体实现，然后将两个类组装，完成业务解耦，同时可以实现多种业务场景需求。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#pragma mark ----- BaseObjectA.h -----</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">BaseObjectA</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 桥接模式的核心实现</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) BaseObjectB *objB;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取数据</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)handle;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#pragma mark ----- BaseObjectA.m -----</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">BaseObjectA</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    A1 --&gt; B1、B2、B3         3种</span></span><br><span class=\"line\"><span class=\"comment\">    A2 --&gt; B1、B2、B3         3种</span></span><br><span class=\"line\"><span class=\"comment\">    A3 --&gt; B1、B2、B3         3种</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)handle</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// override to subclass</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.objB fetchData];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#pragma mark ----- BaseObjectB.h -----</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">BaseObjectB</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)fetchData;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#pragma mark ----- BaseObjectB.m -----</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">BaseObjectB</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)fetchData</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// override to subclass</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>调用桥接类</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#pragma mark ----- BridgeDemo.h -----</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">BridgeDemo</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)fetch;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#pragma mark ----- BridgeDemo.m -----</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">BridgeDemo</span>()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) BaseObjectA *objA;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">BridgeDemo</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> 根据实际业务判断使用那套具体数据</span></span><br><span class=\"line\"><span class=\"comment\"> A1 --&gt; B1、B2、B3         3种</span></span><br><span class=\"line\"><span class=\"comment\"> A2 --&gt; B1、B2、B3         3种</span></span><br><span class=\"line\"><span class=\"comment\"> A3 --&gt; B1、B2、B3         3种</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)fetch</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 创建一个具体的ClassA</span></span><br><span class=\"line\">    _objA = [[ObjectA1 alloc] init];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 创建一个具体的ClassB</span></span><br><span class=\"line\">    BaseObjectB *b1 = [[ObjectB1 alloc] init];</span><br><span class=\"line\">    <span class=\"comment\">// 将一个具体的ClassB1 指定给抽象的ClassB</span></span><br><span class=\"line\">    _objA.objB = b1;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 获取数据</span></span><br><span class=\"line\">    [_objA handle];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"适配器\">适配器</h3>\n<p>被适配类（不应修改的类）</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#pragma mark ----- Target.h -----</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">Target</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)operation;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#pragma mark ----- Target.m -----</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">Target</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)operation</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 原有的具体业务逻辑</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>适配类</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#pragma mark ----- CoolTarget.h -----</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 适配对象</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">CoolTarget</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 被适配对象</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) Target *target;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 对原有方法包装</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)request;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#pragma mark ----- CoolTarget.m -----</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">CoolTarget</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)request</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 额外处理</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.target operation];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 额外处理</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"行为型\">行为型</h2>\n<p>行为型模式(Behavioral Pattern)是对在不同对象之间划分责任和算法的抽象化，更加清晰地划分类与对象的职责，并研究系统在运行时实例对象之间的交互。</p>\n<ul>\n<li>责任链模式</li>\n<li>命令模式</li>\n<li>解释器模式</li>\n<li>迭代器模式</li>\n<li>中介者模式</li>\n<li>备忘录模式</li>\n<li>观察者模式</li>\n<li>状态模式</li>\n<li>策略模式</li>\n<li>模板方法模式</li>\n<li>访问者模式</li>\n</ul>\n<h3 id=\"责任链\">责任链</h3>\n<p>一个类的成员变量中包含这个类（同类型）构成了责任链的基础数据类型。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#pragma mark ----- BusinessObject.h -----</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@class</span> <span class=\"title\">BusinessObject</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">void</span> (^CompletionBlock)(<span class=\"built_in\">BOOL</span> handled);</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">void</span> (^ResultBlock)(BusinessObject * __<span class=\"keyword\">nullable</span> handler, <span class=\"built_in\">BOOL</span> handled);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">BusinessObject</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 下一个响应者</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) BusinessObject *nextBusiness;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 响应者的处理</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)handle:(ResultBlock)result;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 各个业务中的具体处理</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)handleBusiness:(CompletionBlock)completion;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#pragma mark ----- BusinessObject.m -----</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">BusinessObject</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)handle:(ResultBlock)result &#123;</span><br><span class=\"line\">    CompletionBlock completion = ^(<span class=\"built_in\">BOOL</span> handled) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (handled) &#123;</span><br><span class=\"line\">            result(<span class=\"keyword\">self</span>, handled);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.nextBusiness) &#123;</span><br><span class=\"line\">                [<span class=\"keyword\">self</span>.nextBusiness handle:result];</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                result(<span class=\"literal\">nil</span>, <span class=\"literal\">NO</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> handleBusiness:completion];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)handleBusiness:(CompletionBlock)completion &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 业务逻辑处理</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>通过对下一个响应者(nextBusiness)的赋值，实现具体职责的实现顺序。我们可以通过后台服务器配置对应的职责顺序，同时代码中通过类名分别对应相应的业务，实现动态控制相应职责的执行顺序。</p>\n<h3 id=\"命令\">命令</h3>\n<p>命令模式可以将行为参数化，降低代码重合度。</p>\n<p>声明一个抽象命令类，子类可以继承该类实现具体的业务逻辑行为。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#pragma mark ----- Command.h -----</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@class</span> <span class=\"title\">Command</span>;</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">void</span>(^CommandCompletionCallBack)(Command* cmd);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">Command</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">copy</span>) CommandCompletionCallBack completion;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)execute;</span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)cancel;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)done;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#pragma mark ----- Command.m -----</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">Command</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)execute&#123;</span><br><span class=\"line\">    <span class=\"comment\">//override to subclass;</span></span><br><span class=\"line\">    [<span class=\"keyword\">self</span> done];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)cancel &#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.completion = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)done &#123;</span><br><span class=\"line\">    <span class=\"built_in\">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (_completion) &#123;</span><br><span class=\"line\">            _completion(<span class=\"keyword\">self</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//释放</span></span><br><span class=\"line\">        <span class=\"keyword\">self</span>.completion = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">        [[CommandManager sharedInstance].arrayCommands removeObject:<span class=\"keyword\">self</span>];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>再声明一个管理命令的单例类，允许全局控制命令的实行、取消实行。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#pragma mark ----- CommandManager.h -----</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">CommandManager</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 命令管理容器</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">NSMutableArray</span> &lt;Command*&gt; *arrayCommands;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 命令管理者以单例方式呈现</span></span><br><span class=\"line\">+ (<span class=\"keyword\">instancetype</span>)sharedInstance;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 执行命令</span></span><br><span class=\"line\">+ (<span class=\"keyword\">void</span>)executeCommand:(Command *)cmd completion:(CommandCompletionCallBack)completion;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 取消命令</span></span><br><span class=\"line\">+ (<span class=\"keyword\">void</span>)cancelCommand:(Command *)cmd;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">CommandManager</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 命令管理者以单例方式呈现</span></span><br><span class=\"line\">+ (<span class=\"keyword\">instancetype</span>)sharedInstance &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> CommandManager *instance = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"built_in\">dispatch_once_t</span> onceToken;</span><br><span class=\"line\">    <span class=\"built_in\">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class=\"line\">        instance = [[<span class=\"keyword\">super</span> allocWithZone:<span class=\"literal\">NULL</span>] init];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 【必不可少】</span></span><br><span class=\"line\">+ (<span class=\"keyword\">id</span>)allocWithZone:(<span class=\"keyword\">struct</span> _NSZone *)zone &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"keyword\">self</span> sharedInstance];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 【必不可少】</span></span><br><span class=\"line\">- (<span class=\"keyword\">id</span>)copyWithZone:(<span class=\"keyword\">nullable</span> <span class=\"built_in\">NSZone</span> *)zone &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 初始化方法</span></span><br><span class=\"line\">- (<span class=\"keyword\">id</span>)init &#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span> = [<span class=\"keyword\">super</span> init];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 初始化命令容器</span></span><br><span class=\"line\">        _arrayCommands = [<span class=\"built_in\">NSMutableArray</span> array];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (<span class=\"keyword\">void</span>)executeCommand:(Command *)cmd completion:(CommandCompletionCallBack)completion &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cmd) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果命令正在执行不做处理，否则添加并执行命令</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (![<span class=\"keyword\">self</span> _isExecutingCommand:cmd]) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 添加到命令容器当中</span></span><br><span class=\"line\">            [[[<span class=\"keyword\">self</span> sharedInstance] arrayCommands] addObject:cmd];</span><br><span class=\"line\">            <span class=\"comment\">// 设置命令执行完成的回调</span></span><br><span class=\"line\">            cmd.completion = completion;</span><br><span class=\"line\">            <span class=\"comment\">//执行命令</span></span><br><span class=\"line\">            [cmd execute];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 取消命令</span></span><br><span class=\"line\">+ (<span class=\"keyword\">void</span>)cancelCommand:(Command *)cmd &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cmd) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 从命令容器当中移除</span></span><br><span class=\"line\">        [[[<span class=\"keyword\">self</span> sharedInstance] arrayCommands] removeObject:cmd];</span><br><span class=\"line\">        <span class=\"comment\">// 取消命令执行</span></span><br><span class=\"line\">        [cmd cancel];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 判断当前命令是否正在执行</span></span><br><span class=\"line\">+ (<span class=\"built_in\">BOOL</span>)_isExecutingCommand:(Command *)cmd &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cmd) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSArray</span> *cmds = [[<span class=\"keyword\">self</span> sharedInstance] arrayCommands];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Command *aCmd <span class=\"keyword\">in</span> cmds) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 当前命令正在执行</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cmd == aCmd) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">NO</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"结语\">结语</h1>\n<p>设计模式主要就分析这么多，主要需要记住六大设计原则和一些主要的设计模式，能够在遇到问题时灵活运用才是关键。</p>\n<h1 id=\"引用\">引用</h1>\n<p><a href=\"https://github.com/xietao3/Study-Plan/blob/master/DesignPatterns/README.md\" target=\"_blank\" rel=\"noopener\">学习并理解 23 种设计模式</a></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>设计模式 Design Pattern 是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结，使用设计模式是为了代码可重用性、让代码更容易被理解、保证代码可靠性。</p>\n</blockquote>\n<h1>为什么要学习设计模式</h1>\n<ul>\n<li>\n<p>设计模式来源于众多专家的经验和智慧，是从许多优秀的软件系统中总结出的成功的、能够实现可维护性复用的设计方案，使用这些方案将可以避免让我们做一些重复性的工作</p>\n</li>\n<li>\n<p>设计模式提供了一条通用的设计词汇和一种通用的形式来方便开发人员之间的沟通和交流，是的设计方案更加通俗易懂</p>\n</li>\n<li>\n<p>大部分设计模式都兼顾了系统的可重用性和可扩展性，这使得我们可以更好地重用一些已有的设计方案、功能模块甚至一个完整的软件系统，避免我们经常做一系重复的设计、编写一些重复的代码</p>\n</li>\n<li>\n<p>合理使用设计模式并对设计模式的使用情况进行文档化，将有助于别人更快的理解系统</p>\n</li>\n<li>\n<p>将有助于初学者更加深入地理解面向对象思想</p>\n</li>\n</ul>\n<h1>六大设计原则</h1>\n<h2>单一职责原则</h2>\n<p>一个类只负责一件事。<br>\n比如说系统为我们实现的 UIView 与 CALayer 这两个类，UIView 专门负责事件传递和事件响应，而 CALayer 专门负责动画以及视图的显现。</p>\n<h2>依赖倒置原则</h2>\n<p>抽象不应该依赖于具体实现，具体实现可以依赖于抽象。<br>\n换言之，要针对接口编程，而不是针对实现编程。在程序代码中传递参数时或在关联关系时，尽量引用层次高的抽象层类，即使用接口和抽象类进行变量声明、参数类型声明、方法返回类型声明，以及数据类型的转换等，而不要用具体类来做这些事情。</p>\n<h2>开闭原则</h2>\n<p>对修改关闭，对扩展开放。<br>\n当我们定义一个类时，应该尽量考虑到这个类的可扩展性和灵活性，在考虑到当前需求的同时需要考虑后续多个版本迭代需求，需要对类的成员变量以及数据结构尽可能在不改动的情况下通过扩展的方式或者提供接口的方式解决后续的需求问题。</p>\n<h2>里氏替换原则</h2>\n<p>父类可以被子类无缝替换，且原有功能不受任何影响。<br>\n比如 KVO 实现原理，当我们对一个对象进行 addObserver 观察的时候，系统为我们在动态运行时创建一个子类，当我们以为我们观察的是我们的父类，其实已经被悄无声息的替换成对应的子类。</p>\n<h2>接口隔离原则</h2>\n<p>使用多个专门的协议、而不是一个庞大臃肿的协议。<br>\n比如我们经常使用的 UITableViewDelegate 与 UITableViewDataSource 这两个协议，UITableViewDelegate 专门负责 UITableView 的代理回调事件，而 UITableViewDataSource 专门负责数据源的获取，协议中的方法应当尽量少，从而避免一个庞大臃肿的协议。</p>\n<h2>迪米特法则</h2>\n<p>一个对象应当对其他对象有尽可能少的了解。<br>\n高内聚，低耦合。通过降低类与类之间的耦合，减少类与类之间的关联程度，可以让类与类之间的协作更加直接，更容易修改和复用。</p>\n<h1>设计模式分类</h1>\n<h2>创建型</h2>\n<p>创建型模式(Creational Pattern)对类的实例化过程进行了抽象，能够将木块中对象的创建和对象的使用分离。为了是结构更加清晰，外界对于这些对象只需要知道它们的共同接口，而不需要知道具体的实现细节，使整个系统的设计更加符合单一职责原则。</p>\n<ul>\n<li>简单工厂模式</li>\n<li>工厂方法模式</li>\n<li>抽象工厂模式</li>\n<li>单例模式</li>\n<li>生成器模式</li>\n<li>原型模式</li>\n</ul>\n<h3>单例</h3>\n<p>单例模式需要确保某个类有且仅有一个实例，并提供一个访问它的全局访问点。<br>\n注意点主要就是他的唯一性。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#pragma mark ----- SingleInstance.h -----</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">SingleInstance</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">+ (<span class=\"keyword\">id</span>)sharedInstance;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#pragma mark ----- SingleInstance.m -----</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">SingleInstance</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">+ (<span class=\"keyword\">id</span>)sharedInstance</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 静态局部变量</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> Mooc *instance = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 通过dispatch_once方式 确保instance在多线程环境下只被创建一次</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"built_in\">dispatch_once_t</span> onceToken;</span><br><span class=\"line\">    <span class=\"built_in\">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 创建实例</span></span><br><span class=\"line\">        instance = [[<span class=\"keyword\">super</span> allocWithZone:<span class=\"literal\">NULL</span>] init];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 重写方法【必不可少】</span></span><br><span class=\"line\">+ (<span class=\"keyword\">id</span>)allocWithZone:(<span class=\"keyword\">struct</span> _NSZone *)zone&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"keyword\">self</span> sharedInstance];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 重写方法【必不可少】</span></span><br><span class=\"line\">- (<span class=\"keyword\">id</span>)copyWithZone:(<span class=\"keyword\">nullable</span> <span class=\"built_in\">NSZone</span> *)zone&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<h2>结构型</h2>\n<p>结构型模式(Structural Pattern)描述如何将类或者对象结合在一起形成更大的结构，可以分为类结构型模式和对象结构性模式：</p>\n<ul>\n<li>类结构型模式关心类的组合，由多个类可以组合成一个更大的系统，在类机构型模式中一般只存在继承和实现关系。</li>\n<li>对象结构型模式关心类与对象的组合，通过关联关系使得在一个类中定义另一个类的实例对象，然后通过该对象调用其方法。<br>\n结构型模式有以下几类：</li>\n<li>外观模式</li>\n<li>适配器模式</li>\n<li>桥接模式</li>\n<li>代理模式</li>\n<li>装饰者模式</li>\n<li>享元模式</li>\n</ul>\n<h3>桥接</h3>\n<p>举例：一个关于业务解耦的问题，一个列表需要分别适配几种网络数据类型。<br>\n方案：创建两个抽象类 BaseObjectA 与 BaseObjectB，分别解决数据获取和逻辑处理，通过子类(BaseObjectA1…, BaseObjectB1…)完成具体实现，然后将两个类组装，完成业务解耦，同时可以实现多种业务场景需求。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#pragma mark ----- BaseObjectA.h -----</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">BaseObjectA</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 桥接模式的核心实现</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) BaseObjectB *objB;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取数据</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)handle;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#pragma mark ----- BaseObjectA.m -----</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">BaseObjectA</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    A1 --&gt; B1、B2、B3         3种</span></span><br><span class=\"line\"><span class=\"comment\">    A2 --&gt; B1、B2、B3         3种</span></span><br><span class=\"line\"><span class=\"comment\">    A3 --&gt; B1、B2、B3         3种</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)handle</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// override to subclass</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.objB fetchData];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#pragma mark ----- BaseObjectB.h -----</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">BaseObjectB</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)fetchData;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#pragma mark ----- BaseObjectB.m -----</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">BaseObjectB</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)fetchData</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// override to subclass</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>调用桥接类</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#pragma mark ----- BridgeDemo.h -----</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">BridgeDemo</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)fetch;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#pragma mark ----- BridgeDemo.m -----</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">BridgeDemo</span>()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) BaseObjectA *objA;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">BridgeDemo</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> 根据实际业务判断使用那套具体数据</span></span><br><span class=\"line\"><span class=\"comment\"> A1 --&gt; B1、B2、B3         3种</span></span><br><span class=\"line\"><span class=\"comment\"> A2 --&gt; B1、B2、B3         3种</span></span><br><span class=\"line\"><span class=\"comment\"> A3 --&gt; B1、B2、B3         3种</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)fetch</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 创建一个具体的ClassA</span></span><br><span class=\"line\">    _objA = [[ObjectA1 alloc] init];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 创建一个具体的ClassB</span></span><br><span class=\"line\">    BaseObjectB *b1 = [[ObjectB1 alloc] init];</span><br><span class=\"line\">    <span class=\"comment\">// 将一个具体的ClassB1 指定给抽象的ClassB</span></span><br><span class=\"line\">    _objA.objB = b1;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 获取数据</span></span><br><span class=\"line\">    [_objA handle];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<h3>适配器</h3>\n<p>被适配类（不应修改的类）</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#pragma mark ----- Target.h -----</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">Target</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)operation;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#pragma mark ----- Target.m -----</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">Target</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)operation</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 原有的具体业务逻辑</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>适配类</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#pragma mark ----- CoolTarget.h -----</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 适配对象</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">CoolTarget</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 被适配对象</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) Target *target;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 对原有方法包装</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)request;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#pragma mark ----- CoolTarget.m -----</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">CoolTarget</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)request</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 额外处理</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.target operation];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 额外处理</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<h2>行为型</h2>\n<p>行为型模式(Behavioral Pattern)是对在不同对象之间划分责任和算法的抽象化，更加清晰地划分类与对象的职责，并研究系统在运行时实例对象之间的交互。</p>\n<ul>\n<li>责任链模式</li>\n<li>命令模式</li>\n<li>解释器模式</li>\n<li>迭代器模式</li>\n<li>中介者模式</li>\n<li>备忘录模式</li>\n<li>观察者模式</li>\n<li>状态模式</li>\n<li>策略模式</li>\n<li>模板方法模式</li>\n<li>访问者模式</li>\n</ul>\n<h3>责任链</h3>\n<p>一个类的成员变量中包含这个类（同类型）构成了责任链的基础数据类型。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#pragma mark ----- BusinessObject.h -----</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@class</span> <span class=\"title\">BusinessObject</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">void</span> (^CompletionBlock)(<span class=\"built_in\">BOOL</span> handled);</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">void</span> (^ResultBlock)(BusinessObject * __<span class=\"keyword\">nullable</span> handler, <span class=\"built_in\">BOOL</span> handled);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">BusinessObject</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 下一个响应者</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) BusinessObject *nextBusiness;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 响应者的处理</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)handle:(ResultBlock)result;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 各个业务中的具体处理</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)handleBusiness:(CompletionBlock)completion;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#pragma mark ----- BusinessObject.m -----</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">BusinessObject</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)handle:(ResultBlock)result &#123;</span><br><span class=\"line\">    CompletionBlock completion = ^(<span class=\"built_in\">BOOL</span> handled) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (handled) &#123;</span><br><span class=\"line\">            result(<span class=\"keyword\">self</span>, handled);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.nextBusiness) &#123;</span><br><span class=\"line\">                [<span class=\"keyword\">self</span>.nextBusiness handle:result];</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                result(<span class=\"literal\">nil</span>, <span class=\"literal\">NO</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> handleBusiness:completion];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)handleBusiness:(CompletionBlock)completion &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 业务逻辑处理</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>通过对下一个响应者(nextBusiness)的赋值，实现具体职责的实现顺序。我们可以通过后台服务器配置对应的职责顺序，同时代码中通过类名分别对应相应的业务，实现动态控制相应职责的执行顺序。</p>\n<h3>命令</h3>\n<p>命令模式可以将行为参数化，降低代码重合度。</p>\n<p>声明一个抽象命令类，子类可以继承该类实现具体的业务逻辑行为。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#pragma mark ----- Command.h -----</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@class</span> <span class=\"title\">Command</span>;</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">void</span>(^CommandCompletionCallBack)(Command* cmd);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">Command</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">copy</span>) CommandCompletionCallBack completion;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)execute;</span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)cancel;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)done;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#pragma mark ----- Command.m -----</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">Command</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)execute&#123;</span><br><span class=\"line\">    <span class=\"comment\">//override to subclass;</span></span><br><span class=\"line\">    [<span class=\"keyword\">self</span> done];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)cancel &#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.completion = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)done &#123;</span><br><span class=\"line\">    <span class=\"built_in\">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (_completion) &#123;</span><br><span class=\"line\">            _completion(<span class=\"keyword\">self</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//释放</span></span><br><span class=\"line\">        <span class=\"keyword\">self</span>.completion = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">        [[CommandManager sharedInstance].arrayCommands removeObject:<span class=\"keyword\">self</span>];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>再声明一个管理命令的单例类，允许全局控制命令的实行、取消实行。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#pragma mark ----- CommandManager.h -----</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">CommandManager</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 命令管理容器</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">NSMutableArray</span> &lt;Command*&gt; *arrayCommands;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 命令管理者以单例方式呈现</span></span><br><span class=\"line\">+ (<span class=\"keyword\">instancetype</span>)sharedInstance;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 执行命令</span></span><br><span class=\"line\">+ (<span class=\"keyword\">void</span>)executeCommand:(Command *)cmd completion:(CommandCompletionCallBack)completion;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 取消命令</span></span><br><span class=\"line\">+ (<span class=\"keyword\">void</span>)cancelCommand:(Command *)cmd;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">CommandManager</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 命令管理者以单例方式呈现</span></span><br><span class=\"line\">+ (<span class=\"keyword\">instancetype</span>)sharedInstance &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> CommandManager *instance = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"built_in\">dispatch_once_t</span> onceToken;</span><br><span class=\"line\">    <span class=\"built_in\">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class=\"line\">        instance = [[<span class=\"keyword\">super</span> allocWithZone:<span class=\"literal\">NULL</span>] init];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 【必不可少】</span></span><br><span class=\"line\">+ (<span class=\"keyword\">id</span>)allocWithZone:(<span class=\"keyword\">struct</span> _NSZone *)zone &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"keyword\">self</span> sharedInstance];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 【必不可少】</span></span><br><span class=\"line\">- (<span class=\"keyword\">id</span>)copyWithZone:(<span class=\"keyword\">nullable</span> <span class=\"built_in\">NSZone</span> *)zone &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 初始化方法</span></span><br><span class=\"line\">- (<span class=\"keyword\">id</span>)init &#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span> = [<span class=\"keyword\">super</span> init];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 初始化命令容器</span></span><br><span class=\"line\">        _arrayCommands = [<span class=\"built_in\">NSMutableArray</span> array];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (<span class=\"keyword\">void</span>)executeCommand:(Command *)cmd completion:(CommandCompletionCallBack)completion &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cmd) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果命令正在执行不做处理，否则添加并执行命令</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (![<span class=\"keyword\">self</span> _isExecutingCommand:cmd]) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 添加到命令容器当中</span></span><br><span class=\"line\">            [[[<span class=\"keyword\">self</span> sharedInstance] arrayCommands] addObject:cmd];</span><br><span class=\"line\">            <span class=\"comment\">// 设置命令执行完成的回调</span></span><br><span class=\"line\">            cmd.completion = completion;</span><br><span class=\"line\">            <span class=\"comment\">//执行命令</span></span><br><span class=\"line\">            [cmd execute];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 取消命令</span></span><br><span class=\"line\">+ (<span class=\"keyword\">void</span>)cancelCommand:(Command *)cmd &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cmd) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 从命令容器当中移除</span></span><br><span class=\"line\">        [[[<span class=\"keyword\">self</span> sharedInstance] arrayCommands] removeObject:cmd];</span><br><span class=\"line\">        <span class=\"comment\">// 取消命令执行</span></span><br><span class=\"line\">        [cmd cancel];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 判断当前命令是否正在执行</span></span><br><span class=\"line\">+ (<span class=\"built_in\">BOOL</span>)_isExecutingCommand:(Command *)cmd &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cmd) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSArray</span> *cmds = [[<span class=\"keyword\">self</span> sharedInstance] arrayCommands];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Command *aCmd <span class=\"keyword\">in</span> cmds) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 当前命令正在执行</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cmd == aCmd) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">NO</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<h1>结语</h1>\n<p>设计模式主要就分析这么多，主要需要记住六大设计原则和一些主要的设计模式，能够在遇到问题时灵活运用才是关键。</p>\n<h1>引用</h1>\n<p><a href=\"https://github.com/xietao3/Study-Plan/blob/master/DesignPatterns/README.md\" target=\"_blank\" rel=\"noopener\">学习并理解 23 种设计模式</a></p>\n"},{"title":"OpenGL ES学习--同步对象和栅栏","catalog":true,"toc_nav_num":true,"date":"2019-08-21T11:10:54.000Z","subtitle":"About OpenGL ES","header-img":"/img/article_header/article_header.png","busuanzi":true,"_content":"\n> OpenGL ES 3.0为应用程序提供了一组OpenGL操作在GPU上执行结束的机制。我们可以同步多个图形上下文和线程中的GL操作，这对于许多高级图形应用来说很重要。例如：我们可能希望等待交换反馈的结果，然后在应用程序中使用这些结果。\n\n# 刷新和结束\n\nOpenGL ES 3.0 API继承了OpenGL的客户-服务器模型。应用程序（或客户）发出命令，这些命令由OpenGL ES实现（或者服务器）处理。在OpenGL中，客户和服务器可以存在于网络上的不同机器，OpenGL ES也允许客户和服务器处于不同机器上，但是因为OpenGL ES针对的是手持和嵌入平台，所以客户和服务器通常在同一个设备上。\n在客户-服务器模型中，客户发出的命令不一定立刻发送到服务器。如果客户和服务器在一个网络上操作，那么在网络上发送单独命令将非常低效。相反，命令可以缓存在客户端，在稍后的某个时刻发送到服务器。为了支持这种方法，需要一种机制让客户知道服务器合适完成前面提交的命令的执行。考虑另一个例子：多个OpenGL ES上下文（各自为不同线程的当前上下文）共享对象。为了正确地在这些上下文之间同步，很重要的一点是来自上下文A的命令在来自上下文B的命令之前发往服务器，这取决于上下文A修改的OpenGL ES状态。`glFlush`命令用于刷新当前OpenGL ES上下文中未决的命令，并将它们发往服务器。注意，`glFlush`只将命令发往服务器，而不等待它们完成。如果客户端要求这些命令完成，应该使用`glFinish`命令。除非绝对必要，否则我们不建议使用`glFinish`，因为`glFinish`在上下文中所有排队的命令由服务器完全之前不会返回，调用`glFinish`通过强制客户和服务器同步它们的操作可能对性能产生不利的影响。\n\n# 为什么使用同步对象\n\nOpenGL ES 3.0引入了一个称作栅栏（Fence）的新特性，为应用程序提供了通知GPU在一组OpenGL ES操作执行完成之前先等待、然后再将更多执行命令送入队列的手段。我们可以在GL命令流中插入栅栏命令，然后将其与需要等待的同步对象关联。\n如果我们将同步对象的使用与`glFinish`命令作比较，则同步对象更高效，因为可以等待GL命令流的部分完成。相比之下，调用`glFinish`命令可能降低应用程序性能，因为该命令会清空图形管线。\n\n# 创建和删除同步对象\n\n为了在GL命令流中插入栅栏命令并创建同步对象，可以调用如下函数：\n\n``` objc\n/**\n 在GL命令流中插入栅栏命令并创建同步对象\n\n @param condition#> 指定想同步对象发送信号必须符合的条件；必须为GL_SYNC_GPU_COMMANDS_COMPLETE description#>\n @param flags#> 指定控制同步对象行为的标志按位组合；当前必须为0 description#>\n @return GLsync 同步对象\n */\nglFenceSync(GLenum condition, GLbitfield flags);\n```\n\n在同步对象首次创建时，其状态为未收到信号（Unsignaled）。在栅栏命令满足指定条件时，其状态变为已收到信号（Signaled）。因为同步对象不能重用，所以必须为每次同步操作创建一个同步对象。\n要删除同步对象，可以调用如下函数：\n\n``` objc\n/**\n 删除同步对象\n\n @param sync#> 指定要删除的同步对象 description#>\n @return void\n */\nglDeleteSync(GLsync sync);\n```\n\n删除操作不会立即发生，因为同步对象只有在没有其他操作等待它时才能删除。因此，可以在等待同步对象之后调用`glDeleteSync`命令。\n\n# 等待和向同步对象发送信号\n\n可以用如下调用阻塞客户，并等待一个同步对象收到信号：\n\n``` objc\n/**\n 阻塞客户，并等待一个同步对象收到信号\n\n @param sync#> 指定等待其状态的同步对象 description#>\n @param flags#> 指定控制命令刷新行为的位域；可能是GL_SYNC_FLUSH_COMMANDS_BIT description#>\n @param timeout#> 指定等待同步对象获得信号的超时时间（纳秒） description#>\n @return GLenum\n */\nglClientWaitSync(GLsync sync, GLbitfield flags, GLuint64 timeout);\n```\n\n如果同步对象已经处于“已收到信号”的状态，`glClientWaitSync`命令将立即返回。否则，调用将阻塞，并在最多`timeout`纳秒的时间内等待同步对象收到信号。\n`glClientWaitSync`函数可能返回如下值：\n- GL_ARRAY_SIGNALED：同步对象在函数调用时已经处于“已收到信号”状态。\n- GL_TIMEOUT_EXPIRED：同步对象在`timeout`纳秒之后还没有进入“已收到信号”状态。\n- GL_CONDITION_SATISFIED：同步对象在超时之前收到信号。\n- GL_WAIT_FAILED：发生错误。\n\n`glWaitSync`函数类似于`glClientWaitSync`函数，但是该函数立即返回且阻塞GPU，直到同步对象收到信号：\n\n``` objc\n/**\n 阻塞GPU直到同步对象收到信号\n\n @param sync#> 指定等待其状态的同步对象 description#>\n @param flags#> 指定控制命令刷新行为的位域；必须为0 description#>\n @param timeout#> 指定服务器继续之前等待的超时（纳秒）；必须为GL_TIMEOUT_IGNORED description#>\n @return void\n */\nglWaitSync(GLsync sync, GLbitfield flags, GLuint64 timeout);\n```\n\n# 总结\n\n这篇文章介绍了OpenGL ES 3.0中宿主应用和GPU执行同步的基础知识。","source":"_posts/2019/opengl-es-sync-and-fence-0821.md","raw":"---\ntitle: \"OpenGL ES学习--同步对象和栅栏\"\ncatalog: true\ntoc_nav_num: true\ndate: 2019-08-21 19:10:54\nsubtitle: \"About OpenGL ES\"\nheader-img: \"/img/article_header/article_header.png\"\nbusuanzi: true\ntags:\n- iOS\n\n---\n\n> OpenGL ES 3.0为应用程序提供了一组OpenGL操作在GPU上执行结束的机制。我们可以同步多个图形上下文和线程中的GL操作，这对于许多高级图形应用来说很重要。例如：我们可能希望等待交换反馈的结果，然后在应用程序中使用这些结果。\n\n# 刷新和结束\n\nOpenGL ES 3.0 API继承了OpenGL的客户-服务器模型。应用程序（或客户）发出命令，这些命令由OpenGL ES实现（或者服务器）处理。在OpenGL中，客户和服务器可以存在于网络上的不同机器，OpenGL ES也允许客户和服务器处于不同机器上，但是因为OpenGL ES针对的是手持和嵌入平台，所以客户和服务器通常在同一个设备上。\n在客户-服务器模型中，客户发出的命令不一定立刻发送到服务器。如果客户和服务器在一个网络上操作，那么在网络上发送单独命令将非常低效。相反，命令可以缓存在客户端，在稍后的某个时刻发送到服务器。为了支持这种方法，需要一种机制让客户知道服务器合适完成前面提交的命令的执行。考虑另一个例子：多个OpenGL ES上下文（各自为不同线程的当前上下文）共享对象。为了正确地在这些上下文之间同步，很重要的一点是来自上下文A的命令在来自上下文B的命令之前发往服务器，这取决于上下文A修改的OpenGL ES状态。`glFlush`命令用于刷新当前OpenGL ES上下文中未决的命令，并将它们发往服务器。注意，`glFlush`只将命令发往服务器，而不等待它们完成。如果客户端要求这些命令完成，应该使用`glFinish`命令。除非绝对必要，否则我们不建议使用`glFinish`，因为`glFinish`在上下文中所有排队的命令由服务器完全之前不会返回，调用`glFinish`通过强制客户和服务器同步它们的操作可能对性能产生不利的影响。\n\n# 为什么使用同步对象\n\nOpenGL ES 3.0引入了一个称作栅栏（Fence）的新特性，为应用程序提供了通知GPU在一组OpenGL ES操作执行完成之前先等待、然后再将更多执行命令送入队列的手段。我们可以在GL命令流中插入栅栏命令，然后将其与需要等待的同步对象关联。\n如果我们将同步对象的使用与`glFinish`命令作比较，则同步对象更高效，因为可以等待GL命令流的部分完成。相比之下，调用`glFinish`命令可能降低应用程序性能，因为该命令会清空图形管线。\n\n# 创建和删除同步对象\n\n为了在GL命令流中插入栅栏命令并创建同步对象，可以调用如下函数：\n\n``` objc\n/**\n 在GL命令流中插入栅栏命令并创建同步对象\n\n @param condition#> 指定想同步对象发送信号必须符合的条件；必须为GL_SYNC_GPU_COMMANDS_COMPLETE description#>\n @param flags#> 指定控制同步对象行为的标志按位组合；当前必须为0 description#>\n @return GLsync 同步对象\n */\nglFenceSync(GLenum condition, GLbitfield flags);\n```\n\n在同步对象首次创建时，其状态为未收到信号（Unsignaled）。在栅栏命令满足指定条件时，其状态变为已收到信号（Signaled）。因为同步对象不能重用，所以必须为每次同步操作创建一个同步对象。\n要删除同步对象，可以调用如下函数：\n\n``` objc\n/**\n 删除同步对象\n\n @param sync#> 指定要删除的同步对象 description#>\n @return void\n */\nglDeleteSync(GLsync sync);\n```\n\n删除操作不会立即发生，因为同步对象只有在没有其他操作等待它时才能删除。因此，可以在等待同步对象之后调用`glDeleteSync`命令。\n\n# 等待和向同步对象发送信号\n\n可以用如下调用阻塞客户，并等待一个同步对象收到信号：\n\n``` objc\n/**\n 阻塞客户，并等待一个同步对象收到信号\n\n @param sync#> 指定等待其状态的同步对象 description#>\n @param flags#> 指定控制命令刷新行为的位域；可能是GL_SYNC_FLUSH_COMMANDS_BIT description#>\n @param timeout#> 指定等待同步对象获得信号的超时时间（纳秒） description#>\n @return GLenum\n */\nglClientWaitSync(GLsync sync, GLbitfield flags, GLuint64 timeout);\n```\n\n如果同步对象已经处于“已收到信号”的状态，`glClientWaitSync`命令将立即返回。否则，调用将阻塞，并在最多`timeout`纳秒的时间内等待同步对象收到信号。\n`glClientWaitSync`函数可能返回如下值：\n- GL_ARRAY_SIGNALED：同步对象在函数调用时已经处于“已收到信号”状态。\n- GL_TIMEOUT_EXPIRED：同步对象在`timeout`纳秒之后还没有进入“已收到信号”状态。\n- GL_CONDITION_SATISFIED：同步对象在超时之前收到信号。\n- GL_WAIT_FAILED：发生错误。\n\n`glWaitSync`函数类似于`glClientWaitSync`函数，但是该函数立即返回且阻塞GPU，直到同步对象收到信号：\n\n``` objc\n/**\n 阻塞GPU直到同步对象收到信号\n\n @param sync#> 指定等待其状态的同步对象 description#>\n @param flags#> 指定控制命令刷新行为的位域；必须为0 description#>\n @param timeout#> 指定服务器继续之前等待的超时（纳秒）；必须为GL_TIMEOUT_IGNORED description#>\n @return void\n */\nglWaitSync(GLsync sync, GLbitfield flags, GLuint64 timeout);\n```\n\n# 总结\n\n这篇文章介绍了OpenGL ES 3.0中宿主应用和GPU执行同步的基础知识。","slug":"2019/opengl-es-sync-and-fence-0821","published":1,"updated":"2022-01-10T09:04:52.808Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cky8gmc4k001jd1qhkhdl41cq","content":"<blockquote>\n<p>OpenGL ES 3.0为应用程序提供了一组OpenGL操作在GPU上执行结束的机制。我们可以同步多个图形上下文和线程中的GL操作，这对于许多高级图形应用来说很重要。例如：我们可能希望等待交换反馈的结果，然后在应用程序中使用这些结果。</p>\n</blockquote>\n<h1 id=\"刷新和结束\">刷新和结束</h1>\n<p>OpenGL ES 3.0 API继承了OpenGL的客户-服务器模型。应用程序（或客户）发出命令，这些命令由OpenGL ES实现（或者服务器）处理。在OpenGL中，客户和服务器可以存在于网络上的不同机器，OpenGL ES也允许客户和服务器处于不同机器上，但是因为OpenGL ES针对的是手持和嵌入平台，所以客户和服务器通常在同一个设备上。<br>\n在客户-服务器模型中，客户发出的命令不一定立刻发送到服务器。如果客户和服务器在一个网络上操作，那么在网络上发送单独命令将非常低效。相反，命令可以缓存在客户端，在稍后的某个时刻发送到服务器。为了支持这种方法，需要一种机制让客户知道服务器合适完成前面提交的命令的执行。考虑另一个例子：多个OpenGL ES上下文（各自为不同线程的当前上下文）共享对象。为了正确地在这些上下文之间同步，很重要的一点是来自上下文A的命令在来自上下文B的命令之前发往服务器，这取决于上下文A修改的OpenGL ES状态。<code>glFlush</code>命令用于刷新当前OpenGL ES上下文中未决的命令，并将它们发往服务器。注意，<code>glFlush</code>只将命令发往服务器，而不等待它们完成。如果客户端要求这些命令完成，应该使用<code>glFinish</code>命令。除非绝对必要，否则我们不建议使用<code>glFinish</code>，因为<code>glFinish</code>在上下文中所有排队的命令由服务器完全之前不会返回，调用<code>glFinish</code>通过强制客户和服务器同步它们的操作可能对性能产生不利的影响。</p>\n<h1 id=\"为什么使用同步对象\">为什么使用同步对象</h1>\n<p>OpenGL ES 3.0引入了一个称作栅栏（Fence）的新特性，为应用程序提供了通知GPU在一组OpenGL ES操作执行完成之前先等待、然后再将更多执行命令送入队列的手段。我们可以在GL命令流中插入栅栏命令，然后将其与需要等待的同步对象关联。<br>\n如果我们将同步对象的使用与<code>glFinish</code>命令作比较，则同步对象更高效，因为可以等待GL命令流的部分完成。相比之下，调用<code>glFinish</code>命令可能降低应用程序性能，因为该命令会清空图形管线。</p>\n<h1 id=\"创建和删除同步对象\">创建和删除同步对象</h1>\n<p>为了在GL命令流中插入栅栏命令并创建同步对象，可以调用如下函数：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 在GL命令流中插入栅栏命令并创建同步对象</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param condition#&gt; 指定想同步对象发送信号必须符合的条件；必须为GL_SYNC_GPU_COMMANDS_COMPLETE description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param flags#&gt; 指定控制同步对象行为的标志按位组合；当前必须为0 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return GLsync 同步对象</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glFenceSync(GLenum condition, GLbitfield flags);</span><br></pre></td></tr></table></figure>\n<p>在同步对象首次创建时，其状态为未收到信号（Unsignaled）。在栅栏命令满足指定条件时，其状态变为已收到信号（Signaled）。因为同步对象不能重用，所以必须为每次同步操作创建一个同步对象。<br>\n要删除同步对象，可以调用如下函数：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 删除同步对象</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param sync#&gt; 指定要删除的同步对象 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glDeleteSync(GLsync sync);</span><br></pre></td></tr></table></figure>\n<p>删除操作不会立即发生，因为同步对象只有在没有其他操作等待它时才能删除。因此，可以在等待同步对象之后调用<code>glDeleteSync</code>命令。</p>\n<h1 id=\"等待和向同步对象发送信号\">等待和向同步对象发送信号</h1>\n<p>可以用如下调用阻塞客户，并等待一个同步对象收到信号：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 阻塞客户，并等待一个同步对象收到信号</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param sync#&gt; 指定等待其状态的同步对象 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param flags#&gt; 指定控制命令刷新行为的位域；可能是GL_SYNC_FLUSH_COMMANDS_BIT description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param timeout#&gt; 指定等待同步对象获得信号的超时时间（纳秒） description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return GLenum</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glClientWaitSync(GLsync sync, GLbitfield flags, GLuint64 timeout);</span><br></pre></td></tr></table></figure>\n<p>如果同步对象已经处于“已收到信号”的状态，<code>glClientWaitSync</code>命令将立即返回。否则，调用将阻塞，并在最多<code>timeout</code>纳秒的时间内等待同步对象收到信号。<br>\n<code>glClientWaitSync</code>函数可能返回如下值：</p>\n<ul>\n<li>GL_ARRAY_SIGNALED：同步对象在函数调用时已经处于“已收到信号”状态。</li>\n<li>GL_TIMEOUT_EXPIRED：同步对象在<code>timeout</code>纳秒之后还没有进入“已收到信号”状态。</li>\n<li>GL_CONDITION_SATISFIED：同步对象在超时之前收到信号。</li>\n<li>GL_WAIT_FAILED：发生错误。</li>\n</ul>\n<p><code>glWaitSync</code>函数类似于<code>glClientWaitSync</code>函数，但是该函数立即返回且阻塞GPU，直到同步对象收到信号：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 阻塞GPU直到同步对象收到信号</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param sync#&gt; 指定等待其状态的同步对象 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param flags#&gt; 指定控制命令刷新行为的位域；必须为0 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param timeout#&gt; 指定服务器继续之前等待的超时（纳秒）；必须为GL_TIMEOUT_IGNORED description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glWaitSync(GLsync sync, GLbitfield flags, GLuint64 timeout);</span><br></pre></td></tr></table></figure>\n<h1 id=\"总结\">总结</h1>\n<p>这篇文章介绍了OpenGL ES 3.0中宿主应用和GPU执行同步的基础知识。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>OpenGL ES 3.0为应用程序提供了一组OpenGL操作在GPU上执行结束的机制。我们可以同步多个图形上下文和线程中的GL操作，这对于许多高级图形应用来说很重要。例如：我们可能希望等待交换反馈的结果，然后在应用程序中使用这些结果。</p>\n</blockquote>\n<h1>刷新和结束</h1>\n<p>OpenGL ES 3.0 API继承了OpenGL的客户-服务器模型。应用程序（或客户）发出命令，这些命令由OpenGL ES实现（或者服务器）处理。在OpenGL中，客户和服务器可以存在于网络上的不同机器，OpenGL ES也允许客户和服务器处于不同机器上，但是因为OpenGL ES针对的是手持和嵌入平台，所以客户和服务器通常在同一个设备上。<br>\n在客户-服务器模型中，客户发出的命令不一定立刻发送到服务器。如果客户和服务器在一个网络上操作，那么在网络上发送单独命令将非常低效。相反，命令可以缓存在客户端，在稍后的某个时刻发送到服务器。为了支持这种方法，需要一种机制让客户知道服务器合适完成前面提交的命令的执行。考虑另一个例子：多个OpenGL ES上下文（各自为不同线程的当前上下文）共享对象。为了正确地在这些上下文之间同步，很重要的一点是来自上下文A的命令在来自上下文B的命令之前发往服务器，这取决于上下文A修改的OpenGL ES状态。<code>glFlush</code>命令用于刷新当前OpenGL ES上下文中未决的命令，并将它们发往服务器。注意，<code>glFlush</code>只将命令发往服务器，而不等待它们完成。如果客户端要求这些命令完成，应该使用<code>glFinish</code>命令。除非绝对必要，否则我们不建议使用<code>glFinish</code>，因为<code>glFinish</code>在上下文中所有排队的命令由服务器完全之前不会返回，调用<code>glFinish</code>通过强制客户和服务器同步它们的操作可能对性能产生不利的影响。</p>\n<h1>为什么使用同步对象</h1>\n<p>OpenGL ES 3.0引入了一个称作栅栏（Fence）的新特性，为应用程序提供了通知GPU在一组OpenGL ES操作执行完成之前先等待、然后再将更多执行命令送入队列的手段。我们可以在GL命令流中插入栅栏命令，然后将其与需要等待的同步对象关联。<br>\n如果我们将同步对象的使用与<code>glFinish</code>命令作比较，则同步对象更高效，因为可以等待GL命令流的部分完成。相比之下，调用<code>glFinish</code>命令可能降低应用程序性能，因为该命令会清空图形管线。</p>\n<h1>创建和删除同步对象</h1>\n<p>为了在GL命令流中插入栅栏命令并创建同步对象，可以调用如下函数：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 在GL命令流中插入栅栏命令并创建同步对象</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param condition#&gt; 指定想同步对象发送信号必须符合的条件；必须为GL_SYNC_GPU_COMMANDS_COMPLETE description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param flags#&gt; 指定控制同步对象行为的标志按位组合；当前必须为0 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return GLsync 同步对象</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glFenceSync(GLenum condition, GLbitfield flags);</span><br></pre></td></tr></table></figure>\n<p>在同步对象首次创建时，其状态为未收到信号（Unsignaled）。在栅栏命令满足指定条件时，其状态变为已收到信号（Signaled）。因为同步对象不能重用，所以必须为每次同步操作创建一个同步对象。<br>\n要删除同步对象，可以调用如下函数：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 删除同步对象</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param sync#&gt; 指定要删除的同步对象 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glDeleteSync(GLsync sync);</span><br></pre></td></tr></table></figure>\n<p>删除操作不会立即发生，因为同步对象只有在没有其他操作等待它时才能删除。因此，可以在等待同步对象之后调用<code>glDeleteSync</code>命令。</p>\n<h1>等待和向同步对象发送信号</h1>\n<p>可以用如下调用阻塞客户，并等待一个同步对象收到信号：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 阻塞客户，并等待一个同步对象收到信号</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param sync#&gt; 指定等待其状态的同步对象 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param flags#&gt; 指定控制命令刷新行为的位域；可能是GL_SYNC_FLUSH_COMMANDS_BIT description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param timeout#&gt; 指定等待同步对象获得信号的超时时间（纳秒） description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return GLenum</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glClientWaitSync(GLsync sync, GLbitfield flags, GLuint64 timeout);</span><br></pre></td></tr></table></figure>\n<p>如果同步对象已经处于“已收到信号”的状态，<code>glClientWaitSync</code>命令将立即返回。否则，调用将阻塞，并在最多<code>timeout</code>纳秒的时间内等待同步对象收到信号。<br>\n<code>glClientWaitSync</code>函数可能返回如下值：</p>\n<ul>\n<li>GL_ARRAY_SIGNALED：同步对象在函数调用时已经处于“已收到信号”状态。</li>\n<li>GL_TIMEOUT_EXPIRED：同步对象在<code>timeout</code>纳秒之后还没有进入“已收到信号”状态。</li>\n<li>GL_CONDITION_SATISFIED：同步对象在超时之前收到信号。</li>\n<li>GL_WAIT_FAILED：发生错误。</li>\n</ul>\n<p><code>glWaitSync</code>函数类似于<code>glClientWaitSync</code>函数，但是该函数立即返回且阻塞GPU，直到同步对象收到信号：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 阻塞GPU直到同步对象收到信号</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param sync#&gt; 指定等待其状态的同步对象 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param flags#&gt; 指定控制命令刷新行为的位域；必须为0 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param timeout#&gt; 指定服务器继续之前等待的超时（纳秒）；必须为GL_TIMEOUT_IGNORED description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glWaitSync(GLsync sync, GLbitfield flags, GLuint64 timeout);</span><br></pre></td></tr></table></figure>\n<h1>总结</h1>\n<p>这篇文章介绍了OpenGL ES 3.0中宿主应用和GPU执行同步的基础知识。</p>\n"},{"title":"Ubuntu内核升级与开启BBR加速","catalog":true,"toc_nav_num":true,"date":"2019-11-01T08:01:20.000Z","subtitle":"BBR Accelerate","header-img":"/img/article_header/article_header.png","busuanzi":true,"_content":"\n# Introduction\n\nBBR（新的TCP拥塞控制算法Bottleneck Bandwidth and RTT）是个好东西。\n\n众所周知，Ubuntu开启BBR的前提是内核必须高于或等于4.9，所以想要使用它需要先看看我们的内核是否在4.9或以上。\n\n查看命令：`uname -a`\n\n如果内核版本已经在4.9或以上，那么就可以跳过内核升级这一步骤。如何在4.9以下，那么就需要更新一下内核了。（很遗憾，GCE官方默认搭载的镜像，内核是4.4版本的，所以默认情况下都是需要升级的）\n\n# Ubuntu内核升级\n\n升级过程比较简单，先确定系统是32位还是64位，可用`getconf LONG_BIT`查看。\n\n确认系统之后，需要下载必要的升级程序包，可以在[kernel.ubuntu.com](http://kernel.ubuntu.com/~kernel-ppa/mainline/)查找最新的程序包，根据自己的需要使用`wget`命令来下载服务器。\n\n比如我的服务器是64位，安装4.10.2的内核：\n\n```\nsudo wget http://kernel.ubuntu.com/~kernel-ppa/mainline/v4.10.2/linux-image-4.10.2-041002-generic_4.10.2-041002.201703120131_amd64.deb\n（拥有root权限的话可以去掉命令前面的“sudo”）\n```\n\n然后切换到下载目录，执行命令升级：\n\n```\nsudo dpkg -i linux-image-4.10.2-041002-generic_4.10.2-041002.201703120131_amd64.deb\n```\n\n最后执行命令更新grub引导装入程序：\n\n```\nsudo update-grub\n```\n\n一旦各方面完成，就可以重启服务器。系统重启后，可以执行`uname -a`查看内核版本，确保更新成功。\n\n# 开启TCP BBR\n\n修改系统变量：\n\n```\necho \"net.core.default_qdisc=fq\" >> /etc/sysctl.conf\necho \"net.ipv4.tcp_congestion_control=bbr\" >> /etc/sysctl.conf\n```\n\n如果执行以上命令显示拒绝访问，可以尝试以下命令：\n\n```\nsudo bash -c 'echo \"net.core.default_qdisc=fq\" >> /etc/sysctl.conf'\nsudo bash -c 'echo \"net.ipv4.tcp_congestion_control=bbr\" >> /etc/sysctl.conf'\n```\n\n保存生效：\n\n```\nsysctl -p\n```\n\n执行：\n\n```\nsysctl net.ipv4.tcp_available_congestion_control\n```\n\n如果返回结果，那么就表示RRB开启成功了：\n\n```\nnet.ipv4.tcp_available_congestion_control = bbr cubic reno\n```\n\n也可以执行`lsmod | grep bbr`来检测BBR是否真的开启成功。\n\n至此，我们的服务器BBR就开启成功了，赶紧试一试吧。","source":"_posts/2019/ubuntu-core-update-and-bbr-accelerate-1101.md","raw":"---\ntitle: \"Ubuntu内核升级与开启BBR加速\"\ncatalog: true\ntoc_nav_num: true\ndate: 2019-11-01 16:01:20\nsubtitle: \"BBR Accelerate\"\nheader-img: \"/img/article_header/article_header.png\"\nbusuanzi: true\ntags:\n- Tech\n\n---\n\n# Introduction\n\nBBR（新的TCP拥塞控制算法Bottleneck Bandwidth and RTT）是个好东西。\n\n众所周知，Ubuntu开启BBR的前提是内核必须高于或等于4.9，所以想要使用它需要先看看我们的内核是否在4.9或以上。\n\n查看命令：`uname -a`\n\n如果内核版本已经在4.9或以上，那么就可以跳过内核升级这一步骤。如何在4.9以下，那么就需要更新一下内核了。（很遗憾，GCE官方默认搭载的镜像，内核是4.4版本的，所以默认情况下都是需要升级的）\n\n# Ubuntu内核升级\n\n升级过程比较简单，先确定系统是32位还是64位，可用`getconf LONG_BIT`查看。\n\n确认系统之后，需要下载必要的升级程序包，可以在[kernel.ubuntu.com](http://kernel.ubuntu.com/~kernel-ppa/mainline/)查找最新的程序包，根据自己的需要使用`wget`命令来下载服务器。\n\n比如我的服务器是64位，安装4.10.2的内核：\n\n```\nsudo wget http://kernel.ubuntu.com/~kernel-ppa/mainline/v4.10.2/linux-image-4.10.2-041002-generic_4.10.2-041002.201703120131_amd64.deb\n（拥有root权限的话可以去掉命令前面的“sudo”）\n```\n\n然后切换到下载目录，执行命令升级：\n\n```\nsudo dpkg -i linux-image-4.10.2-041002-generic_4.10.2-041002.201703120131_amd64.deb\n```\n\n最后执行命令更新grub引导装入程序：\n\n```\nsudo update-grub\n```\n\n一旦各方面完成，就可以重启服务器。系统重启后，可以执行`uname -a`查看内核版本，确保更新成功。\n\n# 开启TCP BBR\n\n修改系统变量：\n\n```\necho \"net.core.default_qdisc=fq\" >> /etc/sysctl.conf\necho \"net.ipv4.tcp_congestion_control=bbr\" >> /etc/sysctl.conf\n```\n\n如果执行以上命令显示拒绝访问，可以尝试以下命令：\n\n```\nsudo bash -c 'echo \"net.core.default_qdisc=fq\" >> /etc/sysctl.conf'\nsudo bash -c 'echo \"net.ipv4.tcp_congestion_control=bbr\" >> /etc/sysctl.conf'\n```\n\n保存生效：\n\n```\nsysctl -p\n```\n\n执行：\n\n```\nsysctl net.ipv4.tcp_available_congestion_control\n```\n\n如果返回结果，那么就表示RRB开启成功了：\n\n```\nnet.ipv4.tcp_available_congestion_control = bbr cubic reno\n```\n\n也可以执行`lsmod | grep bbr`来检测BBR是否真的开启成功。\n\n至此，我们的服务器BBR就开启成功了，赶紧试一试吧。","slug":"2019/ubuntu-core-update-and-bbr-accelerate-1101","published":1,"updated":"2022-01-10T09:04:52.810Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cky8gmc4l001ld1qhhns9qs01","content":"<h1 id=\"introduction\">Introduction</h1>\n<p>BBR（新的TCP拥塞控制算法Bottleneck Bandwidth and RTT）是个好东西。</p>\n<p>众所周知，Ubuntu开启BBR的前提是内核必须高于或等于4.9，所以想要使用它需要先看看我们的内核是否在4.9或以上。</p>\n<p>查看命令：<code>uname -a</code></p>\n<p>如果内核版本已经在4.9或以上，那么就可以跳过内核升级这一步骤。如何在4.9以下，那么就需要更新一下内核了。（很遗憾，GCE官方默认搭载的镜像，内核是4.4版本的，所以默认情况下都是需要升级的）</p>\n<h1 id=\"ubuntu内核升级\">Ubuntu内核升级</h1>\n<p>升级过程比较简单，先确定系统是32位还是64位，可用<code>getconf LONG_BIT</code>查看。</p>\n<p>确认系统之后，需要下载必要的升级程序包，可以在<a href=\"http://kernel.ubuntu.com/~kernel-ppa/mainline/\" target=\"_blank\" rel=\"noopener\">kernel.ubuntu.com</a>查找最新的程序包，根据自己的需要使用<code>wget</code>命令来下载服务器。</p>\n<p>比如我的服务器是64位，安装4.10.2的内核：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo wget http://kernel.ubuntu.com/~kernel-ppa/mainline/v4.10.2/linux-image-4.10.2-041002-generic_4.10.2-041002.201703120131_amd64.deb</span><br><span class=\"line\">（拥有root权限的话可以去掉命令前面的“sudo”）</span><br></pre></td></tr></table></figure>\n<p>然后切换到下载目录，执行命令升级：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo dpkg -i linux-image-4.10.2-041002-generic_4.10.2-041002.201703120131_amd64.deb</span><br></pre></td></tr></table></figure>\n<p>最后执行命令更新grub引导装入程序：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo update-grub</span><br></pre></td></tr></table></figure>\n<p>一旦各方面完成，就可以重启服务器。系统重启后，可以执行<code>uname -a</code>查看内核版本，确保更新成功。</p>\n<h1 id=\"开启tcp-bbr\">开启TCP BBR</h1>\n<p>修改系统变量：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">echo &quot;net.core.default_qdisc=fq&quot; &gt;&gt; /etc/sysctl.conf</span><br><span class=\"line\">echo &quot;net.ipv4.tcp_congestion_control=bbr&quot; &gt;&gt; /etc/sysctl.conf</span><br></pre></td></tr></table></figure>\n<p>如果执行以上命令显示拒绝访问，可以尝试以下命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo bash -c &apos;echo &quot;net.core.default_qdisc=fq&quot; &gt;&gt; /etc/sysctl.conf&apos;</span><br><span class=\"line\">sudo bash -c &apos;echo &quot;net.ipv4.tcp_congestion_control=bbr&quot; &gt;&gt; /etc/sysctl.conf&apos;</span><br></pre></td></tr></table></figure>\n<p>保存生效：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sysctl -p</span><br></pre></td></tr></table></figure>\n<p>执行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sysctl net.ipv4.tcp_available_congestion_control</span><br></pre></td></tr></table></figure>\n<p>如果返回结果，那么就表示RRB开启成功了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">net.ipv4.tcp_available_congestion_control = bbr cubic reno</span><br></pre></td></tr></table></figure>\n<p>也可以执行<code>lsmod | grep bbr</code>来检测BBR是否真的开启成功。</p>\n<p>至此，我们的服务器BBR就开启成功了，赶紧试一试吧。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1>Introduction</h1>\n<p>BBR（新的TCP拥塞控制算法Bottleneck Bandwidth and RTT）是个好东西。</p>\n<p>众所周知，Ubuntu开启BBR的前提是内核必须高于或等于4.9，所以想要使用它需要先看看我们的内核是否在4.9或以上。</p>\n<p>查看命令：<code>uname -a</code></p>\n<p>如果内核版本已经在4.9或以上，那么就可以跳过内核升级这一步骤。如何在4.9以下，那么就需要更新一下内核了。（很遗憾，GCE官方默认搭载的镜像，内核是4.4版本的，所以默认情况下都是需要升级的）</p>\n<h1>Ubuntu内核升级</h1>\n<p>升级过程比较简单，先确定系统是32位还是64位，可用<code>getconf LONG_BIT</code>查看。</p>\n<p>确认系统之后，需要下载必要的升级程序包，可以在<a href=\"http://kernel.ubuntu.com/~kernel-ppa/mainline/\" target=\"_blank\" rel=\"noopener\">kernel.ubuntu.com</a>查找最新的程序包，根据自己的需要使用<code>wget</code>命令来下载服务器。</p>\n<p>比如我的服务器是64位，安装4.10.2的内核：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo wget http://kernel.ubuntu.com/~kernel-ppa/mainline/v4.10.2/linux-image-4.10.2-041002-generic_4.10.2-041002.201703120131_amd64.deb</span><br><span class=\"line\">（拥有root权限的话可以去掉命令前面的“sudo”）</span><br></pre></td></tr></table></figure>\n<p>然后切换到下载目录，执行命令升级：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo dpkg -i linux-image-4.10.2-041002-generic_4.10.2-041002.201703120131_amd64.deb</span><br></pre></td></tr></table></figure>\n<p>最后执行命令更新grub引导装入程序：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo update-grub</span><br></pre></td></tr></table></figure>\n<p>一旦各方面完成，就可以重启服务器。系统重启后，可以执行<code>uname -a</code>查看内核版本，确保更新成功。</p>\n<h1>开启TCP BBR</h1>\n<p>修改系统变量：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">echo &quot;net.core.default_qdisc=fq&quot; &gt;&gt; /etc/sysctl.conf</span><br><span class=\"line\">echo &quot;net.ipv4.tcp_congestion_control=bbr&quot; &gt;&gt; /etc/sysctl.conf</span><br></pre></td></tr></table></figure>\n<p>如果执行以上命令显示拒绝访问，可以尝试以下命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo bash -c &apos;echo &quot;net.core.default_qdisc=fq&quot; &gt;&gt; /etc/sysctl.conf&apos;</span><br><span class=\"line\">sudo bash -c &apos;echo &quot;net.ipv4.tcp_congestion_control=bbr&quot; &gt;&gt; /etc/sysctl.conf&apos;</span><br></pre></td></tr></table></figure>\n<p>保存生效：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sysctl -p</span><br></pre></td></tr></table></figure>\n<p>执行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sysctl net.ipv4.tcp_available_congestion_control</span><br></pre></td></tr></table></figure>\n<p>如果返回结果，那么就表示RRB开启成功了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">net.ipv4.tcp_available_congestion_control = bbr cubic reno</span><br></pre></td></tr></table></figure>\n<p>也可以执行<code>lsmod | grep bbr</code>来检测BBR是否真的开启成功。</p>\n<p>至此，我们的服务器BBR就开启成功了，赶紧试一试吧。</p>\n"},{"title":"RealityKit - 实景AR","catalog":true,"toc_nav_num":true,"date":"2021-08-30T12:19:02.000Z","subtitle":"RealityKit AR with the Device's Camera","header-img":"/img/article_header/article_header.png","busuanzi":true,"_content":"\n# 前言\n\n有了[上一篇](/article/2021/realitykit-0621)对于`RealityKit`的基础概念介绍，现在我们直接对于实景AR水平平面放置物品进行一个简单实现。\n\n# 初始化\n\n## ARView\n\n我们首先需要创建一个通过设备相机创建的现实场景，可以通过创建一个`arView`属性，同时设置`cameraMode`为`ar`（这边是个枚举，如果选择`nonAr`就是一个使用虚拟相机的场景）：\n``` swift\nprivate lazy var arView: ARView = {\n    let vi = ARView(frame: view.bounds, \n                    cameraMode: .ar, \n                    automaticallyConfigureSession: true)\n    return vi\n}()\n```\n同时为了不必要的渲染动作影响性能，可以对`renderOptions`进行配置：\n``` swift\n...\n    vi.renderOptions = [.disableCameraGrain, \n                        .disableHDR, \n                        .disableMotionBlur,\n                        .disableDepthOfField,\n                        .disableFaceOcclusions,\n                        .disablePersonOcclusion, \n                        .disableGroundingShadows, \n                        .disableAREnvironmentLighting]\n...\n```\n同时为了后期调试的方便，可以对应的打开debug模式，一般开一个世界坐标系就可以：\n``` swift\n...\n    vi.debugOptions = [.showWorldOrigin]\n...\n```\n然后将`arView`添加到对应控制器中的视图就可以：\n``` swift\noverride func viewDidLoad() {\n    super.viewDidLoad()\n\n    view.addSubview(arView)\n}\n```\n\n## ARCoachingOverlayView\n\n这边我们使用一个系统提供的AR引导动画，对它进行一个初始化：\n``` swift\nprivate lazy var coachingOverlay: ARCoachingOverlayView = {\n    let c = ARCoachingOverlayView(frame: arView.bounds)\n    c.session = arView.session\n    arView.addSubview(c)\n}()\n```\n其实`ARCoachingOverlayView`可以直接对于平面识别后提供一个代理的回调，但是对于反复识别不够灵敏且使用上不够灵活，所以我们在设置识别平面后，会把自动识别到平面后消失的状态关闭，由我们手动控制，所以这边代理可实现可不实现（代理是针对`ARCoachingOverlayView`是否处于活跃状态的回调，由于我们自己手动控制它的状态，所以这些状态不一定要通过这个回调），但我们实现看下他的相关方法：\n``` swift\n...\n    c.delegate = self\n    c.goal = .horizontalPlane\n    c.activatesAutomatically = false\n...\n```\n相关代理：\n``` swift\nextension UIViewController: ARCoachingOverlayViewDelegate {\n\n    /// coachingOverlayView即将处于识别活跃状态\n    func coachingOverlayViewWillActivate(_ coachingOverlayView: ARCoachingOverlayView) { }\n    \n    /// coachingOverlayView已经处于取消识别活跃状态\n    func coachingOverlayViewDidDeactivate(_ coachingOverlayView: ARCoachingOverlayView) { }\n\n    /// coachingOverlayView点击重置的回调\n    func coachingOverlayViewDidRequestSessionReset(_ coachingOverlayView: ARCoachingOverlayView) { }\n}\n```\n这边是简单实现，所以我们在进入页面时就可以开始进行一个识别：\n``` swift\n...\n    c.setActive(true, animated: true)\n...\n```\n然后添加到`arView`上：\n``` swift\n...\n    arView.addSubview(coachingOverlay)\n...\n```\n\n## 效果图\n\n这时候我们可以看下效果图：\n![效果图](/img/article/20210830/1.png)\n\n# 平面检测\n\n现在我们需要对于现实世界进行一个平面检测，主要通过`ARSession`，`ARSession`无需我们自己创建，就是从`ARView`中直接获取，先把他声明下，方便使用：\n``` swift\nprivate var session: ARSession {\n    arView.session\n}\n```\n然后对`session`进行一些配置，同时识别水平平面；这边我们创建的`ARWorldTrackingConfiguration`，它内部还有很多其他配置（如图片识别、人脸识别等等）：\n``` swift\nprivate func setupARSession() {\n    let configuration = ARWorldTrackingConfiguration()\n    configuration.planeDetection = [.horizontal]\n    configuration.environmentTexturing = .automatic\n    session.run(configuration, options: [])\n}\n```\n一个关键点，`session`的代理，在代理里面我们就可以在现实世界检测平面并做出回调：\n``` swift\n...\n    session.delegate = self\n...\n```\n相关代理：\n``` swift\nextension UIViewController: ARSessionDelegate {\n    \n    /// 每帧调用\n    func session(_ session: ARSession, didUpdate frame: ARFrame) { }\n    \n    /// 新锚点添加时调用(系统会自动识别到平面时添加锚点)\n    func session(_ session: ARSession, didAdd anchors: [ARAnchor]) { }\n    \n    /// 锚点更新时调用\n    func session(_ session: ARSession, didUpdate anchors: [ARAnchor]) { }\n\n    /// 锚点移除时调用\n    func session(_ session: ARSession, didRemove anchors: [ARAnchor]) { }\n}\n```\n根据上面的回调，其实我们只要用第二个回调方法，在添加水平平面的锚点后，在该锚点位置添加我们的模型就可以了，所以，我们先看下如何创建一个模型（这边只做简单demo，如果想要复杂化，比如检测到平面不立即添加模型，而是有个选择框让用户手动点击添加，可以使用第一个方法，每帧调用的回调，在屏幕上渲染一个选择框，并实时检测是否存在平面）。\n\n# 模型创建与放置\n\n## 自定义Entity类\n这边自定义一个`AnchorEntity`类，继承`Entity`和`HasAnchoring`两个协议，同时内部初始化异步加载一个`ModelEntity`，放置卡线程，异步方法内部实现是`Combine`框架（这边的模型直接使用苹果官方推荐的`USDZ`模型格式，其他还有`OBJ`格式的模型，但这种格式的模型和纹理是两个文件，在渲染合成后存在内存问题，虽然有解决方案，但感觉不是很完美）：\n``` swift\nclass ShoeEntity: Entity, HasAnchoring {\n    private var cancels: Set<AnyCancellable> = .init()\n    \n    required init(name: String) {\n        super.init()\n        \n        loadEntity(name: name)\n    }\n    \n    private func loadEntity(name: String) {\n        Entity.loadModelAsync(named: name).sink { error in\n            debugPrint(error)\n        } receiveValue: { [weak self] entity in\n            self?.addChild(entity)\n        }.store(in: &cancels)\n    }\n    \n    required init() {\n        fatalError(\"init() has not been implemented\")\n    }\n}\n```\n我们定义一个模型属性：\n```\nprivate lazy var shoeEntity: ShoeEntity = .init(name: \"shoe.usdz\")\n```\n## 添加模型并展示\n模型已经有了，然后就是在检测到锚点时关闭引导动画并展示我们的模型，，基础功能就完成了：\n``` swift\nfunc session(_ session: ARSession, didAdd anchors: [ARAnchor]) {\n    guard let anchor = anchors.filter({ $0 is ARPlaneAnchor }).first as? ARPlaneAnchor,\n          anchor.alignment == .horizontal else {\n        return\n    }\n    coachingOverlay.setActive(false, animated: true)\n    shoeEntity.transform.matrix = anchor.transform\n    arView.scene.addAnchor(shoeEntity)\n}\n```\n\n# 效果视频\n\n![效果视频](/img/article/20210830/2.mp4)\n\n# 总结\n\n以上就是一个简单的真实世界识别水平平面并展示模型的一个流程，在整理文章的过程中也让我对`RealityKit`有了更深的理解，把他更为精简的实现。\n后续的话，还有更多的细节可以优化，包括光照，手势，位置修正等等，有时间再更。","source":"_posts/2021/realitykit-live-ar-0830.md","raw":"---\ntitle: \"RealityKit - 实景AR\"\ncatalog: true\ntoc_nav_num: true\ndate: 2021-08-30 20:19:02\nsubtitle: \"RealityKit AR with the Device's Camera\"\nheader-img: \"/img/article_header/article_header.png\"\nbusuanzi: true\ntags:\n- iOS - Swift\n\n---\n\n# 前言\n\n有了[上一篇](/article/2021/realitykit-0621)对于`RealityKit`的基础概念介绍，现在我们直接对于实景AR水平平面放置物品进行一个简单实现。\n\n# 初始化\n\n## ARView\n\n我们首先需要创建一个通过设备相机创建的现实场景，可以通过创建一个`arView`属性，同时设置`cameraMode`为`ar`（这边是个枚举，如果选择`nonAr`就是一个使用虚拟相机的场景）：\n``` swift\nprivate lazy var arView: ARView = {\n    let vi = ARView(frame: view.bounds, \n                    cameraMode: .ar, \n                    automaticallyConfigureSession: true)\n    return vi\n}()\n```\n同时为了不必要的渲染动作影响性能，可以对`renderOptions`进行配置：\n``` swift\n...\n    vi.renderOptions = [.disableCameraGrain, \n                        .disableHDR, \n                        .disableMotionBlur,\n                        .disableDepthOfField,\n                        .disableFaceOcclusions,\n                        .disablePersonOcclusion, \n                        .disableGroundingShadows, \n                        .disableAREnvironmentLighting]\n...\n```\n同时为了后期调试的方便，可以对应的打开debug模式，一般开一个世界坐标系就可以：\n``` swift\n...\n    vi.debugOptions = [.showWorldOrigin]\n...\n```\n然后将`arView`添加到对应控制器中的视图就可以：\n``` swift\noverride func viewDidLoad() {\n    super.viewDidLoad()\n\n    view.addSubview(arView)\n}\n```\n\n## ARCoachingOverlayView\n\n这边我们使用一个系统提供的AR引导动画，对它进行一个初始化：\n``` swift\nprivate lazy var coachingOverlay: ARCoachingOverlayView = {\n    let c = ARCoachingOverlayView(frame: arView.bounds)\n    c.session = arView.session\n    arView.addSubview(c)\n}()\n```\n其实`ARCoachingOverlayView`可以直接对于平面识别后提供一个代理的回调，但是对于反复识别不够灵敏且使用上不够灵活，所以我们在设置识别平面后，会把自动识别到平面后消失的状态关闭，由我们手动控制，所以这边代理可实现可不实现（代理是针对`ARCoachingOverlayView`是否处于活跃状态的回调，由于我们自己手动控制它的状态，所以这些状态不一定要通过这个回调），但我们实现看下他的相关方法：\n``` swift\n...\n    c.delegate = self\n    c.goal = .horizontalPlane\n    c.activatesAutomatically = false\n...\n```\n相关代理：\n``` swift\nextension UIViewController: ARCoachingOverlayViewDelegate {\n\n    /// coachingOverlayView即将处于识别活跃状态\n    func coachingOverlayViewWillActivate(_ coachingOverlayView: ARCoachingOverlayView) { }\n    \n    /// coachingOverlayView已经处于取消识别活跃状态\n    func coachingOverlayViewDidDeactivate(_ coachingOverlayView: ARCoachingOverlayView) { }\n\n    /// coachingOverlayView点击重置的回调\n    func coachingOverlayViewDidRequestSessionReset(_ coachingOverlayView: ARCoachingOverlayView) { }\n}\n```\n这边是简单实现，所以我们在进入页面时就可以开始进行一个识别：\n``` swift\n...\n    c.setActive(true, animated: true)\n...\n```\n然后添加到`arView`上：\n``` swift\n...\n    arView.addSubview(coachingOverlay)\n...\n```\n\n## 效果图\n\n这时候我们可以看下效果图：\n![效果图](/img/article/20210830/1.png)\n\n# 平面检测\n\n现在我们需要对于现实世界进行一个平面检测，主要通过`ARSession`，`ARSession`无需我们自己创建，就是从`ARView`中直接获取，先把他声明下，方便使用：\n``` swift\nprivate var session: ARSession {\n    arView.session\n}\n```\n然后对`session`进行一些配置，同时识别水平平面；这边我们创建的`ARWorldTrackingConfiguration`，它内部还有很多其他配置（如图片识别、人脸识别等等）：\n``` swift\nprivate func setupARSession() {\n    let configuration = ARWorldTrackingConfiguration()\n    configuration.planeDetection = [.horizontal]\n    configuration.environmentTexturing = .automatic\n    session.run(configuration, options: [])\n}\n```\n一个关键点，`session`的代理，在代理里面我们就可以在现实世界检测平面并做出回调：\n``` swift\n...\n    session.delegate = self\n...\n```\n相关代理：\n``` swift\nextension UIViewController: ARSessionDelegate {\n    \n    /// 每帧调用\n    func session(_ session: ARSession, didUpdate frame: ARFrame) { }\n    \n    /// 新锚点添加时调用(系统会自动识别到平面时添加锚点)\n    func session(_ session: ARSession, didAdd anchors: [ARAnchor]) { }\n    \n    /// 锚点更新时调用\n    func session(_ session: ARSession, didUpdate anchors: [ARAnchor]) { }\n\n    /// 锚点移除时调用\n    func session(_ session: ARSession, didRemove anchors: [ARAnchor]) { }\n}\n```\n根据上面的回调，其实我们只要用第二个回调方法，在添加水平平面的锚点后，在该锚点位置添加我们的模型就可以了，所以，我们先看下如何创建一个模型（这边只做简单demo，如果想要复杂化，比如检测到平面不立即添加模型，而是有个选择框让用户手动点击添加，可以使用第一个方法，每帧调用的回调，在屏幕上渲染一个选择框，并实时检测是否存在平面）。\n\n# 模型创建与放置\n\n## 自定义Entity类\n这边自定义一个`AnchorEntity`类，继承`Entity`和`HasAnchoring`两个协议，同时内部初始化异步加载一个`ModelEntity`，放置卡线程，异步方法内部实现是`Combine`框架（这边的模型直接使用苹果官方推荐的`USDZ`模型格式，其他还有`OBJ`格式的模型，但这种格式的模型和纹理是两个文件，在渲染合成后存在内存问题，虽然有解决方案，但感觉不是很完美）：\n``` swift\nclass ShoeEntity: Entity, HasAnchoring {\n    private var cancels: Set<AnyCancellable> = .init()\n    \n    required init(name: String) {\n        super.init()\n        \n        loadEntity(name: name)\n    }\n    \n    private func loadEntity(name: String) {\n        Entity.loadModelAsync(named: name).sink { error in\n            debugPrint(error)\n        } receiveValue: { [weak self] entity in\n            self?.addChild(entity)\n        }.store(in: &cancels)\n    }\n    \n    required init() {\n        fatalError(\"init() has not been implemented\")\n    }\n}\n```\n我们定义一个模型属性：\n```\nprivate lazy var shoeEntity: ShoeEntity = .init(name: \"shoe.usdz\")\n```\n## 添加模型并展示\n模型已经有了，然后就是在检测到锚点时关闭引导动画并展示我们的模型，，基础功能就完成了：\n``` swift\nfunc session(_ session: ARSession, didAdd anchors: [ARAnchor]) {\n    guard let anchor = anchors.filter({ $0 is ARPlaneAnchor }).first as? ARPlaneAnchor,\n          anchor.alignment == .horizontal else {\n        return\n    }\n    coachingOverlay.setActive(false, animated: true)\n    shoeEntity.transform.matrix = anchor.transform\n    arView.scene.addAnchor(shoeEntity)\n}\n```\n\n# 效果视频\n\n![效果视频](/img/article/20210830/2.mp4)\n\n# 总结\n\n以上就是一个简单的真实世界识别水平平面并展示模型的一个流程，在整理文章的过程中也让我对`RealityKit`有了更深的理解，把他更为精简的实现。\n后续的话，还有更多的细节可以优化，包括光照，手势，位置修正等等，有时间再更。","slug":"2021/realitykit-live-ar-0830","published":1,"updated":"2022-01-10T09:04:52.811Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cky8gmc4l001nd1qhhifsxusk","content":"<h1 id=\"前言\">前言</h1>\n<p>有了<a href=\"/article/2021/realitykit-0621\">上一篇</a>对于<code>RealityKit</code>的基础概念介绍，现在我们直接对于实景AR水平平面放置物品进行一个简单实现。</p>\n<h1 id=\"初始化\">初始化</h1>\n<h2 id=\"arview\">ARView</h2>\n<p>我们首先需要创建一个通过设备相机创建的现实场景，可以通过创建一个<code>arView</code>属性，同时设置<code>cameraMode</code>为<code>ar</code>（这边是个枚举，如果选择<code>nonAr</code>就是一个使用虚拟相机的场景）：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"built_in\">lazy</span> <span class=\"keyword\">var</span> arView: <span class=\"type\">ARView</span> = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> vi = <span class=\"type\">ARView</span>(frame: view.bounds, </span><br><span class=\"line\">                    cameraMode: .ar, </span><br><span class=\"line\">                    automaticallyConfigureSession: <span class=\"literal\">true</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> vi</span><br><span class=\"line\">&#125;()</span><br></pre></td></tr></table></figure>\n<p>同时为了不必要的渲染动作影响性能，可以对<code>renderOptions</code>进行配置：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">    vi.renderOptions = [.disableCameraGrain, </span><br><span class=\"line\">                        .disableHDR, </span><br><span class=\"line\">                        .disableMotionBlur,</span><br><span class=\"line\">                        .disableDepthOfField,</span><br><span class=\"line\">                        .disableFaceOcclusions,</span><br><span class=\"line\">                        .disablePersonOcclusion, </span><br><span class=\"line\">                        .disableGroundingShadows, </span><br><span class=\"line\">                        .disableAREnvironmentLighting]</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p>同时为了后期调试的方便，可以对应的打开debug模式，一般开一个世界坐标系就可以：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">    vi.debugOptions = [.showWorldOrigin]</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p>然后将<code>arView</code>添加到对应控制器中的视图就可以：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">viewDidLoad</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.viewDidLoad()</span><br><span class=\"line\"></span><br><span class=\"line\">    view.addSubview(arView)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"arcoachingoverlayview\">ARCoachingOverlayView</h2>\n<p>这边我们使用一个系统提供的AR引导动画，对它进行一个初始化：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"built_in\">lazy</span> <span class=\"keyword\">var</span> coachingOverlay: <span class=\"type\">ARCoachingOverlayView</span> = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"built_in\">c</span> = <span class=\"type\">ARCoachingOverlayView</span>(frame: arView.bounds)</span><br><span class=\"line\">    <span class=\"built_in\">c</span>.session = arView.session</span><br><span class=\"line\">    arView.addSubview(<span class=\"built_in\">c</span>)</span><br><span class=\"line\">&#125;()</span><br></pre></td></tr></table></figure>\n<p>其实<code>ARCoachingOverlayView</code>可以直接对于平面识别后提供一个代理的回调，但是对于反复识别不够灵敏且使用上不够灵活，所以我们在设置识别平面后，会把自动识别到平面后消失的状态关闭，由我们手动控制，所以这边代理可实现可不实现（代理是针对<code>ARCoachingOverlayView</code>是否处于活跃状态的回调，由于我们自己手动控制它的状态，所以这些状态不一定要通过这个回调），但我们实现看下他的相关方法：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">    <span class=\"built_in\">c</span>.delegate = <span class=\"keyword\">self</span></span><br><span class=\"line\">    <span class=\"built_in\">c</span>.goal = .horizontalPlane</span><br><span class=\"line\">    <span class=\"built_in\">c</span>.activatesAutomatically = <span class=\"literal\">false</span></span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p>相关代理：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">UIViewController</span>: <span class=\"title\">ARCoachingOverlayViewDelegate</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// coachingOverlayView即将处于识别活跃状态</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">coachingOverlayViewWillActivate</span><span class=\"params\">(<span class=\"number\">_</span> coachingOverlayView: ARCoachingOverlayView)</span></span> &#123; &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/// coachingOverlayView已经处于取消识别活跃状态</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">coachingOverlayViewDidDeactivate</span><span class=\"params\">(<span class=\"number\">_</span> coachingOverlayView: ARCoachingOverlayView)</span></span> &#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// coachingOverlayView点击重置的回调</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">coachingOverlayViewDidRequestSessionReset</span><span class=\"params\">(<span class=\"number\">_</span> coachingOverlayView: ARCoachingOverlayView)</span></span> &#123; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这边是简单实现，所以我们在进入页面时就可以开始进行一个识别：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">    <span class=\"built_in\">c</span>.setActive(<span class=\"literal\">true</span>, animated: <span class=\"literal\">true</span>)</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p>然后添加到<code>arView</code>上：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">    arView.addSubview(coachingOverlay)</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<h2 id=\"效果图\">效果图</h2>\n<p>这时候我们可以看下效果图：<br>\n<img src=\"/img/article/20210830/1.png\" alt=\"效果图\"></p>\n<h1 id=\"平面检测\">平面检测</h1>\n<p>现在我们需要对于现实世界进行一个平面检测，主要通过<code>ARSession</code>，<code>ARSession</code>无需我们自己创建，就是从<code>ARView</code>中直接获取，先把他声明下，方便使用：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">var</span> session: <span class=\"type\">ARSession</span> &#123;</span><br><span class=\"line\">    arView.session</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后对<code>session</code>进行一些配置，同时识别水平平面；这边我们创建的<code>ARWorldTrackingConfiguration</code>，它内部还有很多其他配置（如图片识别、人脸识别等等）：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">setupARSession</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> configuration = <span class=\"type\">ARWorldTrackingConfiguration</span>()</span><br><span class=\"line\">    configuration.planeDetection = [.horizontal]</span><br><span class=\"line\">    configuration.environmentTexturing = .automatic</span><br><span class=\"line\">    session.run(configuration, options: [])</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>一个关键点，<code>session</code>的代理，在代理里面我们就可以在现实世界检测平面并做出回调：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">    session.delegate = <span class=\"keyword\">self</span></span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p>相关代理：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">UIViewController</span>: <span class=\"title\">ARSessionDelegate</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/// 每帧调用</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">session</span><span class=\"params\">(<span class=\"number\">_</span> session: ARSession, didUpdate frame: ARFrame)</span></span> &#123; &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/// 新锚点添加时调用(系统会自动识别到平面时添加锚点)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">session</span><span class=\"params\">(<span class=\"number\">_</span> session: ARSession, didAdd anchors: [ARAnchor])</span></span> &#123; &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/// 锚点更新时调用</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">session</span><span class=\"params\">(<span class=\"number\">_</span> session: ARSession, didUpdate anchors: [ARAnchor])</span></span> &#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// 锚点移除时调用</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">session</span><span class=\"params\">(<span class=\"number\">_</span> session: ARSession, didRemove anchors: [ARAnchor])</span></span> &#123; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>根据上面的回调，其实我们只要用第二个回调方法，在添加水平平面的锚点后，在该锚点位置添加我们的模型就可以了，所以，我们先看下如何创建一个模型（这边只做简单demo，如果想要复杂化，比如检测到平面不立即添加模型，而是有个选择框让用户手动点击添加，可以使用第一个方法，每帧调用的回调，在屏幕上渲染一个选择框，并实时检测是否存在平面）。</p>\n<h1 id=\"模型创建与放置\">模型创建与放置</h1>\n<h2 id=\"自定义entity类\">自定义Entity类</h2>\n<p>这边自定义一个<code>AnchorEntity</code>类，继承<code>Entity</code>和<code>HasAnchoring</code>两个协议，同时内部初始化异步加载一个<code>ModelEntity</code>，放置卡线程，异步方法内部实现是<code>Combine</code>框架（这边的模型直接使用苹果官方推荐的<code>USDZ</code>模型格式，其他还有<code>OBJ</code>格式的模型，但这种格式的模型和纹理是两个文件，在渲染合成后存在内存问题，虽然有解决方案，但感觉不是很完美）：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ShoeEntity</span>: <span class=\"title\">Entity</span>, <span class=\"title\">HasAnchoring</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> cancels: <span class=\"type\">Set</span>&lt;<span class=\"type\">AnyCancellable</span>&gt; = .<span class=\"keyword\">init</span>()</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">required</span> <span class=\"keyword\">init</span>(name: <span class=\"type\">String</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.<span class=\"keyword\">init</span>()</span><br><span class=\"line\">        </span><br><span class=\"line\">        loadEntity(name: name)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">loadEntity</span><span class=\"params\">(name: String)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Entity</span>.loadModelAsync(named: name).sink &#123; error <span class=\"keyword\">in</span></span><br><span class=\"line\">            <span class=\"built_in\">debugPrint</span>(error)</span><br><span class=\"line\">        &#125; receiveValue: &#123; [<span class=\"keyword\">weak</span> <span class=\"keyword\">self</span>] entity <span class=\"keyword\">in</span></span><br><span class=\"line\">            <span class=\"keyword\">self</span>?.addChild(entity)</span><br><span class=\"line\">        &#125;.store(<span class=\"keyword\">in</span>: &amp;cancels)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">required</span> <span class=\"keyword\">init</span>() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">fatalError</span>(<span class=\"string\">\"init() has not been implemented\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们定义一个模型属性：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private lazy var shoeEntity: ShoeEntity = .init(name: &quot;shoe.usdz&quot;)</span><br></pre></td></tr></table></figure>\n<h2 id=\"添加模型并展示\">添加模型并展示</h2>\n<p>模型已经有了，然后就是在检测到锚点时关闭引导动画并展示我们的模型，，基础功能就完成了：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">session</span><span class=\"params\">(<span class=\"number\">_</span> session: ARSession, didAdd anchors: [ARAnchor])</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">guard</span> <span class=\"keyword\">let</span> anchor = anchors.<span class=\"built_in\">filter</span>(&#123; $<span class=\"number\">0</span> <span class=\"keyword\">is</span> <span class=\"type\">ARPlaneAnchor</span> &#125;).first <span class=\"keyword\">as</span>? <span class=\"type\">ARPlaneAnchor</span>,</span><br><span class=\"line\">          anchor.alignment == .horizontal <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    coachingOverlay.setActive(<span class=\"literal\">false</span>, animated: <span class=\"literal\">true</span>)</span><br><span class=\"line\">    shoeEntity.transform.matrix = anchor.transform</span><br><span class=\"line\">    arView.scene.addAnchor(shoeEntity)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"效果视频\">效果视频</h1>\n<p><img src=\"/img/article/20210830/2.mp4\" alt=\"效果视频\"></p>\n<h1 id=\"总结\">总结</h1>\n<p>以上就是一个简单的真实世界识别水平平面并展示模型的一个流程，在整理文章的过程中也让我对<code>RealityKit</code>有了更深的理解，把他更为精简的实现。<br>\n后续的话，还有更多的细节可以优化，包括光照，手势，位置修正等等，有时间再更。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1>前言</h1>\n<p>有了<a href=\"/article/2021/realitykit-0621\">上一篇</a>对于<code>RealityKit</code>的基础概念介绍，现在我们直接对于实景AR水平平面放置物品进行一个简单实现。</p>\n<h1>初始化</h1>\n<h2>ARView</h2>\n<p>我们首先需要创建一个通过设备相机创建的现实场景，可以通过创建一个<code>arView</code>属性，同时设置<code>cameraMode</code>为<code>ar</code>（这边是个枚举，如果选择<code>nonAr</code>就是一个使用虚拟相机的场景）：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"built_in\">lazy</span> <span class=\"keyword\">var</span> arView: <span class=\"type\">ARView</span> = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> vi = <span class=\"type\">ARView</span>(frame: view.bounds, </span><br><span class=\"line\">                    cameraMode: .ar, </span><br><span class=\"line\">                    automaticallyConfigureSession: <span class=\"literal\">true</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> vi</span><br><span class=\"line\">&#125;()</span><br></pre></td></tr></table></figure>\n<p>同时为了不必要的渲染动作影响性能，可以对<code>renderOptions</code>进行配置：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">    vi.renderOptions = [.disableCameraGrain, </span><br><span class=\"line\">                        .disableHDR, </span><br><span class=\"line\">                        .disableMotionBlur,</span><br><span class=\"line\">                        .disableDepthOfField,</span><br><span class=\"line\">                        .disableFaceOcclusions,</span><br><span class=\"line\">                        .disablePersonOcclusion, </span><br><span class=\"line\">                        .disableGroundingShadows, </span><br><span class=\"line\">                        .disableAREnvironmentLighting]</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p>同时为了后期调试的方便，可以对应的打开debug模式，一般开一个世界坐标系就可以：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">    vi.debugOptions = [.showWorldOrigin]</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p>然后将<code>arView</code>添加到对应控制器中的视图就可以：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">viewDidLoad</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.viewDidLoad()</span><br><span class=\"line\"></span><br><span class=\"line\">    view.addSubview(arView)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2>ARCoachingOverlayView</h2>\n<p>这边我们使用一个系统提供的AR引导动画，对它进行一个初始化：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"built_in\">lazy</span> <span class=\"keyword\">var</span> coachingOverlay: <span class=\"type\">ARCoachingOverlayView</span> = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"built_in\">c</span> = <span class=\"type\">ARCoachingOverlayView</span>(frame: arView.bounds)</span><br><span class=\"line\">    <span class=\"built_in\">c</span>.session = arView.session</span><br><span class=\"line\">    arView.addSubview(<span class=\"built_in\">c</span>)</span><br><span class=\"line\">&#125;()</span><br></pre></td></tr></table></figure>\n<p>其实<code>ARCoachingOverlayView</code>可以直接对于平面识别后提供一个代理的回调，但是对于反复识别不够灵敏且使用上不够灵活，所以我们在设置识别平面后，会把自动识别到平面后消失的状态关闭，由我们手动控制，所以这边代理可实现可不实现（代理是针对<code>ARCoachingOverlayView</code>是否处于活跃状态的回调，由于我们自己手动控制它的状态，所以这些状态不一定要通过这个回调），但我们实现看下他的相关方法：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">    <span class=\"built_in\">c</span>.delegate = <span class=\"keyword\">self</span></span><br><span class=\"line\">    <span class=\"built_in\">c</span>.goal = .horizontalPlane</span><br><span class=\"line\">    <span class=\"built_in\">c</span>.activatesAutomatically = <span class=\"literal\">false</span></span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p>相关代理：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">UIViewController</span>: <span class=\"title\">ARCoachingOverlayViewDelegate</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// coachingOverlayView即将处于识别活跃状态</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">coachingOverlayViewWillActivate</span><span class=\"params\">(<span class=\"number\">_</span> coachingOverlayView: ARCoachingOverlayView)</span></span> &#123; &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/// coachingOverlayView已经处于取消识别活跃状态</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">coachingOverlayViewDidDeactivate</span><span class=\"params\">(<span class=\"number\">_</span> coachingOverlayView: ARCoachingOverlayView)</span></span> &#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// coachingOverlayView点击重置的回调</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">coachingOverlayViewDidRequestSessionReset</span><span class=\"params\">(<span class=\"number\">_</span> coachingOverlayView: ARCoachingOverlayView)</span></span> &#123; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这边是简单实现，所以我们在进入页面时就可以开始进行一个识别：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">    <span class=\"built_in\">c</span>.setActive(<span class=\"literal\">true</span>, animated: <span class=\"literal\">true</span>)</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p>然后添加到<code>arView</code>上：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">    arView.addSubview(coachingOverlay)</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<h2>效果图</h2>\n<p>这时候我们可以看下效果图：<br>\n<img src=\"/img/article/20210830/1.png\" alt=\"效果图\"></p>\n<h1>平面检测</h1>\n<p>现在我们需要对于现实世界进行一个平面检测，主要通过<code>ARSession</code>，<code>ARSession</code>无需我们自己创建，就是从<code>ARView</code>中直接获取，先把他声明下，方便使用：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">var</span> session: <span class=\"type\">ARSession</span> &#123;</span><br><span class=\"line\">    arView.session</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后对<code>session</code>进行一些配置，同时识别水平平面；这边我们创建的<code>ARWorldTrackingConfiguration</code>，它内部还有很多其他配置（如图片识别、人脸识别等等）：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">setupARSession</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> configuration = <span class=\"type\">ARWorldTrackingConfiguration</span>()</span><br><span class=\"line\">    configuration.planeDetection = [.horizontal]</span><br><span class=\"line\">    configuration.environmentTexturing = .automatic</span><br><span class=\"line\">    session.run(configuration, options: [])</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>一个关键点，<code>session</code>的代理，在代理里面我们就可以在现实世界检测平面并做出回调：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">    session.delegate = <span class=\"keyword\">self</span></span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p>相关代理：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">UIViewController</span>: <span class=\"title\">ARSessionDelegate</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/// 每帧调用</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">session</span><span class=\"params\">(<span class=\"number\">_</span> session: ARSession, didUpdate frame: ARFrame)</span></span> &#123; &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/// 新锚点添加时调用(系统会自动识别到平面时添加锚点)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">session</span><span class=\"params\">(<span class=\"number\">_</span> session: ARSession, didAdd anchors: [ARAnchor])</span></span> &#123; &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/// 锚点更新时调用</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">session</span><span class=\"params\">(<span class=\"number\">_</span> session: ARSession, didUpdate anchors: [ARAnchor])</span></span> &#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// 锚点移除时调用</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">session</span><span class=\"params\">(<span class=\"number\">_</span> session: ARSession, didRemove anchors: [ARAnchor])</span></span> &#123; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>根据上面的回调，其实我们只要用第二个回调方法，在添加水平平面的锚点后，在该锚点位置添加我们的模型就可以了，所以，我们先看下如何创建一个模型（这边只做简单demo，如果想要复杂化，比如检测到平面不立即添加模型，而是有个选择框让用户手动点击添加，可以使用第一个方法，每帧调用的回调，在屏幕上渲染一个选择框，并实时检测是否存在平面）。</p>\n<h1>模型创建与放置</h1>\n<h2>自定义Entity类</h2>\n<p>这边自定义一个<code>AnchorEntity</code>类，继承<code>Entity</code>和<code>HasAnchoring</code>两个协议，同时内部初始化异步加载一个<code>ModelEntity</code>，放置卡线程，异步方法内部实现是<code>Combine</code>框架（这边的模型直接使用苹果官方推荐的<code>USDZ</code>模型格式，其他还有<code>OBJ</code>格式的模型，但这种格式的模型和纹理是两个文件，在渲染合成后存在内存问题，虽然有解决方案，但感觉不是很完美）：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ShoeEntity</span>: <span class=\"title\">Entity</span>, <span class=\"title\">HasAnchoring</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> cancels: <span class=\"type\">Set</span>&lt;<span class=\"type\">AnyCancellable</span>&gt; = .<span class=\"keyword\">init</span>()</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">required</span> <span class=\"keyword\">init</span>(name: <span class=\"type\">String</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.<span class=\"keyword\">init</span>()</span><br><span class=\"line\">        </span><br><span class=\"line\">        loadEntity(name: name)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">loadEntity</span><span class=\"params\">(name: String)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Entity</span>.loadModelAsync(named: name).sink &#123; error <span class=\"keyword\">in</span></span><br><span class=\"line\">            <span class=\"built_in\">debugPrint</span>(error)</span><br><span class=\"line\">        &#125; receiveValue: &#123; [<span class=\"keyword\">weak</span> <span class=\"keyword\">self</span>] entity <span class=\"keyword\">in</span></span><br><span class=\"line\">            <span class=\"keyword\">self</span>?.addChild(entity)</span><br><span class=\"line\">        &#125;.store(<span class=\"keyword\">in</span>: &amp;cancels)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">required</span> <span class=\"keyword\">init</span>() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">fatalError</span>(<span class=\"string\">\"init() has not been implemented\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们定义一个模型属性：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private lazy var shoeEntity: ShoeEntity = .init(name: &quot;shoe.usdz&quot;)</span><br></pre></td></tr></table></figure>\n<h2>添加模型并展示</h2>\n<p>模型已经有了，然后就是在检测到锚点时关闭引导动画并展示我们的模型，，基础功能就完成了：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">session</span><span class=\"params\">(<span class=\"number\">_</span> session: ARSession, didAdd anchors: [ARAnchor])</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">guard</span> <span class=\"keyword\">let</span> anchor = anchors.<span class=\"built_in\">filter</span>(&#123; $<span class=\"number\">0</span> <span class=\"keyword\">is</span> <span class=\"type\">ARPlaneAnchor</span> &#125;).first <span class=\"keyword\">as</span>? <span class=\"type\">ARPlaneAnchor</span>,</span><br><span class=\"line\">          anchor.alignment == .horizontal <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    coachingOverlay.setActive(<span class=\"literal\">false</span>, animated: <span class=\"literal\">true</span>)</span><br><span class=\"line\">    shoeEntity.transform.matrix = anchor.transform</span><br><span class=\"line\">    arView.scene.addAnchor(shoeEntity)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1>效果视频</h1>\n<p><img src=\"/img/article/20210830/2.mp4\" alt=\"效果视频\"></p>\n<h1>总结</h1>\n<p>以上就是一个简单的真实世界识别水平平面并展示模型的一个流程，在整理文章的过程中也让我对<code>RealityKit</code>有了更深的理解，把他更为精简的实现。<br>\n后续的话，还有更多的细节可以优化，包括光照，手势，位置修正等等，有时间再更。</p>\n"},{"title":"RealityKit - 基础概念","catalog":true,"toc_nav_num":true,"date":"2021-06-21T11:36:20.000Z","subtitle":"RealityKit Experience","header-img":"/img/article_header/article_header.png","busuanzi":true,"_content":"\n# 前言\n\n最近Apple刚好在`WWDC21`上发布了[Object Capture](https://developer.apple.com/documentation/realitykit/capturing_photographs_for_realitykit_object_capture/)，基于这个契机，我们就想用苹果提供生成的模型加上最新的`RealityKit`框架进行一次实景AR开发，这篇文章就简单介绍`RealityKit`的基础概念。\n\n# 介绍\n\n`RealityKit`框架专门为增强现实量身定制，能够提供逼真的图像渲染、相机特效、动画、物理特效等等。借助原生`ARKit`整合、基于物理的超逼真渲染、变换和骨骼动画、空间音频和刚体物理，`RealityKit`可以比以往更加快速轻松地进行增强现实开发。\n\n# 基础概念\n\n如下图`ARView`的结构层次：\n![RealityKit](/img/article/20210621/1.png)\n\n首先`ARView`就是用于展示AR体验的视图，可以将它添加到父视图中，通过初始化`cameraMode`的不同，可以确定是否需要使用相机生成真实的AR场景还是虚拟场景，这个比较简单。看下API：\n``` swift\npublic init(frame frameRect: CGRect, cameraMode: ARView.CameraMode, automaticallyConfigureSession: Bool)\n```\n\n其次是`Scene`就是保存AR视图呈现的容器，我们不需要直接创建，可以通过`ARView·`获取到`scene`这个熟悉，后续我们的模型都是直接或者间接添加到这个`scene`上。\n\n然后就是`Entity`了，这里有`Anchor Entity`，`Model Entity`，其实本质都是继承与`Entity`，同时，如果我们想要自定义一些`Entity`，我们可以通过继承`Entity`，同时实现相应的协议，同时加载相应的`Component`，就可以创建具有不同外观和行为的实体，如下图：\n![RealityKit](/img/article/20210621/2.png)\n\n这边又有两个概念，一个是协议，一个是`Component`，其实概括来讲就是协议让`Entity`拥有了某项能力，而`Component`则是用来真正装备该能力的组件修饰，所以，如果我想要一个`Entity`拥有外观属性（大小、颜色），那我们我们就需要继承`HasModel`这个协议，同时配置`Component`这个属性赋予这个实体真正的外观属性，后面再深入介绍。\n\n苹果默认提供了两个基础`Entity`，一个是`Anchor Entity`，一个是`Model Entity`，现在我们就来具体介绍这两个`Entity`。\n\n# Entity\n\n一个基类`Entity`默认实现了`HasTransform`和`HasSynchronization`协议，拥有`Transform component`与`Synchronization component`两个组件，分别用于空间转换（大小、位移，旋转）与联网时的同步操作，同时还实现了`HasHierarchy`协议，允许所有的`Entity`拥有层级关系（父实体，子实体）。\n\n## AnchorEntity\n\n`Anchor Entity`默认实现了`HasAnchoring`协议，实现该协议之后就是允许该实体能够将该虚拟内容渲染到真实世界，我们一般用来把他作为基础实体，然后后续具体的实体添加到这个`Anchor Entity`上，后续添加到`ARView`上继续渲染，可以把他当成一个载体，本身并没有形状或者外观。\n\n## ModelEntity\n\n另一个默认提供的实体是`Model Entity`，实现了`HasModel`, `HasPhysics`两个协议。\n- `HasModel`这个协议本身就继承于`HasTransform`协议，他针对与`HasTransform`协议，又增加了一个`Model component`组件，允许设置该实体的外观大小包括纹理等信息。\n- `HasPhysics`这个协议是`HasPhysicsBody`与`HasPhysicsMotion`协议的总和。\n    - `HasPhysicsBody`又继承于`HasCollision`，`HasCollision`又继承于`HasTransform`。`HasCollision`增加的组件特性就是碰撞体积与控制模式（是否需要记录细节碰撞信息）；`HasPhysicsBody`新增的组件特性是允许对该物体施加外力并进行运动。\n    - `HasPhysicsMotion`新增的组件特性是基础运动模式，能够在创建后无需外力就保持一个持续的运动，同时判断是否允许外界改变行为；\n\n## 自定义Entity\n\n所以，基于上面的介绍，我们自定义`Entity`也就很简单了，只要针对于我们的场景，选择不同的协议与添加对于的`Component`就可以得到我们定制的实体，用于展示，非常Swift。\n\n# 简单实现\n\n那么我们就来简单实现一个非AR场景下的Box实体，并增加一个自旋动作。\n首选我们就自定义一个实体，有以下需求：\n- 直接添加到`Scene`上，需要有`Anchor Entity`的锚点添加特性，所以继承`HasAnchoring`协议\n- 需要自定义一个形状box和颜色，所以继承`HasModel`协议\n- 需要增加一个自旋匀速运动，所以继承`HasPhysics`协议\n\n``` swift\nclass Box: Entity, HasAnchoring, HasModel, HasPhysics {\n    required init(world: SIMD3<Float>) {\n        super.init()\n        \n        position = world\n\n        // 设置大小，颜色，形状\n        model = ModelComponent(\n            mesh: .generateBox(size: 0.5),\n            materials: [SimpleMaterial(color: .cyan, roughness: 0.5, isMetallic: true)]\n        )\n\n        // 设置碰撞体积\n        collision = CollisionComponent(\n            shapes: [.generateBox(size: [0.5, 0.5, 0.5])],\n            mode: .default,\n            filter: .default\n        )\n\n        // 设置物理模型大小，密度，运动模式(非动态)\n        physicsBody = {\n            var c = PhysicsBodyComponent(\n                shapes: [ShapeResource.generateBox(size: [0.5, 0.5, 0.5])],\n                density: 0.95,\n                material: .generate(),\n                mode: .kinematic\n            )\n            return c\n        }()\n        \n        // 给定y方向恒定角速度转动\n        physicsMotion = PhysicsMotionComponent(linearVelocity: [0, 0, 0], angularVelocity: [0, 1, 0])\n    }\n    \n    required init() {\n        fatalError(\"init() has not been implemented\")\n    }\n}\n```\n这样，一个简单的自定义实体就已经定制完了。\n\n然后创建我们的`ARView`，添加到主视图，并通过`ARView`获取的`Scene`添加`Box`实例，然后就能肯定一个沿着y轴恒定速度旋转的盒子了。\n代码如下：\n\n``` swift\nclass ViewController: UIViewController {\n    override func viewDidLoad() {\n        super.viewDidLoad() \n\n        let arView = ARView(frame: view.bounds, cameraMode: .nonAR, automaticallyConfigureSession: false)\n        view.addSubview(arView)\n\n        let box = Box(world: [0, 0, 0])\n        arView.scene.addAnchor(box)\n    }\n}\n```\n\n效果图：\n![RealityKit](/img/article/20210621/3.png)\n\n# 结语\n\n一个简单的旋转模型就实现了，是不是很简单，可以自己尝试下。","source":"_posts/2021/realitykit-0621.md","raw":"---\ntitle: \"RealityKit - 基础概念\"\ncatalog: true\ntoc_nav_num: true\ndate: 2021-06-21 19:36:20\nsubtitle: \"RealityKit Experience\"\nheader-img: \"/img/article_header/article_header.png\"\nbusuanzi: true\ntags:\n- iOS - Swift\n\n---\n\n# 前言\n\n最近Apple刚好在`WWDC21`上发布了[Object Capture](https://developer.apple.com/documentation/realitykit/capturing_photographs_for_realitykit_object_capture/)，基于这个契机，我们就想用苹果提供生成的模型加上最新的`RealityKit`框架进行一次实景AR开发，这篇文章就简单介绍`RealityKit`的基础概念。\n\n# 介绍\n\n`RealityKit`框架专门为增强现实量身定制，能够提供逼真的图像渲染、相机特效、动画、物理特效等等。借助原生`ARKit`整合、基于物理的超逼真渲染、变换和骨骼动画、空间音频和刚体物理，`RealityKit`可以比以往更加快速轻松地进行增强现实开发。\n\n# 基础概念\n\n如下图`ARView`的结构层次：\n![RealityKit](/img/article/20210621/1.png)\n\n首先`ARView`就是用于展示AR体验的视图，可以将它添加到父视图中，通过初始化`cameraMode`的不同，可以确定是否需要使用相机生成真实的AR场景还是虚拟场景，这个比较简单。看下API：\n``` swift\npublic init(frame frameRect: CGRect, cameraMode: ARView.CameraMode, automaticallyConfigureSession: Bool)\n```\n\n其次是`Scene`就是保存AR视图呈现的容器，我们不需要直接创建，可以通过`ARView·`获取到`scene`这个熟悉，后续我们的模型都是直接或者间接添加到这个`scene`上。\n\n然后就是`Entity`了，这里有`Anchor Entity`，`Model Entity`，其实本质都是继承与`Entity`，同时，如果我们想要自定义一些`Entity`，我们可以通过继承`Entity`，同时实现相应的协议，同时加载相应的`Component`，就可以创建具有不同外观和行为的实体，如下图：\n![RealityKit](/img/article/20210621/2.png)\n\n这边又有两个概念，一个是协议，一个是`Component`，其实概括来讲就是协议让`Entity`拥有了某项能力，而`Component`则是用来真正装备该能力的组件修饰，所以，如果我想要一个`Entity`拥有外观属性（大小、颜色），那我们我们就需要继承`HasModel`这个协议，同时配置`Component`这个属性赋予这个实体真正的外观属性，后面再深入介绍。\n\n苹果默认提供了两个基础`Entity`，一个是`Anchor Entity`，一个是`Model Entity`，现在我们就来具体介绍这两个`Entity`。\n\n# Entity\n\n一个基类`Entity`默认实现了`HasTransform`和`HasSynchronization`协议，拥有`Transform component`与`Synchronization component`两个组件，分别用于空间转换（大小、位移，旋转）与联网时的同步操作，同时还实现了`HasHierarchy`协议，允许所有的`Entity`拥有层级关系（父实体，子实体）。\n\n## AnchorEntity\n\n`Anchor Entity`默认实现了`HasAnchoring`协议，实现该协议之后就是允许该实体能够将该虚拟内容渲染到真实世界，我们一般用来把他作为基础实体，然后后续具体的实体添加到这个`Anchor Entity`上，后续添加到`ARView`上继续渲染，可以把他当成一个载体，本身并没有形状或者外观。\n\n## ModelEntity\n\n另一个默认提供的实体是`Model Entity`，实现了`HasModel`, `HasPhysics`两个协议。\n- `HasModel`这个协议本身就继承于`HasTransform`协议，他针对与`HasTransform`协议，又增加了一个`Model component`组件，允许设置该实体的外观大小包括纹理等信息。\n- `HasPhysics`这个协议是`HasPhysicsBody`与`HasPhysicsMotion`协议的总和。\n    - `HasPhysicsBody`又继承于`HasCollision`，`HasCollision`又继承于`HasTransform`。`HasCollision`增加的组件特性就是碰撞体积与控制模式（是否需要记录细节碰撞信息）；`HasPhysicsBody`新增的组件特性是允许对该物体施加外力并进行运动。\n    - `HasPhysicsMotion`新增的组件特性是基础运动模式，能够在创建后无需外力就保持一个持续的运动，同时判断是否允许外界改变行为；\n\n## 自定义Entity\n\n所以，基于上面的介绍，我们自定义`Entity`也就很简单了，只要针对于我们的场景，选择不同的协议与添加对于的`Component`就可以得到我们定制的实体，用于展示，非常Swift。\n\n# 简单实现\n\n那么我们就来简单实现一个非AR场景下的Box实体，并增加一个自旋动作。\n首选我们就自定义一个实体，有以下需求：\n- 直接添加到`Scene`上，需要有`Anchor Entity`的锚点添加特性，所以继承`HasAnchoring`协议\n- 需要自定义一个形状box和颜色，所以继承`HasModel`协议\n- 需要增加一个自旋匀速运动，所以继承`HasPhysics`协议\n\n``` swift\nclass Box: Entity, HasAnchoring, HasModel, HasPhysics {\n    required init(world: SIMD3<Float>) {\n        super.init()\n        \n        position = world\n\n        // 设置大小，颜色，形状\n        model = ModelComponent(\n            mesh: .generateBox(size: 0.5),\n            materials: [SimpleMaterial(color: .cyan, roughness: 0.5, isMetallic: true)]\n        )\n\n        // 设置碰撞体积\n        collision = CollisionComponent(\n            shapes: [.generateBox(size: [0.5, 0.5, 0.5])],\n            mode: .default,\n            filter: .default\n        )\n\n        // 设置物理模型大小，密度，运动模式(非动态)\n        physicsBody = {\n            var c = PhysicsBodyComponent(\n                shapes: [ShapeResource.generateBox(size: [0.5, 0.5, 0.5])],\n                density: 0.95,\n                material: .generate(),\n                mode: .kinematic\n            )\n            return c\n        }()\n        \n        // 给定y方向恒定角速度转动\n        physicsMotion = PhysicsMotionComponent(linearVelocity: [0, 0, 0], angularVelocity: [0, 1, 0])\n    }\n    \n    required init() {\n        fatalError(\"init() has not been implemented\")\n    }\n}\n```\n这样，一个简单的自定义实体就已经定制完了。\n\n然后创建我们的`ARView`，添加到主视图，并通过`ARView`获取的`Scene`添加`Box`实例，然后就能肯定一个沿着y轴恒定速度旋转的盒子了。\n代码如下：\n\n``` swift\nclass ViewController: UIViewController {\n    override func viewDidLoad() {\n        super.viewDidLoad() \n\n        let arView = ARView(frame: view.bounds, cameraMode: .nonAR, automaticallyConfigureSession: false)\n        view.addSubview(arView)\n\n        let box = Box(world: [0, 0, 0])\n        arView.scene.addAnchor(box)\n    }\n}\n```\n\n效果图：\n![RealityKit](/img/article/20210621/3.png)\n\n# 结语\n\n一个简单的旋转模型就实现了，是不是很简单，可以自己尝试下。","slug":"2021/realitykit-0621","published":1,"updated":"2022-01-10T09:04:52.811Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cky8gmc4m001qd1qhk9oeuelv","content":"<h1 id=\"前言\">前言</h1>\n<p>最近Apple刚好在<code>WWDC21</code>上发布了<a href=\"https://developer.apple.com/documentation/realitykit/capturing_photographs_for_realitykit_object_capture/\" target=\"_blank\" rel=\"noopener\">Object Capture</a>，基于这个契机，我们就想用苹果提供生成的模型加上最新的<code>RealityKit</code>框架进行一次实景AR开发，这篇文章就简单介绍<code>RealityKit</code>的基础概念。</p>\n<h1 id=\"介绍\">介绍</h1>\n<p><code>RealityKit</code>框架专门为增强现实量身定制，能够提供逼真的图像渲染、相机特效、动画、物理特效等等。借助原生<code>ARKit</code>整合、基于物理的超逼真渲染、变换和骨骼动画、空间音频和刚体物理，<code>RealityKit</code>可以比以往更加快速轻松地进行增强现实开发。</p>\n<h1 id=\"基础概念\">基础概念</h1>\n<p>如下图<code>ARView</code>的结构层次：<br>\n<img src=\"/img/article/20210621/1.png\" alt=\"RealityKit\"></p>\n<p>首先<code>ARView</code>就是用于展示AR体验的视图，可以将它添加到父视图中，通过初始化<code>cameraMode</code>的不同，可以确定是否需要使用相机生成真实的AR场景还是虚拟场景，这个比较简单。看下API：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">init</span>(frame frameRect: <span class=\"type\">CGRect</span>, cameraMode: <span class=\"type\">ARView</span>.<span class=\"type\">CameraMode</span>, automaticallyConfigureSession: <span class=\"type\">Bool</span>)</span><br></pre></td></tr></table></figure>\n<p>其次是<code>Scene</code>就是保存AR视图呈现的容器，我们不需要直接创建，可以通过<code>ARView·</code>获取到<code>scene</code>这个熟悉，后续我们的模型都是直接或者间接添加到这个<code>scene</code>上。</p>\n<p>然后就是<code>Entity</code>了，这里有<code>Anchor Entity</code>，<code>Model Entity</code>，其实本质都是继承与<code>Entity</code>，同时，如果我们想要自定义一些<code>Entity</code>，我们可以通过继承<code>Entity</code>，同时实现相应的协议，同时加载相应的<code>Component</code>，就可以创建具有不同外观和行为的实体，如下图：<br>\n<img src=\"/img/article/20210621/2.png\" alt=\"RealityKit\"></p>\n<p>这边又有两个概念，一个是协议，一个是<code>Component</code>，其实概括来讲就是协议让<code>Entity</code>拥有了某项能力，而<code>Component</code>则是用来真正装备该能力的组件修饰，所以，如果我想要一个<code>Entity</code>拥有外观属性（大小、颜色），那我们我们就需要继承<code>HasModel</code>这个协议，同时配置<code>Component</code>这个属性赋予这个实体真正的外观属性，后面再深入介绍。</p>\n<p>苹果默认提供了两个基础<code>Entity</code>，一个是<code>Anchor Entity</code>，一个是<code>Model Entity</code>，现在我们就来具体介绍这两个<code>Entity</code>。</p>\n<h1 id=\"entity\">Entity</h1>\n<p>一个基类<code>Entity</code>默认实现了<code>HasTransform</code>和<code>HasSynchronization</code>协议，拥有<code>Transform component</code>与<code>Synchronization component</code>两个组件，分别用于空间转换（大小、位移，旋转）与联网时的同步操作，同时还实现了<code>HasHierarchy</code>协议，允许所有的<code>Entity</code>拥有层级关系（父实体，子实体）。</p>\n<h2 id=\"anchorentity\">AnchorEntity</h2>\n<p><code>Anchor Entity</code>默认实现了<code>HasAnchoring</code>协议，实现该协议之后就是允许该实体能够将该虚拟内容渲染到真实世界，我们一般用来把他作为基础实体，然后后续具体的实体添加到这个<code>Anchor Entity</code>上，后续添加到<code>ARView</code>上继续渲染，可以把他当成一个载体，本身并没有形状或者外观。</p>\n<h2 id=\"modelentity\">ModelEntity</h2>\n<p>另一个默认提供的实体是<code>Model Entity</code>，实现了<code>HasModel</code>, <code>HasPhysics</code>两个协议。</p>\n<ul>\n<li><code>HasModel</code>这个协议本身就继承于<code>HasTransform</code>协议，他针对与<code>HasTransform</code>协议，又增加了一个<code>Model component</code>组件，允许设置该实体的外观大小包括纹理等信息。</li>\n<li><code>HasPhysics</code>这个协议是<code>HasPhysicsBody</code>与<code>HasPhysicsMotion</code>协议的总和。\n<ul>\n<li><code>HasPhysicsBody</code>又继承于<code>HasCollision</code>，<code>HasCollision</code>又继承于<code>HasTransform</code>。<code>HasCollision</code>增加的组件特性就是碰撞体积与控制模式（是否需要记录细节碰撞信息）；<code>HasPhysicsBody</code>新增的组件特性是允许对该物体施加外力并进行运动。</li>\n<li><code>HasPhysicsMotion</code>新增的组件特性是基础运动模式，能够在创建后无需外力就保持一个持续的运动，同时判断是否允许外界改变行为；</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"自定义entity\">自定义Entity</h2>\n<p>所以，基于上面的介绍，我们自定义<code>Entity</code>也就很简单了，只要针对于我们的场景，选择不同的协议与添加对于的<code>Component</code>就可以得到我们定制的实体，用于展示，非常Swift。</p>\n<h1 id=\"简单实现\">简单实现</h1>\n<p>那么我们就来简单实现一个非AR场景下的Box实体，并增加一个自旋动作。<br>\n首选我们就自定义一个实体，有以下需求：</p>\n<ul>\n<li>直接添加到<code>Scene</code>上，需要有<code>Anchor Entity</code>的锚点添加特性，所以继承<code>HasAnchoring</code>协议</li>\n<li>需要自定义一个形状box和颜色，所以继承<code>HasModel</code>协议</li>\n<li>需要增加一个自旋匀速运动，所以继承<code>HasPhysics</code>协议</li>\n</ul>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Box</span>: <span class=\"title\">Entity</span>, <span class=\"title\">HasAnchoring</span>, <span class=\"title\">HasModel</span>, <span class=\"title\">HasPhysics</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">required</span> <span class=\"keyword\">init</span>(world: <span class=\"type\">SIMD3</span>&lt;<span class=\"type\">Float</span>&gt;) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.<span class=\"keyword\">init</span>()</span><br><span class=\"line\">        </span><br><span class=\"line\">        position = world</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 设置大小，颜色，形状</span></span><br><span class=\"line\">        model = <span class=\"type\">ModelComponent</span>(</span><br><span class=\"line\">            mesh: .generateBox(size: <span class=\"number\">0.5</span>),</span><br><span class=\"line\">            materials: [<span class=\"type\">SimpleMaterial</span>(color: .cyan, roughness: <span class=\"number\">0.5</span>, isMetallic: <span class=\"literal\">true</span>)]</span><br><span class=\"line\">        )</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 设置碰撞体积</span></span><br><span class=\"line\">        collision = <span class=\"type\">CollisionComponent</span>(</span><br><span class=\"line\">            shapes: [.generateBox(size: [<span class=\"number\">0.5</span>, <span class=\"number\">0.5</span>, <span class=\"number\">0.5</span>])],</span><br><span class=\"line\">            mode: .<span class=\"keyword\">default</span>,</span><br><span class=\"line\">            <span class=\"built_in\">filter</span>: .<span class=\"keyword\">default</span></span><br><span class=\"line\">        )</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 设置物理模型大小，密度，运动模式(非动态)</span></span><br><span class=\"line\">        physicsBody = &#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> <span class=\"built_in\">c</span> = <span class=\"type\">PhysicsBodyComponent</span>(</span><br><span class=\"line\">                shapes: [<span class=\"type\">ShapeResource</span>.generateBox(size: [<span class=\"number\">0.5</span>, <span class=\"number\">0.5</span>, <span class=\"number\">0.5</span>])],</span><br><span class=\"line\">                density: <span class=\"number\">0.95</span>,</span><br><span class=\"line\">                material: .generate(),</span><br><span class=\"line\">                mode: .kinematic</span><br><span class=\"line\">            )</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">c</span></span><br><span class=\"line\">        &#125;()</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 给定y方向恒定角速度转动</span></span><br><span class=\"line\">        physicsMotion = <span class=\"type\">PhysicsMotionComponent</span>(linearVelocity: [<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>], angularVelocity: [<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">required</span> <span class=\"keyword\">init</span>() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">fatalError</span>(<span class=\"string\">\"init() has not been implemented\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样，一个简单的自定义实体就已经定制完了。</p>\n<p>然后创建我们的<code>ARView</code>，添加到主视图，并通过<code>ARView</code>获取的<code>Scene</code>添加<code>Box</code>实例，然后就能肯定一个沿着y轴恒定速度旋转的盒子了。<br>\n代码如下：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ViewController</span>: <span class=\"title\">UIViewController</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">viewDidLoad</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.viewDidLoad() </span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">let</span> arView = <span class=\"type\">ARView</span>(frame: view.bounds, cameraMode: .nonAR, automaticallyConfigureSession: <span class=\"literal\">false</span>)</span><br><span class=\"line\">        view.addSubview(arView)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">let</span> box = <span class=\"type\">Box</span>(world: [<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>])</span><br><span class=\"line\">        arView.scene.addAnchor(box)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>效果图：<br>\n<img src=\"/img/article/20210621/3.png\" alt=\"RealityKit\"></p>\n<h1 id=\"结语\">结语</h1>\n<p>一个简单的旋转模型就实现了，是不是很简单，可以自己尝试下。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1>前言</h1>\n<p>最近Apple刚好在<code>WWDC21</code>上发布了<a href=\"https://developer.apple.com/documentation/realitykit/capturing_photographs_for_realitykit_object_capture/\" target=\"_blank\" rel=\"noopener\">Object Capture</a>，基于这个契机，我们就想用苹果提供生成的模型加上最新的<code>RealityKit</code>框架进行一次实景AR开发，这篇文章就简单介绍<code>RealityKit</code>的基础概念。</p>\n<h1>介绍</h1>\n<p><code>RealityKit</code>框架专门为增强现实量身定制，能够提供逼真的图像渲染、相机特效、动画、物理特效等等。借助原生<code>ARKit</code>整合、基于物理的超逼真渲染、变换和骨骼动画、空间音频和刚体物理，<code>RealityKit</code>可以比以往更加快速轻松地进行增强现实开发。</p>\n<h1>基础概念</h1>\n<p>如下图<code>ARView</code>的结构层次：<br>\n<img src=\"/img/article/20210621/1.png\" alt=\"RealityKit\"></p>\n<p>首先<code>ARView</code>就是用于展示AR体验的视图，可以将它添加到父视图中，通过初始化<code>cameraMode</code>的不同，可以确定是否需要使用相机生成真实的AR场景还是虚拟场景，这个比较简单。看下API：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">init</span>(frame frameRect: <span class=\"type\">CGRect</span>, cameraMode: <span class=\"type\">ARView</span>.<span class=\"type\">CameraMode</span>, automaticallyConfigureSession: <span class=\"type\">Bool</span>)</span><br></pre></td></tr></table></figure>\n<p>其次是<code>Scene</code>就是保存AR视图呈现的容器，我们不需要直接创建，可以通过<code>ARView·</code>获取到<code>scene</code>这个熟悉，后续我们的模型都是直接或者间接添加到这个<code>scene</code>上。</p>\n<p>然后就是<code>Entity</code>了，这里有<code>Anchor Entity</code>，<code>Model Entity</code>，其实本质都是继承与<code>Entity</code>，同时，如果我们想要自定义一些<code>Entity</code>，我们可以通过继承<code>Entity</code>，同时实现相应的协议，同时加载相应的<code>Component</code>，就可以创建具有不同外观和行为的实体，如下图：<br>\n<img src=\"/img/article/20210621/2.png\" alt=\"RealityKit\"></p>\n<p>这边又有两个概念，一个是协议，一个是<code>Component</code>，其实概括来讲就是协议让<code>Entity</code>拥有了某项能力，而<code>Component</code>则是用来真正装备该能力的组件修饰，所以，如果我想要一个<code>Entity</code>拥有外观属性（大小、颜色），那我们我们就需要继承<code>HasModel</code>这个协议，同时配置<code>Component</code>这个属性赋予这个实体真正的外观属性，后面再深入介绍。</p>\n<p>苹果默认提供了两个基础<code>Entity</code>，一个是<code>Anchor Entity</code>，一个是<code>Model Entity</code>，现在我们就来具体介绍这两个<code>Entity</code>。</p>\n<h1>Entity</h1>\n<p>一个基类<code>Entity</code>默认实现了<code>HasTransform</code>和<code>HasSynchronization</code>协议，拥有<code>Transform component</code>与<code>Synchronization component</code>两个组件，分别用于空间转换（大小、位移，旋转）与联网时的同步操作，同时还实现了<code>HasHierarchy</code>协议，允许所有的<code>Entity</code>拥有层级关系（父实体，子实体）。</p>\n<h2>AnchorEntity</h2>\n<p><code>Anchor Entity</code>默认实现了<code>HasAnchoring</code>协议，实现该协议之后就是允许该实体能够将该虚拟内容渲染到真实世界，我们一般用来把他作为基础实体，然后后续具体的实体添加到这个<code>Anchor Entity</code>上，后续添加到<code>ARView</code>上继续渲染，可以把他当成一个载体，本身并没有形状或者外观。</p>\n<h2>ModelEntity</h2>\n<p>另一个默认提供的实体是<code>Model Entity</code>，实现了<code>HasModel</code>, <code>HasPhysics</code>两个协议。</p>\n<ul>\n<li><code>HasModel</code>这个协议本身就继承于<code>HasTransform</code>协议，他针对与<code>HasTransform</code>协议，又增加了一个<code>Model component</code>组件，允许设置该实体的外观大小包括纹理等信息。</li>\n<li><code>HasPhysics</code>这个协议是<code>HasPhysicsBody</code>与<code>HasPhysicsMotion</code>协议的总和。\n<ul>\n<li><code>HasPhysicsBody</code>又继承于<code>HasCollision</code>，<code>HasCollision</code>又继承于<code>HasTransform</code>。<code>HasCollision</code>增加的组件特性就是碰撞体积与控制模式（是否需要记录细节碰撞信息）；<code>HasPhysicsBody</code>新增的组件特性是允许对该物体施加外力并进行运动。</li>\n<li><code>HasPhysicsMotion</code>新增的组件特性是基础运动模式，能够在创建后无需外力就保持一个持续的运动，同时判断是否允许外界改变行为；</li>\n</ul>\n</li>\n</ul>\n<h2>自定义Entity</h2>\n<p>所以，基于上面的介绍，我们自定义<code>Entity</code>也就很简单了，只要针对于我们的场景，选择不同的协议与添加对于的<code>Component</code>就可以得到我们定制的实体，用于展示，非常Swift。</p>\n<h1>简单实现</h1>\n<p>那么我们就来简单实现一个非AR场景下的Box实体，并增加一个自旋动作。<br>\n首选我们就自定义一个实体，有以下需求：</p>\n<ul>\n<li>直接添加到<code>Scene</code>上，需要有<code>Anchor Entity</code>的锚点添加特性，所以继承<code>HasAnchoring</code>协议</li>\n<li>需要自定义一个形状box和颜色，所以继承<code>HasModel</code>协议</li>\n<li>需要增加一个自旋匀速运动，所以继承<code>HasPhysics</code>协议</li>\n</ul>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Box</span>: <span class=\"title\">Entity</span>, <span class=\"title\">HasAnchoring</span>, <span class=\"title\">HasModel</span>, <span class=\"title\">HasPhysics</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">required</span> <span class=\"keyword\">init</span>(world: <span class=\"type\">SIMD3</span>&lt;<span class=\"type\">Float</span>&gt;) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.<span class=\"keyword\">init</span>()</span><br><span class=\"line\">        </span><br><span class=\"line\">        position = world</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 设置大小，颜色，形状</span></span><br><span class=\"line\">        model = <span class=\"type\">ModelComponent</span>(</span><br><span class=\"line\">            mesh: .generateBox(size: <span class=\"number\">0.5</span>),</span><br><span class=\"line\">            materials: [<span class=\"type\">SimpleMaterial</span>(color: .cyan, roughness: <span class=\"number\">0.5</span>, isMetallic: <span class=\"literal\">true</span>)]</span><br><span class=\"line\">        )</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 设置碰撞体积</span></span><br><span class=\"line\">        collision = <span class=\"type\">CollisionComponent</span>(</span><br><span class=\"line\">            shapes: [.generateBox(size: [<span class=\"number\">0.5</span>, <span class=\"number\">0.5</span>, <span class=\"number\">0.5</span>])],</span><br><span class=\"line\">            mode: .<span class=\"keyword\">default</span>,</span><br><span class=\"line\">            <span class=\"built_in\">filter</span>: .<span class=\"keyword\">default</span></span><br><span class=\"line\">        )</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 设置物理模型大小，密度，运动模式(非动态)</span></span><br><span class=\"line\">        physicsBody = &#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> <span class=\"built_in\">c</span> = <span class=\"type\">PhysicsBodyComponent</span>(</span><br><span class=\"line\">                shapes: [<span class=\"type\">ShapeResource</span>.generateBox(size: [<span class=\"number\">0.5</span>, <span class=\"number\">0.5</span>, <span class=\"number\">0.5</span>])],</span><br><span class=\"line\">                density: <span class=\"number\">0.95</span>,</span><br><span class=\"line\">                material: .generate(),</span><br><span class=\"line\">                mode: .kinematic</span><br><span class=\"line\">            )</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">c</span></span><br><span class=\"line\">        &#125;()</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 给定y方向恒定角速度转动</span></span><br><span class=\"line\">        physicsMotion = <span class=\"type\">PhysicsMotionComponent</span>(linearVelocity: [<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>], angularVelocity: [<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">required</span> <span class=\"keyword\">init</span>() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">fatalError</span>(<span class=\"string\">\"init() has not been implemented\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样，一个简单的自定义实体就已经定制完了。</p>\n<p>然后创建我们的<code>ARView</code>，添加到主视图，并通过<code>ARView</code>获取的<code>Scene</code>添加<code>Box</code>实例，然后就能肯定一个沿着y轴恒定速度旋转的盒子了。<br>\n代码如下：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ViewController</span>: <span class=\"title\">UIViewController</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">viewDidLoad</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.viewDidLoad() </span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">let</span> arView = <span class=\"type\">ARView</span>(frame: view.bounds, cameraMode: .nonAR, automaticallyConfigureSession: <span class=\"literal\">false</span>)</span><br><span class=\"line\">        view.addSubview(arView)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">let</span> box = <span class=\"type\">Box</span>(world: [<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>])</span><br><span class=\"line\">        arView.scene.addAnchor(box)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>效果图：<br>\n<img src=\"/img/article/20210621/3.png\" alt=\"RealityKit\"></p>\n<h1>结语</h1>\n<p>一个简单的旋转模型就实现了，是不是很简单，可以自己尝试下。</p>\n"},{"title":"OpenGL ES基础学习","catalog":true,"toc_nav_num":true,"date":"2019-05-19T10:20:03.000Z","subtitle":"Open Graphics Library for Embedded Systems","header-img":"/img/article_header/article_header.png","busuanzi":true,"_content":"\n# Introduction\n\nOpen Graphics Library(OpenGL)用于可视化2D与3D数据，是多用途的开放标准图形库，支持2D和3D数字内容创建、机械和建筑设计、虚拟原型、飞行仿真、视频游戏等等。我们可以使用OpenGL配置3D图形管线并向其提交数据。顶点被转换点亮，组装成基本类型，并进行栅格化来创建2D图片。OpenGL的设计目的是将函数调用转换为可以发送到底层图形硬件的图形命令，因为底层硬件专门处理图形命令，所以OpenGL的绘图非常快。\n\nOpenGL for Embedded Systems(OpenGL ES)是openGL的简化版，消除冗余功能，为移动图形硬件上提供一个更容易学习和实现的库。\n\n![OpenGL ES](/img/article/20190519/1.png)\n\nOpenGL ES允许应用程序利用底层图形处理器的能力，iOS设备上的GPU可以实现复杂的2D和3D绘图，以及图片上每个像素阴影的复杂计算。如果应用程序的而设计要求需要对GPU硬件有直接全面的访问，那么我们应该使用OpenGL ES。OpenGL ES典型的客户端包括视频游戏和呈现3D图形的模拟器。\n\n# Checklist for Building OpenGL ES Apps for iOS\n\nOpenGL ES为使用GPU硬件渲染图形规范定义了无关平台的API。实现OpenGL ES的平台提供了一个用于执行OpenGL ES命令的渲染上下文，持有渲染结果的帧缓冲区，一个或多个展示帧缓冲区内容的渲染目标。iOS中，*EAGLContext*实现了渲染上下文，iOS只提供了一种帧缓冲区类型，OpenGL ES帧缓冲区对象，和实现渲染地点的*GLKView*、*CAEAGLLayer*。\n\n在iOS中创建OpenGL ES应用需要有以下考虑，一些对于OpenGL ES编程通用的，还有一些是iOS特定的考虑：\n1. 决定适用于我们应用的OpenGL ES版本，创建上下文；\n2. 在运行时检测设备是否支持我们想要使用的OpenGL ES功能；\n3. 选择渲染OpenGL ES内容的位置；\n4. 确定应用在iOS中正确运行；\n5. 实现渲染引擎；\n6. 使用Xcode和Instruments调试OpenGL ES应用，调优以获取最优性能；\n\n## 选择OpenGL ES版本\n\n决定应用需要支持OpenGL ES 3.0，OpenGL ES 2.0，OpenGL ES 1.1还是多个版本：\n- OpenGL ES 3.0是在iOS 7的新版本，增加了许多新特性，实现高性能、通用GPU计算技术和之前只能在台式机和游戏机上才能实现的更复杂视觉效果\n- OpenGL ES 2.0是iOS设备的基础配置，具有基于可编程着色器的可配置图形管线\n- OpenGL ES 1.1仅提供基本的固定函数的图形通道，在iOS中主要用于向后兼容\n\n我们应该针对最相关的特性和应用程序的设备选择一个或多个版本，关于iOS设备功能更多可见[iOS Device Compatibility Reference](https://developer.apple.com/library/archive/documentation/DeviceInformation/Reference/iOSDeviceCompatibility/Introduction/Introduction.html#//apple_ref/doc/uid/TP40013599)\n\n## 验证OpenGL ES功能\n\n[iOS Device Compatibility Reference](https://developer.apple.com/library/archive/documentation/DeviceInformation/Reference/iOSDeviceCompatibility/Introduction/Introduction.html#//apple_ref/doc/uid/TP40013599)总结了在已发布iOS设备中可用的功能和扩展，但是，为了让应用程序能够在尽可能多的设备和iOS版本上运行，我们应该始终在运行时查询OpenGL ES可以实现的功能。\n\n要确定实现的特定限制，比如最大纹理大小或顶点属性的最大数量，使用相应的`glGet`方法查找对应的值（如在*gl.h*文件查找*MAX_TEXTURE_SIZE*或*MAX_VERTEX_ATTRIBS*）。\n\n使用`glGetIntegerv`和`glGetStringi`方法检测OpenGL ES 3.0的扩展：\n``` objectivec\n/// #import <OpenGLES/ES3/gl.h>\nBOOL CheckForExtensions(NSString *searchName) {\n    int max = 0;\n    glGetIntegerv(GL_NUM_EXTENSIONS, &max);\n    NSMutableSet *extensions = [NSMutableSet set];\n    for (int i = 0; i < max; i++) {\n        [extensions addObject:@((char *)glGetStringi(GL_EXTENSIONS, i))];\n    }\n    return [extensions containsObject:searchName];\n}\n/// 对于OpenGL ES 2.0和1.1的扩展，使用glGetString(GL_EXTENSIONS)获取以空格分隔的所有扩展名\n```\n\n## 选择渲染位置\n\niOS中，帧缓冲区对象存储了绘图命令的结果，我们可以通过以下多种方式使用帧缓冲区对象的内容：\n- *GLKit*框架提供了绘制OpenGL ES内容和管理自身帧缓冲区的view，和支持动画的控制器。使用这些类创建全屏视图或将OpenGL ES内容放入UIKit视图层次结构中。[Drawing with OpenGL ES and GLKit](#drawing-with-opengl-es-and-glkit)\n- *CAEAGLLayer*类提供绘制OpenGL ES内容作为Core Animation层级组合一部分的方法，但我们必须使用这个类创建自己的帧缓冲区\n- 与任意OpenGL ES实现一样，我们也可以使用帧缓冲区进行离屏图形处理或渲染图像管线其他地方使用的纹理。在OpenGL ES中，离屏缓冲区可以用于使用多个渲染目标的渲染算法\n\n更多关于离屏缓冲区、纹理、Core Animation层级的渲染，前往[Drawing to Other Rendering Destinatons](#drawing-to-other-rendering-destinations)\n\n## iOS集成\n\niOS应用默认支持多任务，但在OpenGL ES应用内处理这个特性需要额外考虑，不正确使用OpenGL ES会导致应用在后台被系统杀死。\n\n许多iOS设备包含高分辨率显示，所以我们需要支持多种显示尺寸和分辨率。\n\n了解如何支持这些和其他iOS特性，前往[Multitasking, High Resolution, and Other iOS Features](#multitasking,-high-resolution,-and-other-ios-features)。\n\n## 实现渲染引擎\n\n设计OpenGL ES绘图代码有许多可能的策略，其详细信息超出了文本的范围。渲染引擎设计的许多方面对于OpenGL和OpenGL ES的所有实现都是通用的。\n\n更多iOS设备设计考虑前往[OpenGL ES Design Guidelines](#opengl-es-design-guidelines)和[Concurrency and OpenGL ES](#concurrency-and-opengl-es)。\n\n## 调试与性能分析\n\nXcode和Instruments提供了许多工具来跟踪渲染问题并分析OpenGL ES的性能，前往[Debugging and Profiling](#debugging-and-profiling)。\n\n# Configuring OpenGL ES Contexts\n\n每个OpenGL ES的实现提供了创建管理OpenGL ES规范所需要状态的渲染上下文的方法，通过在上下文的状态，多个应用可以轻松地共享图形硬件而不会干扰其他应用程序的状态。\n\n在我们使用OpenGL ES方法前，必须初始化*EAGLContext*对象，*EAGLContext*类还提供将OpenGL ES内容与Core Animation集成的方法。\n\n## 当前上下文是OpenGL ES函数调用的目标\n\niOS应用每个线程都有一个当前上下文，当我们调用OpenGL ES的方法时，这个就是状态要被更改的上下文。\n\n设置当前线程上下文，在对应线程调用`setCurrentContext:`方法：\n``` objectivec\n[EAGLContext setCurrentContext:context];\n```\n\n调用*EAGLContext*类方法`currentContext`来检索当前线程的上下文。\n\n> 如果在相同线程切换两种或以上上下文，在设置新的当前上下文之前调用`glFlush`方法确保之前提交的命令能及时交付给图形硬件。\n\nOpenGL ES对当前上下文*EAGLContext*对象持有强引用，当调用`setCurrentContext:`方法切换上下文则不会对之前的对象强持有，为了防止*EAGLContext*对象在切换时被释放，我们应该对之强引用。\n\n## 每个上下文都针对OpenGL ES的特定版本\n\n一个*EAGLContext*对象仅支持OpenGL ES的一个版本。例如：OpenGL ES 1.1版本下的代码不兼容2.0或3.0版本；使用OpenGL ES 2.0版本特性的版本兼容3.0版本，同时2.0版本的扩展经常可以在3.0版本中少量修改后使用；OpenGL ES 3.0的特性和新增的硬件性能需要3.0版本。\n\n我们在创建和初始化*EAGLContext*对象时选择OpenGL ES的版本。如果设备不支持对应的版本，会返回nil，我们必须保证正确初始化之后使用它。\n``` objectivec\nEAGLContext* CreateBestEAGLContext() {\n    EAGLContext *context = [[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES3];\n    if (context == nil) {\n        context = [[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES2];\n    }\n    return context;\n}\n```\n\n## EAGL Sharegroup\n\n尽管上下文持有OpenGL ES的状态，但它不直接管理OpenGL ES的对象。相反，可以通过*EAGLSharegroup*对象创建和持有OpenGL ES对象，每个上下文都包含一个被委托创建对象的*ESGLSharegroup*对象。\n\n在两个或多个上下文引用一个共享组时优势很明显，这时创建OpenGL ES的对象在所有上下文都可用，如果绑定到另一个上下文与创建它的上下文有相同的标识符，则引用相同的OpenGL ES对象。移动设备的资源非常稀缺，在上下文创建多个相同内容的拷贝是浪费资源的，公共资源可以更好的利用设备的图形资源。\n\nsharegroup是一个不透明对象，没有可以调用的属性或方法，可以使用sharegroup对象的上下文对之进行强引用。\n\n![OpenGL ES Sharegroup](/img/article/20190519/2.png)\n\nsharegroup在以下两种情况下最有用：\n- 上下文之间的大多数共享资源不会改变\n- 当我们想要在其他线程创建OpenGL ES对象而主线程用于渲染。例如：第二个上下文在单独的线程上用于获取数据和创建资源，加载资源后，第一个上下文可以绑定到对象并立即使用它。*GLKtextureLoader*类就是使用这个模式来提供异步纹理加载。\n\n想要创建引用相同sharegroup的上下文，第一个上下文使用`initAPI:`方法初始化后会自动创建sharegroup，第二个及后续上下文调用`initAPI:sharegroup:`使用第一个上下文的sharegroup进行初始化。\n\n``` objectivec\nEAGLContext* firstContext = CreateBestEAGLContext();\nEAGLContext* secondContext = [[EAGLContext alloc] initWithAPI:[firstContext API] sharegroup: [firstContext sharegroup]];\n```\n\n当sharegroup由多个上下文共享时，我们有责任管理OpenGL ES对象的状态更改：\n- 应用程序可以同时跨多个上下文访问未修改的对象\n- 当对象被发送到上下文的命令修改时，不能在其他地方读写该对象\n- 在对象修改后，所有上下文必须重新绑定才能看到更改。如果上下文在绑定之前引用该对象，则该对象的内容是未定义的\n\n下面是更新OpenGL ES对象的步骤：\n- 在可能使用对象的每个上下文调用`glFlush`方法\n- 在想要修改对象的上下文，调用一种或多种OpenGL ES方法修改对象\n- 在接收状态修改命令的上下文中调用`glFlush`方法\n- 在每个其他上下文，重新绑定标识符\n\n> 另一种共享对象的方法是使用一个渲染上下文，多个目标帧缓冲区。在渲染时，应用程序绑定合适的帧缓冲区并根据需要渲染帧，因为所有的OpenGL ES对象都是从一个上下文应用，所有会看到相同的OpengGL ES数据。这种模式使用的资源较少，但只适用于单线程应用程序，但单线程程序中可以仔细控制上下文状态。\n\n# Drawing with OpenGL ES and GLKit\n\nGLKit框架提供了视图和控制器类，消除了绘画和动画OpenGL ES内容所需的设置和维护代码，*GLKView*类管理OpenGL ES的基础结构，为绘图代码提供空间，*GLKViewController*类提供一个渲染循环用于GLKit视图上平滑的展示OpenGL ES内容的动画。这些类扩展了用于绘制视图内容和管理视图呈现的标准UIKit设计模式。因此，我们可以将主要精力用于OpenGL ES渲染代码与应用流畅度上。GLKit框架同样提供简化OpenGL ES 2.0与3.0开发的其他特性。\n\n## GLKit视图根据需求绘制OpenGL ES内容\n\n*GLKView*类提供了一个基于OpenGL ES等价于标准UIView的绘图周期。*UIView*对象自动配置图形上下文，所以`drawRect:`实现只需要执行Quartz 2D的绘图命令，*GLKView*对象自动配置自己所以我们的绘图方法只需要执行OpenGL ES的绘图命令。*GLKView*类通过维护持有OpenGL ES绘图命令结果的帧缓冲区来提供此功能，然后在绘图方法返回时自动将他们呈现给Core Animation。\n\n与标准UIKit视图一样，GLKit视图按需渲染。当视图第一次显示，它调用我们的绘图方法--Core Animation缓冲区渲染输出并在视图显示时显示它。当我们想要修改视图内容，调用`setNeedsDisplay`方法，视图会重新调用我们的绘图方法，缓冲区结果图，在屏幕显示它。这个方法在渲染图像的数据修改很少或只响应用户操作时有用，只有在需要的时候渲染新视图内容，这样可以节约设备电量并为其他操作留出更多时间。\n\n![Rending OpenGL ES content with a GLKit view](/img/article/20190519/3.png)\n\n### 创建与配置GLKit View\n\n我们可以以编程的方式创建配置一个GLKView对象，也可以用故事板，在绘图钱，我们需要与之关联*EAGLContext*对象。\n\n- 当以编程方式创建一个视图时，先创建一个上下文然后将它用于*initWithFrame:context:*方法\n- 当从故事板加载一个视图，创建一个上下文然后设置为这个视图的*context*属性\n\n一个GLKit视图自动创建和配置他自己的OpenGL ES帧缓冲区对象和渲染缓冲区。我们使用视图的绘图属性控制这些对象属性，当我们改变尺寸大小、比例系数、或者某个绘画属性，它会在下次内容绘制时自动删除和重新创建相应的帧缓冲区和渲染缓冲区对象。\n\n``` objectivec\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    EAGLContext *context = CreateBestEAGLContext();\n    GLKView *glkView = [[GLKView alloc] initWithFrame:self.view.bounds context:context];\n    // Configure renderbuffers\n    glkView.drawableColorFormat = GLKViewDrawableColorFormatSRGBA8888;\n    glkView.drawableDepthFormat = GLKViewDrawableDepthFormat24;\n    glkView.drawableStencilFormat = GLKViewDrawableStencilFormat8;\n    // enable multisampling\n    // multisampling是一种消除锯齿边缘的反锯齿，在大多数3D应用程序中提高图形质量，代价是使用更多的内存和片段处理时间\n    glkView.drawableMultisample = GLKViewDrawableMultisample4X;\n    [self.view addSubview:glkView];\n}\n```\n\n### 使用GLKit View绘图\n\n绘制OpenGL ES内容分为三步：准备OpenGL ES基础设施，执行绘图命令，将渲染内容提交给Core Animation显示。其中*GLKView*实现了第一步与第三步，下面代码实现了绘图的第二步：\n\n``` objectivec\n- (void)drawRect:(CGRect)rect {\n    // clear the framebuffer\n    glClearColor(0.0, 0.0, 0.1, 1.0);\n    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n    // Draw using previously configured texture, shader, uniforms, and vertex array\n    glBindTexture(GL_TEXTURE_2D, _planetTexture);\n    glUseProgram(_diffuseShading);\n    glUniformMatrix4fv(_uniformModelViewProjectionMatrix, 1, 0, _modelViewProjectionMatrix.m);\n    glBindVertexArray(_planetMesh);\n    glDrawElements(GL_TRIANGLE_STRIP, 256, GL_UNSIGNED_SHORT, NULL);\n}\n```\n\n> *glClear*方法提示OpenGL ES任何现有的帧缓冲区内容都可以被丢弃，避免加载以前的内容到内存中造成高消耗内存操作。为了确保最佳性能，我们应该在每次绘图前总是调用这个函数\n\n*GLKView*可以提供一些简单的接口给OpenGL ES绘图，因为它管理了OpenGL ES渲染过程中的标准部分：\n\n- 在调用绘图方法前，视图需要：\n    + 确保*EAGLContext*为当前上下文\n    + 基于现有尺寸、比例系数、绘图属性创建帧缓冲区对象和渲染缓冲区（如有必要）\n    + 将帧缓冲区对象绑定为绘制命令的当前目标\n    + 设置OpenGL ES视图端口以匹配帧缓冲区大小\n- 在绘图方法返回后，视图需要：\n    + 解析multisampling缓冲区（如果multisampling已设置）\n    + 丢弃不再需要的渲染缓冲区\n    + 将渲染缓冲区内容提交给Core Animation缓冲区和展示\n\n## 使用代理渲染\n\n许多OpenGL ES应用程序使用自定义类实现渲染代码，这个方法的优势在于它能为多个渲染器分别定义不同的渲染类，从而轻松地支持多个渲染算法，共享公共功能的渲染算法可以从父类继承。例如，我们可以使用不同的渲染类同时支持OpenGL ES 2.0和3.0，或者使用它们在具有更强大硬件的设备上定制渲染，以获得更优质的图片。\n\nGLKit非常适合这种方法--我们可以使用渲染器对象成为标准GLKView实例的代理，没有使用继承GLKView和实现`drawInRect:`方法，而是使用渲染器类实现*GLKViewDelegate*代理并实现`glkView:drawInRect:`方法。下面代码演示了应用程序在启动时根据硬件特性选择渲染器类：\n\n``` objectivec\n- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {\n    // Create a context\n    EAGLContext *context = [[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES2];\n    [EAGLContext setCurrentContext:context];\n    \n    // Choose a rendering class based on device features\n    GLint maxTextureSize;\n    glGetIntegerv(GL_MAX_TEXTURE_SIZE, &maxTextureSize);\n    if (maxTextureSize > 2048) {\n        self.renderer = [[MyBigTextureRenderer alloc] initWithContext:context];\n    } else {\n        self.renderer = [[MyRenderer alloc] initWithContext:context];\n    }\n    GLKView *view = (GLKView *)self.window.rootViewController.view;\n    view.delegate = self.renderer;\n    view.context = context;\n    return YES;\n}\n```\n\n## GLKit视图控制器动画OpenGL ES内容\n\n默认情况下，一个*GLKView*对象按需渲染内容。也就是说，使用OpenGL ES绘图的一个关键优势是他能使用图形处理硬件对复杂场景进行连续动画--游戏和模拟器等应用程序很少使用静态图片。对于这些情况，*GLKit*框架提供一个视图控制器类，为它管理的*GLKView*对象维护一个动画循环，这个循环遵循游戏和模拟器中场景中常见的设计模式，分为两个阶段：更新与显示。下图展示了一个简单的动画循环示例：\n\n![The animation loop](/img/article/20190519/4.png)\n\n### 动画循环的理解\n\n更新阶段，视图控制器调用它自身的*update*方法（或者当未继承GLKViewController时可以使用代理的`glkViewControllerUpdate:`方法），这个方法中，我们应该为下一帧绘图做准备。例如，一个游戏可能使用这个方法根据上一帧以来接受到的输入事件来决定玩家和敌对角色的位置，科学的可视化可以使用这种方法运行模拟的一个步骤。如果我们需要时间信息来决定应用程序下一帧的状态，使用这个视图控制器的其中一个时间属性比如`timeSinceLastUpdate`属性。\n\n展示阶段，试图控制器调用视图的`display`方法，这个方法会触发绘图方法。在绘图方法中，我们对GPU提交OpenGL ES的绘图指令来渲染我们的内容。为了最佳性能。我们的应用程序应该在渲染最新一帧时修改OpenGL ES对象，然后提交绘图指令。\n\n动画循环以视图控制器的`framesPerSecond`属性所指示的速率在这两个阶段切换，我们可以使用`preferredFramesPerSecond`属性来设置所需的帧速率--为了当前显示硬件的最优性能，视图控制器自动渲染接近于我们设置值的最优帧速率。\n\n> 为了获得最佳效果，选择一个应用程序可以达到的帧率。平滑、一致的帧率比经常变化的帧率能有更好的用户体验\n\n### 使用GLKit视图控制器\n\n``` objectivec\n@implementation PlanetViewController // subclass of GLKViewController\n \n- (void)viewDidLoad {\n    [super viewDidLoad];\n \n    // Create an OpenGL ES context and assign it to the view loaded from storyboard\n    GLKView *view = (GLKView *)self.view;\n    view.context = [[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES2];\n \n    // Set animation frame rate\n    self.preferredFramesPerSecond = 60;\n \n    // Not shown: load shaders, textures and vertex arrays, set up projection matrix\n    [self setupGL];\n}\n \n- (void)update {\n    _rotation += self.timeSinceLastUpdate * M_PI_2; // one quarter rotation per second\n \n    // Set up transform matrices for the rotating planet\n    GLKMatrix4 modelViewMatrix = GLKMatrix4MakeRotation(_rotation, 0.0f, 1.0f, 0.0f);\n    _normalMatrix = GLKMatrix3InvertAndTranspose(GLKMatrix4GetMatrix3(modelViewMatrix), NULL);\n    _modelViewProjectionMatrix = GLKMatrix4Multiply(_projectionMatrix, modelViewMatrix);\n}\n \n- (void)glkView:(GLKView *)view drawInRect:(CGRect)rect {\n    // Clear the framebuffer\n    glClearColor(0.0f, 0.0f, 0.1f, 1.0f);\n    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n \n    // Set shader uniforms to values calculated in -update\n    glUseProgram(_diffuseShading);\n    glUniformMatrix4fv(_uniformModelViewProjectionMatrix, 1, 0, _modelViewProjectionMatrix.m);\n    glUniformMatrix3fv(_uniformNormalMatrix, 1, 0, _normalMatrix.m);\n \n    // Draw using previously configured texture and vertex array\n    glBindTexture(GL_TEXTURE_2D, _planetTexture);\n    glBindVertexArrayOES(_planetMesh);\n    glDrawElements(GL_TRIANGLE_STRIP, 256, GL_UNSIGNED_SHORT, 0);\n}\n@end\n```\n\n`viewDidLoad`方法创建了OpenGL ES上下文并提供给视图，同时设置动画循环的帧率。视图控制器自动成为视图的代理，同时实现动画循环的更新与显示阶段。在`update`方法中，它计算显示旋转行星所需的变换矩阵。在`glkView:drawInRect:`方法，它将这些矩阵提供给着色器程序，并提交绘制命令来渲染行星的几何形状。\n\n# Drawing to Other Rendering Destinations\n\n帧缓冲区对象是渲染命令的目标。当创建一个帧缓冲区对象，我们可以精确控制它存储的颜色、深度和模板数据。我们通过将图片附加到帧缓冲区来提供这种存储，如下图所示。最常见的图片关联是渲染缓冲区对象。我们也可以将OpenGL ES的纹理附加到帧缓冲区的颜色连接点，这意味着所有的绘图命令都将渲染到纹理中。稍后，纹理可以作为未来渲染命令的输入。我们还可以在一个渲染上下文创建多个帧缓冲区对象，这么做可以在多个帧缓冲区之间共享相同的渲染管线和OpenGL ES资源。\n\n![Famebuffer with color and depth renderbuffers](/img/article/20190519/5.png)\n\n所有这些方法都需要手动创建帧缓冲区和渲染缓冲区对象来存储OpenGL ES上下文的渲染结果，还需要编写额外的代码来将内容呈现到屏幕，如有必要还要运行一个动画循环。\n\n## 创建帧缓冲区对象\n\n根据应用程序打算执行的任务，将配置不同的对象附加到帧缓冲区对象。在多数情况下，配置帧缓冲区的区别在于对象被附加到对象的颜色连接点上：\n- 使用帧缓冲区用于离屏图像处理，附加一个渲染缓冲区。见[创建离屏缓冲区对象](#创建离屏缓冲区对象)\n- 使用帧缓冲区图片作为后续渲染步骤的输入，附加一个纹理。见[使用帧缓冲区对象渲染纹理](#使用帧缓冲区对象渲染纹理)\n- 在Core Animation层级组合中使用帧缓冲区，使用特定Core Animation-aware渲染缓冲区。见[渲染到Core Animation层级](#渲染到Core-Animation层级)\n\n### 创建离屏缓冲区对象\n\n用于离屏渲染的帧缓冲区分配内存给它所有的关联作为OpenGL ES的渲染缓冲区。下面代码分配内存给一个带有颜色和深度关联的帧缓冲区对象：\n\n1. 创建帧缓冲区并绑定：\n``` objectivec\nGLuint framebuffer;\nglGenFramebuffers(1, &framebuffer);\nglBindFramebuffer(GL_FRAMEBUFFER, framebuffer);\n```\n\n2. 创建颜色渲染缓冲区，分配内存，与帧缓冲区的颜色连接点相关联：\n``` objectivec\nGLuint colorRenderbuffer;\nglGenRenderbuffers(1, &colorRenderbuffer);\nglBindRenderbuffer(GL_RENDERBUFFER, colorRenderbuffer);\nglRenderbufferStorage(GL_RENDERBUFFER, GL_RGBA, width, height);\nglFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_RENDERBUFFER, colorRenderbuffer);\n```\n\n3. 创建一个深度或者深度/模板渲染缓冲区，分配内存，与帧缓冲区深度关联点相关联：\n``` objectivec\nGLuint depthRenderbuffer;\nglGenRenderbuffers(1, &depthRenderbuffer);\nglBindRenderbuffer(GL_RENDERBUFFER, depthRenderbuffer);\nglRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH_COMPONENT16, width, height);\nglFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, depthRenderbuffer);\n```\n\n4. 测试帧缓冲区的完整性，这个测试方法只需要在帧缓冲区配置改动时执行：\n``` objectivec\nGLenum status = glCheckFramebufferStatus(GL_FRAMEBUFFER);\nif (status != GL_FRAMEBUFFER_COMPLETE) {\n    NSLog(@\"failed to make complete framebuffer object %x\", status);\n}\n```\n\n在绘图到离屏渲染缓冲区后，使用`glReadPixels`方法返回它的内容到CPU做进一步处理。\n\n### 使用帧缓冲区对象渲染纹理\n\n创建帧缓冲区的代码几乎与离屏实例一样，但现在是纹理分配内存并与颜色关联点相关联：\n1. 创建帧缓存对象（与上例相似）；\n2. 创建目标纹理，与帧缓冲区的颜色关联点相关联：\n``` objectivec\nGLuint texture;\nglGenTextures(1, &texture);\nglBindTexture(GL_TEXTURE_2D, texture);\nglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);   // 纹理过滤\nglTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, NULL);\nglFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, texture, 0);\n```\n3. 分配缓存并关联深度缓冲区（与上例类似）；\n4. 验证帧缓冲区的完整性；\n\n虽然这个例子假设我们正在渲染到颜色纹理，但也可以使用其他选项。例如，使用*OES_depth_texture*扩展，可以将纹理关联到深度关联点，以将场景中的深度信息存储到纹理。我们可以使用这个深度信息计算最终渲染场景中的阴影。\n\n### 渲染到Core Animation层级\n\nCore Animation是iOS上图形渲染和动画的核心基础设施，我们可以使用不同iOS子系统渲染的层级（如UIKit、Quartz 2D、OpenGL ES）来组合应用程序的用户界面或其他可视化显示。OpenGL ES通过*CAEAGLLayer*类关联Core Animation，这个类是一种特殊类的Core Animation层级，其内容来自OpenGL ES渲染缓冲区。Core Animation将渲染缓冲区的内容和其他层级组合在一起，并将结果图像显示在屏幕上。\n\n![Core Animation shares the renderbuffer width OpenGL ES](/img/article/20190519/6.png)\n\n*CAEAGLLayer*通过提供了两项关键功能为OpenGL ES提供支持。首先，它为渲染缓冲区分配内存共享存储，其次，它将渲染缓冲区呈现到Core Animation，用渲染缓冲区中的数据替换层级之前的内容。该模型的优点在于Core Animation层级不需要每一帧都绘制，只需要在渲染图像发生改变时绘制。\n\n> GLKView类自动执行以下步骤，所以当我们想要在视图的内容层中使用OpenGL ES绘图时，应该使用它。\n\n使用Core Animation层级的OpenGL ES渲染：\n1. 创建*CAEAGLLayer*对象并配置它的属性。想要最佳性能，设置层级的*opaue*属性为YES。可选，通过为*CAEAGLLayer*对象的`drawableProperties`属性分配一个新的字典来配置渲染表面的表面属性；可以指定渲染缓冲区的像素格式，并指定渲染缓冲区的内容在发送到Core Animation后是否被丢弃。有关允许的键列表，见[EAGLDrawable Protocol Reference](https://developer.apple.com/documentation/opengles/eagldrawable?language=objc)；\n2. 创建OpenGL ES上下文，并设置为当前上下文；\n3. 创建帧缓冲区对象；\n4. 创建颜色渲染缓冲区，调用`renderbufferStorage:fromDrawable:`方法分配存储内存并将层级对象作为参数传入。宽度、高度、像素格式都是从层级获取并用于渲染缓冲区的分配存储内存：\n``` objectivec\nGLuint colorRenderbuffer;\nglGenRenderbuffers(1, &colorRenderbuffer);\nglBindRenderbuffer(GL_RENDERBUFFER, colorRenderbuffer);\n[myContext renderbufferStorage:GL_RENDERBUFFER fromDrawable:myEAGLLayer];\nglFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_RENDERBUFFER, colorRenderbuffer);\n```\n> 当Core Animation的层级`bounds`或属性改变时，必须重新分配渲染缓冲区存储内存。如果不重新分配内存，渲染缓冲区的大小可能不匹配层级的大小。\n5. 检索颜色渲染缓冲区的高度和宽度：\n```\nGLuint width, height;\nglGetRenderbufferParameteriv(GL_RENDERBUFFER, GL_RENDERBUFFER_WIDTH, &width);\nglGetRenderbufferParameteriv(GL_RENDERBUFFER, GL_RENDERBUFFER_HEIGHT, &height);\n```\n在前面的示例中，显示地提供了渲染缓冲区的宽度和高度以便分配内存。这里，代码在分配存储内存后检索颜色渲染缓冲区的宽度和高度。应用程序之所以这样做，是因为颜色缓冲区的实际尺寸是根据层级的边界大小和缩放因子计算的。关联到帧缓冲区的渲染缓冲区必须具有相同的纬度。除了使用高度和宽度分配深度缓冲区内存，还可以用来分配OpenGL ES视图端口，并帮助确定应用程序的纹理和模型中所需的细节级别；\n6. 分配缓存并关联深度缓冲区；\n7. 验证帧缓冲区的完整性；\n8. 通过将*CAEAGLLayer*对象传递给`addSublayer:`一个可见层级的方法添加到Core Animation的层级结构中。\n\n## 绘制到帧缓冲区对象\n\n现在我们已经拥有了一个帧缓冲区对象，然后就是填充。下面介绍了渲染新帧并呈现给用户所必要的步骤，渲染到纹理或离屏帧缓冲区的行为类似，只是应用程序使用最终帧的方式不同。\n\n### 按需或使用动画循环渲染\n\n我们在渲染到一个Core Animation层级时必须选择何时绘制我们的OpenGL ES内容，就像使用GLKit视图和控制器绘图一样。如果渲染到离屏帧缓冲区或纹理，则在适合使用这些帧缓冲区类型的情况下随时绘制。\n\n对于on-demand绘制，实现我们自己的方法绘制并呈现渲染缓冲区，并在需要显示新内容的时候调用它。\n\n对于动画循环绘制，使用`CADisplayLink`对象。`displayLink`是由Core Animation提供的一种定时器，允许我们将绘图同步到屏幕的刷新率。下面代码展示了我们如何检索显示视图的屏幕，使用这个屏幕创建一个新的`displayLink`对象并添加到运行环中。\n\n> *GLKViewController*类自动使用`CADisplayLink`对象来动画`GLKView`的内容，只有当我们需要超出*GLKit*框架所提供的行为时，才直接使用`CADisplayLink`类\n\n```\nCADisplayLink *displayLink = [self.view.window.screen displayLinkWithTarget:self selector:@selector(drawFrame)];\n[displayLink addToRunLoop:[NSRunLoop currentRunLoop] forMode:NSDefaultRunLoopMode];\n```\n\n在`drawFrame`方法的实现中，读取`displayLink`的`timestamp`属性来获取渲染下一帧的时间戳，可以用来计算下一帧对象的位置。\n\n通常，每次屏幕刷新都会触发`displayLink`对象；该值通常为60Hz，但在不同的设备上有所不同。大多数应用程序不需要每秒更新屏幕60次。我们可以设置`displayLink`的`frameInterval`属性设置为调用该方法之前经过的实际帧数。例如，如果帧间隔设置为3，应用程序则每隔3帧调用一次，或者每秒大约调用20帧（原帧率的三分之一）。\n\n> 为了最佳效果，渲染一个应用程序可以始终实现的帧率。\n\n### 渲染帧\n\n下图展示了OpenGL ES应用程序渲染和呈现帧的步骤，这些步骤包括很多提示以提高应用程序的性能。\n\n![iOS OpenGL Rendering Steps](/img/article/20190519/7.png)\n\n#### 清空缓冲区\n\n在每一帧开始前，删除所有帧缓冲区附加的下一帧不需要使用的内容。调用`glClear`方法，传递一个位掩码清除所有缓冲区：\n\n``` objectivec\nglBindFramebuffer(GL_FRAMEBUFFER, framebuffer);\nglClear(GL_DEPTH_BUFFER_BIT | GL_COLOR_BUFFER_BIT);\n```\n\n使用`glClear`提示OpenGL ES可以丢弃渲染缓冲区或纹理的现有内容，从而避免将先前内容加载到内存中的昂贵内存。\n\n#### 准备资源并执行绘图命令\n\n这两个步骤包含了设计应用程序架构时所做的大多数关键决策。首先，决定我们想要展示给用户的内容并配置相应的OpenGL ES对象上传到GPU（如顶点缓冲对象，纹理，着色器程序及其输入变量）。下一步，提交绘图命令告诉GPU如何使用这些资源渲染帧。\n\n渲染器设计的更多细节见[OpenGL ES Design Guidelines](#opengl-es-design-guidelines)。目前，最需要注意的最重要的性能优化是，如果只在渲染新帧时修改OpenGL ES对象应用程序运行的更快。虽然应用程序可以在修改对象和提交绘图命令中间进行切换，但如果每帧只执行一个步骤会运行地更快。\n\n#### 执行绘图命令\n\n这一步获取我们上一步准备的对象并提交绘图命令使用它们。设计渲染代码这一部分以高效运行的更多细节见[OpenGL ES Design Guidelines](#opengl-es-design-guidelines)。目前，最需要注意的最重要的性能优化是，如果只在渲染新帧时修改OpenGL ES对象应用程序运行的更快。虽然应用程序可以在修改对象和提交绘图命令中间进行切换，但如果每帧只执行一个步骤会运行地更快。\n\n#### 解决多重采样\n\n如果应用程序使用反锯齿提高图形质量，需要在呈现给用户之前解析像素。更多细节见[使用多重采样提高图片质量](#使用多重采样提高图片质量)。\n\n#### 丢弃不需要的渲染帧缓冲区\n\n丢弃操作是一个性能提示，告诉OpenGL ES一个或多个渲染缓冲区的内容不再需要。通过提示OpenGL ES我们不需要一个渲染缓冲区的内容，缓冲区里的数据被丢弃，可以避免缓冲区更新的复杂任务。\n\n在渲染循环的这个阶段，应用程序已经提交了所有的绘图命令。虽然应用程序需要颜色渲染缓冲区来显示在屏幕上，但可能不需要深度缓冲区的内容。\n\n``` objectivec\nconst GLenum discards = {GL_DEPTH_ATTACHMENT};\nglBindFramebuffer(GL_FRAMEBUFFER, framebuffer);\nglDiscardFramebufferEXT(GL_FRAMEBUFFER, 1, discards)\n```\n\n> `glDiscardFramebufferEXT`方法由OpengGL ES1.0和2.0的`EXT_discard_framebuffer`扩展提供。在OpenGL ES 3.0上下文中，使用`glInvalidateFramebuffer`方法。\n\n#### 呈现结果到Core Animation\n\n在这个步骤，颜色渲染缓冲区持有完成帧，所以我们需要做的就是呈现给用户。下面代码将renderbuffer绑定到上下文并呈现。这使得完成帧被交到Core Animation。\n\n``` objectivec\nglBindRenderbuffer(GL_RENDERBUFFER, colorRenderbuffer);\n[context presentRenderbuffer: GL_RENDERBUFFER];\n```\n\n默认情况下，我们必须保证应用程序呈现完渲染缓冲区后内容被丢弃。这意味着每次呈现帧时，当渲染新帧时必须完整重新创建帧内容，由于这个原因，上述的代码总是擦除颜色缓冲区。\n\n如果应用程序想要在帧之间保存颜色缓冲区的内容，那么在`CAEAGLLayer`对象的`drawableProperties`属性字典添加`kEAGLDrawablePropertyRetainedBacking`键为`YES`，同时在`glClear`方法调用中移除`GL_COLOR_BUFFER_BIT`常量。保留备份可能需要iOS分配额外的内存来存储缓冲区内容，可能会降低应用程序的性能。\n\n## 使用多重采样提高图片质量\n\n多重采样是反锯齿的一种形式，平滑锯齿边缘，提高大多数3D应用的图像质量。OpenGL ES 3.0将多重采样作为核心规范的一部分，OpenGL ES 1.0和2.0合一通过`APPLE_framebuffer_multisample`扩展提供。多重采样使用更多的内存和片段处理时间来渲染图片，但相比其他方法使用更低的性能成本提高图像质量。\n\n下图展示了多重采样的工作原理。应用程序不是创建一个帧缓冲区，而是两个。多重采样缓冲区包含所有必要的渲染内容关联（通常是颜色和深度缓冲区），解析缓冲区只包含必要的展示渲染图片给用户的关联（通常是颜色渲染缓冲区，但可能是纹理）。多重采样渲染缓冲器使用和解析渲染缓冲器相同的维度分配内存，但每个维度都包含一个指定每个像素存储的样本数量的额外参数。应用程序将所有的渲染都执行到多重采样缓冲区，然后将这些样本解析到解析缓冲器中生成最终反锯齿图像。\n\n![How multisampling](/img/article/20190519/8.png)\n\n下面代码展示了多重采样缓冲区的创建，使用之前创建缓冲器的宽高。通过调用`glRenderbufferStorageMultisampleAPPLE`方法创建渲染缓冲器的多重采样存储；\n\n``` objectivec\nGLuint sampleFramebuffer;\nglGenFramebuffers(1, &sampleFramebuffer);\nglBindFramebuffer(GL_FRAMEBUFFER, sampleFramebuffer);\n\nGLuint sampleColorRenderbuffer;\nglGenRenderbuffers(1, &sampleColorRenderbuffer);\nglBindRenderbuffer(GL_RENDERBUFFER, sampleColorRenderbuffer);\nglRenderbufferStorageMultisample(GL_RENDERBUFFER, 4, GL_RGBA8_OES, width, height);\nglFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_RENDERBUFFER, sampleColorRenderbuffer);\n\nGLuint sampleDepthRenderbuffer;\nglGenRenderbuffers(1, &sampleDepthRenderbuffer);\nglBindRenderbuffer(GL_RENDERBUFFER, sampleDepthRenderbuffer);\nglRenderbufferStorageMultisample(GL_RENDERBUFFER, 4, GL_DEPTH_COMPONENT16, width, height);\nglFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, sampleDepthRenderbuffer);\n\nif (glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE) {\n    NSLog(@\"Failed to make complete framebuffer object %x\", glCheckFramebufferStatus(GL_FRAMEBUFFER));\n}\n```\n\n下面是一些基于多重采样的修改之后的渲染代码：\n1. 在清除缓冲区步骤，需要同时清除多重采样帧缓冲区内容：\n\n``` obejctivec\nglBindFramebuffer(GL_FRAMEBUFFER, sampleFramebuffer);\nglViewport(0, 0, framebufferWidth, framebufferHeight);  // 选取绘图区域\nglClear(GL_COLOR_BUFFER_BIT, GL_DEPTH_BUFFER_BIT);\n```\n\n2. 在提交绘图命令后，需要将内容从多重缓冲区解析到解析缓冲区。每像素存储的样本将合并到解析缓冲区的单个样本中：\n\n``` objectivec\nglBindFramebuffer(GL_DRAW_FRAMEBUFFER_APPLE, resolveFramebuffer);\nglBindFramebuffer(GL_READ_FRAMEBUFFER_APPLE, smapleFramebuffer);\nglResolveMultisampleFramebufferAPPLE();\n```\n\n3. 在丢弃步骤，我们可以丢弃多重采样帧缓冲区关联的两个渲染缓冲区，这是因为预计呈现的内容以及存储到解析帧缓冲区内：\n\n``` objectivec\nconst GLenum discards[] = {GL_COLOR_ATTACHMENT0, GL_DEPTH_ATTACHMENT};\nglDiscardFramebufferEXT(GL_READ_FRAMEBUFFER_APPLE, 2, discards);\n```\n\n4. 在呈现结果步骤，呈现关联到解析帧缓冲区的颜色渲染缓冲区：\n\n``` objectivec\nglBindRenderBuffer(GL_RENDERBUFFER, colorRenderbuffer);\n[context presentRenderbuffer: GL_RENDERBUFFER];\n```\n\n多重采样并不是免费的；存储额外样本的内存消耗，解析样本到解析帧缓冲区的时耗。如果我们想要添加多重采样到应用中，必须多测试性能以确保它可接受。\n\n> 上述代码基于OpenGL ES 1.0与2.0，多重采样位于OpenGL ES 3.0的核心API，使用不同的方法。\n\n# Multitasking, High Resolution, and Other iOS Features\n\n使用OpenGL ES的许多方面都是平台中立，但是在iOS上使用有一些细节需要特别考虑。特别是，iOS应用使用OpenGL ES正确处理多任务或进入后台有被终止的风险。在iOS设备开发OpenGL ES内容时，我们应该考虑现实分辨率和其他设备的特性。\n\n## 实现一个多任务感知的OpenGL ES应用程序\n\n应用程序在用户切换到其他程序时可以继续运行。更多多任务讨论见[App States and Multitasking](https://developer.apple.com/library/archive/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/BackgroundExecution/BackgroundExecution.html#//apple_ref/doc/uid/TP40007072-CH4)\n\n使用OpenGL ES的应用程序在切入后台时必须执行更多的工作，如果多任务处理不当，那应用可能会崩溃，同样，一个应用程序可能想要释放OpenGL ES资源这样就只适用于前台工作。\n\n### 后台应用程序可能无法在图像硬件上执行命令\n\n如果OpenGL ES应用程序视图在图像硬件上执行OpenGL ES命令可能会崩溃。iOS阻止后台应用程序访问图像处理器，因此最前端的应用程序总是能给用户提供更好的体验。应用程序崩溃不止在后台调用OpenGL ES，还会在进入后台时之前提交的命令刷新到GPU。所以我们必须保证所有之前提交的命令在进入后台前都执行完毕。\n\n如果使用GLKit视图和控制器，只在绘图方法中提交OpenGL ES命令，应用程序会自动在进入后台时正确运行。默认情况下，在应用程序处于非活动时`GLKViewController`类暂停其动画计时器，确保绘图方法不被调用。\n\n如果不适用GLKit视图或者控制器或者在GLKView绘图方法之外提交OpenGL ES命令，我们必须采用以下步骤保证程序在后台不崩溃：\n1. 在`applicationWillResignActive:`方法中，需要停止动画计时器，将自己置于一个已知的良好状态，并调用`glFinish`方法；\n2. 在`applicationDidEnterBackground:`方法中，应用程序可能想要删除一些OpenGL ES对象使内存和资源对于前台应用程序可。调用`glFinish`方法确保立即删除资源；\n3. 在`applicationDidEnterBackground:`方法中，确保没有OpenGL ES的调用，如果有任何调用就会导致崩溃；\n4. 在`applicationWillEnterForeground:`方法中，重新创建对象和启动动画计时器。\n\n总而言之，需要调用`glFinish`方法保证所有之前提交的命令都从命令缓存中取出并被OpenGL ES执行。在进入后台后，在进入前台之前必须避免使用OpenGL ES。\n\n### 在进入后台前删除容易重新创建的资源\n\n在应用程序进入后台时从来不需要释放OpenGL ES对象，通常情况，我们应该避免处理它的内容。考虑两种情况：\n- 应用正在玩游戏并短暂切出去检查日历，当用户返回游戏，游戏的资源仍然在内存中并可以直接继续游戏；\n- 当用户启动另一个OpenGL ES应用程序，如果需要更多的资源那么系统会自动终止后台的OpenGL ES应用程序让它不执行任何额外的工作。\n\n我们的目标应该是把应用程序设计成一个良好公民：这意味着移动到前台的时间尽可能短，同时减少他在后台的内存占用。\n\n下面是我们应该处理的两种情况：\n- 应用程序应该保证纹理，模型和其他资源在内存中；当应用进入后台时，需要长时间重新创建的资源不应该被处理掉；\n- 应用程序应该处理可以快速易创建的对象，寻找消耗巨大内存的对象。\n\n简单的目标是应用程序分配内存持有渲染结果的帧缓冲区，当应用程序在后台时，它对用户是不可见的并可能不会使用OpenGL ES渲染任何新内容。这意味着应用程序的帧缓冲区分配了大量内存但并没有用。同样，帧缓冲区的内容是临时的，大多数应用程序在每次渲染新帧时都会重新创建帧缓冲区的内容。这是用渲染缓冲区成为一个内存密集型资源，可以很容易创建，成为移动到后台时可以处理的候选对象。\n\n如果我们使用GLKit视图和控制器，`GLKViewController`类自动在进入后台时处理关联的视图帧缓冲区。如果我们为其他用途手动创建了帧缓冲区，那在进入后台时应该处理他们。在这两种情况下，我们应该考虑应用程序当时可以处理哪些其他临时资源。\n\n## 支持高分辨率显示\n\n默认情况下，GLKit视图的`contentScaleFactor`属性和包含它屏幕的比例相匹配，因此将其关联的帧缓冲区配置以渲染的全分辨率展现。 更多关于UIKit支持的高分辨率展现的内容见[Supporting High-Resolution Screens In Views](https://developer.apple.com/library/archive/documentation/2DDrawing/Conceptual/DrawingPrintingiOS/SupportingHiResScreensInViews/SupportingHiResScreensInViews.html#//apple_ref/doc/uid/TP40010156-CH15)。\n\n如果使用Core Animation层级出现OpenGL ES的内容，它默认的缩放因子为1.0。为了在Retina显示器的全分辨率下绘图，我们应该修改`CAEAGLayer`对象的缩放因子以匹配屏幕的缩放因子。\n\n当支持高分辨率显示器的设备，我们应该相应地跳转应用程序的模型和纹理资源。当高分辨率的设备下运行，我们可能想要渲染更详细的模型和纹理来渲染更好的图像，相反，在标准分辨率设备下，我们可能使用更小的模型和纹理。\n\n> 许多OpenGL ES API调用都用屏幕像素表示维度，如果使用的缩放因子大于1.0，那么在使用`glScissor`、`glBlitFramebuffer`、`glLineWidth`、`glPointSize`函数或`gl_PointSize`着色器变量时，我们需要相应调整维度。\n\n决定如何支持高分辨率显示器的一个重要因素是性能。Retina显示器上的翻倍比例因子使像素的数量变为四倍，这使得GPU处理的碎片数量变为原来的四倍。如果应用程序对每个片段执行多个计算，像素的增加可能会导致帧率降低。如果我们发现应用程序在较高的比例因子下运行速度明显较慢，考虑以下选项之一：\n- 使用性能调优指南优化片段着色器的性能，见[Tuning Your OpenGL ES App](tuning-your-openGL-es-app)；\n- 在片段着色器实现一个更简单的算法，这样做可以降低单个像素的质量，以更高的分辨率渲染整个图像；\n- 使用在1.0到屏幕比例因子之间的比例因子，比例因子为1.5比1.0提供更高的质量，但需要填充填充的像素比比例为2.0的图像更少；\n- 使用较低精度格式的GLKView对象的`drawableColorFormat`和`drawableDepthFormat`属性。这样做可以减少操作底层渲染缓冲区所需的内存带宽；\n- 使用较低的比例因子，启用多重采样。另一个优点是，多重采样同样可以在不知道高分辨率显示器的设备上提供更高的质量。要为GLKView对象启用多重采样，要更改它的`drawableMultisample`属性值。如果不是渲染到GLKit视图上，则必须手动甚至多重采样缓冲区并在最终图形呈现前解析他们，见[使用多重采样提高图片质量](#使用多重采样提高图片质量)。\n\n## 支持多种屏幕旋转\n\n与任意应用程序一样，OpenGL ES应用程序应该支持与其内容相适应的用户界面方向。可以在应用程序的信息属性列表定义支持的屏幕方向或者拥有OpenGL ES内容的控制器使用`supportedInterfaceOrientations`方法。\n\n默认情况下，`GLKViewController`和`GLKView`类自动处理屏幕转向：当用户渲染设备到支持的方向，系统将产生动画旋转屏幕并更改视图控制器视图的大小，当大小改变时，`GLKView`对象相应调整帧缓冲区和绘图窗口的大小。如果需要响应这个更改，在`GLKViewController`的子类中实现`viewWillLayoutSubviews`或`viewDidLayoutSubviews`方法，如果使用自定义的`GLKView`子类则实现`layoutSubviews`。\n\n如果使用Core Animation层级绘制OpenGL ES的内容，应用程序也应该包含一个视图控制器来管理用户界面方向。\n\n## 在外部显示器上显示OpenGL ES内容\n\n一个iOS设备可以被连接到外部显示器，外部显示器的分辨率及其内容缩放因子可能与主屏幕的不同，渲染帧的代码应该调整以匹配。\n\n在外部显示器绘图的过程基本和主屏幕上的相同：\n1. 按照[Multiple Display Programming Guide for iOS](https://developer.apple.com/library/archive/documentation/WindowsViews/Conceptual/WindowAndScreenGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40012555)的步骤在外部显示器创建一个窗口。\n2. 为渲染策略向窗口添加何时的视图或控制器；\n    - 如果使用GLKit渲染，设置`GLKViewController`和`GLKView`（或自定义子类）的实例并用`rootViewController`属性添加到窗口；\n    - 如果渲染到Core Animation层级，添加包含层级的视图作为窗口的子视图。使用动画循环来渲染，通过检索窗口的`screen`属性并调用`dispalyLinkWithTarget:slector:`方法创建一个外部显示器优化的显示链接对象。\n\n# OpenGL ES Design Guidelines\n\n现在我们已经掌握了在iOS应用中使用OpenGL ES的基础，使用这章下的信息帮助我们设计更优性能的渲染引擎。这一章节介绍了渲染器设计的关键概念；后面的内容将用特定的最佳实践和性能技术对这些信息扩展。\n\n## 如何可视化OpenGL ES\n\n本节描述了可视化OpenGL ES设计的两个方面：作为客户端-服务器架构和作为管线。这两方面在计划和评估应用程序的体系结构都非常有用。\n\n### OpenGL ES作为客户端-服务器架构\n\n应用程序与OpenGL ES客户端通信状态改变、纹理和顶点数据、渲染命令。客户端将这些数据转换成图形硬件理解的格式，并发送到GPU，这些进程会增加应用程序图形性能的开销。\n\n![OpenGL ES client-server architecture](/img/article/20190519/9.png)\n\n要获得出色的性能需要小心管理这些开销。一个优秀设计的应用程序减少对OpenGL ES的调用频率，使用硬件合适的数据格式来降低转换成本，并小心管理和OpenGL ES之间的数据流。\n\n### OpenGL ES作为图形管线\n\n应用程序配置图形管线，然后执行绘图命令将顶点数据发送到管线中。管线的后续阶段运行顶点着色器处理顶点数据，将顶点数据组装成基本类型，将基本类型光栅化为片段，运行片段着色器来计算每个片段的颜色和深度值，并将片段混合到帧缓冲区显示。\n\n![OpenGL ES graphics pipline](/img/article/20190519/10.png)\n\n使用管线作为一个心理模型来识别应用程序执行什么工作来生成一个新帧。我们的渲染器设计包含编写着色器程序处理管线的顶点和片段阶段，组织提供给这些程序的顶点和纹理数据，以及配置OpenGL ES状态机来驱动管线的固定功能的阶段。\n\n图形管线的各个阶段可以同时计算它们的结果--例如，应用程序可能准备了新的基础类型而图形硬件的各个部分还在对之前提交的几何图形执行顶点和片段计算，但是，后期阶段取决于先前阶段的输出，所以如果任何管道阶段执行过多任务或运行太慢，其他管线阶段将处于空闲状态知道最慢的完成工作。一个优秀设计的应用程序应可以根据图形硬件功能平衡每个管道阶段的工作。\n\n> 所以当我们调整应用程序性能时，第一步通常确定它处于哪个位置，以及会遇到哪些瓶颈。\n\n## OpenGL ES版本和渲染器架构\n\niOS支持3中OpenGL ES版本。最新版本提供更多的灵活，允许我们自主实现渲染包含高质量视觉效果而不影响性能的算法。\n\n### OpenGL ES 3.0\n\nOpenGL ES 3.0是iOS 7之后的新版本。应用程序可以使用OpenGL ES 3.0中引入的特性来实现高级的图形编程技术（以前只能用于桌面级硬件和游戏控制台）从而获得更快的图形性能和引人注目的视觉效果。更多见[OpenGL ES API Registry](http://www.khronos.org/registry/OpenGL/index_es.php)。\n[OpenGL ES 3.0](https://developer.apple.com/library/archive/documentation/3DDrawing/Conceptual/OpenGLES_ProgrammingGuide/OpenGLESApplicationDesign/OpenGLESApplicationDesign.html#//apple_ref/doc/uid/TP40008793-CH6-SW13)\n### OpenGL ES 2.0\n### OpenGL ES 1.0\n\n## 设计高性能的OpenGL ES应用程序\n\n总结下，一个优秀设计的OpenGL ES应用程序需要：\n- 利用OpenGL ES管线中的并行性\n- 管理应用程序和图形硬件之间的数据流\n\n下图展示了一个使用OpenGL ES执行动画显示的应用程序流程：\n\n![App model for managing resources](/img/article/20190519/11.png)\n\n当应用程序启动时，要做的第一件事是初始化不打算在生命周期中更改的资源。理想情况下，应用程序将这些资源封装到OpenGL ES的对象中，目标是创建任何在应用程序运行期间保持不变的对象（甚至是应用程序生命周期的一部分，如游戏关卡的持续时间），以增加的初始化时间交换更好的渲染性能。复杂的命令或状态改变应该替换为能与单个函数调用一起使用的OpenGLES对象，比如，配置固定函数管线可能需要几十个函数调用。相反，在初始化阶段编译一个图形着色器，并在运行时通过一个函数调用切换到它。创建或者修改开销较大的OpenGL ES对象应该总是作为静态对象创建。\n\n渲染循环处理我们打算渲染给OpenGL ES上下文的所有项，然后将结果呈现给显示器。在动画场景中，一些数据每一帧都在更新，在上图所示的内部渲染循环中，应用程序在更新渲染资源（在进程中创建或修改OpenGL ES对象）和提交这些资源的绘图命令之间切换。这个内部循环的目标是平衡工作负载让CPU和GPU并行工作，防止应用程序和OpenGL ES同时使用相同的资源。在iOS中，如果不在帧的起始或结束时执行修改OpenGL ES对象，那么修改的代价会非常高。\n\n这个内部循环的一个重要目标是避免将数据从OpenGL ES拷贝回应用程序，将结果从GPU拷贝到CPU会非常慢。如果拷贝的数据同样用于后续渲染当前帧过程的一部分（如上图的渲染循环中展示的），应用程序会被阻塞知道所有之前提交的绘图命令完成。\n\n在应用程序提交帧所需要的所有绘图命令，然后将结果呈现到屏幕上。非交互式哟哟欧诺个程序会将最终图片拷贝到应用程序内存中进行下一步处理。\n\n最终，当应用程序准备退出或结束主要工作，将释放OpenGL ES对象获取更多的可用资源。\n\n总结本设计的重要特点：\n- 在任何可能情况下创建静态资源；\n- 内部渲染循环在修改动态资源和提交渲染命令之间切换，尝试避免在帧的起始或结束之外的时间修改动态资源；\n- 避免将中间渲染结果读取回应用程序；\n\n本节后面的部分提供了游泳的变成技术来实现这个渲染循环的特性。\n\n### 避免同步和Flush操作\n\nOpenGL ES规范不要求实现立即执行命令。通常情况，命令被排队到命令缓冲区，后面由硬件执行。OpenGL ES会等到应用程序许多命令在队列中后发送到硬件--批处理更加有效，但是，一些OpenGL ES函数必须立即刷新命令缓冲区，其他函数不仅刷新命令缓冲区，还会阻塞直到之前的命令完成才返回对应用和程序的控制。只有在必要时才使用刷新和同步命令，过度使用刷新或同步命令会导致应用程序等待硬件结束渲染时停止。\n\n下面这些情况需要OpenGL ES将命令缓冲区提交给硬件执行：\n- `glFlush`函数将命令缓冲区提交到图形硬件，它会阻塞到命令被提交到硬件但不用等到命令执行结束；\n- `glFinish`函数刷新命令缓冲区，然后等待所有之前提交的命令在图像硬件上执行结束；\n- 检索帧缓冲区内容的函数（如`glReadPixels`）同样要等待提交的命令完成；\n- 命令缓冲区已满；\n\n#### 有效利用glFlush\n\n在一些桌面OpenGL的实现中，定期调用`glFlush`函数可以有效平衡CPU和GPU的工作，但在iOS中并非如此。iOS图像硬件实现的延迟算法依赖于一次性缓存所有场景中的顶点数据，因此可以对其进行最有处理，去除隐藏表面。通常，OpenGL ES应用程序只有两种情况下调用`glFlush`或`glFinish`函数：\n- 应用程序在进入后台时需要刷新命令缓冲区，因为应用程序在后台时执行OpenGL ES命令会导致iOS崩溃；\n- 如果应用程序在多个上下文共享OpenGL ES对象（如顶点缓存或纹理），我们需要调用`glFlush`函数同步使用这些资源。例如，在一个上下文加载顶点数据之后调用`glFlush`函数，以确保内容准备被其他上下文检索。当与其他iOS APIs（如Core Image）共用OpenGL ES对象时也可以使用这个建议；\n\n#### 避免查询OpenGL ES状态\n\n调用`glGet*()`，包括`glGetError()`，可能需要OpenGL ES在检索任何状态变量之前执行之前的命令。这种同步会强迫图形硬件和CPU同步运行，减少了并行性的机会。为了避免这种情况，维护自己需要查询任意状态的副本，直接访问它而不是调用OpenGL ES。\n\n当错误发生时，OpenGL ES设置一个错误标识。这些错误和其他错误出现在的Xcode或OpenGL ES分析器的帧调试器中。应该使用这些工具而不是使用`glGetError`函数，如果频繁调用会降低性能。其他查询（例如`glCheckFramebufferStatus()`，`glGetProgramInfoLog()`，`glValidateProgram()`）通常也只在开发和调试中有用。\n\n### 使用OpenGL ES管理资源\n\n许多OpenGL数据可以直接存储到OpenGL ES渲染上下文和与之关联的共享组中。OpenGL ES的实现可以自由将数据转换为适合图形硬件的格式，这可以显著提高性能，特别对于不经常更改的数据。应用程序还可以向OpenGL ES提供如何使用数据的提示，OpenGL ES的实现可以更有效使用这些提示处理数据。例如，静态数据可能被放置在图像处理器可以轻松获取的内存中，甚至可以放置在专用的图形内存中。\n\n### 使用双重缓冲避免资源冲突\n\n当应用程序和OpenGL ES同时访问一个OpenGL ES对象时会发生资源冲突。当一个参与者尝试修改对象而另一个参与者正在使用，他们可能会阻塞直到该对象不再被使用。一旦他们开始修改对象，其他参与者可能在修改完成之前都无法使用。或者，OpenGL ES可以隐式复制对象，以便两个参与者都可以继续执行命令。任何一个选项都是安全的，但是每个都有可能成为应用程序的瓶颈。下图展示了这个问题，在这个例子中，只有一个纹理对象，OpenGL ES和应用程序都想使用它，当应用程序尝试修改纹理，它必须等待之前提交的绘图命令完成--CPU和GPU同步。\n\n![Single-buffered texture data](/img/article/20190519/12.png)\n\n为了解决这个问题，应用程序可以在修改和绘制该对象之间执行额外的工作。但是，如果应用程序没有额外的工作可以执行，它应该显示创建两个大小相同的对象；一个参与者读取对象，另一个参与者修改另一个。下图展示了双缓冲方法，当GPU处理一个纹理时，CPU修改另一个。在初始化启动之后，CPU和GPU都不会处于空闲状态。虽然显示了纹理，这个解决方案几乎适用于任何类型的OpenGL ES对象。\n\n![Double-buffered texture data](/img/article/20190519/13.png)\n\n对于大多数应用程序双缓冲区已经足够，但它要求两个参与者几乎同时完成处理命令。为了避免阻塞，可以添加更多的缓冲区；这实现了传统的生产者-消费者模型。如果生产者在消费者之前完成处理命令，它将接受一个空闲缓冲区并继续处理命令。在这种情况下，只有消费者严重落后，生产者才会停止生产。\n\n双缓冲区和三缓冲区需要消耗额外的内存以防止管道停滞，额外使用内存可能会对应用程序的其他部分造成压力。在iOS设备中，内存稀缺；所以设计必须和其他应用程序优化平衡以使用更多的内存。\n\n### 注意OpenGL ES的状态\n\nOpenGL ES的实现维护了一份复杂的状态数据，包括使用`glEnable`或`glDisable`函数设置的开关、当前着色器程序以及其统一变量、当前绑定的纹理图元、当前绑定的顶点缓存及其启用的顶点属性。硬件有一个当前状态，它被缓存并懒加载。切换状态是昂贵的，所以最好减少状态切换。\n\n不要设置以及设置的状态。一旦启用某个特性就不用再启用。比如，如果多次调用相同参数的`glUniform`函数，OpenGL ES可能不会检查已经设置的相同的状态，它只是简单的更新状态值，即使值相同。\n\n避免使用专用的设置或关闭过程设置不必要的状态，而不是将这类调用放入绘图循环。设置和关闭过程对于开启关闭实现特定视觉效果的特性很有用--例如，当绘制线框轮廓线围绕有纹理的多边形时。\n\n#### 使用OpenGL ES对象封装状态\n\n要减少状态更改，创建一个对象，将多个OpenGL ES状态更改收集到一个对象，该对象可以使用一个函数绑定。例如，顶点数组对象将多个顶点属性的配置存储到一个对象中。见[使用顶点数组对象合并顶点数组状态更改](使用顶点数组对象合并顶点数组状态更改)。\n\n#### 组织绘图调用最小化状态更改\n\nOpenGL ES的状态更改的效果没有立即生成。相反，当我们发出绘图指令时，OpenGL ES将执行绘制状态值所需的工作。通过减少状态更改，我们可以减少CPU用于配置图形管线的时间。例如，在应用程序中保留一个状态向量，并且只有在绘制调用之间的状态发生时才设置相应的OpenGL ES状态。另一个有用的算法是状态排序--跟踪我们需要做的绘图操作和每个操作所需的状态更改量，然后对它们排序，以便连续使用相同的状态执行操作。\n\nOpenGL ES的iOS实现可以缓存它在状态之间高效切换所需的一些配置数据，但每个唯一状态集的初始配置需要更长的时间。为了保持一致的性能，我们可以在配置过程中“预热”计划使用的每个状态：\n- 启用计划使用的状态配置或着色器；\n- 使用状态配置绘制少量顶点；\n- 刷新OpenGL ES上下文，以便在预热阶段不显示绘图；\n\n# Best Practices for Working with Vertex Data\n\n要使用OpenGL ES渲染帧，应用程序需要配置图形管线并提交要绘制的图形图元。在一些应用中，所有的图元都是使用同样的管线配置绘制；其他应用可能使用不同的技术渲染不同的帧元素。但无论应用程序使用的哪个图元，管线如何配置，应用程序都需要向OpenGL ES提供顶点。本章提供了一个关于顶点的课程并就如何有效处理顶点数据提供了针对性的建议。\n\n顶点由一个或多个属性组成，例如位置、颜色、法线或纹理坐标。OpenGL ES 2.0或3.0应用程序可以自由定义自己的属性；顶点数据的每个属性对应于作为顶点着色器的属性变量。OpenGL ES 1.1的应用程序使用固定管线定义好的属性。\n\n将一个属性定义为由一到四个组件构成的向量，属性中的所有组件共享一个公共数据类型。例如，一个颜色可能被定义为四个`GLubyte`组件（r,g,b,a）。当一个属性被加载到着色器变量中时，OpenGL ES使用默认值填充所有应用程序未提供的组件数据。最后一个组件被填充为1，其他未指定组件为0，如下图所示：\n\n![Conversion of attribute data to shader variables](/img/article/20190519/14.png)\n\n应用程序可能将一个属性配置为常量，这意味着对于作为绘图命令部分提交的所有顶点使用相同的值，又意味着每个顶点都是该属性的值。当应用程序调用OpenGL ES的函数绘制一组顶点时，顶点数据被拷贝到图形硬件。处理顶点数据的图形硬件，在着色器处理每个顶点，组装图元并将它们光栅化到帧缓冲区。OpenGL ES的一个优点在于将提交到OpenGL ES顶点数据的一组函数标准化，移除OpenGL ES提供的陈旧和低效的机制。\n\n应用程序必须提交大量图元来渲染一帧，需要小心管理它们的顶点数据和如何提交到OpenGL ES。本章所述的做法可以概括为以下几个基本原则：\n- 减少顶点数据的大小；\n- 减少OpenGL ES将顶点数据传输到图形硬件之前的预处理；\n- 减少拷贝顶点数据到图形硬件花费的时间；\n- 减少对每个顶点的计算；\n\n## 简化模型\n\n基于iOS设备的图形硬件很强大，但它显示的图片一般很小。我们不需要非常复杂的模型在iOS上呈现引人注目的图形。减少用于绘制模型的顶点数量可以直接减少顶点的数据和对顶点数据执行的计算。\n\n我们可以使用以下技术降低模型的复杂度：\n\n- 在不同细节级别提供不同版本的模型，并在运行时基于到摄像机的距离和显示的尺寸渲染合适的模型；\n- 使用纹理来消除对某些顶点信息的需要。例如，凹凸贴图可以用来在不添加更多顶点数据的情况下向模型添加细节；\n- 一些模型添加顶点改进光照细节或渲染质量。这通常是在计算每个顶点的值并在光栅化阶段对三角形进行插值完成的。例如，如果我们将聚光灯指向三角形的中心，它的效果可能被忽略，因为聚光灯醉了的部分不是指向一个顶点。通过添加顶点，我们可以额外提供插值点，代价是增加顶点数据的大小和模型上执行的计算。如果不想要添加额外的顶点，考虑将计算移动到管线的片段阶段：\n    + 如果应用程序使用OpenGL ES 2.0或之后的版本，应用程序在顶点着色器执行计算并将其分配给一个可变变量。变化的值由图形硬件插值并作为输入传递到片段着色器。相反，将计算的输入分配给变量并在片段着色器执行计算。这样做会将执行计算的成本从每个顶点的成本到每个片段的成本，从而减少顶点阶段的压力并增加管线片段阶段的压力。当应用程序在顶点处理时被阻塞，这样做，计算是相对廉价的并可以通过更改显著减少顶点数。\n    + 如果应用程序使用OpenGL ES 1.1，我们可以使用DOT3照明来执行各个片段的光照。我们可以通过添加凹凸贴图纹理来保存正常信息，并使用`GL_DOT3_RGB`模式的纹理组合操作应用凹凸贴图。\n\n## 避免在属性数组中存储常量\n\n如果模型中包含在这个模型中使用保持不变的数据的属性，则不要为每个顶点复制该数据。OpenGL ES 2.0和3.0应用程序可以设置一个常量顶点属性或使用一个统一的着色器值来保存该值。OpenGL ES 1.1应用程序应该使用每个顶点的属性函数，如`glColor4ub`或`glTexCoord2f`。\n\n> 待更新...\n\n# Reference\n\n> [About OpenGL ES](https://developer.apple.com/library/archive/documentation/3DDrawing/Conceptual/OpenGLES_ProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008793-CH1-SW1)","source":"_posts/2019/opengl-es-study-0519.md","raw":"---\ntitle: \"OpenGL ES基础学习\"\ncatalog: true\ntoc_nav_num: true\ndate: 2019-05-19 18:20:03\nsubtitle: \"Open Graphics Library for Embedded Systems\"\nheader-img: \"/img/article_header/article_header.png\"\nbusuanzi: true\ntags: \n- iOS\n\n---\n\n# Introduction\n\nOpen Graphics Library(OpenGL)用于可视化2D与3D数据，是多用途的开放标准图形库，支持2D和3D数字内容创建、机械和建筑设计、虚拟原型、飞行仿真、视频游戏等等。我们可以使用OpenGL配置3D图形管线并向其提交数据。顶点被转换点亮，组装成基本类型，并进行栅格化来创建2D图片。OpenGL的设计目的是将函数调用转换为可以发送到底层图形硬件的图形命令，因为底层硬件专门处理图形命令，所以OpenGL的绘图非常快。\n\nOpenGL for Embedded Systems(OpenGL ES)是openGL的简化版，消除冗余功能，为移动图形硬件上提供一个更容易学习和实现的库。\n\n![OpenGL ES](/img/article/20190519/1.png)\n\nOpenGL ES允许应用程序利用底层图形处理器的能力，iOS设备上的GPU可以实现复杂的2D和3D绘图，以及图片上每个像素阴影的复杂计算。如果应用程序的而设计要求需要对GPU硬件有直接全面的访问，那么我们应该使用OpenGL ES。OpenGL ES典型的客户端包括视频游戏和呈现3D图形的模拟器。\n\n# Checklist for Building OpenGL ES Apps for iOS\n\nOpenGL ES为使用GPU硬件渲染图形规范定义了无关平台的API。实现OpenGL ES的平台提供了一个用于执行OpenGL ES命令的渲染上下文，持有渲染结果的帧缓冲区，一个或多个展示帧缓冲区内容的渲染目标。iOS中，*EAGLContext*实现了渲染上下文，iOS只提供了一种帧缓冲区类型，OpenGL ES帧缓冲区对象，和实现渲染地点的*GLKView*、*CAEAGLLayer*。\n\n在iOS中创建OpenGL ES应用需要有以下考虑，一些对于OpenGL ES编程通用的，还有一些是iOS特定的考虑：\n1. 决定适用于我们应用的OpenGL ES版本，创建上下文；\n2. 在运行时检测设备是否支持我们想要使用的OpenGL ES功能；\n3. 选择渲染OpenGL ES内容的位置；\n4. 确定应用在iOS中正确运行；\n5. 实现渲染引擎；\n6. 使用Xcode和Instruments调试OpenGL ES应用，调优以获取最优性能；\n\n## 选择OpenGL ES版本\n\n决定应用需要支持OpenGL ES 3.0，OpenGL ES 2.0，OpenGL ES 1.1还是多个版本：\n- OpenGL ES 3.0是在iOS 7的新版本，增加了许多新特性，实现高性能、通用GPU计算技术和之前只能在台式机和游戏机上才能实现的更复杂视觉效果\n- OpenGL ES 2.0是iOS设备的基础配置，具有基于可编程着色器的可配置图形管线\n- OpenGL ES 1.1仅提供基本的固定函数的图形通道，在iOS中主要用于向后兼容\n\n我们应该针对最相关的特性和应用程序的设备选择一个或多个版本，关于iOS设备功能更多可见[iOS Device Compatibility Reference](https://developer.apple.com/library/archive/documentation/DeviceInformation/Reference/iOSDeviceCompatibility/Introduction/Introduction.html#//apple_ref/doc/uid/TP40013599)\n\n## 验证OpenGL ES功能\n\n[iOS Device Compatibility Reference](https://developer.apple.com/library/archive/documentation/DeviceInformation/Reference/iOSDeviceCompatibility/Introduction/Introduction.html#//apple_ref/doc/uid/TP40013599)总结了在已发布iOS设备中可用的功能和扩展，但是，为了让应用程序能够在尽可能多的设备和iOS版本上运行，我们应该始终在运行时查询OpenGL ES可以实现的功能。\n\n要确定实现的特定限制，比如最大纹理大小或顶点属性的最大数量，使用相应的`glGet`方法查找对应的值（如在*gl.h*文件查找*MAX_TEXTURE_SIZE*或*MAX_VERTEX_ATTRIBS*）。\n\n使用`glGetIntegerv`和`glGetStringi`方法检测OpenGL ES 3.0的扩展：\n``` objectivec\n/// #import <OpenGLES/ES3/gl.h>\nBOOL CheckForExtensions(NSString *searchName) {\n    int max = 0;\n    glGetIntegerv(GL_NUM_EXTENSIONS, &max);\n    NSMutableSet *extensions = [NSMutableSet set];\n    for (int i = 0; i < max; i++) {\n        [extensions addObject:@((char *)glGetStringi(GL_EXTENSIONS, i))];\n    }\n    return [extensions containsObject:searchName];\n}\n/// 对于OpenGL ES 2.0和1.1的扩展，使用glGetString(GL_EXTENSIONS)获取以空格分隔的所有扩展名\n```\n\n## 选择渲染位置\n\niOS中，帧缓冲区对象存储了绘图命令的结果，我们可以通过以下多种方式使用帧缓冲区对象的内容：\n- *GLKit*框架提供了绘制OpenGL ES内容和管理自身帧缓冲区的view，和支持动画的控制器。使用这些类创建全屏视图或将OpenGL ES内容放入UIKit视图层次结构中。[Drawing with OpenGL ES and GLKit](#drawing-with-opengl-es-and-glkit)\n- *CAEAGLLayer*类提供绘制OpenGL ES内容作为Core Animation层级组合一部分的方法，但我们必须使用这个类创建自己的帧缓冲区\n- 与任意OpenGL ES实现一样，我们也可以使用帧缓冲区进行离屏图形处理或渲染图像管线其他地方使用的纹理。在OpenGL ES中，离屏缓冲区可以用于使用多个渲染目标的渲染算法\n\n更多关于离屏缓冲区、纹理、Core Animation层级的渲染，前往[Drawing to Other Rendering Destinatons](#drawing-to-other-rendering-destinations)\n\n## iOS集成\n\niOS应用默认支持多任务，但在OpenGL ES应用内处理这个特性需要额外考虑，不正确使用OpenGL ES会导致应用在后台被系统杀死。\n\n许多iOS设备包含高分辨率显示，所以我们需要支持多种显示尺寸和分辨率。\n\n了解如何支持这些和其他iOS特性，前往[Multitasking, High Resolution, and Other iOS Features](#multitasking,-high-resolution,-and-other-ios-features)。\n\n## 实现渲染引擎\n\n设计OpenGL ES绘图代码有许多可能的策略，其详细信息超出了文本的范围。渲染引擎设计的许多方面对于OpenGL和OpenGL ES的所有实现都是通用的。\n\n更多iOS设备设计考虑前往[OpenGL ES Design Guidelines](#opengl-es-design-guidelines)和[Concurrency and OpenGL ES](#concurrency-and-opengl-es)。\n\n## 调试与性能分析\n\nXcode和Instruments提供了许多工具来跟踪渲染问题并分析OpenGL ES的性能，前往[Debugging and Profiling](#debugging-and-profiling)。\n\n# Configuring OpenGL ES Contexts\n\n每个OpenGL ES的实现提供了创建管理OpenGL ES规范所需要状态的渲染上下文的方法，通过在上下文的状态，多个应用可以轻松地共享图形硬件而不会干扰其他应用程序的状态。\n\n在我们使用OpenGL ES方法前，必须初始化*EAGLContext*对象，*EAGLContext*类还提供将OpenGL ES内容与Core Animation集成的方法。\n\n## 当前上下文是OpenGL ES函数调用的目标\n\niOS应用每个线程都有一个当前上下文，当我们调用OpenGL ES的方法时，这个就是状态要被更改的上下文。\n\n设置当前线程上下文，在对应线程调用`setCurrentContext:`方法：\n``` objectivec\n[EAGLContext setCurrentContext:context];\n```\n\n调用*EAGLContext*类方法`currentContext`来检索当前线程的上下文。\n\n> 如果在相同线程切换两种或以上上下文，在设置新的当前上下文之前调用`glFlush`方法确保之前提交的命令能及时交付给图形硬件。\n\nOpenGL ES对当前上下文*EAGLContext*对象持有强引用，当调用`setCurrentContext:`方法切换上下文则不会对之前的对象强持有，为了防止*EAGLContext*对象在切换时被释放，我们应该对之强引用。\n\n## 每个上下文都针对OpenGL ES的特定版本\n\n一个*EAGLContext*对象仅支持OpenGL ES的一个版本。例如：OpenGL ES 1.1版本下的代码不兼容2.0或3.0版本；使用OpenGL ES 2.0版本特性的版本兼容3.0版本，同时2.0版本的扩展经常可以在3.0版本中少量修改后使用；OpenGL ES 3.0的特性和新增的硬件性能需要3.0版本。\n\n我们在创建和初始化*EAGLContext*对象时选择OpenGL ES的版本。如果设备不支持对应的版本，会返回nil，我们必须保证正确初始化之后使用它。\n``` objectivec\nEAGLContext* CreateBestEAGLContext() {\n    EAGLContext *context = [[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES3];\n    if (context == nil) {\n        context = [[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES2];\n    }\n    return context;\n}\n```\n\n## EAGL Sharegroup\n\n尽管上下文持有OpenGL ES的状态，但它不直接管理OpenGL ES的对象。相反，可以通过*EAGLSharegroup*对象创建和持有OpenGL ES对象，每个上下文都包含一个被委托创建对象的*ESGLSharegroup*对象。\n\n在两个或多个上下文引用一个共享组时优势很明显，这时创建OpenGL ES的对象在所有上下文都可用，如果绑定到另一个上下文与创建它的上下文有相同的标识符，则引用相同的OpenGL ES对象。移动设备的资源非常稀缺，在上下文创建多个相同内容的拷贝是浪费资源的，公共资源可以更好的利用设备的图形资源。\n\nsharegroup是一个不透明对象，没有可以调用的属性或方法，可以使用sharegroup对象的上下文对之进行强引用。\n\n![OpenGL ES Sharegroup](/img/article/20190519/2.png)\n\nsharegroup在以下两种情况下最有用：\n- 上下文之间的大多数共享资源不会改变\n- 当我们想要在其他线程创建OpenGL ES对象而主线程用于渲染。例如：第二个上下文在单独的线程上用于获取数据和创建资源，加载资源后，第一个上下文可以绑定到对象并立即使用它。*GLKtextureLoader*类就是使用这个模式来提供异步纹理加载。\n\n想要创建引用相同sharegroup的上下文，第一个上下文使用`initAPI:`方法初始化后会自动创建sharegroup，第二个及后续上下文调用`initAPI:sharegroup:`使用第一个上下文的sharegroup进行初始化。\n\n``` objectivec\nEAGLContext* firstContext = CreateBestEAGLContext();\nEAGLContext* secondContext = [[EAGLContext alloc] initWithAPI:[firstContext API] sharegroup: [firstContext sharegroup]];\n```\n\n当sharegroup由多个上下文共享时，我们有责任管理OpenGL ES对象的状态更改：\n- 应用程序可以同时跨多个上下文访问未修改的对象\n- 当对象被发送到上下文的命令修改时，不能在其他地方读写该对象\n- 在对象修改后，所有上下文必须重新绑定才能看到更改。如果上下文在绑定之前引用该对象，则该对象的内容是未定义的\n\n下面是更新OpenGL ES对象的步骤：\n- 在可能使用对象的每个上下文调用`glFlush`方法\n- 在想要修改对象的上下文，调用一种或多种OpenGL ES方法修改对象\n- 在接收状态修改命令的上下文中调用`glFlush`方法\n- 在每个其他上下文，重新绑定标识符\n\n> 另一种共享对象的方法是使用一个渲染上下文，多个目标帧缓冲区。在渲染时，应用程序绑定合适的帧缓冲区并根据需要渲染帧，因为所有的OpenGL ES对象都是从一个上下文应用，所有会看到相同的OpengGL ES数据。这种模式使用的资源较少，但只适用于单线程应用程序，但单线程程序中可以仔细控制上下文状态。\n\n# Drawing with OpenGL ES and GLKit\n\nGLKit框架提供了视图和控制器类，消除了绘画和动画OpenGL ES内容所需的设置和维护代码，*GLKView*类管理OpenGL ES的基础结构，为绘图代码提供空间，*GLKViewController*类提供一个渲染循环用于GLKit视图上平滑的展示OpenGL ES内容的动画。这些类扩展了用于绘制视图内容和管理视图呈现的标准UIKit设计模式。因此，我们可以将主要精力用于OpenGL ES渲染代码与应用流畅度上。GLKit框架同样提供简化OpenGL ES 2.0与3.0开发的其他特性。\n\n## GLKit视图根据需求绘制OpenGL ES内容\n\n*GLKView*类提供了一个基于OpenGL ES等价于标准UIView的绘图周期。*UIView*对象自动配置图形上下文，所以`drawRect:`实现只需要执行Quartz 2D的绘图命令，*GLKView*对象自动配置自己所以我们的绘图方法只需要执行OpenGL ES的绘图命令。*GLKView*类通过维护持有OpenGL ES绘图命令结果的帧缓冲区来提供此功能，然后在绘图方法返回时自动将他们呈现给Core Animation。\n\n与标准UIKit视图一样，GLKit视图按需渲染。当视图第一次显示，它调用我们的绘图方法--Core Animation缓冲区渲染输出并在视图显示时显示它。当我们想要修改视图内容，调用`setNeedsDisplay`方法，视图会重新调用我们的绘图方法，缓冲区结果图，在屏幕显示它。这个方法在渲染图像的数据修改很少或只响应用户操作时有用，只有在需要的时候渲染新视图内容，这样可以节约设备电量并为其他操作留出更多时间。\n\n![Rending OpenGL ES content with a GLKit view](/img/article/20190519/3.png)\n\n### 创建与配置GLKit View\n\n我们可以以编程的方式创建配置一个GLKView对象，也可以用故事板，在绘图钱，我们需要与之关联*EAGLContext*对象。\n\n- 当以编程方式创建一个视图时，先创建一个上下文然后将它用于*initWithFrame:context:*方法\n- 当从故事板加载一个视图，创建一个上下文然后设置为这个视图的*context*属性\n\n一个GLKit视图自动创建和配置他自己的OpenGL ES帧缓冲区对象和渲染缓冲区。我们使用视图的绘图属性控制这些对象属性，当我们改变尺寸大小、比例系数、或者某个绘画属性，它会在下次内容绘制时自动删除和重新创建相应的帧缓冲区和渲染缓冲区对象。\n\n``` objectivec\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    EAGLContext *context = CreateBestEAGLContext();\n    GLKView *glkView = [[GLKView alloc] initWithFrame:self.view.bounds context:context];\n    // Configure renderbuffers\n    glkView.drawableColorFormat = GLKViewDrawableColorFormatSRGBA8888;\n    glkView.drawableDepthFormat = GLKViewDrawableDepthFormat24;\n    glkView.drawableStencilFormat = GLKViewDrawableStencilFormat8;\n    // enable multisampling\n    // multisampling是一种消除锯齿边缘的反锯齿，在大多数3D应用程序中提高图形质量，代价是使用更多的内存和片段处理时间\n    glkView.drawableMultisample = GLKViewDrawableMultisample4X;\n    [self.view addSubview:glkView];\n}\n```\n\n### 使用GLKit View绘图\n\n绘制OpenGL ES内容分为三步：准备OpenGL ES基础设施，执行绘图命令，将渲染内容提交给Core Animation显示。其中*GLKView*实现了第一步与第三步，下面代码实现了绘图的第二步：\n\n``` objectivec\n- (void)drawRect:(CGRect)rect {\n    // clear the framebuffer\n    glClearColor(0.0, 0.0, 0.1, 1.0);\n    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n    // Draw using previously configured texture, shader, uniforms, and vertex array\n    glBindTexture(GL_TEXTURE_2D, _planetTexture);\n    glUseProgram(_diffuseShading);\n    glUniformMatrix4fv(_uniformModelViewProjectionMatrix, 1, 0, _modelViewProjectionMatrix.m);\n    glBindVertexArray(_planetMesh);\n    glDrawElements(GL_TRIANGLE_STRIP, 256, GL_UNSIGNED_SHORT, NULL);\n}\n```\n\n> *glClear*方法提示OpenGL ES任何现有的帧缓冲区内容都可以被丢弃，避免加载以前的内容到内存中造成高消耗内存操作。为了确保最佳性能，我们应该在每次绘图前总是调用这个函数\n\n*GLKView*可以提供一些简单的接口给OpenGL ES绘图，因为它管理了OpenGL ES渲染过程中的标准部分：\n\n- 在调用绘图方法前，视图需要：\n    + 确保*EAGLContext*为当前上下文\n    + 基于现有尺寸、比例系数、绘图属性创建帧缓冲区对象和渲染缓冲区（如有必要）\n    + 将帧缓冲区对象绑定为绘制命令的当前目标\n    + 设置OpenGL ES视图端口以匹配帧缓冲区大小\n- 在绘图方法返回后，视图需要：\n    + 解析multisampling缓冲区（如果multisampling已设置）\n    + 丢弃不再需要的渲染缓冲区\n    + 将渲染缓冲区内容提交给Core Animation缓冲区和展示\n\n## 使用代理渲染\n\n许多OpenGL ES应用程序使用自定义类实现渲染代码，这个方法的优势在于它能为多个渲染器分别定义不同的渲染类，从而轻松地支持多个渲染算法，共享公共功能的渲染算法可以从父类继承。例如，我们可以使用不同的渲染类同时支持OpenGL ES 2.0和3.0，或者使用它们在具有更强大硬件的设备上定制渲染，以获得更优质的图片。\n\nGLKit非常适合这种方法--我们可以使用渲染器对象成为标准GLKView实例的代理，没有使用继承GLKView和实现`drawInRect:`方法，而是使用渲染器类实现*GLKViewDelegate*代理并实现`glkView:drawInRect:`方法。下面代码演示了应用程序在启动时根据硬件特性选择渲染器类：\n\n``` objectivec\n- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {\n    // Create a context\n    EAGLContext *context = [[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES2];\n    [EAGLContext setCurrentContext:context];\n    \n    // Choose a rendering class based on device features\n    GLint maxTextureSize;\n    glGetIntegerv(GL_MAX_TEXTURE_SIZE, &maxTextureSize);\n    if (maxTextureSize > 2048) {\n        self.renderer = [[MyBigTextureRenderer alloc] initWithContext:context];\n    } else {\n        self.renderer = [[MyRenderer alloc] initWithContext:context];\n    }\n    GLKView *view = (GLKView *)self.window.rootViewController.view;\n    view.delegate = self.renderer;\n    view.context = context;\n    return YES;\n}\n```\n\n## GLKit视图控制器动画OpenGL ES内容\n\n默认情况下，一个*GLKView*对象按需渲染内容。也就是说，使用OpenGL ES绘图的一个关键优势是他能使用图形处理硬件对复杂场景进行连续动画--游戏和模拟器等应用程序很少使用静态图片。对于这些情况，*GLKit*框架提供一个视图控制器类，为它管理的*GLKView*对象维护一个动画循环，这个循环遵循游戏和模拟器中场景中常见的设计模式，分为两个阶段：更新与显示。下图展示了一个简单的动画循环示例：\n\n![The animation loop](/img/article/20190519/4.png)\n\n### 动画循环的理解\n\n更新阶段，视图控制器调用它自身的*update*方法（或者当未继承GLKViewController时可以使用代理的`glkViewControllerUpdate:`方法），这个方法中，我们应该为下一帧绘图做准备。例如，一个游戏可能使用这个方法根据上一帧以来接受到的输入事件来决定玩家和敌对角色的位置，科学的可视化可以使用这种方法运行模拟的一个步骤。如果我们需要时间信息来决定应用程序下一帧的状态，使用这个视图控制器的其中一个时间属性比如`timeSinceLastUpdate`属性。\n\n展示阶段，试图控制器调用视图的`display`方法，这个方法会触发绘图方法。在绘图方法中，我们对GPU提交OpenGL ES的绘图指令来渲染我们的内容。为了最佳性能。我们的应用程序应该在渲染最新一帧时修改OpenGL ES对象，然后提交绘图指令。\n\n动画循环以视图控制器的`framesPerSecond`属性所指示的速率在这两个阶段切换，我们可以使用`preferredFramesPerSecond`属性来设置所需的帧速率--为了当前显示硬件的最优性能，视图控制器自动渲染接近于我们设置值的最优帧速率。\n\n> 为了获得最佳效果，选择一个应用程序可以达到的帧率。平滑、一致的帧率比经常变化的帧率能有更好的用户体验\n\n### 使用GLKit视图控制器\n\n``` objectivec\n@implementation PlanetViewController // subclass of GLKViewController\n \n- (void)viewDidLoad {\n    [super viewDidLoad];\n \n    // Create an OpenGL ES context and assign it to the view loaded from storyboard\n    GLKView *view = (GLKView *)self.view;\n    view.context = [[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES2];\n \n    // Set animation frame rate\n    self.preferredFramesPerSecond = 60;\n \n    // Not shown: load shaders, textures and vertex arrays, set up projection matrix\n    [self setupGL];\n}\n \n- (void)update {\n    _rotation += self.timeSinceLastUpdate * M_PI_2; // one quarter rotation per second\n \n    // Set up transform matrices for the rotating planet\n    GLKMatrix4 modelViewMatrix = GLKMatrix4MakeRotation(_rotation, 0.0f, 1.0f, 0.0f);\n    _normalMatrix = GLKMatrix3InvertAndTranspose(GLKMatrix4GetMatrix3(modelViewMatrix), NULL);\n    _modelViewProjectionMatrix = GLKMatrix4Multiply(_projectionMatrix, modelViewMatrix);\n}\n \n- (void)glkView:(GLKView *)view drawInRect:(CGRect)rect {\n    // Clear the framebuffer\n    glClearColor(0.0f, 0.0f, 0.1f, 1.0f);\n    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n \n    // Set shader uniforms to values calculated in -update\n    glUseProgram(_diffuseShading);\n    glUniformMatrix4fv(_uniformModelViewProjectionMatrix, 1, 0, _modelViewProjectionMatrix.m);\n    glUniformMatrix3fv(_uniformNormalMatrix, 1, 0, _normalMatrix.m);\n \n    // Draw using previously configured texture and vertex array\n    glBindTexture(GL_TEXTURE_2D, _planetTexture);\n    glBindVertexArrayOES(_planetMesh);\n    glDrawElements(GL_TRIANGLE_STRIP, 256, GL_UNSIGNED_SHORT, 0);\n}\n@end\n```\n\n`viewDidLoad`方法创建了OpenGL ES上下文并提供给视图，同时设置动画循环的帧率。视图控制器自动成为视图的代理，同时实现动画循环的更新与显示阶段。在`update`方法中，它计算显示旋转行星所需的变换矩阵。在`glkView:drawInRect:`方法，它将这些矩阵提供给着色器程序，并提交绘制命令来渲染行星的几何形状。\n\n# Drawing to Other Rendering Destinations\n\n帧缓冲区对象是渲染命令的目标。当创建一个帧缓冲区对象，我们可以精确控制它存储的颜色、深度和模板数据。我们通过将图片附加到帧缓冲区来提供这种存储，如下图所示。最常见的图片关联是渲染缓冲区对象。我们也可以将OpenGL ES的纹理附加到帧缓冲区的颜色连接点，这意味着所有的绘图命令都将渲染到纹理中。稍后，纹理可以作为未来渲染命令的输入。我们还可以在一个渲染上下文创建多个帧缓冲区对象，这么做可以在多个帧缓冲区之间共享相同的渲染管线和OpenGL ES资源。\n\n![Famebuffer with color and depth renderbuffers](/img/article/20190519/5.png)\n\n所有这些方法都需要手动创建帧缓冲区和渲染缓冲区对象来存储OpenGL ES上下文的渲染结果，还需要编写额外的代码来将内容呈现到屏幕，如有必要还要运行一个动画循环。\n\n## 创建帧缓冲区对象\n\n根据应用程序打算执行的任务，将配置不同的对象附加到帧缓冲区对象。在多数情况下，配置帧缓冲区的区别在于对象被附加到对象的颜色连接点上：\n- 使用帧缓冲区用于离屏图像处理，附加一个渲染缓冲区。见[创建离屏缓冲区对象](#创建离屏缓冲区对象)\n- 使用帧缓冲区图片作为后续渲染步骤的输入，附加一个纹理。见[使用帧缓冲区对象渲染纹理](#使用帧缓冲区对象渲染纹理)\n- 在Core Animation层级组合中使用帧缓冲区，使用特定Core Animation-aware渲染缓冲区。见[渲染到Core Animation层级](#渲染到Core-Animation层级)\n\n### 创建离屏缓冲区对象\n\n用于离屏渲染的帧缓冲区分配内存给它所有的关联作为OpenGL ES的渲染缓冲区。下面代码分配内存给一个带有颜色和深度关联的帧缓冲区对象：\n\n1. 创建帧缓冲区并绑定：\n``` objectivec\nGLuint framebuffer;\nglGenFramebuffers(1, &framebuffer);\nglBindFramebuffer(GL_FRAMEBUFFER, framebuffer);\n```\n\n2. 创建颜色渲染缓冲区，分配内存，与帧缓冲区的颜色连接点相关联：\n``` objectivec\nGLuint colorRenderbuffer;\nglGenRenderbuffers(1, &colorRenderbuffer);\nglBindRenderbuffer(GL_RENDERBUFFER, colorRenderbuffer);\nglRenderbufferStorage(GL_RENDERBUFFER, GL_RGBA, width, height);\nglFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_RENDERBUFFER, colorRenderbuffer);\n```\n\n3. 创建一个深度或者深度/模板渲染缓冲区，分配内存，与帧缓冲区深度关联点相关联：\n``` objectivec\nGLuint depthRenderbuffer;\nglGenRenderbuffers(1, &depthRenderbuffer);\nglBindRenderbuffer(GL_RENDERBUFFER, depthRenderbuffer);\nglRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH_COMPONENT16, width, height);\nglFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, depthRenderbuffer);\n```\n\n4. 测试帧缓冲区的完整性，这个测试方法只需要在帧缓冲区配置改动时执行：\n``` objectivec\nGLenum status = glCheckFramebufferStatus(GL_FRAMEBUFFER);\nif (status != GL_FRAMEBUFFER_COMPLETE) {\n    NSLog(@\"failed to make complete framebuffer object %x\", status);\n}\n```\n\n在绘图到离屏渲染缓冲区后，使用`glReadPixels`方法返回它的内容到CPU做进一步处理。\n\n### 使用帧缓冲区对象渲染纹理\n\n创建帧缓冲区的代码几乎与离屏实例一样，但现在是纹理分配内存并与颜色关联点相关联：\n1. 创建帧缓存对象（与上例相似）；\n2. 创建目标纹理，与帧缓冲区的颜色关联点相关联：\n``` objectivec\nGLuint texture;\nglGenTextures(1, &texture);\nglBindTexture(GL_TEXTURE_2D, texture);\nglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);   // 纹理过滤\nglTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, NULL);\nglFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, texture, 0);\n```\n3. 分配缓存并关联深度缓冲区（与上例类似）；\n4. 验证帧缓冲区的完整性；\n\n虽然这个例子假设我们正在渲染到颜色纹理，但也可以使用其他选项。例如，使用*OES_depth_texture*扩展，可以将纹理关联到深度关联点，以将场景中的深度信息存储到纹理。我们可以使用这个深度信息计算最终渲染场景中的阴影。\n\n### 渲染到Core Animation层级\n\nCore Animation是iOS上图形渲染和动画的核心基础设施，我们可以使用不同iOS子系统渲染的层级（如UIKit、Quartz 2D、OpenGL ES）来组合应用程序的用户界面或其他可视化显示。OpenGL ES通过*CAEAGLLayer*类关联Core Animation，这个类是一种特殊类的Core Animation层级，其内容来自OpenGL ES渲染缓冲区。Core Animation将渲染缓冲区的内容和其他层级组合在一起，并将结果图像显示在屏幕上。\n\n![Core Animation shares the renderbuffer width OpenGL ES](/img/article/20190519/6.png)\n\n*CAEAGLLayer*通过提供了两项关键功能为OpenGL ES提供支持。首先，它为渲染缓冲区分配内存共享存储，其次，它将渲染缓冲区呈现到Core Animation，用渲染缓冲区中的数据替换层级之前的内容。该模型的优点在于Core Animation层级不需要每一帧都绘制，只需要在渲染图像发生改变时绘制。\n\n> GLKView类自动执行以下步骤，所以当我们想要在视图的内容层中使用OpenGL ES绘图时，应该使用它。\n\n使用Core Animation层级的OpenGL ES渲染：\n1. 创建*CAEAGLLayer*对象并配置它的属性。想要最佳性能，设置层级的*opaue*属性为YES。可选，通过为*CAEAGLLayer*对象的`drawableProperties`属性分配一个新的字典来配置渲染表面的表面属性；可以指定渲染缓冲区的像素格式，并指定渲染缓冲区的内容在发送到Core Animation后是否被丢弃。有关允许的键列表，见[EAGLDrawable Protocol Reference](https://developer.apple.com/documentation/opengles/eagldrawable?language=objc)；\n2. 创建OpenGL ES上下文，并设置为当前上下文；\n3. 创建帧缓冲区对象；\n4. 创建颜色渲染缓冲区，调用`renderbufferStorage:fromDrawable:`方法分配存储内存并将层级对象作为参数传入。宽度、高度、像素格式都是从层级获取并用于渲染缓冲区的分配存储内存：\n``` objectivec\nGLuint colorRenderbuffer;\nglGenRenderbuffers(1, &colorRenderbuffer);\nglBindRenderbuffer(GL_RENDERBUFFER, colorRenderbuffer);\n[myContext renderbufferStorage:GL_RENDERBUFFER fromDrawable:myEAGLLayer];\nglFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_RENDERBUFFER, colorRenderbuffer);\n```\n> 当Core Animation的层级`bounds`或属性改变时，必须重新分配渲染缓冲区存储内存。如果不重新分配内存，渲染缓冲区的大小可能不匹配层级的大小。\n5. 检索颜色渲染缓冲区的高度和宽度：\n```\nGLuint width, height;\nglGetRenderbufferParameteriv(GL_RENDERBUFFER, GL_RENDERBUFFER_WIDTH, &width);\nglGetRenderbufferParameteriv(GL_RENDERBUFFER, GL_RENDERBUFFER_HEIGHT, &height);\n```\n在前面的示例中，显示地提供了渲染缓冲区的宽度和高度以便分配内存。这里，代码在分配存储内存后检索颜色渲染缓冲区的宽度和高度。应用程序之所以这样做，是因为颜色缓冲区的实际尺寸是根据层级的边界大小和缩放因子计算的。关联到帧缓冲区的渲染缓冲区必须具有相同的纬度。除了使用高度和宽度分配深度缓冲区内存，还可以用来分配OpenGL ES视图端口，并帮助确定应用程序的纹理和模型中所需的细节级别；\n6. 分配缓存并关联深度缓冲区；\n7. 验证帧缓冲区的完整性；\n8. 通过将*CAEAGLLayer*对象传递给`addSublayer:`一个可见层级的方法添加到Core Animation的层级结构中。\n\n## 绘制到帧缓冲区对象\n\n现在我们已经拥有了一个帧缓冲区对象，然后就是填充。下面介绍了渲染新帧并呈现给用户所必要的步骤，渲染到纹理或离屏帧缓冲区的行为类似，只是应用程序使用最终帧的方式不同。\n\n### 按需或使用动画循环渲染\n\n我们在渲染到一个Core Animation层级时必须选择何时绘制我们的OpenGL ES内容，就像使用GLKit视图和控制器绘图一样。如果渲染到离屏帧缓冲区或纹理，则在适合使用这些帧缓冲区类型的情况下随时绘制。\n\n对于on-demand绘制，实现我们自己的方法绘制并呈现渲染缓冲区，并在需要显示新内容的时候调用它。\n\n对于动画循环绘制，使用`CADisplayLink`对象。`displayLink`是由Core Animation提供的一种定时器，允许我们将绘图同步到屏幕的刷新率。下面代码展示了我们如何检索显示视图的屏幕，使用这个屏幕创建一个新的`displayLink`对象并添加到运行环中。\n\n> *GLKViewController*类自动使用`CADisplayLink`对象来动画`GLKView`的内容，只有当我们需要超出*GLKit*框架所提供的行为时，才直接使用`CADisplayLink`类\n\n```\nCADisplayLink *displayLink = [self.view.window.screen displayLinkWithTarget:self selector:@selector(drawFrame)];\n[displayLink addToRunLoop:[NSRunLoop currentRunLoop] forMode:NSDefaultRunLoopMode];\n```\n\n在`drawFrame`方法的实现中，读取`displayLink`的`timestamp`属性来获取渲染下一帧的时间戳，可以用来计算下一帧对象的位置。\n\n通常，每次屏幕刷新都会触发`displayLink`对象；该值通常为60Hz，但在不同的设备上有所不同。大多数应用程序不需要每秒更新屏幕60次。我们可以设置`displayLink`的`frameInterval`属性设置为调用该方法之前经过的实际帧数。例如，如果帧间隔设置为3，应用程序则每隔3帧调用一次，或者每秒大约调用20帧（原帧率的三分之一）。\n\n> 为了最佳效果，渲染一个应用程序可以始终实现的帧率。\n\n### 渲染帧\n\n下图展示了OpenGL ES应用程序渲染和呈现帧的步骤，这些步骤包括很多提示以提高应用程序的性能。\n\n![iOS OpenGL Rendering Steps](/img/article/20190519/7.png)\n\n#### 清空缓冲区\n\n在每一帧开始前，删除所有帧缓冲区附加的下一帧不需要使用的内容。调用`glClear`方法，传递一个位掩码清除所有缓冲区：\n\n``` objectivec\nglBindFramebuffer(GL_FRAMEBUFFER, framebuffer);\nglClear(GL_DEPTH_BUFFER_BIT | GL_COLOR_BUFFER_BIT);\n```\n\n使用`glClear`提示OpenGL ES可以丢弃渲染缓冲区或纹理的现有内容，从而避免将先前内容加载到内存中的昂贵内存。\n\n#### 准备资源并执行绘图命令\n\n这两个步骤包含了设计应用程序架构时所做的大多数关键决策。首先，决定我们想要展示给用户的内容并配置相应的OpenGL ES对象上传到GPU（如顶点缓冲对象，纹理，着色器程序及其输入变量）。下一步，提交绘图命令告诉GPU如何使用这些资源渲染帧。\n\n渲染器设计的更多细节见[OpenGL ES Design Guidelines](#opengl-es-design-guidelines)。目前，最需要注意的最重要的性能优化是，如果只在渲染新帧时修改OpenGL ES对象应用程序运行的更快。虽然应用程序可以在修改对象和提交绘图命令中间进行切换，但如果每帧只执行一个步骤会运行地更快。\n\n#### 执行绘图命令\n\n这一步获取我们上一步准备的对象并提交绘图命令使用它们。设计渲染代码这一部分以高效运行的更多细节见[OpenGL ES Design Guidelines](#opengl-es-design-guidelines)。目前，最需要注意的最重要的性能优化是，如果只在渲染新帧时修改OpenGL ES对象应用程序运行的更快。虽然应用程序可以在修改对象和提交绘图命令中间进行切换，但如果每帧只执行一个步骤会运行地更快。\n\n#### 解决多重采样\n\n如果应用程序使用反锯齿提高图形质量，需要在呈现给用户之前解析像素。更多细节见[使用多重采样提高图片质量](#使用多重采样提高图片质量)。\n\n#### 丢弃不需要的渲染帧缓冲区\n\n丢弃操作是一个性能提示，告诉OpenGL ES一个或多个渲染缓冲区的内容不再需要。通过提示OpenGL ES我们不需要一个渲染缓冲区的内容，缓冲区里的数据被丢弃，可以避免缓冲区更新的复杂任务。\n\n在渲染循环的这个阶段，应用程序已经提交了所有的绘图命令。虽然应用程序需要颜色渲染缓冲区来显示在屏幕上，但可能不需要深度缓冲区的内容。\n\n``` objectivec\nconst GLenum discards = {GL_DEPTH_ATTACHMENT};\nglBindFramebuffer(GL_FRAMEBUFFER, framebuffer);\nglDiscardFramebufferEXT(GL_FRAMEBUFFER, 1, discards)\n```\n\n> `glDiscardFramebufferEXT`方法由OpengGL ES1.0和2.0的`EXT_discard_framebuffer`扩展提供。在OpenGL ES 3.0上下文中，使用`glInvalidateFramebuffer`方法。\n\n#### 呈现结果到Core Animation\n\n在这个步骤，颜色渲染缓冲区持有完成帧，所以我们需要做的就是呈现给用户。下面代码将renderbuffer绑定到上下文并呈现。这使得完成帧被交到Core Animation。\n\n``` objectivec\nglBindRenderbuffer(GL_RENDERBUFFER, colorRenderbuffer);\n[context presentRenderbuffer: GL_RENDERBUFFER];\n```\n\n默认情况下，我们必须保证应用程序呈现完渲染缓冲区后内容被丢弃。这意味着每次呈现帧时，当渲染新帧时必须完整重新创建帧内容，由于这个原因，上述的代码总是擦除颜色缓冲区。\n\n如果应用程序想要在帧之间保存颜色缓冲区的内容，那么在`CAEAGLLayer`对象的`drawableProperties`属性字典添加`kEAGLDrawablePropertyRetainedBacking`键为`YES`，同时在`glClear`方法调用中移除`GL_COLOR_BUFFER_BIT`常量。保留备份可能需要iOS分配额外的内存来存储缓冲区内容，可能会降低应用程序的性能。\n\n## 使用多重采样提高图片质量\n\n多重采样是反锯齿的一种形式，平滑锯齿边缘，提高大多数3D应用的图像质量。OpenGL ES 3.0将多重采样作为核心规范的一部分，OpenGL ES 1.0和2.0合一通过`APPLE_framebuffer_multisample`扩展提供。多重采样使用更多的内存和片段处理时间来渲染图片，但相比其他方法使用更低的性能成本提高图像质量。\n\n下图展示了多重采样的工作原理。应用程序不是创建一个帧缓冲区，而是两个。多重采样缓冲区包含所有必要的渲染内容关联（通常是颜色和深度缓冲区），解析缓冲区只包含必要的展示渲染图片给用户的关联（通常是颜色渲染缓冲区，但可能是纹理）。多重采样渲染缓冲器使用和解析渲染缓冲器相同的维度分配内存，但每个维度都包含一个指定每个像素存储的样本数量的额外参数。应用程序将所有的渲染都执行到多重采样缓冲区，然后将这些样本解析到解析缓冲器中生成最终反锯齿图像。\n\n![How multisampling](/img/article/20190519/8.png)\n\n下面代码展示了多重采样缓冲区的创建，使用之前创建缓冲器的宽高。通过调用`glRenderbufferStorageMultisampleAPPLE`方法创建渲染缓冲器的多重采样存储；\n\n``` objectivec\nGLuint sampleFramebuffer;\nglGenFramebuffers(1, &sampleFramebuffer);\nglBindFramebuffer(GL_FRAMEBUFFER, sampleFramebuffer);\n\nGLuint sampleColorRenderbuffer;\nglGenRenderbuffers(1, &sampleColorRenderbuffer);\nglBindRenderbuffer(GL_RENDERBUFFER, sampleColorRenderbuffer);\nglRenderbufferStorageMultisample(GL_RENDERBUFFER, 4, GL_RGBA8_OES, width, height);\nglFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_RENDERBUFFER, sampleColorRenderbuffer);\n\nGLuint sampleDepthRenderbuffer;\nglGenRenderbuffers(1, &sampleDepthRenderbuffer);\nglBindRenderbuffer(GL_RENDERBUFFER, sampleDepthRenderbuffer);\nglRenderbufferStorageMultisample(GL_RENDERBUFFER, 4, GL_DEPTH_COMPONENT16, width, height);\nglFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, sampleDepthRenderbuffer);\n\nif (glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE) {\n    NSLog(@\"Failed to make complete framebuffer object %x\", glCheckFramebufferStatus(GL_FRAMEBUFFER));\n}\n```\n\n下面是一些基于多重采样的修改之后的渲染代码：\n1. 在清除缓冲区步骤，需要同时清除多重采样帧缓冲区内容：\n\n``` obejctivec\nglBindFramebuffer(GL_FRAMEBUFFER, sampleFramebuffer);\nglViewport(0, 0, framebufferWidth, framebufferHeight);  // 选取绘图区域\nglClear(GL_COLOR_BUFFER_BIT, GL_DEPTH_BUFFER_BIT);\n```\n\n2. 在提交绘图命令后，需要将内容从多重缓冲区解析到解析缓冲区。每像素存储的样本将合并到解析缓冲区的单个样本中：\n\n``` objectivec\nglBindFramebuffer(GL_DRAW_FRAMEBUFFER_APPLE, resolveFramebuffer);\nglBindFramebuffer(GL_READ_FRAMEBUFFER_APPLE, smapleFramebuffer);\nglResolveMultisampleFramebufferAPPLE();\n```\n\n3. 在丢弃步骤，我们可以丢弃多重采样帧缓冲区关联的两个渲染缓冲区，这是因为预计呈现的内容以及存储到解析帧缓冲区内：\n\n``` objectivec\nconst GLenum discards[] = {GL_COLOR_ATTACHMENT0, GL_DEPTH_ATTACHMENT};\nglDiscardFramebufferEXT(GL_READ_FRAMEBUFFER_APPLE, 2, discards);\n```\n\n4. 在呈现结果步骤，呈现关联到解析帧缓冲区的颜色渲染缓冲区：\n\n``` objectivec\nglBindRenderBuffer(GL_RENDERBUFFER, colorRenderbuffer);\n[context presentRenderbuffer: GL_RENDERBUFFER];\n```\n\n多重采样并不是免费的；存储额外样本的内存消耗，解析样本到解析帧缓冲区的时耗。如果我们想要添加多重采样到应用中，必须多测试性能以确保它可接受。\n\n> 上述代码基于OpenGL ES 1.0与2.0，多重采样位于OpenGL ES 3.0的核心API，使用不同的方法。\n\n# Multitasking, High Resolution, and Other iOS Features\n\n使用OpenGL ES的许多方面都是平台中立，但是在iOS上使用有一些细节需要特别考虑。特别是，iOS应用使用OpenGL ES正确处理多任务或进入后台有被终止的风险。在iOS设备开发OpenGL ES内容时，我们应该考虑现实分辨率和其他设备的特性。\n\n## 实现一个多任务感知的OpenGL ES应用程序\n\n应用程序在用户切换到其他程序时可以继续运行。更多多任务讨论见[App States and Multitasking](https://developer.apple.com/library/archive/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/BackgroundExecution/BackgroundExecution.html#//apple_ref/doc/uid/TP40007072-CH4)\n\n使用OpenGL ES的应用程序在切入后台时必须执行更多的工作，如果多任务处理不当，那应用可能会崩溃，同样，一个应用程序可能想要释放OpenGL ES资源这样就只适用于前台工作。\n\n### 后台应用程序可能无法在图像硬件上执行命令\n\n如果OpenGL ES应用程序视图在图像硬件上执行OpenGL ES命令可能会崩溃。iOS阻止后台应用程序访问图像处理器，因此最前端的应用程序总是能给用户提供更好的体验。应用程序崩溃不止在后台调用OpenGL ES，还会在进入后台时之前提交的命令刷新到GPU。所以我们必须保证所有之前提交的命令在进入后台前都执行完毕。\n\n如果使用GLKit视图和控制器，只在绘图方法中提交OpenGL ES命令，应用程序会自动在进入后台时正确运行。默认情况下，在应用程序处于非活动时`GLKViewController`类暂停其动画计时器，确保绘图方法不被调用。\n\n如果不适用GLKit视图或者控制器或者在GLKView绘图方法之外提交OpenGL ES命令，我们必须采用以下步骤保证程序在后台不崩溃：\n1. 在`applicationWillResignActive:`方法中，需要停止动画计时器，将自己置于一个已知的良好状态，并调用`glFinish`方法；\n2. 在`applicationDidEnterBackground:`方法中，应用程序可能想要删除一些OpenGL ES对象使内存和资源对于前台应用程序可。调用`glFinish`方法确保立即删除资源；\n3. 在`applicationDidEnterBackground:`方法中，确保没有OpenGL ES的调用，如果有任何调用就会导致崩溃；\n4. 在`applicationWillEnterForeground:`方法中，重新创建对象和启动动画计时器。\n\n总而言之，需要调用`glFinish`方法保证所有之前提交的命令都从命令缓存中取出并被OpenGL ES执行。在进入后台后，在进入前台之前必须避免使用OpenGL ES。\n\n### 在进入后台前删除容易重新创建的资源\n\n在应用程序进入后台时从来不需要释放OpenGL ES对象，通常情况，我们应该避免处理它的内容。考虑两种情况：\n- 应用正在玩游戏并短暂切出去检查日历，当用户返回游戏，游戏的资源仍然在内存中并可以直接继续游戏；\n- 当用户启动另一个OpenGL ES应用程序，如果需要更多的资源那么系统会自动终止后台的OpenGL ES应用程序让它不执行任何额外的工作。\n\n我们的目标应该是把应用程序设计成一个良好公民：这意味着移动到前台的时间尽可能短，同时减少他在后台的内存占用。\n\n下面是我们应该处理的两种情况：\n- 应用程序应该保证纹理，模型和其他资源在内存中；当应用进入后台时，需要长时间重新创建的资源不应该被处理掉；\n- 应用程序应该处理可以快速易创建的对象，寻找消耗巨大内存的对象。\n\n简单的目标是应用程序分配内存持有渲染结果的帧缓冲区，当应用程序在后台时，它对用户是不可见的并可能不会使用OpenGL ES渲染任何新内容。这意味着应用程序的帧缓冲区分配了大量内存但并没有用。同样，帧缓冲区的内容是临时的，大多数应用程序在每次渲染新帧时都会重新创建帧缓冲区的内容。这是用渲染缓冲区成为一个内存密集型资源，可以很容易创建，成为移动到后台时可以处理的候选对象。\n\n如果我们使用GLKit视图和控制器，`GLKViewController`类自动在进入后台时处理关联的视图帧缓冲区。如果我们为其他用途手动创建了帧缓冲区，那在进入后台时应该处理他们。在这两种情况下，我们应该考虑应用程序当时可以处理哪些其他临时资源。\n\n## 支持高分辨率显示\n\n默认情况下，GLKit视图的`contentScaleFactor`属性和包含它屏幕的比例相匹配，因此将其关联的帧缓冲区配置以渲染的全分辨率展现。 更多关于UIKit支持的高分辨率展现的内容见[Supporting High-Resolution Screens In Views](https://developer.apple.com/library/archive/documentation/2DDrawing/Conceptual/DrawingPrintingiOS/SupportingHiResScreensInViews/SupportingHiResScreensInViews.html#//apple_ref/doc/uid/TP40010156-CH15)。\n\n如果使用Core Animation层级出现OpenGL ES的内容，它默认的缩放因子为1.0。为了在Retina显示器的全分辨率下绘图，我们应该修改`CAEAGLayer`对象的缩放因子以匹配屏幕的缩放因子。\n\n当支持高分辨率显示器的设备，我们应该相应地跳转应用程序的模型和纹理资源。当高分辨率的设备下运行，我们可能想要渲染更详细的模型和纹理来渲染更好的图像，相反，在标准分辨率设备下，我们可能使用更小的模型和纹理。\n\n> 许多OpenGL ES API调用都用屏幕像素表示维度，如果使用的缩放因子大于1.0，那么在使用`glScissor`、`glBlitFramebuffer`、`glLineWidth`、`glPointSize`函数或`gl_PointSize`着色器变量时，我们需要相应调整维度。\n\n决定如何支持高分辨率显示器的一个重要因素是性能。Retina显示器上的翻倍比例因子使像素的数量变为四倍，这使得GPU处理的碎片数量变为原来的四倍。如果应用程序对每个片段执行多个计算，像素的增加可能会导致帧率降低。如果我们发现应用程序在较高的比例因子下运行速度明显较慢，考虑以下选项之一：\n- 使用性能调优指南优化片段着色器的性能，见[Tuning Your OpenGL ES App](tuning-your-openGL-es-app)；\n- 在片段着色器实现一个更简单的算法，这样做可以降低单个像素的质量，以更高的分辨率渲染整个图像；\n- 使用在1.0到屏幕比例因子之间的比例因子，比例因子为1.5比1.0提供更高的质量，但需要填充填充的像素比比例为2.0的图像更少；\n- 使用较低精度格式的GLKView对象的`drawableColorFormat`和`drawableDepthFormat`属性。这样做可以减少操作底层渲染缓冲区所需的内存带宽；\n- 使用较低的比例因子，启用多重采样。另一个优点是，多重采样同样可以在不知道高分辨率显示器的设备上提供更高的质量。要为GLKView对象启用多重采样，要更改它的`drawableMultisample`属性值。如果不是渲染到GLKit视图上，则必须手动甚至多重采样缓冲区并在最终图形呈现前解析他们，见[使用多重采样提高图片质量](#使用多重采样提高图片质量)。\n\n## 支持多种屏幕旋转\n\n与任意应用程序一样，OpenGL ES应用程序应该支持与其内容相适应的用户界面方向。可以在应用程序的信息属性列表定义支持的屏幕方向或者拥有OpenGL ES内容的控制器使用`supportedInterfaceOrientations`方法。\n\n默认情况下，`GLKViewController`和`GLKView`类自动处理屏幕转向：当用户渲染设备到支持的方向，系统将产生动画旋转屏幕并更改视图控制器视图的大小，当大小改变时，`GLKView`对象相应调整帧缓冲区和绘图窗口的大小。如果需要响应这个更改，在`GLKViewController`的子类中实现`viewWillLayoutSubviews`或`viewDidLayoutSubviews`方法，如果使用自定义的`GLKView`子类则实现`layoutSubviews`。\n\n如果使用Core Animation层级绘制OpenGL ES的内容，应用程序也应该包含一个视图控制器来管理用户界面方向。\n\n## 在外部显示器上显示OpenGL ES内容\n\n一个iOS设备可以被连接到外部显示器，外部显示器的分辨率及其内容缩放因子可能与主屏幕的不同，渲染帧的代码应该调整以匹配。\n\n在外部显示器绘图的过程基本和主屏幕上的相同：\n1. 按照[Multiple Display Programming Guide for iOS](https://developer.apple.com/library/archive/documentation/WindowsViews/Conceptual/WindowAndScreenGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40012555)的步骤在外部显示器创建一个窗口。\n2. 为渲染策略向窗口添加何时的视图或控制器；\n    - 如果使用GLKit渲染，设置`GLKViewController`和`GLKView`（或自定义子类）的实例并用`rootViewController`属性添加到窗口；\n    - 如果渲染到Core Animation层级，添加包含层级的视图作为窗口的子视图。使用动画循环来渲染，通过检索窗口的`screen`属性并调用`dispalyLinkWithTarget:slector:`方法创建一个外部显示器优化的显示链接对象。\n\n# OpenGL ES Design Guidelines\n\n现在我们已经掌握了在iOS应用中使用OpenGL ES的基础，使用这章下的信息帮助我们设计更优性能的渲染引擎。这一章节介绍了渲染器设计的关键概念；后面的内容将用特定的最佳实践和性能技术对这些信息扩展。\n\n## 如何可视化OpenGL ES\n\n本节描述了可视化OpenGL ES设计的两个方面：作为客户端-服务器架构和作为管线。这两方面在计划和评估应用程序的体系结构都非常有用。\n\n### OpenGL ES作为客户端-服务器架构\n\n应用程序与OpenGL ES客户端通信状态改变、纹理和顶点数据、渲染命令。客户端将这些数据转换成图形硬件理解的格式，并发送到GPU，这些进程会增加应用程序图形性能的开销。\n\n![OpenGL ES client-server architecture](/img/article/20190519/9.png)\n\n要获得出色的性能需要小心管理这些开销。一个优秀设计的应用程序减少对OpenGL ES的调用频率，使用硬件合适的数据格式来降低转换成本，并小心管理和OpenGL ES之间的数据流。\n\n### OpenGL ES作为图形管线\n\n应用程序配置图形管线，然后执行绘图命令将顶点数据发送到管线中。管线的后续阶段运行顶点着色器处理顶点数据，将顶点数据组装成基本类型，将基本类型光栅化为片段，运行片段着色器来计算每个片段的颜色和深度值，并将片段混合到帧缓冲区显示。\n\n![OpenGL ES graphics pipline](/img/article/20190519/10.png)\n\n使用管线作为一个心理模型来识别应用程序执行什么工作来生成一个新帧。我们的渲染器设计包含编写着色器程序处理管线的顶点和片段阶段，组织提供给这些程序的顶点和纹理数据，以及配置OpenGL ES状态机来驱动管线的固定功能的阶段。\n\n图形管线的各个阶段可以同时计算它们的结果--例如，应用程序可能准备了新的基础类型而图形硬件的各个部分还在对之前提交的几何图形执行顶点和片段计算，但是，后期阶段取决于先前阶段的输出，所以如果任何管道阶段执行过多任务或运行太慢，其他管线阶段将处于空闲状态知道最慢的完成工作。一个优秀设计的应用程序应可以根据图形硬件功能平衡每个管道阶段的工作。\n\n> 所以当我们调整应用程序性能时，第一步通常确定它处于哪个位置，以及会遇到哪些瓶颈。\n\n## OpenGL ES版本和渲染器架构\n\niOS支持3中OpenGL ES版本。最新版本提供更多的灵活，允许我们自主实现渲染包含高质量视觉效果而不影响性能的算法。\n\n### OpenGL ES 3.0\n\nOpenGL ES 3.0是iOS 7之后的新版本。应用程序可以使用OpenGL ES 3.0中引入的特性来实现高级的图形编程技术（以前只能用于桌面级硬件和游戏控制台）从而获得更快的图形性能和引人注目的视觉效果。更多见[OpenGL ES API Registry](http://www.khronos.org/registry/OpenGL/index_es.php)。\n[OpenGL ES 3.0](https://developer.apple.com/library/archive/documentation/3DDrawing/Conceptual/OpenGLES_ProgrammingGuide/OpenGLESApplicationDesign/OpenGLESApplicationDesign.html#//apple_ref/doc/uid/TP40008793-CH6-SW13)\n### OpenGL ES 2.0\n### OpenGL ES 1.0\n\n## 设计高性能的OpenGL ES应用程序\n\n总结下，一个优秀设计的OpenGL ES应用程序需要：\n- 利用OpenGL ES管线中的并行性\n- 管理应用程序和图形硬件之间的数据流\n\n下图展示了一个使用OpenGL ES执行动画显示的应用程序流程：\n\n![App model for managing resources](/img/article/20190519/11.png)\n\n当应用程序启动时，要做的第一件事是初始化不打算在生命周期中更改的资源。理想情况下，应用程序将这些资源封装到OpenGL ES的对象中，目标是创建任何在应用程序运行期间保持不变的对象（甚至是应用程序生命周期的一部分，如游戏关卡的持续时间），以增加的初始化时间交换更好的渲染性能。复杂的命令或状态改变应该替换为能与单个函数调用一起使用的OpenGLES对象，比如，配置固定函数管线可能需要几十个函数调用。相反，在初始化阶段编译一个图形着色器，并在运行时通过一个函数调用切换到它。创建或者修改开销较大的OpenGL ES对象应该总是作为静态对象创建。\n\n渲染循环处理我们打算渲染给OpenGL ES上下文的所有项，然后将结果呈现给显示器。在动画场景中，一些数据每一帧都在更新，在上图所示的内部渲染循环中，应用程序在更新渲染资源（在进程中创建或修改OpenGL ES对象）和提交这些资源的绘图命令之间切换。这个内部循环的目标是平衡工作负载让CPU和GPU并行工作，防止应用程序和OpenGL ES同时使用相同的资源。在iOS中，如果不在帧的起始或结束时执行修改OpenGL ES对象，那么修改的代价会非常高。\n\n这个内部循环的一个重要目标是避免将数据从OpenGL ES拷贝回应用程序，将结果从GPU拷贝到CPU会非常慢。如果拷贝的数据同样用于后续渲染当前帧过程的一部分（如上图的渲染循环中展示的），应用程序会被阻塞知道所有之前提交的绘图命令完成。\n\n在应用程序提交帧所需要的所有绘图命令，然后将结果呈现到屏幕上。非交互式哟哟欧诺个程序会将最终图片拷贝到应用程序内存中进行下一步处理。\n\n最终，当应用程序准备退出或结束主要工作，将释放OpenGL ES对象获取更多的可用资源。\n\n总结本设计的重要特点：\n- 在任何可能情况下创建静态资源；\n- 内部渲染循环在修改动态资源和提交渲染命令之间切换，尝试避免在帧的起始或结束之外的时间修改动态资源；\n- 避免将中间渲染结果读取回应用程序；\n\n本节后面的部分提供了游泳的变成技术来实现这个渲染循环的特性。\n\n### 避免同步和Flush操作\n\nOpenGL ES规范不要求实现立即执行命令。通常情况，命令被排队到命令缓冲区，后面由硬件执行。OpenGL ES会等到应用程序许多命令在队列中后发送到硬件--批处理更加有效，但是，一些OpenGL ES函数必须立即刷新命令缓冲区，其他函数不仅刷新命令缓冲区，还会阻塞直到之前的命令完成才返回对应用和程序的控制。只有在必要时才使用刷新和同步命令，过度使用刷新或同步命令会导致应用程序等待硬件结束渲染时停止。\n\n下面这些情况需要OpenGL ES将命令缓冲区提交给硬件执行：\n- `glFlush`函数将命令缓冲区提交到图形硬件，它会阻塞到命令被提交到硬件但不用等到命令执行结束；\n- `glFinish`函数刷新命令缓冲区，然后等待所有之前提交的命令在图像硬件上执行结束；\n- 检索帧缓冲区内容的函数（如`glReadPixels`）同样要等待提交的命令完成；\n- 命令缓冲区已满；\n\n#### 有效利用glFlush\n\n在一些桌面OpenGL的实现中，定期调用`glFlush`函数可以有效平衡CPU和GPU的工作，但在iOS中并非如此。iOS图像硬件实现的延迟算法依赖于一次性缓存所有场景中的顶点数据，因此可以对其进行最有处理，去除隐藏表面。通常，OpenGL ES应用程序只有两种情况下调用`glFlush`或`glFinish`函数：\n- 应用程序在进入后台时需要刷新命令缓冲区，因为应用程序在后台时执行OpenGL ES命令会导致iOS崩溃；\n- 如果应用程序在多个上下文共享OpenGL ES对象（如顶点缓存或纹理），我们需要调用`glFlush`函数同步使用这些资源。例如，在一个上下文加载顶点数据之后调用`glFlush`函数，以确保内容准备被其他上下文检索。当与其他iOS APIs（如Core Image）共用OpenGL ES对象时也可以使用这个建议；\n\n#### 避免查询OpenGL ES状态\n\n调用`glGet*()`，包括`glGetError()`，可能需要OpenGL ES在检索任何状态变量之前执行之前的命令。这种同步会强迫图形硬件和CPU同步运行，减少了并行性的机会。为了避免这种情况，维护自己需要查询任意状态的副本，直接访问它而不是调用OpenGL ES。\n\n当错误发生时，OpenGL ES设置一个错误标识。这些错误和其他错误出现在的Xcode或OpenGL ES分析器的帧调试器中。应该使用这些工具而不是使用`glGetError`函数，如果频繁调用会降低性能。其他查询（例如`glCheckFramebufferStatus()`，`glGetProgramInfoLog()`，`glValidateProgram()`）通常也只在开发和调试中有用。\n\n### 使用OpenGL ES管理资源\n\n许多OpenGL数据可以直接存储到OpenGL ES渲染上下文和与之关联的共享组中。OpenGL ES的实现可以自由将数据转换为适合图形硬件的格式，这可以显著提高性能，特别对于不经常更改的数据。应用程序还可以向OpenGL ES提供如何使用数据的提示，OpenGL ES的实现可以更有效使用这些提示处理数据。例如，静态数据可能被放置在图像处理器可以轻松获取的内存中，甚至可以放置在专用的图形内存中。\n\n### 使用双重缓冲避免资源冲突\n\n当应用程序和OpenGL ES同时访问一个OpenGL ES对象时会发生资源冲突。当一个参与者尝试修改对象而另一个参与者正在使用，他们可能会阻塞直到该对象不再被使用。一旦他们开始修改对象，其他参与者可能在修改完成之前都无法使用。或者，OpenGL ES可以隐式复制对象，以便两个参与者都可以继续执行命令。任何一个选项都是安全的，但是每个都有可能成为应用程序的瓶颈。下图展示了这个问题，在这个例子中，只有一个纹理对象，OpenGL ES和应用程序都想使用它，当应用程序尝试修改纹理，它必须等待之前提交的绘图命令完成--CPU和GPU同步。\n\n![Single-buffered texture data](/img/article/20190519/12.png)\n\n为了解决这个问题，应用程序可以在修改和绘制该对象之间执行额外的工作。但是，如果应用程序没有额外的工作可以执行，它应该显示创建两个大小相同的对象；一个参与者读取对象，另一个参与者修改另一个。下图展示了双缓冲方法，当GPU处理一个纹理时，CPU修改另一个。在初始化启动之后，CPU和GPU都不会处于空闲状态。虽然显示了纹理，这个解决方案几乎适用于任何类型的OpenGL ES对象。\n\n![Double-buffered texture data](/img/article/20190519/13.png)\n\n对于大多数应用程序双缓冲区已经足够，但它要求两个参与者几乎同时完成处理命令。为了避免阻塞，可以添加更多的缓冲区；这实现了传统的生产者-消费者模型。如果生产者在消费者之前完成处理命令，它将接受一个空闲缓冲区并继续处理命令。在这种情况下，只有消费者严重落后，生产者才会停止生产。\n\n双缓冲区和三缓冲区需要消耗额外的内存以防止管道停滞，额外使用内存可能会对应用程序的其他部分造成压力。在iOS设备中，内存稀缺；所以设计必须和其他应用程序优化平衡以使用更多的内存。\n\n### 注意OpenGL ES的状态\n\nOpenGL ES的实现维护了一份复杂的状态数据，包括使用`glEnable`或`glDisable`函数设置的开关、当前着色器程序以及其统一变量、当前绑定的纹理图元、当前绑定的顶点缓存及其启用的顶点属性。硬件有一个当前状态，它被缓存并懒加载。切换状态是昂贵的，所以最好减少状态切换。\n\n不要设置以及设置的状态。一旦启用某个特性就不用再启用。比如，如果多次调用相同参数的`glUniform`函数，OpenGL ES可能不会检查已经设置的相同的状态，它只是简单的更新状态值，即使值相同。\n\n避免使用专用的设置或关闭过程设置不必要的状态，而不是将这类调用放入绘图循环。设置和关闭过程对于开启关闭实现特定视觉效果的特性很有用--例如，当绘制线框轮廓线围绕有纹理的多边形时。\n\n#### 使用OpenGL ES对象封装状态\n\n要减少状态更改，创建一个对象，将多个OpenGL ES状态更改收集到一个对象，该对象可以使用一个函数绑定。例如，顶点数组对象将多个顶点属性的配置存储到一个对象中。见[使用顶点数组对象合并顶点数组状态更改](使用顶点数组对象合并顶点数组状态更改)。\n\n#### 组织绘图调用最小化状态更改\n\nOpenGL ES的状态更改的效果没有立即生成。相反，当我们发出绘图指令时，OpenGL ES将执行绘制状态值所需的工作。通过减少状态更改，我们可以减少CPU用于配置图形管线的时间。例如，在应用程序中保留一个状态向量，并且只有在绘制调用之间的状态发生时才设置相应的OpenGL ES状态。另一个有用的算法是状态排序--跟踪我们需要做的绘图操作和每个操作所需的状态更改量，然后对它们排序，以便连续使用相同的状态执行操作。\n\nOpenGL ES的iOS实现可以缓存它在状态之间高效切换所需的一些配置数据，但每个唯一状态集的初始配置需要更长的时间。为了保持一致的性能，我们可以在配置过程中“预热”计划使用的每个状态：\n- 启用计划使用的状态配置或着色器；\n- 使用状态配置绘制少量顶点；\n- 刷新OpenGL ES上下文，以便在预热阶段不显示绘图；\n\n# Best Practices for Working with Vertex Data\n\n要使用OpenGL ES渲染帧，应用程序需要配置图形管线并提交要绘制的图形图元。在一些应用中，所有的图元都是使用同样的管线配置绘制；其他应用可能使用不同的技术渲染不同的帧元素。但无论应用程序使用的哪个图元，管线如何配置，应用程序都需要向OpenGL ES提供顶点。本章提供了一个关于顶点的课程并就如何有效处理顶点数据提供了针对性的建议。\n\n顶点由一个或多个属性组成，例如位置、颜色、法线或纹理坐标。OpenGL ES 2.0或3.0应用程序可以自由定义自己的属性；顶点数据的每个属性对应于作为顶点着色器的属性变量。OpenGL ES 1.1的应用程序使用固定管线定义好的属性。\n\n将一个属性定义为由一到四个组件构成的向量，属性中的所有组件共享一个公共数据类型。例如，一个颜色可能被定义为四个`GLubyte`组件（r,g,b,a）。当一个属性被加载到着色器变量中时，OpenGL ES使用默认值填充所有应用程序未提供的组件数据。最后一个组件被填充为1，其他未指定组件为0，如下图所示：\n\n![Conversion of attribute data to shader variables](/img/article/20190519/14.png)\n\n应用程序可能将一个属性配置为常量，这意味着对于作为绘图命令部分提交的所有顶点使用相同的值，又意味着每个顶点都是该属性的值。当应用程序调用OpenGL ES的函数绘制一组顶点时，顶点数据被拷贝到图形硬件。处理顶点数据的图形硬件，在着色器处理每个顶点，组装图元并将它们光栅化到帧缓冲区。OpenGL ES的一个优点在于将提交到OpenGL ES顶点数据的一组函数标准化，移除OpenGL ES提供的陈旧和低效的机制。\n\n应用程序必须提交大量图元来渲染一帧，需要小心管理它们的顶点数据和如何提交到OpenGL ES。本章所述的做法可以概括为以下几个基本原则：\n- 减少顶点数据的大小；\n- 减少OpenGL ES将顶点数据传输到图形硬件之前的预处理；\n- 减少拷贝顶点数据到图形硬件花费的时间；\n- 减少对每个顶点的计算；\n\n## 简化模型\n\n基于iOS设备的图形硬件很强大，但它显示的图片一般很小。我们不需要非常复杂的模型在iOS上呈现引人注目的图形。减少用于绘制模型的顶点数量可以直接减少顶点的数据和对顶点数据执行的计算。\n\n我们可以使用以下技术降低模型的复杂度：\n\n- 在不同细节级别提供不同版本的模型，并在运行时基于到摄像机的距离和显示的尺寸渲染合适的模型；\n- 使用纹理来消除对某些顶点信息的需要。例如，凹凸贴图可以用来在不添加更多顶点数据的情况下向模型添加细节；\n- 一些模型添加顶点改进光照细节或渲染质量。这通常是在计算每个顶点的值并在光栅化阶段对三角形进行插值完成的。例如，如果我们将聚光灯指向三角形的中心，它的效果可能被忽略，因为聚光灯醉了的部分不是指向一个顶点。通过添加顶点，我们可以额外提供插值点，代价是增加顶点数据的大小和模型上执行的计算。如果不想要添加额外的顶点，考虑将计算移动到管线的片段阶段：\n    + 如果应用程序使用OpenGL ES 2.0或之后的版本，应用程序在顶点着色器执行计算并将其分配给一个可变变量。变化的值由图形硬件插值并作为输入传递到片段着色器。相反，将计算的输入分配给变量并在片段着色器执行计算。这样做会将执行计算的成本从每个顶点的成本到每个片段的成本，从而减少顶点阶段的压力并增加管线片段阶段的压力。当应用程序在顶点处理时被阻塞，这样做，计算是相对廉价的并可以通过更改显著减少顶点数。\n    + 如果应用程序使用OpenGL ES 1.1，我们可以使用DOT3照明来执行各个片段的光照。我们可以通过添加凹凸贴图纹理来保存正常信息，并使用`GL_DOT3_RGB`模式的纹理组合操作应用凹凸贴图。\n\n## 避免在属性数组中存储常量\n\n如果模型中包含在这个模型中使用保持不变的数据的属性，则不要为每个顶点复制该数据。OpenGL ES 2.0和3.0应用程序可以设置一个常量顶点属性或使用一个统一的着色器值来保存该值。OpenGL ES 1.1应用程序应该使用每个顶点的属性函数，如`glColor4ub`或`glTexCoord2f`。\n\n> 待更新...\n\n# Reference\n\n> [About OpenGL ES](https://developer.apple.com/library/archive/documentation/3DDrawing/Conceptual/OpenGLES_ProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008793-CH1-SW1)","slug":"2019/opengl-es-study-0519","published":1,"updated":"2022-01-10T09:04:52.808Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cky8gmc4v001yd1qh8ycodj4y","content":"<h1 id=\"introduction\">Introduction</h1>\n<p>Open Graphics Library(OpenGL)用于可视化2D与3D数据，是多用途的开放标准图形库，支持2D和3D数字内容创建、机械和建筑设计、虚拟原型、飞行仿真、视频游戏等等。我们可以使用OpenGL配置3D图形管线并向其提交数据。顶点被转换点亮，组装成基本类型，并进行栅格化来创建2D图片。OpenGL的设计目的是将函数调用转换为可以发送到底层图形硬件的图形命令，因为底层硬件专门处理图形命令，所以OpenGL的绘图非常快。</p>\n<p>OpenGL for Embedded Systems(OpenGL ES)是openGL的简化版，消除冗余功能，为移动图形硬件上提供一个更容易学习和实现的库。</p>\n<p><img src=\"/img/article/20190519/1.png\" alt=\"OpenGL ES\"></p>\n<p>OpenGL ES允许应用程序利用底层图形处理器的能力，iOS设备上的GPU可以实现复杂的2D和3D绘图，以及图片上每个像素阴影的复杂计算。如果应用程序的而设计要求需要对GPU硬件有直接全面的访问，那么我们应该使用OpenGL ES。OpenGL ES典型的客户端包括视频游戏和呈现3D图形的模拟器。</p>\n<h1 id=\"checklist-for-building-opengl-es-apps-for-ios\">Checklist for Building OpenGL ES Apps for iOS</h1>\n<p>OpenGL ES为使用GPU硬件渲染图形规范定义了无关平台的API。实现OpenGL ES的平台提供了一个用于执行OpenGL ES命令的渲染上下文，持有渲染结果的帧缓冲区，一个或多个展示帧缓冲区内容的渲染目标。iOS中，<em>EAGLContext</em>实现了渲染上下文，iOS只提供了一种帧缓冲区类型，OpenGL ES帧缓冲区对象，和实现渲染地点的<em>GLKView</em>、<em>CAEAGLLayer</em>。</p>\n<p>在iOS中创建OpenGL ES应用需要有以下考虑，一些对于OpenGL ES编程通用的，还有一些是iOS特定的考虑：</p>\n<ol>\n<li>决定适用于我们应用的OpenGL ES版本，创建上下文；</li>\n<li>在运行时检测设备是否支持我们想要使用的OpenGL ES功能；</li>\n<li>选择渲染OpenGL ES内容的位置；</li>\n<li>确定应用在iOS中正确运行；</li>\n<li>实现渲染引擎；</li>\n<li>使用Xcode和Instruments调试OpenGL ES应用，调优以获取最优性能；</li>\n</ol>\n<h2 id=\"选择opengl-es版本\">选择OpenGL ES版本</h2>\n<p>决定应用需要支持OpenGL ES 3.0，OpenGL ES 2.0，OpenGL ES 1.1还是多个版本：</p>\n<ul>\n<li>OpenGL ES 3.0是在iOS 7的新版本，增加了许多新特性，实现高性能、通用GPU计算技术和之前只能在台式机和游戏机上才能实现的更复杂视觉效果</li>\n<li>OpenGL ES 2.0是iOS设备的基础配置，具有基于可编程着色器的可配置图形管线</li>\n<li>OpenGL ES 1.1仅提供基本的固定函数的图形通道，在iOS中主要用于向后兼容</li>\n</ul>\n<p>我们应该针对最相关的特性和应用程序的设备选择一个或多个版本，关于iOS设备功能更多可见<a href=\"https://developer.apple.com/library/archive/documentation/DeviceInformation/Reference/iOSDeviceCompatibility/Introduction/Introduction.html#//apple_ref/doc/uid/TP40013599\" target=\"_blank\" rel=\"noopener\">iOS Device Compatibility Reference</a></p>\n<h2 id=\"验证opengl-es功能\">验证OpenGL ES功能</h2>\n<p><a href=\"https://developer.apple.com/library/archive/documentation/DeviceInformation/Reference/iOSDeviceCompatibility/Introduction/Introduction.html#//apple_ref/doc/uid/TP40013599\" target=\"_blank\" rel=\"noopener\">iOS Device Compatibility Reference</a>总结了在已发布iOS设备中可用的功能和扩展，但是，为了让应用程序能够在尽可能多的设备和iOS版本上运行，我们应该始终在运行时查询OpenGL ES可以实现的功能。</p>\n<p>要确定实现的特定限制，比如最大纹理大小或顶点属性的最大数量，使用相应的<code>glGet</code>方法查找对应的值（如在<em>gl.h</em>文件查找<em>MAX_TEXTURE_SIZE</em>或<em>MAX_VERTEX_ATTRIBS</em>）。</p>\n<p>使用<code>glGetIntegerv</code>和<code>glGetStringi</code>方法检测OpenGL ES 3.0的扩展：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// #import &lt;OpenGLES/ES3/gl.h&gt;</span></span><br><span class=\"line\"><span class=\"built_in\">BOOL</span> CheckForExtensions(<span class=\"built_in\">NSString</span> *searchName) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> max = <span class=\"number\">0</span>;</span><br><span class=\"line\">    glGetIntegerv(GL_NUM_EXTENSIONS, &amp;max);</span><br><span class=\"line\">    <span class=\"built_in\">NSMutableSet</span> *extensions = [<span class=\"built_in\">NSMutableSet</span> set];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; max; i++) &#123;</span><br><span class=\"line\">        [extensions addObject:@((<span class=\"keyword\">char</span> *)glGetStringi(GL_EXTENSIONS, i))];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [extensions containsObject:searchName];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/// 对于OpenGL ES 2.0和1.1的扩展，使用glGetString(GL_EXTENSIONS)获取以空格分隔的所有扩展名</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"选择渲染位置\">选择渲染位置</h2>\n<p>iOS中，帧缓冲区对象存储了绘图命令的结果，我们可以通过以下多种方式使用帧缓冲区对象的内容：</p>\n<ul>\n<li><em>GLKit</em>框架提供了绘制OpenGL ES内容和管理自身帧缓冲区的view，和支持动画的控制器。使用这些类创建全屏视图或将OpenGL ES内容放入UIKit视图层次结构中。<a href=\"#drawing-with-opengl-es-and-glkit\">Drawing with OpenGL ES and GLKit</a></li>\n<li><em>CAEAGLLayer</em>类提供绘制OpenGL ES内容作为Core Animation层级组合一部分的方法，但我们必须使用这个类创建自己的帧缓冲区</li>\n<li>与任意OpenGL ES实现一样，我们也可以使用帧缓冲区进行离屏图形处理或渲染图像管线其他地方使用的纹理。在OpenGL ES中，离屏缓冲区可以用于使用多个渲染目标的渲染算法</li>\n</ul>\n<p>更多关于离屏缓冲区、纹理、Core Animation层级的渲染，前往<a href=\"#drawing-to-other-rendering-destinations\">Drawing to Other Rendering Destinatons</a></p>\n<h2 id=\"ios集成\">iOS集成</h2>\n<p>iOS应用默认支持多任务，但在OpenGL ES应用内处理这个特性需要额外考虑，不正确使用OpenGL ES会导致应用在后台被系统杀死。</p>\n<p>许多iOS设备包含高分辨率显示，所以我们需要支持多种显示尺寸和分辨率。</p>\n<p>了解如何支持这些和其他iOS特性，前往<a href=\"#multitasking,-high-resolution,-and-other-ios-features\">Multitasking, High Resolution, and Other iOS Features</a>。</p>\n<h2 id=\"实现渲染引擎\">实现渲染引擎</h2>\n<p>设计OpenGL ES绘图代码有许多可能的策略，其详细信息超出了文本的范围。渲染引擎设计的许多方面对于OpenGL和OpenGL ES的所有实现都是通用的。</p>\n<p>更多iOS设备设计考虑前往<a href=\"#opengl-es-design-guidelines\">OpenGL ES Design Guidelines</a>和<a href=\"#concurrency-and-opengl-es\">Concurrency and OpenGL ES</a>。</p>\n<h2 id=\"调试与性能分析\">调试与性能分析</h2>\n<p>Xcode和Instruments提供了许多工具来跟踪渲染问题并分析OpenGL ES的性能，前往<a href=\"#debugging-and-profiling\">Debugging and Profiling</a>。</p>\n<h1 id=\"configuring-opengl-es-contexts\">Configuring OpenGL ES Contexts</h1>\n<p>每个OpenGL ES的实现提供了创建管理OpenGL ES规范所需要状态的渲染上下文的方法，通过在上下文的状态，多个应用可以轻松地共享图形硬件而不会干扰其他应用程序的状态。</p>\n<p>在我们使用OpenGL ES方法前，必须初始化<em>EAGLContext</em>对象，<em>EAGLContext</em>类还提供将OpenGL ES内容与Core Animation集成的方法。</p>\n<h2 id=\"当前上下文是opengl-es函数调用的目标\">当前上下文是OpenGL ES函数调用的目标</h2>\n<p>iOS应用每个线程都有一个当前上下文，当我们调用OpenGL ES的方法时，这个就是状态要被更改的上下文。</p>\n<p>设置当前线程上下文，在对应线程调用<code>setCurrentContext:</code>方法：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[EAGLContext setCurrentContext:context];</span><br></pre></td></tr></table></figure>\n<p>调用<em>EAGLContext</em>类方法<code>currentContext</code>来检索当前线程的上下文。</p>\n<blockquote>\n<p>如果在相同线程切换两种或以上上下文，在设置新的当前上下文之前调用<code>glFlush</code>方法确保之前提交的命令能及时交付给图形硬件。</p>\n</blockquote>\n<p>OpenGL ES对当前上下文<em>EAGLContext</em>对象持有强引用，当调用<code>setCurrentContext:</code>方法切换上下文则不会对之前的对象强持有，为了防止<em>EAGLContext</em>对象在切换时被释放，我们应该对之强引用。</p>\n<h2 id=\"每个上下文都针对opengl-es的特定版本\">每个上下文都针对OpenGL ES的特定版本</h2>\n<p>一个<em>EAGLContext</em>对象仅支持OpenGL ES的一个版本。例如：OpenGL ES 1.1版本下的代码不兼容2.0或3.0版本；使用OpenGL ES 2.0版本特性的版本兼容3.0版本，同时2.0版本的扩展经常可以在3.0版本中少量修改后使用；OpenGL ES 3.0的特性和新增的硬件性能需要3.0版本。</p>\n<p>我们在创建和初始化<em>EAGLContext</em>对象时选择OpenGL ES的版本。如果设备不支持对应的版本，会返回nil，我们必须保证正确初始化之后使用它。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EAGLContext* CreateBestEAGLContext() &#123;</span><br><span class=\"line\">    EAGLContext *context = [[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES3];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (context == <span class=\"literal\">nil</span>) &#123;</span><br><span class=\"line\">        context = [[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES2];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> context;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"eagl-sharegroup\">EAGL Sharegroup</h2>\n<p>尽管上下文持有OpenGL ES的状态，但它不直接管理OpenGL ES的对象。相反，可以通过<em>EAGLSharegroup</em>对象创建和持有OpenGL ES对象，每个上下文都包含一个被委托创建对象的<em>ESGLSharegroup</em>对象。</p>\n<p>在两个或多个上下文引用一个共享组时优势很明显，这时创建OpenGL ES的对象在所有上下文都可用，如果绑定到另一个上下文与创建它的上下文有相同的标识符，则引用相同的OpenGL ES对象。移动设备的资源非常稀缺，在上下文创建多个相同内容的拷贝是浪费资源的，公共资源可以更好的利用设备的图形资源。</p>\n<p>sharegroup是一个不透明对象，没有可以调用的属性或方法，可以使用sharegroup对象的上下文对之进行强引用。</p>\n<p><img src=\"/img/article/20190519/2.png\" alt=\"OpenGL ES Sharegroup\"></p>\n<p>sharegroup在以下两种情况下最有用：</p>\n<ul>\n<li>上下文之间的大多数共享资源不会改变</li>\n<li>当我们想要在其他线程创建OpenGL ES对象而主线程用于渲染。例如：第二个上下文在单独的线程上用于获取数据和创建资源，加载资源后，第一个上下文可以绑定到对象并立即使用它。<em>GLKtextureLoader</em>类就是使用这个模式来提供异步纹理加载。</li>\n</ul>\n<p>想要创建引用相同sharegroup的上下文，第一个上下文使用<code>initAPI:</code>方法初始化后会自动创建sharegroup，第二个及后续上下文调用<code>initAPI:sharegroup:</code>使用第一个上下文的sharegroup进行初始化。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EAGLContext* firstContext = CreateBestEAGLContext();</span><br><span class=\"line\">EAGLContext* secondContext = [[EAGLContext alloc] initWithAPI:[firstContext API] sharegroup: [firstContext sharegroup]];</span><br></pre></td></tr></table></figure>\n<p>当sharegroup由多个上下文共享时，我们有责任管理OpenGL ES对象的状态更改：</p>\n<ul>\n<li>应用程序可以同时跨多个上下文访问未修改的对象</li>\n<li>当对象被发送到上下文的命令修改时，不能在其他地方读写该对象</li>\n<li>在对象修改后，所有上下文必须重新绑定才能看到更改。如果上下文在绑定之前引用该对象，则该对象的内容是未定义的</li>\n</ul>\n<p>下面是更新OpenGL ES对象的步骤：</p>\n<ul>\n<li>在可能使用对象的每个上下文调用<code>glFlush</code>方法</li>\n<li>在想要修改对象的上下文，调用一种或多种OpenGL ES方法修改对象</li>\n<li>在接收状态修改命令的上下文中调用<code>glFlush</code>方法</li>\n<li>在每个其他上下文，重新绑定标识符</li>\n</ul>\n<blockquote>\n<p>另一种共享对象的方法是使用一个渲染上下文，多个目标帧缓冲区。在渲染时，应用程序绑定合适的帧缓冲区并根据需要渲染帧，因为所有的OpenGL ES对象都是从一个上下文应用，所有会看到相同的OpengGL ES数据。这种模式使用的资源较少，但只适用于单线程应用程序，但单线程程序中可以仔细控制上下文状态。</p>\n</blockquote>\n<h1 id=\"drawing-with-opengl-es-and-glkit\">Drawing with OpenGL ES and GLKit</h1>\n<p>GLKit框架提供了视图和控制器类，消除了绘画和动画OpenGL ES内容所需的设置和维护代码，<em>GLKView</em>类管理OpenGL ES的基础结构，为绘图代码提供空间，<em>GLKViewController</em>类提供一个渲染循环用于GLKit视图上平滑的展示OpenGL ES内容的动画。这些类扩展了用于绘制视图内容和管理视图呈现的标准UIKit设计模式。因此，我们可以将主要精力用于OpenGL ES渲染代码与应用流畅度上。GLKit框架同样提供简化OpenGL ES 2.0与3.0开发的其他特性。</p>\n<h2 id=\"glkit视图根据需求绘制opengl-es内容\">GLKit视图根据需求绘制OpenGL ES内容</h2>\n<p><em>GLKView</em>类提供了一个基于OpenGL ES等价于标准UIView的绘图周期。<em>UIView</em>对象自动配置图形上下文，所以<code>drawRect:</code>实现只需要执行Quartz 2D的绘图命令，<em>GLKView</em>对象自动配置自己所以我们的绘图方法只需要执行OpenGL ES的绘图命令。<em>GLKView</em>类通过维护持有OpenGL ES绘图命令结果的帧缓冲区来提供此功能，然后在绘图方法返回时自动将他们呈现给Core Animation。</p>\n<p>与标准UIKit视图一样，GLKit视图按需渲染。当视图第一次显示，它调用我们的绘图方法–Core Animation缓冲区渲染输出并在视图显示时显示它。当我们想要修改视图内容，调用<code>setNeedsDisplay</code>方法，视图会重新调用我们的绘图方法，缓冲区结果图，在屏幕显示它。这个方法在渲染图像的数据修改很少或只响应用户操作时有用，只有在需要的时候渲染新视图内容，这样可以节约设备电量并为其他操作留出更多时间。</p>\n<p><img src=\"/img/article/20190519/3.png\" alt=\"Rending OpenGL ES content with a GLKit view\"></p>\n<h3 id=\"创建与配置glkit-view\">创建与配置GLKit View</h3>\n<p>我们可以以编程的方式创建配置一个GLKView对象，也可以用故事板，在绘图钱，我们需要与之关联<em>EAGLContext</em>对象。</p>\n<ul>\n<li>当以编程方式创建一个视图时，先创建一个上下文然后将它用于*initWithFrame:context:*方法</li>\n<li>当从故事板加载一个视图，创建一个上下文然后设置为这个视图的<em>context</em>属性</li>\n</ul>\n<p>一个GLKit视图自动创建和配置他自己的OpenGL ES帧缓冲区对象和渲染缓冲区。我们使用视图的绘图属性控制这些对象属性，当我们改变尺寸大小、比例系数、或者某个绘画属性，它会在下次内容绘制时自动删除和重新创建相应的帧缓冲区和渲染缓冲区对象。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</span><br><span class=\"line\">    </span><br><span class=\"line\">    EAGLContext *context = CreateBestEAGLContext();</span><br><span class=\"line\">    GLKView *glkView = [[GLKView alloc] initWithFrame:<span class=\"keyword\">self</span>.view.bounds context:context];</span><br><span class=\"line\">    <span class=\"comment\">// Configure renderbuffers</span></span><br><span class=\"line\">    glkView.drawableColorFormat = GLKViewDrawableColorFormatSRGBA8888;</span><br><span class=\"line\">    glkView.drawableDepthFormat = GLKViewDrawableDepthFormat24;</span><br><span class=\"line\">    glkView.drawableStencilFormat = GLKViewDrawableStencilFormat8;</span><br><span class=\"line\">    <span class=\"comment\">// enable multisampling</span></span><br><span class=\"line\">    <span class=\"comment\">// multisampling是一种消除锯齿边缘的反锯齿，在大多数3D应用程序中提高图形质量，代价是使用更多的内存和片段处理时间</span></span><br><span class=\"line\">    glkView.drawableMultisample = GLKViewDrawableMultisample4X;</span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.view addSubview:glkView];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用glkit-view绘图\">使用GLKit View绘图</h3>\n<p>绘制OpenGL ES内容分为三步：准备OpenGL ES基础设施，执行绘图命令，将渲染内容提交给Core Animation显示。其中<em>GLKView</em>实现了第一步与第三步，下面代码实现了绘图的第二步：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)drawRect:(<span class=\"built_in\">CGRect</span>)rect &#123;</span><br><span class=\"line\">    <span class=\"comment\">// clear the framebuffer</span></span><br><span class=\"line\">    glClearColor(<span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">0.1</span>, <span class=\"number\">1.0</span>);</span><br><span class=\"line\">    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span><br><span class=\"line\">    <span class=\"comment\">// Draw using previously configured texture, shader, uniforms, and vertex array</span></span><br><span class=\"line\">    glBindTexture(GL_TEXTURE_2D, _planetTexture);</span><br><span class=\"line\">    glUseProgram(_diffuseShading);</span><br><span class=\"line\">    glUniformMatrix4fv(_uniformModelViewProjectionMatrix, <span class=\"number\">1</span>, <span class=\"number\">0</span>, _modelViewProjectionMatrix.m);</span><br><span class=\"line\">    glBindVertexArray(_planetMesh);</span><br><span class=\"line\">    glDrawElements(GL_TRIANGLE_STRIP, <span class=\"number\">256</span>, GL_UNSIGNED_SHORT, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><em>glClear</em>方法提示OpenGL ES任何现有的帧缓冲区内容都可以被丢弃，避免加载以前的内容到内存中造成高消耗内存操作。为了确保最佳性能，我们应该在每次绘图前总是调用这个函数</p>\n</blockquote>\n<p><em>GLKView</em>可以提供一些简单的接口给OpenGL ES绘图，因为它管理了OpenGL ES渲染过程中的标准部分：</p>\n<ul>\n<li>在调用绘图方法前，视图需要：\n<ul>\n<li>确保<em>EAGLContext</em>为当前上下文</li>\n<li>基于现有尺寸、比例系数、绘图属性创建帧缓冲区对象和渲染缓冲区（如有必要）</li>\n<li>将帧缓冲区对象绑定为绘制命令的当前目标</li>\n<li>设置OpenGL ES视图端口以匹配帧缓冲区大小</li>\n</ul>\n</li>\n<li>在绘图方法返回后，视图需要：\n<ul>\n<li>解析multisampling缓冲区（如果multisampling已设置）</li>\n<li>丢弃不再需要的渲染缓冲区</li>\n<li>将渲染缓冲区内容提交给Core Animation缓冲区和展示</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"使用代理渲染\">使用代理渲染</h2>\n<p>许多OpenGL ES应用程序使用自定义类实现渲染代码，这个方法的优势在于它能为多个渲染器分别定义不同的渲染类，从而轻松地支持多个渲染算法，共享公共功能的渲染算法可以从父类继承。例如，我们可以使用不同的渲染类同时支持OpenGL ES 2.0和3.0，或者使用它们在具有更强大硬件的设备上定制渲染，以获得更优质的图片。</p>\n<p>GLKit非常适合这种方法–我们可以使用渲染器对象成为标准GLKView实例的代理，没有使用继承GLKView和实现<code>drawInRect:</code>方法，而是使用渲染器类实现<em>GLKViewDelegate</em>代理并实现<code>glkView:drawInRect:</code>方法。下面代码演示了应用程序在启动时根据硬件特性选择渲染器类：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)application:(<span class=\"built_in\">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class=\"built_in\">NSDictionary</span> *)launchOptions &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Create a context</span></span><br><span class=\"line\">    EAGLContext *context = [[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES2];</span><br><span class=\"line\">    [EAGLContext setCurrentContext:context];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// Choose a rendering class based on device features</span></span><br><span class=\"line\">    GLint maxTextureSize;</span><br><span class=\"line\">    glGetIntegerv(GL_MAX_TEXTURE_SIZE, &amp;maxTextureSize);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (maxTextureSize &gt; <span class=\"number\">2048</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.renderer = [[MyBigTextureRenderer alloc] initWithContext:context];</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.renderer = [[MyRenderer alloc] initWithContext:context];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    GLKView *view = (GLKView *)<span class=\"keyword\">self</span>.window.rootViewController.view;</span><br><span class=\"line\">    view.delegate = <span class=\"keyword\">self</span>.renderer;</span><br><span class=\"line\">    view.context = context;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"glkit视图控制器动画opengl-es内容\">GLKit视图控制器动画OpenGL ES内容</h2>\n<p>默认情况下，一个<em>GLKView</em>对象按需渲染内容。也就是说，使用OpenGL ES绘图的一个关键优势是他能使用图形处理硬件对复杂场景进行连续动画–游戏和模拟器等应用程序很少使用静态图片。对于这些情况，<em>GLKit</em>框架提供一个视图控制器类，为它管理的<em>GLKView</em>对象维护一个动画循环，这个循环遵循游戏和模拟器中场景中常见的设计模式，分为两个阶段：更新与显示。下图展示了一个简单的动画循环示例：</p>\n<p><img src=\"/img/article/20190519/4.png\" alt=\"The animation loop\"></p>\n<h3 id=\"动画循环的理解\">动画循环的理解</h3>\n<p>更新阶段，视图控制器调用它自身的<em>update</em>方法（或者当未继承GLKViewController时可以使用代理的<code>glkViewControllerUpdate:</code>方法），这个方法中，我们应该为下一帧绘图做准备。例如，一个游戏可能使用这个方法根据上一帧以来接受到的输入事件来决定玩家和敌对角色的位置，科学的可视化可以使用这种方法运行模拟的一个步骤。如果我们需要时间信息来决定应用程序下一帧的状态，使用这个视图控制器的其中一个时间属性比如<code>timeSinceLastUpdate</code>属性。</p>\n<p>展示阶段，试图控制器调用视图的<code>display</code>方法，这个方法会触发绘图方法。在绘图方法中，我们对GPU提交OpenGL ES的绘图指令来渲染我们的内容。为了最佳性能。我们的应用程序应该在渲染最新一帧时修改OpenGL ES对象，然后提交绘图指令。</p>\n<p>动画循环以视图控制器的<code>framesPerSecond</code>属性所指示的速率在这两个阶段切换，我们可以使用<code>preferredFramesPerSecond</code>属性来设置所需的帧速率–为了当前显示硬件的最优性能，视图控制器自动渲染接近于我们设置值的最优帧速率。</p>\n<blockquote>\n<p>为了获得最佳效果，选择一个应用程序可以达到的帧率。平滑、一致的帧率比经常变化的帧率能有更好的用户体验</p>\n</blockquote>\n<h3 id=\"使用glkit视图控制器\">使用GLKit视图控制器</h3>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">PlanetViewController</span> // <span class=\"title\">subclass</span> <span class=\"title\">of</span> <span class=\"title\">GLKViewController</span></span></span><br><span class=\"line\"> </span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">// Create an OpenGL ES context and assign it to the view loaded from storyboard</span></span><br><span class=\"line\">    GLKView *view = (GLKView *)<span class=\"keyword\">self</span>.view;</span><br><span class=\"line\">    view.context = [[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES2];</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">// Set animation frame rate</span></span><br><span class=\"line\">    <span class=\"keyword\">self</span>.preferredFramesPerSecond = <span class=\"number\">60</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">// Not shown: load shaders, textures and vertex arrays, set up projection matrix</span></span><br><span class=\"line\">    [<span class=\"keyword\">self</span> setupGL];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)update &#123;</span><br><span class=\"line\">    _rotation += <span class=\"keyword\">self</span>.timeSinceLastUpdate * M_PI_2; <span class=\"comment\">// one quarter rotation per second</span></span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">// Set up transform matrices for the rotating planet</span></span><br><span class=\"line\">    GLKMatrix4 modelViewMatrix = GLKMatrix4MakeRotation(_rotation, <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f, <span class=\"number\">0.0</span>f);</span><br><span class=\"line\">    _normalMatrix = GLKMatrix3InvertAndTranspose(GLKMatrix4GetMatrix3(modelViewMatrix), <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    _modelViewProjectionMatrix = GLKMatrix4Multiply(_projectionMatrix, modelViewMatrix);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)glkView:(GLKView *)view drawInRect:(<span class=\"built_in\">CGRect</span>)rect &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Clear the framebuffer</span></span><br><span class=\"line\">    glClearColor(<span class=\"number\">0.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">0.1</span>f, <span class=\"number\">1.0</span>f);</span><br><span class=\"line\">    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">// Set shader uniforms to values calculated in -update</span></span><br><span class=\"line\">    glUseProgram(_diffuseShading);</span><br><span class=\"line\">    glUniformMatrix4fv(_uniformModelViewProjectionMatrix, <span class=\"number\">1</span>, <span class=\"number\">0</span>, _modelViewProjectionMatrix.m);</span><br><span class=\"line\">    glUniformMatrix3fv(_uniformNormalMatrix, <span class=\"number\">1</span>, <span class=\"number\">0</span>, _normalMatrix.m);</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">// Draw using previously configured texture and vertex array</span></span><br><span class=\"line\">    glBindTexture(GL_TEXTURE_2D, _planetTexture);</span><br><span class=\"line\">    glBindVertexArrayOES(_planetMesh);</span><br><span class=\"line\">    glDrawElements(GL_TRIANGLE_STRIP, <span class=\"number\">256</span>, GL_UNSIGNED_SHORT, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p><code>viewDidLoad</code>方法创建了OpenGL ES上下文并提供给视图，同时设置动画循环的帧率。视图控制器自动成为视图的代理，同时实现动画循环的更新与显示阶段。在<code>update</code>方法中，它计算显示旋转行星所需的变换矩阵。在<code>glkView:drawInRect:</code>方法，它将这些矩阵提供给着色器程序，并提交绘制命令来渲染行星的几何形状。</p>\n<h1 id=\"drawing-to-other-rendering-destinations\">Drawing to Other Rendering Destinations</h1>\n<p>帧缓冲区对象是渲染命令的目标。当创建一个帧缓冲区对象，我们可以精确控制它存储的颜色、深度和模板数据。我们通过将图片附加到帧缓冲区来提供这种存储，如下图所示。最常见的图片关联是渲染缓冲区对象。我们也可以将OpenGL ES的纹理附加到帧缓冲区的颜色连接点，这意味着所有的绘图命令都将渲染到纹理中。稍后，纹理可以作为未来渲染命令的输入。我们还可以在一个渲染上下文创建多个帧缓冲区对象，这么做可以在多个帧缓冲区之间共享相同的渲染管线和OpenGL ES资源。</p>\n<p><img src=\"/img/article/20190519/5.png\" alt=\"Famebuffer with color and depth renderbuffers\"></p>\n<p>所有这些方法都需要手动创建帧缓冲区和渲染缓冲区对象来存储OpenGL ES上下文的渲染结果，还需要编写额外的代码来将内容呈现到屏幕，如有必要还要运行一个动画循环。</p>\n<h2 id=\"创建帧缓冲区对象\">创建帧缓冲区对象</h2>\n<p>根据应用程序打算执行的任务，将配置不同的对象附加到帧缓冲区对象。在多数情况下，配置帧缓冲区的区别在于对象被附加到对象的颜色连接点上：</p>\n<ul>\n<li>使用帧缓冲区用于离屏图像处理，附加一个渲染缓冲区。见<a href=\"#%E5%88%9B%E5%BB%BA%E7%A6%BB%E5%B1%8F%E7%BC%93%E5%86%B2%E5%8C%BA%E5%AF%B9%E8%B1%A1\">创建离屏缓冲区对象</a></li>\n<li>使用帧缓冲区图片作为后续渲染步骤的输入，附加一个纹理。见<a href=\"#%E4%BD%BF%E7%94%A8%E5%B8%A7%E7%BC%93%E5%86%B2%E5%8C%BA%E5%AF%B9%E8%B1%A1%E6%B8%B2%E6%9F%93%E7%BA%B9%E7%90%86\">使用帧缓冲区对象渲染纹理</a></li>\n<li>在Core Animation层级组合中使用帧缓冲区，使用特定Core Animation-aware渲染缓冲区。见<a href=\"#%E6%B8%B2%E6%9F%93%E5%88%B0Core-Animation%E5%B1%82%E7%BA%A7\">渲染到Core Animation层级</a></li>\n</ul>\n<h3 id=\"创建离屏缓冲区对象\">创建离屏缓冲区对象</h3>\n<p>用于离屏渲染的帧缓冲区分配内存给它所有的关联作为OpenGL ES的渲染缓冲区。下面代码分配内存给一个带有颜色和深度关联的帧缓冲区对象：</p>\n<ol>\n<li>创建帧缓冲区并绑定：</li>\n</ol>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GLuint framebuffer;</span><br><span class=\"line\">glGenFramebuffers(<span class=\"number\">1</span>, &amp;framebuffer);</span><br><span class=\"line\">glBindFramebuffer(GL_FRAMEBUFFER, framebuffer);</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>创建颜色渲染缓冲区，分配内存，与帧缓冲区的颜色连接点相关联：</li>\n</ol>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GLuint colorRenderbuffer;</span><br><span class=\"line\">glGenRenderbuffers(<span class=\"number\">1</span>, &amp;colorRenderbuffer);</span><br><span class=\"line\">glBindRenderbuffer(GL_RENDERBUFFER, colorRenderbuffer);</span><br><span class=\"line\">glRenderbufferStorage(GL_RENDERBUFFER, GL_RGBA, width, height);</span><br><span class=\"line\">glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_RENDERBUFFER, colorRenderbuffer);</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>创建一个深度或者深度/模板渲染缓冲区，分配内存，与帧缓冲区深度关联点相关联：</li>\n</ol>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GLuint depthRenderbuffer;</span><br><span class=\"line\">glGenRenderbuffers(<span class=\"number\">1</span>, &amp;depthRenderbuffer);</span><br><span class=\"line\">glBindRenderbuffer(GL_RENDERBUFFER, depthRenderbuffer);</span><br><span class=\"line\">glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH_COMPONENT16, width, height);</span><br><span class=\"line\">glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, depthRenderbuffer);</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>测试帧缓冲区的完整性，这个测试方法只需要在帧缓冲区配置改动时执行：</li>\n</ol>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GLenum status = glCheckFramebufferStatus(GL_FRAMEBUFFER);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (status != GL_FRAMEBUFFER_COMPLETE) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"failed to make complete framebuffer object %x\"</span>, status);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在绘图到离屏渲染缓冲区后，使用<code>glReadPixels</code>方法返回它的内容到CPU做进一步处理。</p>\n<h3 id=\"使用帧缓冲区对象渲染纹理\">使用帧缓冲区对象渲染纹理</h3>\n<p>创建帧缓冲区的代码几乎与离屏实例一样，但现在是纹理分配内存并与颜色关联点相关联：</p>\n<ol>\n<li>创建帧缓存对象（与上例相似）；</li>\n<li>创建目标纹理，与帧缓冲区的颜色关联点相关联：</li>\n</ol>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GLuint texture;</span><br><span class=\"line\">glGenTextures(<span class=\"number\">1</span>, &amp;texture);</span><br><span class=\"line\">glBindTexture(GL_TEXTURE_2D, texture);</span><br><span class=\"line\">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);   <span class=\"comment\">// 纹理过滤</span></span><br><span class=\"line\">glTexImage2D(GL_TEXTURE_2D, <span class=\"number\">0</span>, GL_RGBA8, width, height, <span class=\"number\">0</span>, GL_RGBA, GL_UNSIGNED_BYTE, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, texture, <span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>分配缓存并关联深度缓冲区（与上例类似）；</li>\n<li>验证帧缓冲区的完整性；</li>\n</ol>\n<p>虽然这个例子假设我们正在渲染到颜色纹理，但也可以使用其他选项。例如，使用<em>OES_depth_texture</em>扩展，可以将纹理关联到深度关联点，以将场景中的深度信息存储到纹理。我们可以使用这个深度信息计算最终渲染场景中的阴影。</p>\n<h3 id=\"渲染到core-animation层级\">渲染到Core Animation层级</h3>\n<p>Core Animation是iOS上图形渲染和动画的核心基础设施，我们可以使用不同iOS子系统渲染的层级（如UIKit、Quartz 2D、OpenGL ES）来组合应用程序的用户界面或其他可视化显示。OpenGL ES通过<em>CAEAGLLayer</em>类关联Core Animation，这个类是一种特殊类的Core Animation层级，其内容来自OpenGL ES渲染缓冲区。Core Animation将渲染缓冲区的内容和其他层级组合在一起，并将结果图像显示在屏幕上。</p>\n<p><img src=\"/img/article/20190519/6.png\" alt=\"Core Animation shares the renderbuffer width OpenGL ES\"></p>\n<p><em>CAEAGLLayer</em>通过提供了两项关键功能为OpenGL ES提供支持。首先，它为渲染缓冲区分配内存共享存储，其次，它将渲染缓冲区呈现到Core Animation，用渲染缓冲区中的数据替换层级之前的内容。该模型的优点在于Core Animation层级不需要每一帧都绘制，只需要在渲染图像发生改变时绘制。</p>\n<blockquote>\n<p>GLKView类自动执行以下步骤，所以当我们想要在视图的内容层中使用OpenGL ES绘图时，应该使用它。</p>\n</blockquote>\n<p>使用Core Animation层级的OpenGL ES渲染：</p>\n<ol>\n<li>创建<em>CAEAGLLayer</em>对象并配置它的属性。想要最佳性能，设置层级的<em>opaue</em>属性为YES。可选，通过为<em>CAEAGLLayer</em>对象的<code>drawableProperties</code>属性分配一个新的字典来配置渲染表面的表面属性；可以指定渲染缓冲区的像素格式，并指定渲染缓冲区的内容在发送到Core Animation后是否被丢弃。有关允许的键列表，见<a href=\"https://developer.apple.com/documentation/opengles/eagldrawable?language=objc\" target=\"_blank\" rel=\"noopener\">EAGLDrawable Protocol Reference</a>；</li>\n<li>创建OpenGL ES上下文，并设置为当前上下文；</li>\n<li>创建帧缓冲区对象；</li>\n<li>创建颜色渲染缓冲区，调用<code>renderbufferStorage:fromDrawable:</code>方法分配存储内存并将层级对象作为参数传入。宽度、高度、像素格式都是从层级获取并用于渲染缓冲区的分配存储内存：</li>\n</ol>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GLuint colorRenderbuffer;</span><br><span class=\"line\">glGenRenderbuffers(<span class=\"number\">1</span>, &amp;colorRenderbuffer);</span><br><span class=\"line\">glBindRenderbuffer(GL_RENDERBUFFER, colorRenderbuffer);</span><br><span class=\"line\">[myContext renderbufferStorage:GL_RENDERBUFFER fromDrawable:myEAGLLayer];</span><br><span class=\"line\">glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_RENDERBUFFER, colorRenderbuffer);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>当Core Animation的层级<code>bounds</code>或属性改变时，必须重新分配渲染缓冲区存储内存。如果不重新分配内存，渲染缓冲区的大小可能不匹配层级的大小。</p>\n</blockquote>\n<ol start=\"5\">\n<li>检索颜色渲染缓冲区的高度和宽度：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GLuint width, height;</span><br><span class=\"line\">glGetRenderbufferParameteriv(GL_RENDERBUFFER, GL_RENDERBUFFER_WIDTH, &amp;width);</span><br><span class=\"line\">glGetRenderbufferParameteriv(GL_RENDERBUFFER, GL_RENDERBUFFER_HEIGHT, &amp;height);</span><br></pre></td></tr></table></figure>\n<p>在前面的示例中，显示地提供了渲染缓冲区的宽度和高度以便分配内存。这里，代码在分配存储内存后检索颜色渲染缓冲区的宽度和高度。应用程序之所以这样做，是因为颜色缓冲区的实际尺寸是根据层级的边界大小和缩放因子计算的。关联到帧缓冲区的渲染缓冲区必须具有相同的纬度。除了使用高度和宽度分配深度缓冲区内存，还可以用来分配OpenGL ES视图端口，并帮助确定应用程序的纹理和模型中所需的细节级别；</p>\n<ol start=\"6\">\n<li>分配缓存并关联深度缓冲区；</li>\n<li>验证帧缓冲区的完整性；</li>\n<li>通过将<em>CAEAGLLayer</em>对象传递给<code>addSublayer:</code>一个可见层级的方法添加到Core Animation的层级结构中。</li>\n</ol>\n<h2 id=\"绘制到帧缓冲区对象\">绘制到帧缓冲区对象</h2>\n<p>现在我们已经拥有了一个帧缓冲区对象，然后就是填充。下面介绍了渲染新帧并呈现给用户所必要的步骤，渲染到纹理或离屏帧缓冲区的行为类似，只是应用程序使用最终帧的方式不同。</p>\n<h3 id=\"按需或使用动画循环渲染\">按需或使用动画循环渲染</h3>\n<p>我们在渲染到一个Core Animation层级时必须选择何时绘制我们的OpenGL ES内容，就像使用GLKit视图和控制器绘图一样。如果渲染到离屏帧缓冲区或纹理，则在适合使用这些帧缓冲区类型的情况下随时绘制。</p>\n<p>对于on-demand绘制，实现我们自己的方法绘制并呈现渲染缓冲区，并在需要显示新内容的时候调用它。</p>\n<p>对于动画循环绘制，使用<code>CADisplayLink</code>对象。<code>displayLink</code>是由Core Animation提供的一种定时器，允许我们将绘图同步到屏幕的刷新率。下面代码展示了我们如何检索显示视图的屏幕，使用这个屏幕创建一个新的<code>displayLink</code>对象并添加到运行环中。</p>\n<blockquote>\n<p><em>GLKViewController</em>类自动使用<code>CADisplayLink</code>对象来动画<code>GLKView</code>的内容，只有当我们需要超出<em>GLKit</em>框架所提供的行为时，才直接使用<code>CADisplayLink</code>类</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CADisplayLink *displayLink = [self.view.window.screen displayLinkWithTarget:self selector:@selector(drawFrame)];</span><br><span class=\"line\">[displayLink addToRunLoop:[NSRunLoop currentRunLoop] forMode:NSDefaultRunLoopMode];</span><br></pre></td></tr></table></figure>\n<p>在<code>drawFrame</code>方法的实现中，读取<code>displayLink</code>的<code>timestamp</code>属性来获取渲染下一帧的时间戳，可以用来计算下一帧对象的位置。</p>\n<p>通常，每次屏幕刷新都会触发<code>displayLink</code>对象；该值通常为60Hz，但在不同的设备上有所不同。大多数应用程序不需要每秒更新屏幕60次。我们可以设置<code>displayLink</code>的<code>frameInterval</code>属性设置为调用该方法之前经过的实际帧数。例如，如果帧间隔设置为3，应用程序则每隔3帧调用一次，或者每秒大约调用20帧（原帧率的三分之一）。</p>\n<blockquote>\n<p>为了最佳效果，渲染一个应用程序可以始终实现的帧率。</p>\n</blockquote>\n<h3 id=\"渲染帧\">渲染帧</h3>\n<p>下图展示了OpenGL ES应用程序渲染和呈现帧的步骤，这些步骤包括很多提示以提高应用程序的性能。</p>\n<p><img src=\"/img/article/20190519/7.png\" alt=\"iOS OpenGL Rendering Steps\"></p>\n<h4 id=\"清空缓冲区\">清空缓冲区</h4>\n<p>在每一帧开始前，删除所有帧缓冲区附加的下一帧不需要使用的内容。调用<code>glClear</code>方法，传递一个位掩码清除所有缓冲区：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">glBindFramebuffer(GL_FRAMEBUFFER, framebuffer);</span><br><span class=\"line\">glClear(GL_DEPTH_BUFFER_BIT | GL_COLOR_BUFFER_BIT);</span><br></pre></td></tr></table></figure>\n<p>使用<code>glClear</code>提示OpenGL ES可以丢弃渲染缓冲区或纹理的现有内容，从而避免将先前内容加载到内存中的昂贵内存。</p>\n<h4 id=\"准备资源并执行绘图命令\">准备资源并执行绘图命令</h4>\n<p>这两个步骤包含了设计应用程序架构时所做的大多数关键决策。首先，决定我们想要展示给用户的内容并配置相应的OpenGL ES对象上传到GPU（如顶点缓冲对象，纹理，着色器程序及其输入变量）。下一步，提交绘图命令告诉GPU如何使用这些资源渲染帧。</p>\n<p>渲染器设计的更多细节见<a href=\"#opengl-es-design-guidelines\">OpenGL ES Design Guidelines</a>。目前，最需要注意的最重要的性能优化是，如果只在渲染新帧时修改OpenGL ES对象应用程序运行的更快。虽然应用程序可以在修改对象和提交绘图命令中间进行切换，但如果每帧只执行一个步骤会运行地更快。</p>\n<h4 id=\"执行绘图命令\">执行绘图命令</h4>\n<p>这一步获取我们上一步准备的对象并提交绘图命令使用它们。设计渲染代码这一部分以高效运行的更多细节见<a href=\"#opengl-es-design-guidelines\">OpenGL ES Design Guidelines</a>。目前，最需要注意的最重要的性能优化是，如果只在渲染新帧时修改OpenGL ES对象应用程序运行的更快。虽然应用程序可以在修改对象和提交绘图命令中间进行切换，但如果每帧只执行一个步骤会运行地更快。</p>\n<h4 id=\"解决多重采样\">解决多重采样</h4>\n<p>如果应用程序使用反锯齿提高图形质量，需要在呈现给用户之前解析像素。更多细节见<a href=\"#%E4%BD%BF%E7%94%A8%E5%A4%9A%E9%87%8D%E9%87%87%E6%A0%B7%E6%8F%90%E9%AB%98%E5%9B%BE%E7%89%87%E8%B4%A8%E9%87%8F\">使用多重采样提高图片质量</a>。</p>\n<h4 id=\"丢弃不需要的渲染帧缓冲区\">丢弃不需要的渲染帧缓冲区</h4>\n<p>丢弃操作是一个性能提示，告诉OpenGL ES一个或多个渲染缓冲区的内容不再需要。通过提示OpenGL ES我们不需要一个渲染缓冲区的内容，缓冲区里的数据被丢弃，可以避免缓冲区更新的复杂任务。</p>\n<p>在渲染循环的这个阶段，应用程序已经提交了所有的绘图命令。虽然应用程序需要颜色渲染缓冲区来显示在屏幕上，但可能不需要深度缓冲区的内容。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> GLenum discards = &#123;GL_DEPTH_ATTACHMENT&#125;;</span><br><span class=\"line\">glBindFramebuffer(GL_FRAMEBUFFER, framebuffer);</span><br><span class=\"line\">glDiscardFramebufferEXT(GL_FRAMEBUFFER, <span class=\"number\">1</span>, discards)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>glDiscardFramebufferEXT</code>方法由OpengGL ES1.0和2.0的<code>EXT_discard_framebuffer</code>扩展提供。在OpenGL ES 3.0上下文中，使用<code>glInvalidateFramebuffer</code>方法。</p>\n</blockquote>\n<h4 id=\"呈现结果到core-animation\">呈现结果到Core Animation</h4>\n<p>在这个步骤，颜色渲染缓冲区持有完成帧，所以我们需要做的就是呈现给用户。下面代码将renderbuffer绑定到上下文并呈现。这使得完成帧被交到Core Animation。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">glBindRenderbuffer(GL_RENDERBUFFER, colorRenderbuffer);</span><br><span class=\"line\">[context presentRenderbuffer: GL_RENDERBUFFER];</span><br></pre></td></tr></table></figure>\n<p>默认情况下，我们必须保证应用程序呈现完渲染缓冲区后内容被丢弃。这意味着每次呈现帧时，当渲染新帧时必须完整重新创建帧内容，由于这个原因，上述的代码总是擦除颜色缓冲区。</p>\n<p>如果应用程序想要在帧之间保存颜色缓冲区的内容，那么在<code>CAEAGLLayer</code>对象的<code>drawableProperties</code>属性字典添加<code>kEAGLDrawablePropertyRetainedBacking</code>键为<code>YES</code>，同时在<code>glClear</code>方法调用中移除<code>GL_COLOR_BUFFER_BIT</code>常量。保留备份可能需要iOS分配额外的内存来存储缓冲区内容，可能会降低应用程序的性能。</p>\n<h2 id=\"使用多重采样提高图片质量\">使用多重采样提高图片质量</h2>\n<p>多重采样是反锯齿的一种形式，平滑锯齿边缘，提高大多数3D应用的图像质量。OpenGL ES 3.0将多重采样作为核心规范的一部分，OpenGL ES 1.0和2.0合一通过<code>APPLE_framebuffer_multisample</code>扩展提供。多重采样使用更多的内存和片段处理时间来渲染图片，但相比其他方法使用更低的性能成本提高图像质量。</p>\n<p>下图展示了多重采样的工作原理。应用程序不是创建一个帧缓冲区，而是两个。多重采样缓冲区包含所有必要的渲染内容关联（通常是颜色和深度缓冲区），解析缓冲区只包含必要的展示渲染图片给用户的关联（通常是颜色渲染缓冲区，但可能是纹理）。多重采样渲染缓冲器使用和解析渲染缓冲器相同的维度分配内存，但每个维度都包含一个指定每个像素存储的样本数量的额外参数。应用程序将所有的渲染都执行到多重采样缓冲区，然后将这些样本解析到解析缓冲器中生成最终反锯齿图像。</p>\n<p><img src=\"/img/article/20190519/8.png\" alt=\"How multisampling\"></p>\n<p>下面代码展示了多重采样缓冲区的创建，使用之前创建缓冲器的宽高。通过调用<code>glRenderbufferStorageMultisampleAPPLE</code>方法创建渲染缓冲器的多重采样存储；</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GLuint sampleFramebuffer;</span><br><span class=\"line\">glGenFramebuffers(<span class=\"number\">1</span>, &amp;sampleFramebuffer);</span><br><span class=\"line\">glBindFramebuffer(GL_FRAMEBUFFER, sampleFramebuffer);</span><br><span class=\"line\"></span><br><span class=\"line\">GLuint sampleColorRenderbuffer;</span><br><span class=\"line\">glGenRenderbuffers(<span class=\"number\">1</span>, &amp;sampleColorRenderbuffer);</span><br><span class=\"line\">glBindRenderbuffer(GL_RENDERBUFFER, sampleColorRenderbuffer);</span><br><span class=\"line\">glRenderbufferStorageMultisample(GL_RENDERBUFFER, <span class=\"number\">4</span>, GL_RGBA8_OES, width, height);</span><br><span class=\"line\">glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_RENDERBUFFER, sampleColorRenderbuffer);</span><br><span class=\"line\"></span><br><span class=\"line\">GLuint sampleDepthRenderbuffer;</span><br><span class=\"line\">glGenRenderbuffers(<span class=\"number\">1</span>, &amp;sampleDepthRenderbuffer);</span><br><span class=\"line\">glBindRenderbuffer(GL_RENDERBUFFER, sampleDepthRenderbuffer);</span><br><span class=\"line\">glRenderbufferStorageMultisample(GL_RENDERBUFFER, <span class=\"number\">4</span>, GL_DEPTH_COMPONENT16, width, height);</span><br><span class=\"line\">glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, sampleDepthRenderbuffer);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Failed to make complete framebuffer object %x\"</span>, glCheckFramebufferStatus(GL_FRAMEBUFFER));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>下面是一些基于多重采样的修改之后的渲染代码：</p>\n<ol>\n<li>在清除缓冲区步骤，需要同时清除多重采样帧缓冲区内容：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">glBindFramebuffer(GL_FRAMEBUFFER, sampleFramebuffer);</span><br><span class=\"line\">glViewport(0, 0, framebufferWidth, framebufferHeight);  // 选取绘图区域</span><br><span class=\"line\">glClear(GL_COLOR_BUFFER_BIT, GL_DEPTH_BUFFER_BIT);</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>在提交绘图命令后，需要将内容从多重缓冲区解析到解析缓冲区。每像素存储的样本将合并到解析缓冲区的单个样本中：</li>\n</ol>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">glBindFramebuffer(GL_DRAW_FRAMEBUFFER_APPLE, resolveFramebuffer);</span><br><span class=\"line\">glBindFramebuffer(GL_READ_FRAMEBUFFER_APPLE, smapleFramebuffer);</span><br><span class=\"line\">glResolveMultisampleFramebufferAPPLE();</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>在丢弃步骤，我们可以丢弃多重采样帧缓冲区关联的两个渲染缓冲区，这是因为预计呈现的内容以及存储到解析帧缓冲区内：</li>\n</ol>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> GLenum discards[] = &#123;GL_COLOR_ATTACHMENT0, GL_DEPTH_ATTACHMENT&#125;;</span><br><span class=\"line\">glDiscardFramebufferEXT(GL_READ_FRAMEBUFFER_APPLE, <span class=\"number\">2</span>, discards);</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>在呈现结果步骤，呈现关联到解析帧缓冲区的颜色渲染缓冲区：</li>\n</ol>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">glBindRenderBuffer(GL_RENDERBUFFER, colorRenderbuffer);</span><br><span class=\"line\">[context presentRenderbuffer: GL_RENDERBUFFER];</span><br></pre></td></tr></table></figure>\n<p>多重采样并不是免费的；存储额外样本的内存消耗，解析样本到解析帧缓冲区的时耗。如果我们想要添加多重采样到应用中，必须多测试性能以确保它可接受。</p>\n<blockquote>\n<p>上述代码基于OpenGL ES 1.0与2.0，多重采样位于OpenGL ES 3.0的核心API，使用不同的方法。</p>\n</blockquote>\n<h1 id=\"multitasking-high-resolution-and-other-ios-features\">Multitasking, High Resolution, and Other iOS Features</h1>\n<p>使用OpenGL ES的许多方面都是平台中立，但是在iOS上使用有一些细节需要特别考虑。特别是，iOS应用使用OpenGL ES正确处理多任务或进入后台有被终止的风险。在iOS设备开发OpenGL ES内容时，我们应该考虑现实分辨率和其他设备的特性。</p>\n<h2 id=\"实现一个多任务感知的opengl-es应用程序\">实现一个多任务感知的OpenGL ES应用程序</h2>\n<p>应用程序在用户切换到其他程序时可以继续运行。更多多任务讨论见<a href=\"https://developer.apple.com/library/archive/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/BackgroundExecution/BackgroundExecution.html#//apple_ref/doc/uid/TP40007072-CH4\" target=\"_blank\" rel=\"noopener\">App States and Multitasking</a></p>\n<p>使用OpenGL ES的应用程序在切入后台时必须执行更多的工作，如果多任务处理不当，那应用可能会崩溃，同样，一个应用程序可能想要释放OpenGL ES资源这样就只适用于前台工作。</p>\n<h3 id=\"后台应用程序可能无法在图像硬件上执行命令\">后台应用程序可能无法在图像硬件上执行命令</h3>\n<p>如果OpenGL ES应用程序视图在图像硬件上执行OpenGL ES命令可能会崩溃。iOS阻止后台应用程序访问图像处理器，因此最前端的应用程序总是能给用户提供更好的体验。应用程序崩溃不止在后台调用OpenGL ES，还会在进入后台时之前提交的命令刷新到GPU。所以我们必须保证所有之前提交的命令在进入后台前都执行完毕。</p>\n<p>如果使用GLKit视图和控制器，只在绘图方法中提交OpenGL ES命令，应用程序会自动在进入后台时正确运行。默认情况下，在应用程序处于非活动时<code>GLKViewController</code>类暂停其动画计时器，确保绘图方法不被调用。</p>\n<p>如果不适用GLKit视图或者控制器或者在GLKView绘图方法之外提交OpenGL ES命令，我们必须采用以下步骤保证程序在后台不崩溃：</p>\n<ol>\n<li>在<code>applicationWillResignActive:</code>方法中，需要停止动画计时器，将自己置于一个已知的良好状态，并调用<code>glFinish</code>方法；</li>\n<li>在<code>applicationDidEnterBackground:</code>方法中，应用程序可能想要删除一些OpenGL ES对象使内存和资源对于前台应用程序可。调用<code>glFinish</code>方法确保立即删除资源；</li>\n<li>在<code>applicationDidEnterBackground:</code>方法中，确保没有OpenGL ES的调用，如果有任何调用就会导致崩溃；</li>\n<li>在<code>applicationWillEnterForeground:</code>方法中，重新创建对象和启动动画计时器。</li>\n</ol>\n<p>总而言之，需要调用<code>glFinish</code>方法保证所有之前提交的命令都从命令缓存中取出并被OpenGL ES执行。在进入后台后，在进入前台之前必须避免使用OpenGL ES。</p>\n<h3 id=\"在进入后台前删除容易重新创建的资源\">在进入后台前删除容易重新创建的资源</h3>\n<p>在应用程序进入后台时从来不需要释放OpenGL ES对象，通常情况，我们应该避免处理它的内容。考虑两种情况：</p>\n<ul>\n<li>应用正在玩游戏并短暂切出去检查日历，当用户返回游戏，游戏的资源仍然在内存中并可以直接继续游戏；</li>\n<li>当用户启动另一个OpenGL ES应用程序，如果需要更多的资源那么系统会自动终止后台的OpenGL ES应用程序让它不执行任何额外的工作。</li>\n</ul>\n<p>我们的目标应该是把应用程序设计成一个良好公民：这意味着移动到前台的时间尽可能短，同时减少他在后台的内存占用。</p>\n<p>下面是我们应该处理的两种情况：</p>\n<ul>\n<li>应用程序应该保证纹理，模型和其他资源在内存中；当应用进入后台时，需要长时间重新创建的资源不应该被处理掉；</li>\n<li>应用程序应该处理可以快速易创建的对象，寻找消耗巨大内存的对象。</li>\n</ul>\n<p>简单的目标是应用程序分配内存持有渲染结果的帧缓冲区，当应用程序在后台时，它对用户是不可见的并可能不会使用OpenGL ES渲染任何新内容。这意味着应用程序的帧缓冲区分配了大量内存但并没有用。同样，帧缓冲区的内容是临时的，大多数应用程序在每次渲染新帧时都会重新创建帧缓冲区的内容。这是用渲染缓冲区成为一个内存密集型资源，可以很容易创建，成为移动到后台时可以处理的候选对象。</p>\n<p>如果我们使用GLKit视图和控制器，<code>GLKViewController</code>类自动在进入后台时处理关联的视图帧缓冲区。如果我们为其他用途手动创建了帧缓冲区，那在进入后台时应该处理他们。在这两种情况下，我们应该考虑应用程序当时可以处理哪些其他临时资源。</p>\n<h2 id=\"支持高分辨率显示\">支持高分辨率显示</h2>\n<p>默认情况下，GLKit视图的<code>contentScaleFactor</code>属性和包含它屏幕的比例相匹配，因此将其关联的帧缓冲区配置以渲染的全分辨率展现。 更多关于UIKit支持的高分辨率展现的内容见<a href=\"https://developer.apple.com/library/archive/documentation/2DDrawing/Conceptual/DrawingPrintingiOS/SupportingHiResScreensInViews/SupportingHiResScreensInViews.html#//apple_ref/doc/uid/TP40010156-CH15\" target=\"_blank\" rel=\"noopener\">Supporting High-Resolution Screens In Views</a>。</p>\n<p>如果使用Core Animation层级出现OpenGL ES的内容，它默认的缩放因子为1.0。为了在Retina显示器的全分辨率下绘图，我们应该修改<code>CAEAGLayer</code>对象的缩放因子以匹配屏幕的缩放因子。</p>\n<p>当支持高分辨率显示器的设备，我们应该相应地跳转应用程序的模型和纹理资源。当高分辨率的设备下运行，我们可能想要渲染更详细的模型和纹理来渲染更好的图像，相反，在标准分辨率设备下，我们可能使用更小的模型和纹理。</p>\n<blockquote>\n<p>许多OpenGL ES API调用都用屏幕像素表示维度，如果使用的缩放因子大于1.0，那么在使用<code>glScissor</code>、<code>glBlitFramebuffer</code>、<code>glLineWidth</code>、<code>glPointSize</code>函数或<code>gl_PointSize</code>着色器变量时，我们需要相应调整维度。</p>\n</blockquote>\n<p>决定如何支持高分辨率显示器的一个重要因素是性能。Retina显示器上的翻倍比例因子使像素的数量变为四倍，这使得GPU处理的碎片数量变为原来的四倍。如果应用程序对每个片段执行多个计算，像素的增加可能会导致帧率降低。如果我们发现应用程序在较高的比例因子下运行速度明显较慢，考虑以下选项之一：</p>\n<ul>\n<li>使用性能调优指南优化片段着色器的性能，见<a href=\"tuning-your-openGL-es-app\">Tuning Your OpenGL ES App</a>；</li>\n<li>在片段着色器实现一个更简单的算法，这样做可以降低单个像素的质量，以更高的分辨率渲染整个图像；</li>\n<li>使用在1.0到屏幕比例因子之间的比例因子，比例因子为1.5比1.0提供更高的质量，但需要填充填充的像素比比例为2.0的图像更少；</li>\n<li>使用较低精度格式的GLKView对象的<code>drawableColorFormat</code>和<code>drawableDepthFormat</code>属性。这样做可以减少操作底层渲染缓冲区所需的内存带宽；</li>\n<li>使用较低的比例因子，启用多重采样。另一个优点是，多重采样同样可以在不知道高分辨率显示器的设备上提供更高的质量。要为GLKView对象启用多重采样，要更改它的<code>drawableMultisample</code>属性值。如果不是渲染到GLKit视图上，则必须手动甚至多重采样缓冲区并在最终图形呈现前解析他们，见<a href=\"#%E4%BD%BF%E7%94%A8%E5%A4%9A%E9%87%8D%E9%87%87%E6%A0%B7%E6%8F%90%E9%AB%98%E5%9B%BE%E7%89%87%E8%B4%A8%E9%87%8F\">使用多重采样提高图片质量</a>。</li>\n</ul>\n<h2 id=\"支持多种屏幕旋转\">支持多种屏幕旋转</h2>\n<p>与任意应用程序一样，OpenGL ES应用程序应该支持与其内容相适应的用户界面方向。可以在应用程序的信息属性列表定义支持的屏幕方向或者拥有OpenGL ES内容的控制器使用<code>supportedInterfaceOrientations</code>方法。</p>\n<p>默认情况下，<code>GLKViewController</code>和<code>GLKView</code>类自动处理屏幕转向：当用户渲染设备到支持的方向，系统将产生动画旋转屏幕并更改视图控制器视图的大小，当大小改变时，<code>GLKView</code>对象相应调整帧缓冲区和绘图窗口的大小。如果需要响应这个更改，在<code>GLKViewController</code>的子类中实现<code>viewWillLayoutSubviews</code>或<code>viewDidLayoutSubviews</code>方法，如果使用自定义的<code>GLKView</code>子类则实现<code>layoutSubviews</code>。</p>\n<p>如果使用Core Animation层级绘制OpenGL ES的内容，应用程序也应该包含一个视图控制器来管理用户界面方向。</p>\n<h2 id=\"在外部显示器上显示opengl-es内容\">在外部显示器上显示OpenGL ES内容</h2>\n<p>一个iOS设备可以被连接到外部显示器，外部显示器的分辨率及其内容缩放因子可能与主屏幕的不同，渲染帧的代码应该调整以匹配。</p>\n<p>在外部显示器绘图的过程基本和主屏幕上的相同：</p>\n<ol>\n<li>按照<a href=\"https://developer.apple.com/library/archive/documentation/WindowsViews/Conceptual/WindowAndScreenGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40012555\" target=\"_blank\" rel=\"noopener\">Multiple Display Programming Guide for iOS</a>的步骤在外部显示器创建一个窗口。</li>\n<li>为渲染策略向窗口添加何时的视图或控制器；\n<ul>\n<li>如果使用GLKit渲染，设置<code>GLKViewController</code>和<code>GLKView</code>（或自定义子类）的实例并用<code>rootViewController</code>属性添加到窗口；</li>\n<li>如果渲染到Core Animation层级，添加包含层级的视图作为窗口的子视图。使用动画循环来渲染，通过检索窗口的<code>screen</code>属性并调用<code>dispalyLinkWithTarget:slector:</code>方法创建一个外部显示器优化的显示链接对象。</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"opengl-es-design-guidelines\">OpenGL ES Design Guidelines</h1>\n<p>现在我们已经掌握了在iOS应用中使用OpenGL ES的基础，使用这章下的信息帮助我们设计更优性能的渲染引擎。这一章节介绍了渲染器设计的关键概念；后面的内容将用特定的最佳实践和性能技术对这些信息扩展。</p>\n<h2 id=\"如何可视化opengl-es\">如何可视化OpenGL ES</h2>\n<p>本节描述了可视化OpenGL ES设计的两个方面：作为客户端-服务器架构和作为管线。这两方面在计划和评估应用程序的体系结构都非常有用。</p>\n<h3 id=\"opengl-es作为客户端-服务器架构\">OpenGL ES作为客户端-服务器架构</h3>\n<p>应用程序与OpenGL ES客户端通信状态改变、纹理和顶点数据、渲染命令。客户端将这些数据转换成图形硬件理解的格式，并发送到GPU，这些进程会增加应用程序图形性能的开销。</p>\n<p><img src=\"/img/article/20190519/9.png\" alt=\"OpenGL ES client-server architecture\"></p>\n<p>要获得出色的性能需要小心管理这些开销。一个优秀设计的应用程序减少对OpenGL ES的调用频率，使用硬件合适的数据格式来降低转换成本，并小心管理和OpenGL ES之间的数据流。</p>\n<h3 id=\"opengl-es作为图形管线\">OpenGL ES作为图形管线</h3>\n<p>应用程序配置图形管线，然后执行绘图命令将顶点数据发送到管线中。管线的后续阶段运行顶点着色器处理顶点数据，将顶点数据组装成基本类型，将基本类型光栅化为片段，运行片段着色器来计算每个片段的颜色和深度值，并将片段混合到帧缓冲区显示。</p>\n<p><img src=\"/img/article/20190519/10.png\" alt=\"OpenGL ES graphics pipline\"></p>\n<p>使用管线作为一个心理模型来识别应用程序执行什么工作来生成一个新帧。我们的渲染器设计包含编写着色器程序处理管线的顶点和片段阶段，组织提供给这些程序的顶点和纹理数据，以及配置OpenGL ES状态机来驱动管线的固定功能的阶段。</p>\n<p>图形管线的各个阶段可以同时计算它们的结果–例如，应用程序可能准备了新的基础类型而图形硬件的各个部分还在对之前提交的几何图形执行顶点和片段计算，但是，后期阶段取决于先前阶段的输出，所以如果任何管道阶段执行过多任务或运行太慢，其他管线阶段将处于空闲状态知道最慢的完成工作。一个优秀设计的应用程序应可以根据图形硬件功能平衡每个管道阶段的工作。</p>\n<blockquote>\n<p>所以当我们调整应用程序性能时，第一步通常确定它处于哪个位置，以及会遇到哪些瓶颈。</p>\n</blockquote>\n<h2 id=\"opengl-es版本和渲染器架构\">OpenGL ES版本和渲染器架构</h2>\n<p>iOS支持3中OpenGL ES版本。最新版本提供更多的灵活，允许我们自主实现渲染包含高质量视觉效果而不影响性能的算法。</p>\n<h3 id=\"opengl-es-30\">OpenGL ES 3.0</h3>\n<p>OpenGL ES 3.0是iOS 7之后的新版本。应用程序可以使用OpenGL ES 3.0中引入的特性来实现高级的图形编程技术（以前只能用于桌面级硬件和游戏控制台）从而获得更快的图形性能和引人注目的视觉效果。更多见<a href=\"http://www.khronos.org/registry/OpenGL/index_es.php\" target=\"_blank\" rel=\"noopener\">OpenGL ES API Registry</a>。<br>\n<a href=\"https://developer.apple.com/library/archive/documentation/3DDrawing/Conceptual/OpenGLES_ProgrammingGuide/OpenGLESApplicationDesign/OpenGLESApplicationDesign.html#//apple_ref/doc/uid/TP40008793-CH6-SW13\" target=\"_blank\" rel=\"noopener\">OpenGL ES 3.0</a></p>\n<h3 id=\"opengl-es-20\">OpenGL ES 2.0</h3>\n<h3 id=\"opengl-es-10\">OpenGL ES 1.0</h3>\n<h2 id=\"设计高性能的opengl-es应用程序\">设计高性能的OpenGL ES应用程序</h2>\n<p>总结下，一个优秀设计的OpenGL ES应用程序需要：</p>\n<ul>\n<li>利用OpenGL ES管线中的并行性</li>\n<li>管理应用程序和图形硬件之间的数据流</li>\n</ul>\n<p>下图展示了一个使用OpenGL ES执行动画显示的应用程序流程：</p>\n<p><img src=\"/img/article/20190519/11.png\" alt=\"App model for managing resources\"></p>\n<p>当应用程序启动时，要做的第一件事是初始化不打算在生命周期中更改的资源。理想情况下，应用程序将这些资源封装到OpenGL ES的对象中，目标是创建任何在应用程序运行期间保持不变的对象（甚至是应用程序生命周期的一部分，如游戏关卡的持续时间），以增加的初始化时间交换更好的渲染性能。复杂的命令或状态改变应该替换为能与单个函数调用一起使用的OpenGLES对象，比如，配置固定函数管线可能需要几十个函数调用。相反，在初始化阶段编译一个图形着色器，并在运行时通过一个函数调用切换到它。创建或者修改开销较大的OpenGL ES对象应该总是作为静态对象创建。</p>\n<p>渲染循环处理我们打算渲染给OpenGL ES上下文的所有项，然后将结果呈现给显示器。在动画场景中，一些数据每一帧都在更新，在上图所示的内部渲染循环中，应用程序在更新渲染资源（在进程中创建或修改OpenGL ES对象）和提交这些资源的绘图命令之间切换。这个内部循环的目标是平衡工作负载让CPU和GPU并行工作，防止应用程序和OpenGL ES同时使用相同的资源。在iOS中，如果不在帧的起始或结束时执行修改OpenGL ES对象，那么修改的代价会非常高。</p>\n<p>这个内部循环的一个重要目标是避免将数据从OpenGL ES拷贝回应用程序，将结果从GPU拷贝到CPU会非常慢。如果拷贝的数据同样用于后续渲染当前帧过程的一部分（如上图的渲染循环中展示的），应用程序会被阻塞知道所有之前提交的绘图命令完成。</p>\n<p>在应用程序提交帧所需要的所有绘图命令，然后将结果呈现到屏幕上。非交互式哟哟欧诺个程序会将最终图片拷贝到应用程序内存中进行下一步处理。</p>\n<p>最终，当应用程序准备退出或结束主要工作，将释放OpenGL ES对象获取更多的可用资源。</p>\n<p>总结本设计的重要特点：</p>\n<ul>\n<li>在任何可能情况下创建静态资源；</li>\n<li>内部渲染循环在修改动态资源和提交渲染命令之间切换，尝试避免在帧的起始或结束之外的时间修改动态资源；</li>\n<li>避免将中间渲染结果读取回应用程序；</li>\n</ul>\n<p>本节后面的部分提供了游泳的变成技术来实现这个渲染循环的特性。</p>\n<h3 id=\"避免同步和flush操作\">避免同步和Flush操作</h3>\n<p>OpenGL ES规范不要求实现立即执行命令。通常情况，命令被排队到命令缓冲区，后面由硬件执行。OpenGL ES会等到应用程序许多命令在队列中后发送到硬件–批处理更加有效，但是，一些OpenGL ES函数必须立即刷新命令缓冲区，其他函数不仅刷新命令缓冲区，还会阻塞直到之前的命令完成才返回对应用和程序的控制。只有在必要时才使用刷新和同步命令，过度使用刷新或同步命令会导致应用程序等待硬件结束渲染时停止。</p>\n<p>下面这些情况需要OpenGL ES将命令缓冲区提交给硬件执行：</p>\n<ul>\n<li><code>glFlush</code>函数将命令缓冲区提交到图形硬件，它会阻塞到命令被提交到硬件但不用等到命令执行结束；</li>\n<li><code>glFinish</code>函数刷新命令缓冲区，然后等待所有之前提交的命令在图像硬件上执行结束；</li>\n<li>检索帧缓冲区内容的函数（如<code>glReadPixels</code>）同样要等待提交的命令完成；</li>\n<li>命令缓冲区已满；</li>\n</ul>\n<h4 id=\"有效利用glflush\">有效利用glFlush</h4>\n<p>在一些桌面OpenGL的实现中，定期调用<code>glFlush</code>函数可以有效平衡CPU和GPU的工作，但在iOS中并非如此。iOS图像硬件实现的延迟算法依赖于一次性缓存所有场景中的顶点数据，因此可以对其进行最有处理，去除隐藏表面。通常，OpenGL ES应用程序只有两种情况下调用<code>glFlush</code>或<code>glFinish</code>函数：</p>\n<ul>\n<li>应用程序在进入后台时需要刷新命令缓冲区，因为应用程序在后台时执行OpenGL ES命令会导致iOS崩溃；</li>\n<li>如果应用程序在多个上下文共享OpenGL ES对象（如顶点缓存或纹理），我们需要调用<code>glFlush</code>函数同步使用这些资源。例如，在一个上下文加载顶点数据之后调用<code>glFlush</code>函数，以确保内容准备被其他上下文检索。当与其他iOS APIs（如Core Image）共用OpenGL ES对象时也可以使用这个建议；</li>\n</ul>\n<h4 id=\"避免查询opengl-es状态\">避免查询OpenGL ES状态</h4>\n<p>调用<code>glGet*()</code>，包括<code>glGetError()</code>，可能需要OpenGL ES在检索任何状态变量之前执行之前的命令。这种同步会强迫图形硬件和CPU同步运行，减少了并行性的机会。为了避免这种情况，维护自己需要查询任意状态的副本，直接访问它而不是调用OpenGL ES。</p>\n<p>当错误发生时，OpenGL ES设置一个错误标识。这些错误和其他错误出现在的Xcode或OpenGL ES分析器的帧调试器中。应该使用这些工具而不是使用<code>glGetError</code>函数，如果频繁调用会降低性能。其他查询（例如<code>glCheckFramebufferStatus()</code>，<code>glGetProgramInfoLog()</code>，<code>glValidateProgram()</code>）通常也只在开发和调试中有用。</p>\n<h3 id=\"使用opengl-es管理资源\">使用OpenGL ES管理资源</h3>\n<p>许多OpenGL数据可以直接存储到OpenGL ES渲染上下文和与之关联的共享组中。OpenGL ES的实现可以自由将数据转换为适合图形硬件的格式，这可以显著提高性能，特别对于不经常更改的数据。应用程序还可以向OpenGL ES提供如何使用数据的提示，OpenGL ES的实现可以更有效使用这些提示处理数据。例如，静态数据可能被放置在图像处理器可以轻松获取的内存中，甚至可以放置在专用的图形内存中。</p>\n<h3 id=\"使用双重缓冲避免资源冲突\">使用双重缓冲避免资源冲突</h3>\n<p>当应用程序和OpenGL ES同时访问一个OpenGL ES对象时会发生资源冲突。当一个参与者尝试修改对象而另一个参与者正在使用，他们可能会阻塞直到该对象不再被使用。一旦他们开始修改对象，其他参与者可能在修改完成之前都无法使用。或者，OpenGL ES可以隐式复制对象，以便两个参与者都可以继续执行命令。任何一个选项都是安全的，但是每个都有可能成为应用程序的瓶颈。下图展示了这个问题，在这个例子中，只有一个纹理对象，OpenGL ES和应用程序都想使用它，当应用程序尝试修改纹理，它必须等待之前提交的绘图命令完成–CPU和GPU同步。</p>\n<p><img src=\"/img/article/20190519/12.png\" alt=\"Single-buffered texture data\"></p>\n<p>为了解决这个问题，应用程序可以在修改和绘制该对象之间执行额外的工作。但是，如果应用程序没有额外的工作可以执行，它应该显示创建两个大小相同的对象；一个参与者读取对象，另一个参与者修改另一个。下图展示了双缓冲方法，当GPU处理一个纹理时，CPU修改另一个。在初始化启动之后，CPU和GPU都不会处于空闲状态。虽然显示了纹理，这个解决方案几乎适用于任何类型的OpenGL ES对象。</p>\n<p><img src=\"/img/article/20190519/13.png\" alt=\"Double-buffered texture data\"></p>\n<p>对于大多数应用程序双缓冲区已经足够，但它要求两个参与者几乎同时完成处理命令。为了避免阻塞，可以添加更多的缓冲区；这实现了传统的生产者-消费者模型。如果生产者在消费者之前完成处理命令，它将接受一个空闲缓冲区并继续处理命令。在这种情况下，只有消费者严重落后，生产者才会停止生产。</p>\n<p>双缓冲区和三缓冲区需要消耗额外的内存以防止管道停滞，额外使用内存可能会对应用程序的其他部分造成压力。在iOS设备中，内存稀缺；所以设计必须和其他应用程序优化平衡以使用更多的内存。</p>\n<h3 id=\"注意opengl-es的状态\">注意OpenGL ES的状态</h3>\n<p>OpenGL ES的实现维护了一份复杂的状态数据，包括使用<code>glEnable</code>或<code>glDisable</code>函数设置的开关、当前着色器程序以及其统一变量、当前绑定的纹理图元、当前绑定的顶点缓存及其启用的顶点属性。硬件有一个当前状态，它被缓存并懒加载。切换状态是昂贵的，所以最好减少状态切换。</p>\n<p>不要设置以及设置的状态。一旦启用某个特性就不用再启用。比如，如果多次调用相同参数的<code>glUniform</code>函数，OpenGL ES可能不会检查已经设置的相同的状态，它只是简单的更新状态值，即使值相同。</p>\n<p>避免使用专用的设置或关闭过程设置不必要的状态，而不是将这类调用放入绘图循环。设置和关闭过程对于开启关闭实现特定视觉效果的特性很有用–例如，当绘制线框轮廓线围绕有纹理的多边形时。</p>\n<h4 id=\"使用opengl-es对象封装状态\">使用OpenGL ES对象封装状态</h4>\n<p>要减少状态更改，创建一个对象，将多个OpenGL ES状态更改收集到一个对象，该对象可以使用一个函数绑定。例如，顶点数组对象将多个顶点属性的配置存储到一个对象中。见<a href=\"%E4%BD%BF%E7%94%A8%E9%A1%B6%E7%82%B9%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1%E5%90%88%E5%B9%B6%E9%A1%B6%E7%82%B9%E6%95%B0%E7%BB%84%E7%8A%B6%E6%80%81%E6%9B%B4%E6%94%B9\">使用顶点数组对象合并顶点数组状态更改</a>。</p>\n<h4 id=\"组织绘图调用最小化状态更改\">组织绘图调用最小化状态更改</h4>\n<p>OpenGL ES的状态更改的效果没有立即生成。相反，当我们发出绘图指令时，OpenGL ES将执行绘制状态值所需的工作。通过减少状态更改，我们可以减少CPU用于配置图形管线的时间。例如，在应用程序中保留一个状态向量，并且只有在绘制调用之间的状态发生时才设置相应的OpenGL ES状态。另一个有用的算法是状态排序–跟踪我们需要做的绘图操作和每个操作所需的状态更改量，然后对它们排序，以便连续使用相同的状态执行操作。</p>\n<p>OpenGL ES的iOS实现可以缓存它在状态之间高效切换所需的一些配置数据，但每个唯一状态集的初始配置需要更长的时间。为了保持一致的性能，我们可以在配置过程中“预热”计划使用的每个状态：</p>\n<ul>\n<li>启用计划使用的状态配置或着色器；</li>\n<li>使用状态配置绘制少量顶点；</li>\n<li>刷新OpenGL ES上下文，以便在预热阶段不显示绘图；</li>\n</ul>\n<h1 id=\"best-practices-for-working-with-vertex-data\">Best Practices for Working with Vertex Data</h1>\n<p>要使用OpenGL ES渲染帧，应用程序需要配置图形管线并提交要绘制的图形图元。在一些应用中，所有的图元都是使用同样的管线配置绘制；其他应用可能使用不同的技术渲染不同的帧元素。但无论应用程序使用的哪个图元，管线如何配置，应用程序都需要向OpenGL ES提供顶点。本章提供了一个关于顶点的课程并就如何有效处理顶点数据提供了针对性的建议。</p>\n<p>顶点由一个或多个属性组成，例如位置、颜色、法线或纹理坐标。OpenGL ES 2.0或3.0应用程序可以自由定义自己的属性；顶点数据的每个属性对应于作为顶点着色器的属性变量。OpenGL ES 1.1的应用程序使用固定管线定义好的属性。</p>\n<p>将一个属性定义为由一到四个组件构成的向量，属性中的所有组件共享一个公共数据类型。例如，一个颜色可能被定义为四个<code>GLubyte</code>组件（r,g,b,a）。当一个属性被加载到着色器变量中时，OpenGL ES使用默认值填充所有应用程序未提供的组件数据。最后一个组件被填充为1，其他未指定组件为0，如下图所示：</p>\n<p><img src=\"/img/article/20190519/14.png\" alt=\"Conversion of attribute data to shader variables\"></p>\n<p>应用程序可能将一个属性配置为常量，这意味着对于作为绘图命令部分提交的所有顶点使用相同的值，又意味着每个顶点都是该属性的值。当应用程序调用OpenGL ES的函数绘制一组顶点时，顶点数据被拷贝到图形硬件。处理顶点数据的图形硬件，在着色器处理每个顶点，组装图元并将它们光栅化到帧缓冲区。OpenGL ES的一个优点在于将提交到OpenGL ES顶点数据的一组函数标准化，移除OpenGL ES提供的陈旧和低效的机制。</p>\n<p>应用程序必须提交大量图元来渲染一帧，需要小心管理它们的顶点数据和如何提交到OpenGL ES。本章所述的做法可以概括为以下几个基本原则：</p>\n<ul>\n<li>减少顶点数据的大小；</li>\n<li>减少OpenGL ES将顶点数据传输到图形硬件之前的预处理；</li>\n<li>减少拷贝顶点数据到图形硬件花费的时间；</li>\n<li>减少对每个顶点的计算；</li>\n</ul>\n<h2 id=\"简化模型\">简化模型</h2>\n<p>基于iOS设备的图形硬件很强大，但它显示的图片一般很小。我们不需要非常复杂的模型在iOS上呈现引人注目的图形。减少用于绘制模型的顶点数量可以直接减少顶点的数据和对顶点数据执行的计算。</p>\n<p>我们可以使用以下技术降低模型的复杂度：</p>\n<ul>\n<li>在不同细节级别提供不同版本的模型，并在运行时基于到摄像机的距离和显示的尺寸渲染合适的模型；</li>\n<li>使用纹理来消除对某些顶点信息的需要。例如，凹凸贴图可以用来在不添加更多顶点数据的情况下向模型添加细节；</li>\n<li>一些模型添加顶点改进光照细节或渲染质量。这通常是在计算每个顶点的值并在光栅化阶段对三角形进行插值完成的。例如，如果我们将聚光灯指向三角形的中心，它的效果可能被忽略，因为聚光灯醉了的部分不是指向一个顶点。通过添加顶点，我们可以额外提供插值点，代价是增加顶点数据的大小和模型上执行的计算。如果不想要添加额外的顶点，考虑将计算移动到管线的片段阶段：\n<ul>\n<li>如果应用程序使用OpenGL ES 2.0或之后的版本，应用程序在顶点着色器执行计算并将其分配给一个可变变量。变化的值由图形硬件插值并作为输入传递到片段着色器。相反，将计算的输入分配给变量并在片段着色器执行计算。这样做会将执行计算的成本从每个顶点的成本到每个片段的成本，从而减少顶点阶段的压力并增加管线片段阶段的压力。当应用程序在顶点处理时被阻塞，这样做，计算是相对廉价的并可以通过更改显著减少顶点数。</li>\n<li>如果应用程序使用OpenGL ES 1.1，我们可以使用DOT3照明来执行各个片段的光照。我们可以通过添加凹凸贴图纹理来保存正常信息，并使用<code>GL_DOT3_RGB</code>模式的纹理组合操作应用凹凸贴图。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"避免在属性数组中存储常量\">避免在属性数组中存储常量</h2>\n<p>如果模型中包含在这个模型中使用保持不变的数据的属性，则不要为每个顶点复制该数据。OpenGL ES 2.0和3.0应用程序可以设置一个常量顶点属性或使用一个统一的着色器值来保存该值。OpenGL ES 1.1应用程序应该使用每个顶点的属性函数，如<code>glColor4ub</code>或<code>glTexCoord2f</code>。</p>\n<blockquote>\n<p>待更新…</p>\n</blockquote>\n<h1 id=\"reference\">Reference</h1>\n<blockquote>\n<p><a href=\"https://developer.apple.com/library/archive/documentation/3DDrawing/Conceptual/OpenGLES_ProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008793-CH1-SW1\" target=\"_blank\" rel=\"noopener\">About OpenGL ES</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1>Introduction</h1>\n<p>Open Graphics Library(OpenGL)用于可视化2D与3D数据，是多用途的开放标准图形库，支持2D和3D数字内容创建、机械和建筑设计、虚拟原型、飞行仿真、视频游戏等等。我们可以使用OpenGL配置3D图形管线并向其提交数据。顶点被转换点亮，组装成基本类型，并进行栅格化来创建2D图片。OpenGL的设计目的是将函数调用转换为可以发送到底层图形硬件的图形命令，因为底层硬件专门处理图形命令，所以OpenGL的绘图非常快。</p>\n<p>OpenGL for Embedded Systems(OpenGL ES)是openGL的简化版，消除冗余功能，为移动图形硬件上提供一个更容易学习和实现的库。</p>\n<p><img src=\"/img/article/20190519/1.png\" alt=\"OpenGL ES\"></p>\n<p>OpenGL ES允许应用程序利用底层图形处理器的能力，iOS设备上的GPU可以实现复杂的2D和3D绘图，以及图片上每个像素阴影的复杂计算。如果应用程序的而设计要求需要对GPU硬件有直接全面的访问，那么我们应该使用OpenGL ES。OpenGL ES典型的客户端包括视频游戏和呈现3D图形的模拟器。</p>\n<h1>Checklist for Building OpenGL ES Apps for iOS</h1>\n<p>OpenGL ES为使用GPU硬件渲染图形规范定义了无关平台的API。实现OpenGL ES的平台提供了一个用于执行OpenGL ES命令的渲染上下文，持有渲染结果的帧缓冲区，一个或多个展示帧缓冲区内容的渲染目标。iOS中，<em>EAGLContext</em>实现了渲染上下文，iOS只提供了一种帧缓冲区类型，OpenGL ES帧缓冲区对象，和实现渲染地点的<em>GLKView</em>、<em>CAEAGLLayer</em>。</p>\n<p>在iOS中创建OpenGL ES应用需要有以下考虑，一些对于OpenGL ES编程通用的，还有一些是iOS特定的考虑：</p>\n<ol>\n<li>决定适用于我们应用的OpenGL ES版本，创建上下文；</li>\n<li>在运行时检测设备是否支持我们想要使用的OpenGL ES功能；</li>\n<li>选择渲染OpenGL ES内容的位置；</li>\n<li>确定应用在iOS中正确运行；</li>\n<li>实现渲染引擎；</li>\n<li>使用Xcode和Instruments调试OpenGL ES应用，调优以获取最优性能；</li>\n</ol>\n<h2>选择OpenGL ES版本</h2>\n<p>决定应用需要支持OpenGL ES 3.0，OpenGL ES 2.0，OpenGL ES 1.1还是多个版本：</p>\n<ul>\n<li>OpenGL ES 3.0是在iOS 7的新版本，增加了许多新特性，实现高性能、通用GPU计算技术和之前只能在台式机和游戏机上才能实现的更复杂视觉效果</li>\n<li>OpenGL ES 2.0是iOS设备的基础配置，具有基于可编程着色器的可配置图形管线</li>\n<li>OpenGL ES 1.1仅提供基本的固定函数的图形通道，在iOS中主要用于向后兼容</li>\n</ul>\n<p>我们应该针对最相关的特性和应用程序的设备选择一个或多个版本，关于iOS设备功能更多可见<a href=\"https://developer.apple.com/library/archive/documentation/DeviceInformation/Reference/iOSDeviceCompatibility/Introduction/Introduction.html#//apple_ref/doc/uid/TP40013599\" target=\"_blank\" rel=\"noopener\">iOS Device Compatibility Reference</a></p>\n<h2>验证OpenGL ES功能</h2>\n<p><a href=\"https://developer.apple.com/library/archive/documentation/DeviceInformation/Reference/iOSDeviceCompatibility/Introduction/Introduction.html#//apple_ref/doc/uid/TP40013599\" target=\"_blank\" rel=\"noopener\">iOS Device Compatibility Reference</a>总结了在已发布iOS设备中可用的功能和扩展，但是，为了让应用程序能够在尽可能多的设备和iOS版本上运行，我们应该始终在运行时查询OpenGL ES可以实现的功能。</p>\n<p>要确定实现的特定限制，比如最大纹理大小或顶点属性的最大数量，使用相应的<code>glGet</code>方法查找对应的值（如在<em>gl.h</em>文件查找<em>MAX_TEXTURE_SIZE</em>或<em>MAX_VERTEX_ATTRIBS</em>）。</p>\n<p>使用<code>glGetIntegerv</code>和<code>glGetStringi</code>方法检测OpenGL ES 3.0的扩展：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// #import &lt;OpenGLES/ES3/gl.h&gt;</span></span><br><span class=\"line\"><span class=\"built_in\">BOOL</span> CheckForExtensions(<span class=\"built_in\">NSString</span> *searchName) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> max = <span class=\"number\">0</span>;</span><br><span class=\"line\">    glGetIntegerv(GL_NUM_EXTENSIONS, &amp;max);</span><br><span class=\"line\">    <span class=\"built_in\">NSMutableSet</span> *extensions = [<span class=\"built_in\">NSMutableSet</span> set];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; max; i++) &#123;</span><br><span class=\"line\">        [extensions addObject:@((<span class=\"keyword\">char</span> *)glGetStringi(GL_EXTENSIONS, i))];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [extensions containsObject:searchName];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/// 对于OpenGL ES 2.0和1.1的扩展，使用glGetString(GL_EXTENSIONS)获取以空格分隔的所有扩展名</span></span><br></pre></td></tr></table></figure>\n<h2>选择渲染位置</h2>\n<p>iOS中，帧缓冲区对象存储了绘图命令的结果，我们可以通过以下多种方式使用帧缓冲区对象的内容：</p>\n<ul>\n<li><em>GLKit</em>框架提供了绘制OpenGL ES内容和管理自身帧缓冲区的view，和支持动画的控制器。使用这些类创建全屏视图或将OpenGL ES内容放入UIKit视图层次结构中。<a href=\"#drawing-with-opengl-es-and-glkit\">Drawing with OpenGL ES and GLKit</a></li>\n<li><em>CAEAGLLayer</em>类提供绘制OpenGL ES内容作为Core Animation层级组合一部分的方法，但我们必须使用这个类创建自己的帧缓冲区</li>\n<li>与任意OpenGL ES实现一样，我们也可以使用帧缓冲区进行离屏图形处理或渲染图像管线其他地方使用的纹理。在OpenGL ES中，离屏缓冲区可以用于使用多个渲染目标的渲染算法</li>\n</ul>\n<p>更多关于离屏缓冲区、纹理、Core Animation层级的渲染，前往<a href=\"#drawing-to-other-rendering-destinations\">Drawing to Other Rendering Destinatons</a></p>\n<h2>iOS集成</h2>\n<p>iOS应用默认支持多任务，但在OpenGL ES应用内处理这个特性需要额外考虑，不正确使用OpenGL ES会导致应用在后台被系统杀死。</p>\n<p>许多iOS设备包含高分辨率显示，所以我们需要支持多种显示尺寸和分辨率。</p>\n<p>了解如何支持这些和其他iOS特性，前往<a href=\"#multitasking,-high-resolution,-and-other-ios-features\">Multitasking, High Resolution, and Other iOS Features</a>。</p>\n<h2>实现渲染引擎</h2>\n<p>设计OpenGL ES绘图代码有许多可能的策略，其详细信息超出了文本的范围。渲染引擎设计的许多方面对于OpenGL和OpenGL ES的所有实现都是通用的。</p>\n<p>更多iOS设备设计考虑前往<a href=\"#opengl-es-design-guidelines\">OpenGL ES Design Guidelines</a>和<a href=\"#concurrency-and-opengl-es\">Concurrency and OpenGL ES</a>。</p>\n<h2>调试与性能分析</h2>\n<p>Xcode和Instruments提供了许多工具来跟踪渲染问题并分析OpenGL ES的性能，前往<a href=\"#debugging-and-profiling\">Debugging and Profiling</a>。</p>\n<h1>Configuring OpenGL ES Contexts</h1>\n<p>每个OpenGL ES的实现提供了创建管理OpenGL ES规范所需要状态的渲染上下文的方法，通过在上下文的状态，多个应用可以轻松地共享图形硬件而不会干扰其他应用程序的状态。</p>\n<p>在我们使用OpenGL ES方法前，必须初始化<em>EAGLContext</em>对象，<em>EAGLContext</em>类还提供将OpenGL ES内容与Core Animation集成的方法。</p>\n<h2>当前上下文是OpenGL ES函数调用的目标</h2>\n<p>iOS应用每个线程都有一个当前上下文，当我们调用OpenGL ES的方法时，这个就是状态要被更改的上下文。</p>\n<p>设置当前线程上下文，在对应线程调用<code>setCurrentContext:</code>方法：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[EAGLContext setCurrentContext:context];</span><br></pre></td></tr></table></figure>\n<p>调用<em>EAGLContext</em>类方法<code>currentContext</code>来检索当前线程的上下文。</p>\n<blockquote>\n<p>如果在相同线程切换两种或以上上下文，在设置新的当前上下文之前调用<code>glFlush</code>方法确保之前提交的命令能及时交付给图形硬件。</p>\n</blockquote>\n<p>OpenGL ES对当前上下文<em>EAGLContext</em>对象持有强引用，当调用<code>setCurrentContext:</code>方法切换上下文则不会对之前的对象强持有，为了防止<em>EAGLContext</em>对象在切换时被释放，我们应该对之强引用。</p>\n<h2>每个上下文都针对OpenGL ES的特定版本</h2>\n<p>一个<em>EAGLContext</em>对象仅支持OpenGL ES的一个版本。例如：OpenGL ES 1.1版本下的代码不兼容2.0或3.0版本；使用OpenGL ES 2.0版本特性的版本兼容3.0版本，同时2.0版本的扩展经常可以在3.0版本中少量修改后使用；OpenGL ES 3.0的特性和新增的硬件性能需要3.0版本。</p>\n<p>我们在创建和初始化<em>EAGLContext</em>对象时选择OpenGL ES的版本。如果设备不支持对应的版本，会返回nil，我们必须保证正确初始化之后使用它。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EAGLContext* CreateBestEAGLContext() &#123;</span><br><span class=\"line\">    EAGLContext *context = [[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES3];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (context == <span class=\"literal\">nil</span>) &#123;</span><br><span class=\"line\">        context = [[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES2];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> context;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2>EAGL Sharegroup</h2>\n<p>尽管上下文持有OpenGL ES的状态，但它不直接管理OpenGL ES的对象。相反，可以通过<em>EAGLSharegroup</em>对象创建和持有OpenGL ES对象，每个上下文都包含一个被委托创建对象的<em>ESGLSharegroup</em>对象。</p>\n<p>在两个或多个上下文引用一个共享组时优势很明显，这时创建OpenGL ES的对象在所有上下文都可用，如果绑定到另一个上下文与创建它的上下文有相同的标识符，则引用相同的OpenGL ES对象。移动设备的资源非常稀缺，在上下文创建多个相同内容的拷贝是浪费资源的，公共资源可以更好的利用设备的图形资源。</p>\n<p>sharegroup是一个不透明对象，没有可以调用的属性或方法，可以使用sharegroup对象的上下文对之进行强引用。</p>\n<p><img src=\"/img/article/20190519/2.png\" alt=\"OpenGL ES Sharegroup\"></p>\n<p>sharegroup在以下两种情况下最有用：</p>\n<ul>\n<li>上下文之间的大多数共享资源不会改变</li>\n<li>当我们想要在其他线程创建OpenGL ES对象而主线程用于渲染。例如：第二个上下文在单独的线程上用于获取数据和创建资源，加载资源后，第一个上下文可以绑定到对象并立即使用它。<em>GLKtextureLoader</em>类就是使用这个模式来提供异步纹理加载。</li>\n</ul>\n<p>想要创建引用相同sharegroup的上下文，第一个上下文使用<code>initAPI:</code>方法初始化后会自动创建sharegroup，第二个及后续上下文调用<code>initAPI:sharegroup:</code>使用第一个上下文的sharegroup进行初始化。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EAGLContext* firstContext = CreateBestEAGLContext();</span><br><span class=\"line\">EAGLContext* secondContext = [[EAGLContext alloc] initWithAPI:[firstContext API] sharegroup: [firstContext sharegroup]];</span><br></pre></td></tr></table></figure>\n<p>当sharegroup由多个上下文共享时，我们有责任管理OpenGL ES对象的状态更改：</p>\n<ul>\n<li>应用程序可以同时跨多个上下文访问未修改的对象</li>\n<li>当对象被发送到上下文的命令修改时，不能在其他地方读写该对象</li>\n<li>在对象修改后，所有上下文必须重新绑定才能看到更改。如果上下文在绑定之前引用该对象，则该对象的内容是未定义的</li>\n</ul>\n<p>下面是更新OpenGL ES对象的步骤：</p>\n<ul>\n<li>在可能使用对象的每个上下文调用<code>glFlush</code>方法</li>\n<li>在想要修改对象的上下文，调用一种或多种OpenGL ES方法修改对象</li>\n<li>在接收状态修改命令的上下文中调用<code>glFlush</code>方法</li>\n<li>在每个其他上下文，重新绑定标识符</li>\n</ul>\n<blockquote>\n<p>另一种共享对象的方法是使用一个渲染上下文，多个目标帧缓冲区。在渲染时，应用程序绑定合适的帧缓冲区并根据需要渲染帧，因为所有的OpenGL ES对象都是从一个上下文应用，所有会看到相同的OpengGL ES数据。这种模式使用的资源较少，但只适用于单线程应用程序，但单线程程序中可以仔细控制上下文状态。</p>\n</blockquote>\n<h1>Drawing with OpenGL ES and GLKit</h1>\n<p>GLKit框架提供了视图和控制器类，消除了绘画和动画OpenGL ES内容所需的设置和维护代码，<em>GLKView</em>类管理OpenGL ES的基础结构，为绘图代码提供空间，<em>GLKViewController</em>类提供一个渲染循环用于GLKit视图上平滑的展示OpenGL ES内容的动画。这些类扩展了用于绘制视图内容和管理视图呈现的标准UIKit设计模式。因此，我们可以将主要精力用于OpenGL ES渲染代码与应用流畅度上。GLKit框架同样提供简化OpenGL ES 2.0与3.0开发的其他特性。</p>\n<h2>GLKit视图根据需求绘制OpenGL ES内容</h2>\n<p><em>GLKView</em>类提供了一个基于OpenGL ES等价于标准UIView的绘图周期。<em>UIView</em>对象自动配置图形上下文，所以<code>drawRect:</code>实现只需要执行Quartz 2D的绘图命令，<em>GLKView</em>对象自动配置自己所以我们的绘图方法只需要执行OpenGL ES的绘图命令。<em>GLKView</em>类通过维护持有OpenGL ES绘图命令结果的帧缓冲区来提供此功能，然后在绘图方法返回时自动将他们呈现给Core Animation。</p>\n<p>与标准UIKit视图一样，GLKit视图按需渲染。当视图第一次显示，它调用我们的绘图方法–Core Animation缓冲区渲染输出并在视图显示时显示它。当我们想要修改视图内容，调用<code>setNeedsDisplay</code>方法，视图会重新调用我们的绘图方法，缓冲区结果图，在屏幕显示它。这个方法在渲染图像的数据修改很少或只响应用户操作时有用，只有在需要的时候渲染新视图内容，这样可以节约设备电量并为其他操作留出更多时间。</p>\n<p><img src=\"/img/article/20190519/3.png\" alt=\"Rending OpenGL ES content with a GLKit view\"></p>\n<h3>创建与配置GLKit View</h3>\n<p>我们可以以编程的方式创建配置一个GLKView对象，也可以用故事板，在绘图钱，我们需要与之关联<em>EAGLContext</em>对象。</p>\n<ul>\n<li>当以编程方式创建一个视图时，先创建一个上下文然后将它用于*initWithFrame:context:*方法</li>\n<li>当从故事板加载一个视图，创建一个上下文然后设置为这个视图的<em>context</em>属性</li>\n</ul>\n<p>一个GLKit视图自动创建和配置他自己的OpenGL ES帧缓冲区对象和渲染缓冲区。我们使用视图的绘图属性控制这些对象属性，当我们改变尺寸大小、比例系数、或者某个绘画属性，它会在下次内容绘制时自动删除和重新创建相应的帧缓冲区和渲染缓冲区对象。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</span><br><span class=\"line\">    </span><br><span class=\"line\">    EAGLContext *context = CreateBestEAGLContext();</span><br><span class=\"line\">    GLKView *glkView = [[GLKView alloc] initWithFrame:<span class=\"keyword\">self</span>.view.bounds context:context];</span><br><span class=\"line\">    <span class=\"comment\">// Configure renderbuffers</span></span><br><span class=\"line\">    glkView.drawableColorFormat = GLKViewDrawableColorFormatSRGBA8888;</span><br><span class=\"line\">    glkView.drawableDepthFormat = GLKViewDrawableDepthFormat24;</span><br><span class=\"line\">    glkView.drawableStencilFormat = GLKViewDrawableStencilFormat8;</span><br><span class=\"line\">    <span class=\"comment\">// enable multisampling</span></span><br><span class=\"line\">    <span class=\"comment\">// multisampling是一种消除锯齿边缘的反锯齿，在大多数3D应用程序中提高图形质量，代价是使用更多的内存和片段处理时间</span></span><br><span class=\"line\">    glkView.drawableMultisample = GLKViewDrawableMultisample4X;</span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.view addSubview:glkView];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3>使用GLKit View绘图</h3>\n<p>绘制OpenGL ES内容分为三步：准备OpenGL ES基础设施，执行绘图命令，将渲染内容提交给Core Animation显示。其中<em>GLKView</em>实现了第一步与第三步，下面代码实现了绘图的第二步：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)drawRect:(<span class=\"built_in\">CGRect</span>)rect &#123;</span><br><span class=\"line\">    <span class=\"comment\">// clear the framebuffer</span></span><br><span class=\"line\">    glClearColor(<span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">0.1</span>, <span class=\"number\">1.0</span>);</span><br><span class=\"line\">    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span><br><span class=\"line\">    <span class=\"comment\">// Draw using previously configured texture, shader, uniforms, and vertex array</span></span><br><span class=\"line\">    glBindTexture(GL_TEXTURE_2D, _planetTexture);</span><br><span class=\"line\">    glUseProgram(_diffuseShading);</span><br><span class=\"line\">    glUniformMatrix4fv(_uniformModelViewProjectionMatrix, <span class=\"number\">1</span>, <span class=\"number\">0</span>, _modelViewProjectionMatrix.m);</span><br><span class=\"line\">    glBindVertexArray(_planetMesh);</span><br><span class=\"line\">    glDrawElements(GL_TRIANGLE_STRIP, <span class=\"number\">256</span>, GL_UNSIGNED_SHORT, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><em>glClear</em>方法提示OpenGL ES任何现有的帧缓冲区内容都可以被丢弃，避免加载以前的内容到内存中造成高消耗内存操作。为了确保最佳性能，我们应该在每次绘图前总是调用这个函数</p>\n</blockquote>\n<p><em>GLKView</em>可以提供一些简单的接口给OpenGL ES绘图，因为它管理了OpenGL ES渲染过程中的标准部分：</p>\n<ul>\n<li>在调用绘图方法前，视图需要：\n<ul>\n<li>确保<em>EAGLContext</em>为当前上下文</li>\n<li>基于现有尺寸、比例系数、绘图属性创建帧缓冲区对象和渲染缓冲区（如有必要）</li>\n<li>将帧缓冲区对象绑定为绘制命令的当前目标</li>\n<li>设置OpenGL ES视图端口以匹配帧缓冲区大小</li>\n</ul>\n</li>\n<li>在绘图方法返回后，视图需要：\n<ul>\n<li>解析multisampling缓冲区（如果multisampling已设置）</li>\n<li>丢弃不再需要的渲染缓冲区</li>\n<li>将渲染缓冲区内容提交给Core Animation缓冲区和展示</li>\n</ul>\n</li>\n</ul>\n<h2>使用代理渲染</h2>\n<p>许多OpenGL ES应用程序使用自定义类实现渲染代码，这个方法的优势在于它能为多个渲染器分别定义不同的渲染类，从而轻松地支持多个渲染算法，共享公共功能的渲染算法可以从父类继承。例如，我们可以使用不同的渲染类同时支持OpenGL ES 2.0和3.0，或者使用它们在具有更强大硬件的设备上定制渲染，以获得更优质的图片。</p>\n<p>GLKit非常适合这种方法–我们可以使用渲染器对象成为标准GLKView实例的代理，没有使用继承GLKView和实现<code>drawInRect:</code>方法，而是使用渲染器类实现<em>GLKViewDelegate</em>代理并实现<code>glkView:drawInRect:</code>方法。下面代码演示了应用程序在启动时根据硬件特性选择渲染器类：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)application:(<span class=\"built_in\">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class=\"built_in\">NSDictionary</span> *)launchOptions &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Create a context</span></span><br><span class=\"line\">    EAGLContext *context = [[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES2];</span><br><span class=\"line\">    [EAGLContext setCurrentContext:context];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// Choose a rendering class based on device features</span></span><br><span class=\"line\">    GLint maxTextureSize;</span><br><span class=\"line\">    glGetIntegerv(GL_MAX_TEXTURE_SIZE, &amp;maxTextureSize);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (maxTextureSize &gt; <span class=\"number\">2048</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.renderer = [[MyBigTextureRenderer alloc] initWithContext:context];</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.renderer = [[MyRenderer alloc] initWithContext:context];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    GLKView *view = (GLKView *)<span class=\"keyword\">self</span>.window.rootViewController.view;</span><br><span class=\"line\">    view.delegate = <span class=\"keyword\">self</span>.renderer;</span><br><span class=\"line\">    view.context = context;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2>GLKit视图控制器动画OpenGL ES内容</h2>\n<p>默认情况下，一个<em>GLKView</em>对象按需渲染内容。也就是说，使用OpenGL ES绘图的一个关键优势是他能使用图形处理硬件对复杂场景进行连续动画–游戏和模拟器等应用程序很少使用静态图片。对于这些情况，<em>GLKit</em>框架提供一个视图控制器类，为它管理的<em>GLKView</em>对象维护一个动画循环，这个循环遵循游戏和模拟器中场景中常见的设计模式，分为两个阶段：更新与显示。下图展示了一个简单的动画循环示例：</p>\n<p><img src=\"/img/article/20190519/4.png\" alt=\"The animation loop\"></p>\n<h3>动画循环的理解</h3>\n<p>更新阶段，视图控制器调用它自身的<em>update</em>方法（或者当未继承GLKViewController时可以使用代理的<code>glkViewControllerUpdate:</code>方法），这个方法中，我们应该为下一帧绘图做准备。例如，一个游戏可能使用这个方法根据上一帧以来接受到的输入事件来决定玩家和敌对角色的位置，科学的可视化可以使用这种方法运行模拟的一个步骤。如果我们需要时间信息来决定应用程序下一帧的状态，使用这个视图控制器的其中一个时间属性比如<code>timeSinceLastUpdate</code>属性。</p>\n<p>展示阶段，试图控制器调用视图的<code>display</code>方法，这个方法会触发绘图方法。在绘图方法中，我们对GPU提交OpenGL ES的绘图指令来渲染我们的内容。为了最佳性能。我们的应用程序应该在渲染最新一帧时修改OpenGL ES对象，然后提交绘图指令。</p>\n<p>动画循环以视图控制器的<code>framesPerSecond</code>属性所指示的速率在这两个阶段切换，我们可以使用<code>preferredFramesPerSecond</code>属性来设置所需的帧速率–为了当前显示硬件的最优性能，视图控制器自动渲染接近于我们设置值的最优帧速率。</p>\n<blockquote>\n<p>为了获得最佳效果，选择一个应用程序可以达到的帧率。平滑、一致的帧率比经常变化的帧率能有更好的用户体验</p>\n</blockquote>\n<h3>使用GLKit视图控制器</h3>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">PlanetViewController</span> // <span class=\"title\">subclass</span> <span class=\"title\">of</span> <span class=\"title\">GLKViewController</span></span></span><br><span class=\"line\"> </span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">// Create an OpenGL ES context and assign it to the view loaded from storyboard</span></span><br><span class=\"line\">    GLKView *view = (GLKView *)<span class=\"keyword\">self</span>.view;</span><br><span class=\"line\">    view.context = [[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES2];</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">// Set animation frame rate</span></span><br><span class=\"line\">    <span class=\"keyword\">self</span>.preferredFramesPerSecond = <span class=\"number\">60</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">// Not shown: load shaders, textures and vertex arrays, set up projection matrix</span></span><br><span class=\"line\">    [<span class=\"keyword\">self</span> setupGL];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)update &#123;</span><br><span class=\"line\">    _rotation += <span class=\"keyword\">self</span>.timeSinceLastUpdate * M_PI_2; <span class=\"comment\">// one quarter rotation per second</span></span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">// Set up transform matrices for the rotating planet</span></span><br><span class=\"line\">    GLKMatrix4 modelViewMatrix = GLKMatrix4MakeRotation(_rotation, <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f, <span class=\"number\">0.0</span>f);</span><br><span class=\"line\">    _normalMatrix = GLKMatrix3InvertAndTranspose(GLKMatrix4GetMatrix3(modelViewMatrix), <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    _modelViewProjectionMatrix = GLKMatrix4Multiply(_projectionMatrix, modelViewMatrix);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)glkView:(GLKView *)view drawInRect:(<span class=\"built_in\">CGRect</span>)rect &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Clear the framebuffer</span></span><br><span class=\"line\">    glClearColor(<span class=\"number\">0.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">0.1</span>f, <span class=\"number\">1.0</span>f);</span><br><span class=\"line\">    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">// Set shader uniforms to values calculated in -update</span></span><br><span class=\"line\">    glUseProgram(_diffuseShading);</span><br><span class=\"line\">    glUniformMatrix4fv(_uniformModelViewProjectionMatrix, <span class=\"number\">1</span>, <span class=\"number\">0</span>, _modelViewProjectionMatrix.m);</span><br><span class=\"line\">    glUniformMatrix3fv(_uniformNormalMatrix, <span class=\"number\">1</span>, <span class=\"number\">0</span>, _normalMatrix.m);</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">// Draw using previously configured texture and vertex array</span></span><br><span class=\"line\">    glBindTexture(GL_TEXTURE_2D, _planetTexture);</span><br><span class=\"line\">    glBindVertexArrayOES(_planetMesh);</span><br><span class=\"line\">    glDrawElements(GL_TRIANGLE_STRIP, <span class=\"number\">256</span>, GL_UNSIGNED_SHORT, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p><code>viewDidLoad</code>方法创建了OpenGL ES上下文并提供给视图，同时设置动画循环的帧率。视图控制器自动成为视图的代理，同时实现动画循环的更新与显示阶段。在<code>update</code>方法中，它计算显示旋转行星所需的变换矩阵。在<code>glkView:drawInRect:</code>方法，它将这些矩阵提供给着色器程序，并提交绘制命令来渲染行星的几何形状。</p>\n<h1>Drawing to Other Rendering Destinations</h1>\n<p>帧缓冲区对象是渲染命令的目标。当创建一个帧缓冲区对象，我们可以精确控制它存储的颜色、深度和模板数据。我们通过将图片附加到帧缓冲区来提供这种存储，如下图所示。最常见的图片关联是渲染缓冲区对象。我们也可以将OpenGL ES的纹理附加到帧缓冲区的颜色连接点，这意味着所有的绘图命令都将渲染到纹理中。稍后，纹理可以作为未来渲染命令的输入。我们还可以在一个渲染上下文创建多个帧缓冲区对象，这么做可以在多个帧缓冲区之间共享相同的渲染管线和OpenGL ES资源。</p>\n<p><img src=\"/img/article/20190519/5.png\" alt=\"Famebuffer with color and depth renderbuffers\"></p>\n<p>所有这些方法都需要手动创建帧缓冲区和渲染缓冲区对象来存储OpenGL ES上下文的渲染结果，还需要编写额外的代码来将内容呈现到屏幕，如有必要还要运行一个动画循环。</p>\n<h2>创建帧缓冲区对象</h2>\n<p>根据应用程序打算执行的任务，将配置不同的对象附加到帧缓冲区对象。在多数情况下，配置帧缓冲区的区别在于对象被附加到对象的颜色连接点上：</p>\n<ul>\n<li>使用帧缓冲区用于离屏图像处理，附加一个渲染缓冲区。见<a href=\"#%E5%88%9B%E5%BB%BA%E7%A6%BB%E5%B1%8F%E7%BC%93%E5%86%B2%E5%8C%BA%E5%AF%B9%E8%B1%A1\">创建离屏缓冲区对象</a></li>\n<li>使用帧缓冲区图片作为后续渲染步骤的输入，附加一个纹理。见<a href=\"#%E4%BD%BF%E7%94%A8%E5%B8%A7%E7%BC%93%E5%86%B2%E5%8C%BA%E5%AF%B9%E8%B1%A1%E6%B8%B2%E6%9F%93%E7%BA%B9%E7%90%86\">使用帧缓冲区对象渲染纹理</a></li>\n<li>在Core Animation层级组合中使用帧缓冲区，使用特定Core Animation-aware渲染缓冲区。见<a href=\"#%E6%B8%B2%E6%9F%93%E5%88%B0Core-Animation%E5%B1%82%E7%BA%A7\">渲染到Core Animation层级</a></li>\n</ul>\n<h3>创建离屏缓冲区对象</h3>\n<p>用于离屏渲染的帧缓冲区分配内存给它所有的关联作为OpenGL ES的渲染缓冲区。下面代码分配内存给一个带有颜色和深度关联的帧缓冲区对象：</p>\n<ol>\n<li>创建帧缓冲区并绑定：</li>\n</ol>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GLuint framebuffer;</span><br><span class=\"line\">glGenFramebuffers(<span class=\"number\">1</span>, &amp;framebuffer);</span><br><span class=\"line\">glBindFramebuffer(GL_FRAMEBUFFER, framebuffer);</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>创建颜色渲染缓冲区，分配内存，与帧缓冲区的颜色连接点相关联：</li>\n</ol>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GLuint colorRenderbuffer;</span><br><span class=\"line\">glGenRenderbuffers(<span class=\"number\">1</span>, &amp;colorRenderbuffer);</span><br><span class=\"line\">glBindRenderbuffer(GL_RENDERBUFFER, colorRenderbuffer);</span><br><span class=\"line\">glRenderbufferStorage(GL_RENDERBUFFER, GL_RGBA, width, height);</span><br><span class=\"line\">glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_RENDERBUFFER, colorRenderbuffer);</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>创建一个深度或者深度/模板渲染缓冲区，分配内存，与帧缓冲区深度关联点相关联：</li>\n</ol>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GLuint depthRenderbuffer;</span><br><span class=\"line\">glGenRenderbuffers(<span class=\"number\">1</span>, &amp;depthRenderbuffer);</span><br><span class=\"line\">glBindRenderbuffer(GL_RENDERBUFFER, depthRenderbuffer);</span><br><span class=\"line\">glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH_COMPONENT16, width, height);</span><br><span class=\"line\">glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, depthRenderbuffer);</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>测试帧缓冲区的完整性，这个测试方法只需要在帧缓冲区配置改动时执行：</li>\n</ol>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GLenum status = glCheckFramebufferStatus(GL_FRAMEBUFFER);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (status != GL_FRAMEBUFFER_COMPLETE) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"failed to make complete framebuffer object %x\"</span>, status);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在绘图到离屏渲染缓冲区后，使用<code>glReadPixels</code>方法返回它的内容到CPU做进一步处理。</p>\n<h3>使用帧缓冲区对象渲染纹理</h3>\n<p>创建帧缓冲区的代码几乎与离屏实例一样，但现在是纹理分配内存并与颜色关联点相关联：</p>\n<ol>\n<li>创建帧缓存对象（与上例相似）；</li>\n<li>创建目标纹理，与帧缓冲区的颜色关联点相关联：</li>\n</ol>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GLuint texture;</span><br><span class=\"line\">glGenTextures(<span class=\"number\">1</span>, &amp;texture);</span><br><span class=\"line\">glBindTexture(GL_TEXTURE_2D, texture);</span><br><span class=\"line\">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);   <span class=\"comment\">// 纹理过滤</span></span><br><span class=\"line\">glTexImage2D(GL_TEXTURE_2D, <span class=\"number\">0</span>, GL_RGBA8, width, height, <span class=\"number\">0</span>, GL_RGBA, GL_UNSIGNED_BYTE, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, texture, <span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>分配缓存并关联深度缓冲区（与上例类似）；</li>\n<li>验证帧缓冲区的完整性；</li>\n</ol>\n<p>虽然这个例子假设我们正在渲染到颜色纹理，但也可以使用其他选项。例如，使用<em>OES_depth_texture</em>扩展，可以将纹理关联到深度关联点，以将场景中的深度信息存储到纹理。我们可以使用这个深度信息计算最终渲染场景中的阴影。</p>\n<h3>渲染到Core Animation层级</h3>\n<p>Core Animation是iOS上图形渲染和动画的核心基础设施，我们可以使用不同iOS子系统渲染的层级（如UIKit、Quartz 2D、OpenGL ES）来组合应用程序的用户界面或其他可视化显示。OpenGL ES通过<em>CAEAGLLayer</em>类关联Core Animation，这个类是一种特殊类的Core Animation层级，其内容来自OpenGL ES渲染缓冲区。Core Animation将渲染缓冲区的内容和其他层级组合在一起，并将结果图像显示在屏幕上。</p>\n<p><img src=\"/img/article/20190519/6.png\" alt=\"Core Animation shares the renderbuffer width OpenGL ES\"></p>\n<p><em>CAEAGLLayer</em>通过提供了两项关键功能为OpenGL ES提供支持。首先，它为渲染缓冲区分配内存共享存储，其次，它将渲染缓冲区呈现到Core Animation，用渲染缓冲区中的数据替换层级之前的内容。该模型的优点在于Core Animation层级不需要每一帧都绘制，只需要在渲染图像发生改变时绘制。</p>\n<blockquote>\n<p>GLKView类自动执行以下步骤，所以当我们想要在视图的内容层中使用OpenGL ES绘图时，应该使用它。</p>\n</blockquote>\n<p>使用Core Animation层级的OpenGL ES渲染：</p>\n<ol>\n<li>创建<em>CAEAGLLayer</em>对象并配置它的属性。想要最佳性能，设置层级的<em>opaue</em>属性为YES。可选，通过为<em>CAEAGLLayer</em>对象的<code>drawableProperties</code>属性分配一个新的字典来配置渲染表面的表面属性；可以指定渲染缓冲区的像素格式，并指定渲染缓冲区的内容在发送到Core Animation后是否被丢弃。有关允许的键列表，见<a href=\"https://developer.apple.com/documentation/opengles/eagldrawable?language=objc\" target=\"_blank\" rel=\"noopener\">EAGLDrawable Protocol Reference</a>；</li>\n<li>创建OpenGL ES上下文，并设置为当前上下文；</li>\n<li>创建帧缓冲区对象；</li>\n<li>创建颜色渲染缓冲区，调用<code>renderbufferStorage:fromDrawable:</code>方法分配存储内存并将层级对象作为参数传入。宽度、高度、像素格式都是从层级获取并用于渲染缓冲区的分配存储内存：</li>\n</ol>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GLuint colorRenderbuffer;</span><br><span class=\"line\">glGenRenderbuffers(<span class=\"number\">1</span>, &amp;colorRenderbuffer);</span><br><span class=\"line\">glBindRenderbuffer(GL_RENDERBUFFER, colorRenderbuffer);</span><br><span class=\"line\">[myContext renderbufferStorage:GL_RENDERBUFFER fromDrawable:myEAGLLayer];</span><br><span class=\"line\">glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_RENDERBUFFER, colorRenderbuffer);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>当Core Animation的层级<code>bounds</code>或属性改变时，必须重新分配渲染缓冲区存储内存。如果不重新分配内存，渲染缓冲区的大小可能不匹配层级的大小。</p>\n</blockquote>\n<ol start=\"5\">\n<li>检索颜色渲染缓冲区的高度和宽度：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GLuint width, height;</span><br><span class=\"line\">glGetRenderbufferParameteriv(GL_RENDERBUFFER, GL_RENDERBUFFER_WIDTH, &amp;width);</span><br><span class=\"line\">glGetRenderbufferParameteriv(GL_RENDERBUFFER, GL_RENDERBUFFER_HEIGHT, &amp;height);</span><br></pre></td></tr></table></figure>\n<p>在前面的示例中，显示地提供了渲染缓冲区的宽度和高度以便分配内存。这里，代码在分配存储内存后检索颜色渲染缓冲区的宽度和高度。应用程序之所以这样做，是因为颜色缓冲区的实际尺寸是根据层级的边界大小和缩放因子计算的。关联到帧缓冲区的渲染缓冲区必须具有相同的纬度。除了使用高度和宽度分配深度缓冲区内存，还可以用来分配OpenGL ES视图端口，并帮助确定应用程序的纹理和模型中所需的细节级别；</p>\n<ol start=\"6\">\n<li>分配缓存并关联深度缓冲区；</li>\n<li>验证帧缓冲区的完整性；</li>\n<li>通过将<em>CAEAGLLayer</em>对象传递给<code>addSublayer:</code>一个可见层级的方法添加到Core Animation的层级结构中。</li>\n</ol>\n<h2>绘制到帧缓冲区对象</h2>\n<p>现在我们已经拥有了一个帧缓冲区对象，然后就是填充。下面介绍了渲染新帧并呈现给用户所必要的步骤，渲染到纹理或离屏帧缓冲区的行为类似，只是应用程序使用最终帧的方式不同。</p>\n<h3>按需或使用动画循环渲染</h3>\n<p>我们在渲染到一个Core Animation层级时必须选择何时绘制我们的OpenGL ES内容，就像使用GLKit视图和控制器绘图一样。如果渲染到离屏帧缓冲区或纹理，则在适合使用这些帧缓冲区类型的情况下随时绘制。</p>\n<p>对于on-demand绘制，实现我们自己的方法绘制并呈现渲染缓冲区，并在需要显示新内容的时候调用它。</p>\n<p>对于动画循环绘制，使用<code>CADisplayLink</code>对象。<code>displayLink</code>是由Core Animation提供的一种定时器，允许我们将绘图同步到屏幕的刷新率。下面代码展示了我们如何检索显示视图的屏幕，使用这个屏幕创建一个新的<code>displayLink</code>对象并添加到运行环中。</p>\n<blockquote>\n<p><em>GLKViewController</em>类自动使用<code>CADisplayLink</code>对象来动画<code>GLKView</code>的内容，只有当我们需要超出<em>GLKit</em>框架所提供的行为时，才直接使用<code>CADisplayLink</code>类</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CADisplayLink *displayLink = [self.view.window.screen displayLinkWithTarget:self selector:@selector(drawFrame)];</span><br><span class=\"line\">[displayLink addToRunLoop:[NSRunLoop currentRunLoop] forMode:NSDefaultRunLoopMode];</span><br></pre></td></tr></table></figure>\n<p>在<code>drawFrame</code>方法的实现中，读取<code>displayLink</code>的<code>timestamp</code>属性来获取渲染下一帧的时间戳，可以用来计算下一帧对象的位置。</p>\n<p>通常，每次屏幕刷新都会触发<code>displayLink</code>对象；该值通常为60Hz，但在不同的设备上有所不同。大多数应用程序不需要每秒更新屏幕60次。我们可以设置<code>displayLink</code>的<code>frameInterval</code>属性设置为调用该方法之前经过的实际帧数。例如，如果帧间隔设置为3，应用程序则每隔3帧调用一次，或者每秒大约调用20帧（原帧率的三分之一）。</p>\n<blockquote>\n<p>为了最佳效果，渲染一个应用程序可以始终实现的帧率。</p>\n</blockquote>\n<h3>渲染帧</h3>\n<p>下图展示了OpenGL ES应用程序渲染和呈现帧的步骤，这些步骤包括很多提示以提高应用程序的性能。</p>\n<p><img src=\"/img/article/20190519/7.png\" alt=\"iOS OpenGL Rendering Steps\"></p>\n<h4>清空缓冲区</h4>\n<p>在每一帧开始前，删除所有帧缓冲区附加的下一帧不需要使用的内容。调用<code>glClear</code>方法，传递一个位掩码清除所有缓冲区：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">glBindFramebuffer(GL_FRAMEBUFFER, framebuffer);</span><br><span class=\"line\">glClear(GL_DEPTH_BUFFER_BIT | GL_COLOR_BUFFER_BIT);</span><br></pre></td></tr></table></figure>\n<p>使用<code>glClear</code>提示OpenGL ES可以丢弃渲染缓冲区或纹理的现有内容，从而避免将先前内容加载到内存中的昂贵内存。</p>\n<h4>准备资源并执行绘图命令</h4>\n<p>这两个步骤包含了设计应用程序架构时所做的大多数关键决策。首先，决定我们想要展示给用户的内容并配置相应的OpenGL ES对象上传到GPU（如顶点缓冲对象，纹理，着色器程序及其输入变量）。下一步，提交绘图命令告诉GPU如何使用这些资源渲染帧。</p>\n<p>渲染器设计的更多细节见<a href=\"#opengl-es-design-guidelines\">OpenGL ES Design Guidelines</a>。目前，最需要注意的最重要的性能优化是，如果只在渲染新帧时修改OpenGL ES对象应用程序运行的更快。虽然应用程序可以在修改对象和提交绘图命令中间进行切换，但如果每帧只执行一个步骤会运行地更快。</p>\n<h4>执行绘图命令</h4>\n<p>这一步获取我们上一步准备的对象并提交绘图命令使用它们。设计渲染代码这一部分以高效运行的更多细节见<a href=\"#opengl-es-design-guidelines\">OpenGL ES Design Guidelines</a>。目前，最需要注意的最重要的性能优化是，如果只在渲染新帧时修改OpenGL ES对象应用程序运行的更快。虽然应用程序可以在修改对象和提交绘图命令中间进行切换，但如果每帧只执行一个步骤会运行地更快。</p>\n<h4>解决多重采样</h4>\n<p>如果应用程序使用反锯齿提高图形质量，需要在呈现给用户之前解析像素。更多细节见<a href=\"#%E4%BD%BF%E7%94%A8%E5%A4%9A%E9%87%8D%E9%87%87%E6%A0%B7%E6%8F%90%E9%AB%98%E5%9B%BE%E7%89%87%E8%B4%A8%E9%87%8F\">使用多重采样提高图片质量</a>。</p>\n<h4>丢弃不需要的渲染帧缓冲区</h4>\n<p>丢弃操作是一个性能提示，告诉OpenGL ES一个或多个渲染缓冲区的内容不再需要。通过提示OpenGL ES我们不需要一个渲染缓冲区的内容，缓冲区里的数据被丢弃，可以避免缓冲区更新的复杂任务。</p>\n<p>在渲染循环的这个阶段，应用程序已经提交了所有的绘图命令。虽然应用程序需要颜色渲染缓冲区来显示在屏幕上，但可能不需要深度缓冲区的内容。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> GLenum discards = &#123;GL_DEPTH_ATTACHMENT&#125;;</span><br><span class=\"line\">glBindFramebuffer(GL_FRAMEBUFFER, framebuffer);</span><br><span class=\"line\">glDiscardFramebufferEXT(GL_FRAMEBUFFER, <span class=\"number\">1</span>, discards)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>glDiscardFramebufferEXT</code>方法由OpengGL ES1.0和2.0的<code>EXT_discard_framebuffer</code>扩展提供。在OpenGL ES 3.0上下文中，使用<code>glInvalidateFramebuffer</code>方法。</p>\n</blockquote>\n<h4>呈现结果到Core Animation</h4>\n<p>在这个步骤，颜色渲染缓冲区持有完成帧，所以我们需要做的就是呈现给用户。下面代码将renderbuffer绑定到上下文并呈现。这使得完成帧被交到Core Animation。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">glBindRenderbuffer(GL_RENDERBUFFER, colorRenderbuffer);</span><br><span class=\"line\">[context presentRenderbuffer: GL_RENDERBUFFER];</span><br></pre></td></tr></table></figure>\n<p>默认情况下，我们必须保证应用程序呈现完渲染缓冲区后内容被丢弃。这意味着每次呈现帧时，当渲染新帧时必须完整重新创建帧内容，由于这个原因，上述的代码总是擦除颜色缓冲区。</p>\n<p>如果应用程序想要在帧之间保存颜色缓冲区的内容，那么在<code>CAEAGLLayer</code>对象的<code>drawableProperties</code>属性字典添加<code>kEAGLDrawablePropertyRetainedBacking</code>键为<code>YES</code>，同时在<code>glClear</code>方法调用中移除<code>GL_COLOR_BUFFER_BIT</code>常量。保留备份可能需要iOS分配额外的内存来存储缓冲区内容，可能会降低应用程序的性能。</p>\n<h2>使用多重采样提高图片质量</h2>\n<p>多重采样是反锯齿的一种形式，平滑锯齿边缘，提高大多数3D应用的图像质量。OpenGL ES 3.0将多重采样作为核心规范的一部分，OpenGL ES 1.0和2.0合一通过<code>APPLE_framebuffer_multisample</code>扩展提供。多重采样使用更多的内存和片段处理时间来渲染图片，但相比其他方法使用更低的性能成本提高图像质量。</p>\n<p>下图展示了多重采样的工作原理。应用程序不是创建一个帧缓冲区，而是两个。多重采样缓冲区包含所有必要的渲染内容关联（通常是颜色和深度缓冲区），解析缓冲区只包含必要的展示渲染图片给用户的关联（通常是颜色渲染缓冲区，但可能是纹理）。多重采样渲染缓冲器使用和解析渲染缓冲器相同的维度分配内存，但每个维度都包含一个指定每个像素存储的样本数量的额外参数。应用程序将所有的渲染都执行到多重采样缓冲区，然后将这些样本解析到解析缓冲器中生成最终反锯齿图像。</p>\n<p><img src=\"/img/article/20190519/8.png\" alt=\"How multisampling\"></p>\n<p>下面代码展示了多重采样缓冲区的创建，使用之前创建缓冲器的宽高。通过调用<code>glRenderbufferStorageMultisampleAPPLE</code>方法创建渲染缓冲器的多重采样存储；</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GLuint sampleFramebuffer;</span><br><span class=\"line\">glGenFramebuffers(<span class=\"number\">1</span>, &amp;sampleFramebuffer);</span><br><span class=\"line\">glBindFramebuffer(GL_FRAMEBUFFER, sampleFramebuffer);</span><br><span class=\"line\"></span><br><span class=\"line\">GLuint sampleColorRenderbuffer;</span><br><span class=\"line\">glGenRenderbuffers(<span class=\"number\">1</span>, &amp;sampleColorRenderbuffer);</span><br><span class=\"line\">glBindRenderbuffer(GL_RENDERBUFFER, sampleColorRenderbuffer);</span><br><span class=\"line\">glRenderbufferStorageMultisample(GL_RENDERBUFFER, <span class=\"number\">4</span>, GL_RGBA8_OES, width, height);</span><br><span class=\"line\">glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_RENDERBUFFER, sampleColorRenderbuffer);</span><br><span class=\"line\"></span><br><span class=\"line\">GLuint sampleDepthRenderbuffer;</span><br><span class=\"line\">glGenRenderbuffers(<span class=\"number\">1</span>, &amp;sampleDepthRenderbuffer);</span><br><span class=\"line\">glBindRenderbuffer(GL_RENDERBUFFER, sampleDepthRenderbuffer);</span><br><span class=\"line\">glRenderbufferStorageMultisample(GL_RENDERBUFFER, <span class=\"number\">4</span>, GL_DEPTH_COMPONENT16, width, height);</span><br><span class=\"line\">glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, sampleDepthRenderbuffer);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Failed to make complete framebuffer object %x\"</span>, glCheckFramebufferStatus(GL_FRAMEBUFFER));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>下面是一些基于多重采样的修改之后的渲染代码：</p>\n<ol>\n<li>在清除缓冲区步骤，需要同时清除多重采样帧缓冲区内容：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">glBindFramebuffer(GL_FRAMEBUFFER, sampleFramebuffer);</span><br><span class=\"line\">glViewport(0, 0, framebufferWidth, framebufferHeight);  // 选取绘图区域</span><br><span class=\"line\">glClear(GL_COLOR_BUFFER_BIT, GL_DEPTH_BUFFER_BIT);</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>在提交绘图命令后，需要将内容从多重缓冲区解析到解析缓冲区。每像素存储的样本将合并到解析缓冲区的单个样本中：</li>\n</ol>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">glBindFramebuffer(GL_DRAW_FRAMEBUFFER_APPLE, resolveFramebuffer);</span><br><span class=\"line\">glBindFramebuffer(GL_READ_FRAMEBUFFER_APPLE, smapleFramebuffer);</span><br><span class=\"line\">glResolveMultisampleFramebufferAPPLE();</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>在丢弃步骤，我们可以丢弃多重采样帧缓冲区关联的两个渲染缓冲区，这是因为预计呈现的内容以及存储到解析帧缓冲区内：</li>\n</ol>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> GLenum discards[] = &#123;GL_COLOR_ATTACHMENT0, GL_DEPTH_ATTACHMENT&#125;;</span><br><span class=\"line\">glDiscardFramebufferEXT(GL_READ_FRAMEBUFFER_APPLE, <span class=\"number\">2</span>, discards);</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>在呈现结果步骤，呈现关联到解析帧缓冲区的颜色渲染缓冲区：</li>\n</ol>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">glBindRenderBuffer(GL_RENDERBUFFER, colorRenderbuffer);</span><br><span class=\"line\">[context presentRenderbuffer: GL_RENDERBUFFER];</span><br></pre></td></tr></table></figure>\n<p>多重采样并不是免费的；存储额外样本的内存消耗，解析样本到解析帧缓冲区的时耗。如果我们想要添加多重采样到应用中，必须多测试性能以确保它可接受。</p>\n<blockquote>\n<p>上述代码基于OpenGL ES 1.0与2.0，多重采样位于OpenGL ES 3.0的核心API，使用不同的方法。</p>\n</blockquote>\n<h1>Multitasking, High Resolution, and Other iOS Features</h1>\n<p>使用OpenGL ES的许多方面都是平台中立，但是在iOS上使用有一些细节需要特别考虑。特别是，iOS应用使用OpenGL ES正确处理多任务或进入后台有被终止的风险。在iOS设备开发OpenGL ES内容时，我们应该考虑现实分辨率和其他设备的特性。</p>\n<h2>实现一个多任务感知的OpenGL ES应用程序</h2>\n<p>应用程序在用户切换到其他程序时可以继续运行。更多多任务讨论见<a href=\"https://developer.apple.com/library/archive/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/BackgroundExecution/BackgroundExecution.html#//apple_ref/doc/uid/TP40007072-CH4\" target=\"_blank\" rel=\"noopener\">App States and Multitasking</a></p>\n<p>使用OpenGL ES的应用程序在切入后台时必须执行更多的工作，如果多任务处理不当，那应用可能会崩溃，同样，一个应用程序可能想要释放OpenGL ES资源这样就只适用于前台工作。</p>\n<h3>后台应用程序可能无法在图像硬件上执行命令</h3>\n<p>如果OpenGL ES应用程序视图在图像硬件上执行OpenGL ES命令可能会崩溃。iOS阻止后台应用程序访问图像处理器，因此最前端的应用程序总是能给用户提供更好的体验。应用程序崩溃不止在后台调用OpenGL ES，还会在进入后台时之前提交的命令刷新到GPU。所以我们必须保证所有之前提交的命令在进入后台前都执行完毕。</p>\n<p>如果使用GLKit视图和控制器，只在绘图方法中提交OpenGL ES命令，应用程序会自动在进入后台时正确运行。默认情况下，在应用程序处于非活动时<code>GLKViewController</code>类暂停其动画计时器，确保绘图方法不被调用。</p>\n<p>如果不适用GLKit视图或者控制器或者在GLKView绘图方法之外提交OpenGL ES命令，我们必须采用以下步骤保证程序在后台不崩溃：</p>\n<ol>\n<li>在<code>applicationWillResignActive:</code>方法中，需要停止动画计时器，将自己置于一个已知的良好状态，并调用<code>glFinish</code>方法；</li>\n<li>在<code>applicationDidEnterBackground:</code>方法中，应用程序可能想要删除一些OpenGL ES对象使内存和资源对于前台应用程序可。调用<code>glFinish</code>方法确保立即删除资源；</li>\n<li>在<code>applicationDidEnterBackground:</code>方法中，确保没有OpenGL ES的调用，如果有任何调用就会导致崩溃；</li>\n<li>在<code>applicationWillEnterForeground:</code>方法中，重新创建对象和启动动画计时器。</li>\n</ol>\n<p>总而言之，需要调用<code>glFinish</code>方法保证所有之前提交的命令都从命令缓存中取出并被OpenGL ES执行。在进入后台后，在进入前台之前必须避免使用OpenGL ES。</p>\n<h3>在进入后台前删除容易重新创建的资源</h3>\n<p>在应用程序进入后台时从来不需要释放OpenGL ES对象，通常情况，我们应该避免处理它的内容。考虑两种情况：</p>\n<ul>\n<li>应用正在玩游戏并短暂切出去检查日历，当用户返回游戏，游戏的资源仍然在内存中并可以直接继续游戏；</li>\n<li>当用户启动另一个OpenGL ES应用程序，如果需要更多的资源那么系统会自动终止后台的OpenGL ES应用程序让它不执行任何额外的工作。</li>\n</ul>\n<p>我们的目标应该是把应用程序设计成一个良好公民：这意味着移动到前台的时间尽可能短，同时减少他在后台的内存占用。</p>\n<p>下面是我们应该处理的两种情况：</p>\n<ul>\n<li>应用程序应该保证纹理，模型和其他资源在内存中；当应用进入后台时，需要长时间重新创建的资源不应该被处理掉；</li>\n<li>应用程序应该处理可以快速易创建的对象，寻找消耗巨大内存的对象。</li>\n</ul>\n<p>简单的目标是应用程序分配内存持有渲染结果的帧缓冲区，当应用程序在后台时，它对用户是不可见的并可能不会使用OpenGL ES渲染任何新内容。这意味着应用程序的帧缓冲区分配了大量内存但并没有用。同样，帧缓冲区的内容是临时的，大多数应用程序在每次渲染新帧时都会重新创建帧缓冲区的内容。这是用渲染缓冲区成为一个内存密集型资源，可以很容易创建，成为移动到后台时可以处理的候选对象。</p>\n<p>如果我们使用GLKit视图和控制器，<code>GLKViewController</code>类自动在进入后台时处理关联的视图帧缓冲区。如果我们为其他用途手动创建了帧缓冲区，那在进入后台时应该处理他们。在这两种情况下，我们应该考虑应用程序当时可以处理哪些其他临时资源。</p>\n<h2>支持高分辨率显示</h2>\n<p>默认情况下，GLKit视图的<code>contentScaleFactor</code>属性和包含它屏幕的比例相匹配，因此将其关联的帧缓冲区配置以渲染的全分辨率展现。 更多关于UIKit支持的高分辨率展现的内容见<a href=\"https://developer.apple.com/library/archive/documentation/2DDrawing/Conceptual/DrawingPrintingiOS/SupportingHiResScreensInViews/SupportingHiResScreensInViews.html#//apple_ref/doc/uid/TP40010156-CH15\" target=\"_blank\" rel=\"noopener\">Supporting High-Resolution Screens In Views</a>。</p>\n<p>如果使用Core Animation层级出现OpenGL ES的内容，它默认的缩放因子为1.0。为了在Retina显示器的全分辨率下绘图，我们应该修改<code>CAEAGLayer</code>对象的缩放因子以匹配屏幕的缩放因子。</p>\n<p>当支持高分辨率显示器的设备，我们应该相应地跳转应用程序的模型和纹理资源。当高分辨率的设备下运行，我们可能想要渲染更详细的模型和纹理来渲染更好的图像，相反，在标准分辨率设备下，我们可能使用更小的模型和纹理。</p>\n<blockquote>\n<p>许多OpenGL ES API调用都用屏幕像素表示维度，如果使用的缩放因子大于1.0，那么在使用<code>glScissor</code>、<code>glBlitFramebuffer</code>、<code>glLineWidth</code>、<code>glPointSize</code>函数或<code>gl_PointSize</code>着色器变量时，我们需要相应调整维度。</p>\n</blockquote>\n<p>决定如何支持高分辨率显示器的一个重要因素是性能。Retina显示器上的翻倍比例因子使像素的数量变为四倍，这使得GPU处理的碎片数量变为原来的四倍。如果应用程序对每个片段执行多个计算，像素的增加可能会导致帧率降低。如果我们发现应用程序在较高的比例因子下运行速度明显较慢，考虑以下选项之一：</p>\n<ul>\n<li>使用性能调优指南优化片段着色器的性能，见<a href=\"tuning-your-openGL-es-app\">Tuning Your OpenGL ES App</a>；</li>\n<li>在片段着色器实现一个更简单的算法，这样做可以降低单个像素的质量，以更高的分辨率渲染整个图像；</li>\n<li>使用在1.0到屏幕比例因子之间的比例因子，比例因子为1.5比1.0提供更高的质量，但需要填充填充的像素比比例为2.0的图像更少；</li>\n<li>使用较低精度格式的GLKView对象的<code>drawableColorFormat</code>和<code>drawableDepthFormat</code>属性。这样做可以减少操作底层渲染缓冲区所需的内存带宽；</li>\n<li>使用较低的比例因子，启用多重采样。另一个优点是，多重采样同样可以在不知道高分辨率显示器的设备上提供更高的质量。要为GLKView对象启用多重采样，要更改它的<code>drawableMultisample</code>属性值。如果不是渲染到GLKit视图上，则必须手动甚至多重采样缓冲区并在最终图形呈现前解析他们，见<a href=\"#%E4%BD%BF%E7%94%A8%E5%A4%9A%E9%87%8D%E9%87%87%E6%A0%B7%E6%8F%90%E9%AB%98%E5%9B%BE%E7%89%87%E8%B4%A8%E9%87%8F\">使用多重采样提高图片质量</a>。</li>\n</ul>\n<h2>支持多种屏幕旋转</h2>\n<p>与任意应用程序一样，OpenGL ES应用程序应该支持与其内容相适应的用户界面方向。可以在应用程序的信息属性列表定义支持的屏幕方向或者拥有OpenGL ES内容的控制器使用<code>supportedInterfaceOrientations</code>方法。</p>\n<p>默认情况下，<code>GLKViewController</code>和<code>GLKView</code>类自动处理屏幕转向：当用户渲染设备到支持的方向，系统将产生动画旋转屏幕并更改视图控制器视图的大小，当大小改变时，<code>GLKView</code>对象相应调整帧缓冲区和绘图窗口的大小。如果需要响应这个更改，在<code>GLKViewController</code>的子类中实现<code>viewWillLayoutSubviews</code>或<code>viewDidLayoutSubviews</code>方法，如果使用自定义的<code>GLKView</code>子类则实现<code>layoutSubviews</code>。</p>\n<p>如果使用Core Animation层级绘制OpenGL ES的内容，应用程序也应该包含一个视图控制器来管理用户界面方向。</p>\n<h2>在外部显示器上显示OpenGL ES内容</h2>\n<p>一个iOS设备可以被连接到外部显示器，外部显示器的分辨率及其内容缩放因子可能与主屏幕的不同，渲染帧的代码应该调整以匹配。</p>\n<p>在外部显示器绘图的过程基本和主屏幕上的相同：</p>\n<ol>\n<li>按照<a href=\"https://developer.apple.com/library/archive/documentation/WindowsViews/Conceptual/WindowAndScreenGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40012555\" target=\"_blank\" rel=\"noopener\">Multiple Display Programming Guide for iOS</a>的步骤在外部显示器创建一个窗口。</li>\n<li>为渲染策略向窗口添加何时的视图或控制器；\n<ul>\n<li>如果使用GLKit渲染，设置<code>GLKViewController</code>和<code>GLKView</code>（或自定义子类）的实例并用<code>rootViewController</code>属性添加到窗口；</li>\n<li>如果渲染到Core Animation层级，添加包含层级的视图作为窗口的子视图。使用动画循环来渲染，通过检索窗口的<code>screen</code>属性并调用<code>dispalyLinkWithTarget:slector:</code>方法创建一个外部显示器优化的显示链接对象。</li>\n</ul>\n</li>\n</ol>\n<h1>OpenGL ES Design Guidelines</h1>\n<p>现在我们已经掌握了在iOS应用中使用OpenGL ES的基础，使用这章下的信息帮助我们设计更优性能的渲染引擎。这一章节介绍了渲染器设计的关键概念；后面的内容将用特定的最佳实践和性能技术对这些信息扩展。</p>\n<h2>如何可视化OpenGL ES</h2>\n<p>本节描述了可视化OpenGL ES设计的两个方面：作为客户端-服务器架构和作为管线。这两方面在计划和评估应用程序的体系结构都非常有用。</p>\n<h3>OpenGL ES作为客户端-服务器架构</h3>\n<p>应用程序与OpenGL ES客户端通信状态改变、纹理和顶点数据、渲染命令。客户端将这些数据转换成图形硬件理解的格式，并发送到GPU，这些进程会增加应用程序图形性能的开销。</p>\n<p><img src=\"/img/article/20190519/9.png\" alt=\"OpenGL ES client-server architecture\"></p>\n<p>要获得出色的性能需要小心管理这些开销。一个优秀设计的应用程序减少对OpenGL ES的调用频率，使用硬件合适的数据格式来降低转换成本，并小心管理和OpenGL ES之间的数据流。</p>\n<h3>OpenGL ES作为图形管线</h3>\n<p>应用程序配置图形管线，然后执行绘图命令将顶点数据发送到管线中。管线的后续阶段运行顶点着色器处理顶点数据，将顶点数据组装成基本类型，将基本类型光栅化为片段，运行片段着色器来计算每个片段的颜色和深度值，并将片段混合到帧缓冲区显示。</p>\n<p><img src=\"/img/article/20190519/10.png\" alt=\"OpenGL ES graphics pipline\"></p>\n<p>使用管线作为一个心理模型来识别应用程序执行什么工作来生成一个新帧。我们的渲染器设计包含编写着色器程序处理管线的顶点和片段阶段，组织提供给这些程序的顶点和纹理数据，以及配置OpenGL ES状态机来驱动管线的固定功能的阶段。</p>\n<p>图形管线的各个阶段可以同时计算它们的结果–例如，应用程序可能准备了新的基础类型而图形硬件的各个部分还在对之前提交的几何图形执行顶点和片段计算，但是，后期阶段取决于先前阶段的输出，所以如果任何管道阶段执行过多任务或运行太慢，其他管线阶段将处于空闲状态知道最慢的完成工作。一个优秀设计的应用程序应可以根据图形硬件功能平衡每个管道阶段的工作。</p>\n<blockquote>\n<p>所以当我们调整应用程序性能时，第一步通常确定它处于哪个位置，以及会遇到哪些瓶颈。</p>\n</blockquote>\n<h2>OpenGL ES版本和渲染器架构</h2>\n<p>iOS支持3中OpenGL ES版本。最新版本提供更多的灵活，允许我们自主实现渲染包含高质量视觉效果而不影响性能的算法。</p>\n<h3>OpenGL ES 3.0</h3>\n<p>OpenGL ES 3.0是iOS 7之后的新版本。应用程序可以使用OpenGL ES 3.0中引入的特性来实现高级的图形编程技术（以前只能用于桌面级硬件和游戏控制台）从而获得更快的图形性能和引人注目的视觉效果。更多见<a href=\"http://www.khronos.org/registry/OpenGL/index_es.php\" target=\"_blank\" rel=\"noopener\">OpenGL ES API Registry</a>。<br>\n<a href=\"https://developer.apple.com/library/archive/documentation/3DDrawing/Conceptual/OpenGLES_ProgrammingGuide/OpenGLESApplicationDesign/OpenGLESApplicationDesign.html#//apple_ref/doc/uid/TP40008793-CH6-SW13\" target=\"_blank\" rel=\"noopener\">OpenGL ES 3.0</a></p>\n<h3>OpenGL ES 2.0</h3>\n<h3>OpenGL ES 1.0</h3>\n<h2>设计高性能的OpenGL ES应用程序</h2>\n<p>总结下，一个优秀设计的OpenGL ES应用程序需要：</p>\n<ul>\n<li>利用OpenGL ES管线中的并行性</li>\n<li>管理应用程序和图形硬件之间的数据流</li>\n</ul>\n<p>下图展示了一个使用OpenGL ES执行动画显示的应用程序流程：</p>\n<p><img src=\"/img/article/20190519/11.png\" alt=\"App model for managing resources\"></p>\n<p>当应用程序启动时，要做的第一件事是初始化不打算在生命周期中更改的资源。理想情况下，应用程序将这些资源封装到OpenGL ES的对象中，目标是创建任何在应用程序运行期间保持不变的对象（甚至是应用程序生命周期的一部分，如游戏关卡的持续时间），以增加的初始化时间交换更好的渲染性能。复杂的命令或状态改变应该替换为能与单个函数调用一起使用的OpenGLES对象，比如，配置固定函数管线可能需要几十个函数调用。相反，在初始化阶段编译一个图形着色器，并在运行时通过一个函数调用切换到它。创建或者修改开销较大的OpenGL ES对象应该总是作为静态对象创建。</p>\n<p>渲染循环处理我们打算渲染给OpenGL ES上下文的所有项，然后将结果呈现给显示器。在动画场景中，一些数据每一帧都在更新，在上图所示的内部渲染循环中，应用程序在更新渲染资源（在进程中创建或修改OpenGL ES对象）和提交这些资源的绘图命令之间切换。这个内部循环的目标是平衡工作负载让CPU和GPU并行工作，防止应用程序和OpenGL ES同时使用相同的资源。在iOS中，如果不在帧的起始或结束时执行修改OpenGL ES对象，那么修改的代价会非常高。</p>\n<p>这个内部循环的一个重要目标是避免将数据从OpenGL ES拷贝回应用程序，将结果从GPU拷贝到CPU会非常慢。如果拷贝的数据同样用于后续渲染当前帧过程的一部分（如上图的渲染循环中展示的），应用程序会被阻塞知道所有之前提交的绘图命令完成。</p>\n<p>在应用程序提交帧所需要的所有绘图命令，然后将结果呈现到屏幕上。非交互式哟哟欧诺个程序会将最终图片拷贝到应用程序内存中进行下一步处理。</p>\n<p>最终，当应用程序准备退出或结束主要工作，将释放OpenGL ES对象获取更多的可用资源。</p>\n<p>总结本设计的重要特点：</p>\n<ul>\n<li>在任何可能情况下创建静态资源；</li>\n<li>内部渲染循环在修改动态资源和提交渲染命令之间切换，尝试避免在帧的起始或结束之外的时间修改动态资源；</li>\n<li>避免将中间渲染结果读取回应用程序；</li>\n</ul>\n<p>本节后面的部分提供了游泳的变成技术来实现这个渲染循环的特性。</p>\n<h3>避免同步和Flush操作</h3>\n<p>OpenGL ES规范不要求实现立即执行命令。通常情况，命令被排队到命令缓冲区，后面由硬件执行。OpenGL ES会等到应用程序许多命令在队列中后发送到硬件–批处理更加有效，但是，一些OpenGL ES函数必须立即刷新命令缓冲区，其他函数不仅刷新命令缓冲区，还会阻塞直到之前的命令完成才返回对应用和程序的控制。只有在必要时才使用刷新和同步命令，过度使用刷新或同步命令会导致应用程序等待硬件结束渲染时停止。</p>\n<p>下面这些情况需要OpenGL ES将命令缓冲区提交给硬件执行：</p>\n<ul>\n<li><code>glFlush</code>函数将命令缓冲区提交到图形硬件，它会阻塞到命令被提交到硬件但不用等到命令执行结束；</li>\n<li><code>glFinish</code>函数刷新命令缓冲区，然后等待所有之前提交的命令在图像硬件上执行结束；</li>\n<li>检索帧缓冲区内容的函数（如<code>glReadPixels</code>）同样要等待提交的命令完成；</li>\n<li>命令缓冲区已满；</li>\n</ul>\n<h4>有效利用glFlush</h4>\n<p>在一些桌面OpenGL的实现中，定期调用<code>glFlush</code>函数可以有效平衡CPU和GPU的工作，但在iOS中并非如此。iOS图像硬件实现的延迟算法依赖于一次性缓存所有场景中的顶点数据，因此可以对其进行最有处理，去除隐藏表面。通常，OpenGL ES应用程序只有两种情况下调用<code>glFlush</code>或<code>glFinish</code>函数：</p>\n<ul>\n<li>应用程序在进入后台时需要刷新命令缓冲区，因为应用程序在后台时执行OpenGL ES命令会导致iOS崩溃；</li>\n<li>如果应用程序在多个上下文共享OpenGL ES对象（如顶点缓存或纹理），我们需要调用<code>glFlush</code>函数同步使用这些资源。例如，在一个上下文加载顶点数据之后调用<code>glFlush</code>函数，以确保内容准备被其他上下文检索。当与其他iOS APIs（如Core Image）共用OpenGL ES对象时也可以使用这个建议；</li>\n</ul>\n<h4>避免查询OpenGL ES状态</h4>\n<p>调用<code>glGet*()</code>，包括<code>glGetError()</code>，可能需要OpenGL ES在检索任何状态变量之前执行之前的命令。这种同步会强迫图形硬件和CPU同步运行，减少了并行性的机会。为了避免这种情况，维护自己需要查询任意状态的副本，直接访问它而不是调用OpenGL ES。</p>\n<p>当错误发生时，OpenGL ES设置一个错误标识。这些错误和其他错误出现在的Xcode或OpenGL ES分析器的帧调试器中。应该使用这些工具而不是使用<code>glGetError</code>函数，如果频繁调用会降低性能。其他查询（例如<code>glCheckFramebufferStatus()</code>，<code>glGetProgramInfoLog()</code>，<code>glValidateProgram()</code>）通常也只在开发和调试中有用。</p>\n<h3>使用OpenGL ES管理资源</h3>\n<p>许多OpenGL数据可以直接存储到OpenGL ES渲染上下文和与之关联的共享组中。OpenGL ES的实现可以自由将数据转换为适合图形硬件的格式，这可以显著提高性能，特别对于不经常更改的数据。应用程序还可以向OpenGL ES提供如何使用数据的提示，OpenGL ES的实现可以更有效使用这些提示处理数据。例如，静态数据可能被放置在图像处理器可以轻松获取的内存中，甚至可以放置在专用的图形内存中。</p>\n<h3>使用双重缓冲避免资源冲突</h3>\n<p>当应用程序和OpenGL ES同时访问一个OpenGL ES对象时会发生资源冲突。当一个参与者尝试修改对象而另一个参与者正在使用，他们可能会阻塞直到该对象不再被使用。一旦他们开始修改对象，其他参与者可能在修改完成之前都无法使用。或者，OpenGL ES可以隐式复制对象，以便两个参与者都可以继续执行命令。任何一个选项都是安全的，但是每个都有可能成为应用程序的瓶颈。下图展示了这个问题，在这个例子中，只有一个纹理对象，OpenGL ES和应用程序都想使用它，当应用程序尝试修改纹理，它必须等待之前提交的绘图命令完成–CPU和GPU同步。</p>\n<p><img src=\"/img/article/20190519/12.png\" alt=\"Single-buffered texture data\"></p>\n<p>为了解决这个问题，应用程序可以在修改和绘制该对象之间执行额外的工作。但是，如果应用程序没有额外的工作可以执行，它应该显示创建两个大小相同的对象；一个参与者读取对象，另一个参与者修改另一个。下图展示了双缓冲方法，当GPU处理一个纹理时，CPU修改另一个。在初始化启动之后，CPU和GPU都不会处于空闲状态。虽然显示了纹理，这个解决方案几乎适用于任何类型的OpenGL ES对象。</p>\n<p><img src=\"/img/article/20190519/13.png\" alt=\"Double-buffered texture data\"></p>\n<p>对于大多数应用程序双缓冲区已经足够，但它要求两个参与者几乎同时完成处理命令。为了避免阻塞，可以添加更多的缓冲区；这实现了传统的生产者-消费者模型。如果生产者在消费者之前完成处理命令，它将接受一个空闲缓冲区并继续处理命令。在这种情况下，只有消费者严重落后，生产者才会停止生产。</p>\n<p>双缓冲区和三缓冲区需要消耗额外的内存以防止管道停滞，额外使用内存可能会对应用程序的其他部分造成压力。在iOS设备中，内存稀缺；所以设计必须和其他应用程序优化平衡以使用更多的内存。</p>\n<h3>注意OpenGL ES的状态</h3>\n<p>OpenGL ES的实现维护了一份复杂的状态数据，包括使用<code>glEnable</code>或<code>glDisable</code>函数设置的开关、当前着色器程序以及其统一变量、当前绑定的纹理图元、当前绑定的顶点缓存及其启用的顶点属性。硬件有一个当前状态，它被缓存并懒加载。切换状态是昂贵的，所以最好减少状态切换。</p>\n<p>不要设置以及设置的状态。一旦启用某个特性就不用再启用。比如，如果多次调用相同参数的<code>glUniform</code>函数，OpenGL ES可能不会检查已经设置的相同的状态，它只是简单的更新状态值，即使值相同。</p>\n<p>避免使用专用的设置或关闭过程设置不必要的状态，而不是将这类调用放入绘图循环。设置和关闭过程对于开启关闭实现特定视觉效果的特性很有用–例如，当绘制线框轮廓线围绕有纹理的多边形时。</p>\n<h4>使用OpenGL ES对象封装状态</h4>\n<p>要减少状态更改，创建一个对象，将多个OpenGL ES状态更改收集到一个对象，该对象可以使用一个函数绑定。例如，顶点数组对象将多个顶点属性的配置存储到一个对象中。见<a href=\"%E4%BD%BF%E7%94%A8%E9%A1%B6%E7%82%B9%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1%E5%90%88%E5%B9%B6%E9%A1%B6%E7%82%B9%E6%95%B0%E7%BB%84%E7%8A%B6%E6%80%81%E6%9B%B4%E6%94%B9\">使用顶点数组对象合并顶点数组状态更改</a>。</p>\n<h4>组织绘图调用最小化状态更改</h4>\n<p>OpenGL ES的状态更改的效果没有立即生成。相反，当我们发出绘图指令时，OpenGL ES将执行绘制状态值所需的工作。通过减少状态更改，我们可以减少CPU用于配置图形管线的时间。例如，在应用程序中保留一个状态向量，并且只有在绘制调用之间的状态发生时才设置相应的OpenGL ES状态。另一个有用的算法是状态排序–跟踪我们需要做的绘图操作和每个操作所需的状态更改量，然后对它们排序，以便连续使用相同的状态执行操作。</p>\n<p>OpenGL ES的iOS实现可以缓存它在状态之间高效切换所需的一些配置数据，但每个唯一状态集的初始配置需要更长的时间。为了保持一致的性能，我们可以在配置过程中“预热”计划使用的每个状态：</p>\n<ul>\n<li>启用计划使用的状态配置或着色器；</li>\n<li>使用状态配置绘制少量顶点；</li>\n<li>刷新OpenGL ES上下文，以便在预热阶段不显示绘图；</li>\n</ul>\n<h1>Best Practices for Working with Vertex Data</h1>\n<p>要使用OpenGL ES渲染帧，应用程序需要配置图形管线并提交要绘制的图形图元。在一些应用中，所有的图元都是使用同样的管线配置绘制；其他应用可能使用不同的技术渲染不同的帧元素。但无论应用程序使用的哪个图元，管线如何配置，应用程序都需要向OpenGL ES提供顶点。本章提供了一个关于顶点的课程并就如何有效处理顶点数据提供了针对性的建议。</p>\n<p>顶点由一个或多个属性组成，例如位置、颜色、法线或纹理坐标。OpenGL ES 2.0或3.0应用程序可以自由定义自己的属性；顶点数据的每个属性对应于作为顶点着色器的属性变量。OpenGL ES 1.1的应用程序使用固定管线定义好的属性。</p>\n<p>将一个属性定义为由一到四个组件构成的向量，属性中的所有组件共享一个公共数据类型。例如，一个颜色可能被定义为四个<code>GLubyte</code>组件（r,g,b,a）。当一个属性被加载到着色器变量中时，OpenGL ES使用默认值填充所有应用程序未提供的组件数据。最后一个组件被填充为1，其他未指定组件为0，如下图所示：</p>\n<p><img src=\"/img/article/20190519/14.png\" alt=\"Conversion of attribute data to shader variables\"></p>\n<p>应用程序可能将一个属性配置为常量，这意味着对于作为绘图命令部分提交的所有顶点使用相同的值，又意味着每个顶点都是该属性的值。当应用程序调用OpenGL ES的函数绘制一组顶点时，顶点数据被拷贝到图形硬件。处理顶点数据的图形硬件，在着色器处理每个顶点，组装图元并将它们光栅化到帧缓冲区。OpenGL ES的一个优点在于将提交到OpenGL ES顶点数据的一组函数标准化，移除OpenGL ES提供的陈旧和低效的机制。</p>\n<p>应用程序必须提交大量图元来渲染一帧，需要小心管理它们的顶点数据和如何提交到OpenGL ES。本章所述的做法可以概括为以下几个基本原则：</p>\n<ul>\n<li>减少顶点数据的大小；</li>\n<li>减少OpenGL ES将顶点数据传输到图形硬件之前的预处理；</li>\n<li>减少拷贝顶点数据到图形硬件花费的时间；</li>\n<li>减少对每个顶点的计算；</li>\n</ul>\n<h2>简化模型</h2>\n<p>基于iOS设备的图形硬件很强大，但它显示的图片一般很小。我们不需要非常复杂的模型在iOS上呈现引人注目的图形。减少用于绘制模型的顶点数量可以直接减少顶点的数据和对顶点数据执行的计算。</p>\n<p>我们可以使用以下技术降低模型的复杂度：</p>\n<ul>\n<li>在不同细节级别提供不同版本的模型，并在运行时基于到摄像机的距离和显示的尺寸渲染合适的模型；</li>\n<li>使用纹理来消除对某些顶点信息的需要。例如，凹凸贴图可以用来在不添加更多顶点数据的情况下向模型添加细节；</li>\n<li>一些模型添加顶点改进光照细节或渲染质量。这通常是在计算每个顶点的值并在光栅化阶段对三角形进行插值完成的。例如，如果我们将聚光灯指向三角形的中心，它的效果可能被忽略，因为聚光灯醉了的部分不是指向一个顶点。通过添加顶点，我们可以额外提供插值点，代价是增加顶点数据的大小和模型上执行的计算。如果不想要添加额外的顶点，考虑将计算移动到管线的片段阶段：\n<ul>\n<li>如果应用程序使用OpenGL ES 2.0或之后的版本，应用程序在顶点着色器执行计算并将其分配给一个可变变量。变化的值由图形硬件插值并作为输入传递到片段着色器。相反，将计算的输入分配给变量并在片段着色器执行计算。这样做会将执行计算的成本从每个顶点的成本到每个片段的成本，从而减少顶点阶段的压力并增加管线片段阶段的压力。当应用程序在顶点处理时被阻塞，这样做，计算是相对廉价的并可以通过更改显著减少顶点数。</li>\n<li>如果应用程序使用OpenGL ES 1.1，我们可以使用DOT3照明来执行各个片段的光照。我们可以通过添加凹凸贴图纹理来保存正常信息，并使用<code>GL_DOT3_RGB</code>模式的纹理组合操作应用凹凸贴图。</li>\n</ul>\n</li>\n</ul>\n<h2>避免在属性数组中存储常量</h2>\n<p>如果模型中包含在这个模型中使用保持不变的数据的属性，则不要为每个顶点复制该数据。OpenGL ES 2.0和3.0应用程序可以设置一个常量顶点属性或使用一个统一的着色器值来保存该值。OpenGL ES 1.1应用程序应该使用每个顶点的属性函数，如<code>glColor4ub</code>或<code>glTexCoord2f</code>。</p>\n<blockquote>\n<p>待更新…</p>\n</blockquote>\n<h1>Reference</h1>\n<blockquote>\n<p><a href=\"https://developer.apple.com/library/archive/documentation/3DDrawing/Conceptual/OpenGLES_ProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008793-CH1-SW1\" target=\"_blank\" rel=\"noopener\">About OpenGL ES</a></p>\n</blockquote>\n"},{"title":"OpenGL ES学习--纹理","catalog":true,"toc_nav_num":true,"date":"2019-08-10T08:38:20.000Z","subtitle":"About OpenGL ES","header-img":"/img/article_header/article_header.png","busuanzi":true,"_content":"\n> 之前我们已经介绍了顶点着色器，管线的下一步是片段着色器，这是大部分OpenGL ES 3.0视觉魔法发生的地方。片段着色器的核心方面是对表面应用纹理。\n\n# 纹理基础\n\n3D图形渲染中最基本的操作之一是对一个表面应用纹理。纹理可以表现只从网格的几何形状中无法得到的附加细节。OpenGL ES 3.0中的纹理有多种形式：2D纹理、2D纹理数组、3D纹理和立方图纹理。\n纹理通常使用纹理坐标应用到一个表面，纹理坐标可以视为纹理数组数据中的索引。\n\n## 2D纹理\n\n2D纹理是OpenGL ES中最基本和常用的纹理形式，是一个图形数据的二维数组。一个纹理的单独数据元素称作”纹素“（Texel，”texture pixels“（纹理像素）的简写）。OpenGL ES中的纹理图像数据可以用许多不同的基本格式表现。纹理数据可用的基本格式如下表：\n\n基本格式 | 纹素数据描述\n- | -\nGL_RED | (红)\nGL_RG | (红，绿)\nGL_RGB | (红，绿，蓝)\nGL_RGBA | (红，绿，蓝，Alpha)\nGL_LUMINANCE | (亮度)\nGL_LUMINANCE_ALPHA | (亮度，Alpha)\nGL_ALPHA | (Alpha)\nGL_DEPTH_COMPONENT | (深度)\nGL_DEPTH_STENCIL | (深度，模板)\nGL_RED_INTEGER | (整数红)\nGL_RG_INTEGER | (整数红，整数绿)\nGL_RGB_INTEGER | (整数红，整数绿，整数蓝)\nGL_RGBA_INTERGER | (整数红，整数绿，整数蓝，整数Alpha)\n\n图像中的每个纹素根据基本格式和数据类型指定。用2D纹理渲染时，纹理坐标用作纹理图形中的索引。一般来说，在3D内容创作程序中将制作一个网格，每个顶点都有一个纹理坐标。2D纹理的纹理坐标用一对2D坐标(s, t)指定，有时也称作(u, v)坐标。这些坐标代表用于查找一个纹理贴图的规范化坐标。\n\n![2D纹理坐标](/img/article/20190810/1.png)\n\n纹理图像的左下角由`st`坐标(0.0, 0.0)指定，右上角由`st`坐标(1.0, 1.0)指定。在[0.0, 1.0]区间之外的坐标是允许的，在该区间之外的纹理读取行为由纹理包装模式定义。\n\n## 立方图纹理\n\n除了2D纹理之外，OpenGL ES 3.0还支持立方图纹理。从最基本的特征讲，立方图就是一个由6个单独2D纹理面组成的纹理。立方图的每个面代表立方体六面中的一个。虽然立方图在3D渲染中有多重高级的使用方式，但是最常用的是所谓的环境贴图特效。对这种特效，环境在物体上的倒影通过使用一个表示环境的立方图渲染。通常，生成环境贴图所用的立方图通过在场景中央防止一个摄像机，从6个轴的方向(+X, -X, +Y, -Y, +Z, -Z)捕捉场景图形并将结果保存在立方体的每个面来生成。\n立方图纹素的读取通过使用一个3D向量(s, t, r)作为纹理坐标，在立方图中查找。纹理坐标(s, t, r)代表着3D向量的(x, y, z)分量。这个3D向量首先用于选择立方图中需要读取的一个面，然后该坐标投影到2D坐标(s, t)，然后从该面上读取。我们可以通过从一个立方体内部的原点绘制一个3D向量来直观地了解这一过程。这个向量与立方体相交的点就是从立方图读取的纹素。\n\n![立方图的3D纹理坐标](/img/article/20190810/2.png)\n\n立方图各个面的指定方法与2D纹理的相同。每个面必须为正方形（宽度和高度必须相等），每个面的宽度和高度都一样。用于纹理坐标的3D向量和2D纹理的不同，通常不直接逐顶点地保存在网格上。相反，立方图通常使用法向量作为计算立方图纹理坐标的基础来读取。一般来说，法向量和一个来自眼睛的向量一起使用，计算出一个反射向量，然后用这个向量在立方图中查找。\n\n## 3D纹理\n\nOpenGL ES 3.0中的另一类纹理是3D纹理（或者体纹理）。3D纹理可以看做2D纹理多个切片的一个数组，它用一个3元(s, t, r)坐标访问，这与立方体很相似。对于3D纹理，r坐标选择3D纹理中需要采样的切片，(s, t)坐标用于读取每个切片中的2D贴图。下图展示了一个3D纹理，其中每个切片由一个单独的2D纹理组成。3D纹理中的每个mip贴图级别包含上一个级别的纹理中的半数切片。\n\n![3D纹理](/img/article/20190810/3.png)\n\n## 2D纹理数组\n\nOpenGL ES 3.0中最后一种纹理是2D纹理数组。2D纹理数组与3D纹理很相似，但是用途不同。例如，2D纹理数组尝尝用于存储2D图像的一个动画。数组的每个切片表示纹理动画的一帧。2D纹理数组和3D纹理之间的差别很细微，但是很重要。对于3D纹理，过滤发生在切片之间，而从2D纹理数组中读取只从一个单独的切片采样。mip贴图也不一样。2D纹理数组中的每个mip贴图级别包含与以上级别相同的切片数量。每个2D切片的mip贴图完全独立于其他切片（这与3D纹理的情况不同，3D纹理的每个mip贴图级别只有以上级别切片数量的一半）。\n\n为了在2D纹理数组中定位，需使用与3D纹理一样的纹理坐标(s, t, r)，r坐标选择2D纹理数组中要使用的切片，(s, t)坐标用于选择切片，选择的方法与2D纹理完全一样。\n\n## 纹理对象和纹理的加载\n\n纹理应用的第一步是创建一个纹理对象。纹理对象是一个容器对象，保存渲染所需的纹理数据，例如图像数据、过滤模式和包装模式。在OpenGL ES中，纹理对象用一个无符号整数表示，该整数是纹理对象的一个句柄。用于生成纹理对象的函数是`glGenTextures`：\n\n``` objc\n/**\n 生成纹理\n\n @param n#> 指定要生成的纹理对象数量 description#>\n @param textures#> 一个保存n个纹理对象ID的无符号整数数组 description#>\n @return void\n */\nglGenTextures(GLsizei n, GLuint *textures);\n```\n\n在创建的时候，`glGenTextures`生成的纹理对象是一个空的容器，用于加载纹理数据和参数。纹理对象在应用程序不在需要它们的时候也必须删除。这一步骤通常在应用程序关闭或者游戏级别改变时完成，可以使用`glDeleteTextures`实现：\n\n``` objc\n/**\n 删除纹理\n\n @param n#> 指定要删除的纹理对象数量 description#>\n @param textures#> 一个保存要删除的n个纹理对象ID的无符号整数数组 description#>\n @return void\n */\nglDeleteTextures(GLsizei n, const GLuint *textures);\n```\n\n一旦用`glGenTextures`生成了纹理对象ID，应用程序就必须绑定纹理对象进行操作。绑定纹理对象之后，后续的操作(如`glTexImage2D`和`glTexParameter`)将影响绑定的纹理对象。用于绑定纹理对象的函数是`glBindTexture`：\n\n``` objc\n/**\n 绑定纹理对象\n\n @param target#> 将纹理对象绑定到GL_TEXTURE_2D、GL_TEXTURE_3D、GL_TEXTURE_2D_ARRAY或者GL_TEXTURE_CUBE_MAP description#>\n @param texture#> 要绑定的纹理对象句柄 description#>\n @return void\n */\nglBindTexture(GLenum target, GLuint texture);\n```\n\n一旦纹理绑定到一个特定的纹理目标，纹理对象在删除之前就一直绑定到它的目标。生成纹理对象并绑定它之后，使用纹理的下一个步骤是真正地加载图像数据。用于加载2D和立方图纹理的基本函数是`glTexImage2D`。此外，在OpenGL ES 3.0中可以使用多种替代方法指定2D纹理，包括不可变纹理(`glTexStorage2D`)和`glTexSubImage2D`的结合。我们首先从最基本的方法开始--使用`glTexImage2D`--并在后面描述不可变纹理。为了获得最佳性能，建议使用不可变纹理。\n\n``` objc\n/**\n 加载2D和立方图纹理\n\n @param target#> 指定目标纹理，可以为GL_TEXTURE_2D、GL_TEXTURE_CUBE_MAP_POSITIVE_(X, Y, Z)、GL_TEXTURE_CUBE_MAP_NEGATIVE_(X, Y, Z) description#>\n @param level#> 指定要加载的mip级别，第一个级别为0，后续的mip贴图级别递增 description#>\n @param internalformat#> 纹理存储的内部格式；可以是未确定大小的基本内部格式，后者是确定大小的内部格式。未确定大小的内部格式可以为GL_RGBA，GL_RGB，GL_LUMINANCE_ALPHA，GL_LUMINANCE，GL_ALPHA。确定大小的内部格式有GL_RGB，GL_DEPTH_COMPONENT16等 description#>\n @param width#> 图像的像素宽度 description#>\n @param height#> 图像的像素高度 description#>\n @param border#> 这个参数在OpenGL ES中被忽略，保留它是为了与桌面的OpenGL接口兼容；应该为0 description#>\n @param format#> 输入的纹理数据格式，可以为GL_RED(_INTEGER)，GL_RG(_INTEGER)，GL_RGB(_INTERGER)，GL_RGBA(_INTEGER)，GL_DEPTH_COMPONENT，GL_DEPTH_STENCIL，GL_LUMINANCE_ALPHA，GL_ALPHA description#>\n @param type#> 输入像素数据的类型 description#>\n @param pixels#> 包含图像的实际像素数据。数据必须包含（width*height*高度）个像素，每个像素根据格式和类型规范有相应的字节数。像素行必须对其到用`glPixelStorei`设置的GL_UNPACK_ALIGHMENT description#>\n @return void\n */\nglTexImage2D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels);\n```\n\n下面举个例子，演示了生成纹理对象、绑定该对象然后加载由无符号字节表示的RGB图像数据组成的 2x2 2D纹理：\n\n``` objc\nGLuint textureId;\nGLubyte pixels[] = {\n    255, 0, 0,\n    0, 255, 0,\n    0, 0, 255,\n    255, 255, 0\n};\n\n// User tightly packed data\nglPixelStorei(GL_UNPACK_ALIGNMENT, 1);\n\n// Generate a texture object\nglGenTextures(1, &textureId);\n\n// Bind the texture object\nglBindTexture(GL_TEXTURE_2D, textureId);\n\n// Load the texture\nglTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, 2, 2, 0, GL_RGB, GL_UNSIGNED_BYTE, pixels);\n\n// Set the filtering mode\nglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);\nglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);\n```\n\n在上述代码的第一部分，`pixels`数组用简单的2x2纹理数据初始化。这些数据由无符号字节RGB三元组组成，范围为[0, 255]。当着色器中从一个8位无符号字节纹理分量读取数据时，该值从[0, 255]区间被映射到浮点区间[0.0, 1.0]。一般来说，应用程序不会以这种简单的方式创建纹理数据，而从一个图像文件中加载数据。\n在调用`glTexImage2D`之前，应用程序调用`glPixelStorei`设置解包对齐。通过`glTexImage2D`上传纹理数据时，像素行被认定为对齐到`GL_UNPACK_ALIGNMENT`设置的值。默认情况下，该值为4，意味着像素行被认定为从4字节的边界开始。\n这个应用程序将解包对齐设置为1，意味着每个像素行从字节边界开始（换言之，数据被紧密打包）。\n\n``` objc\n/**\n 设置包装或者解包对齐\n\n @param pname#> 指定设置的像素存储类型，下面的选项影响调用glTexImage2D、glTexImage3D、glTexSubImage2D和glTexSubImage3D时数据从内存中解包的方式：GL_UNPACK_ROW_LENGTH，GL_UNPACK_IMAGE_HEIGHT，GL_UNPACK_SKIP_PIXELS，GL_UNPACK_SKIP_ROWS，GL_UNPACK_SKIP_IMAGES，GL_UNPACK_ALIGNMENT；下面的选项影响调用glReadPixels时数据打包到内存中的方式：GL_PACK_ROW_LENGTH，GL_PACK_IMAGE_HEIGHT，GL_PACK_SKIP_PIXELS，GL_PACK_SKIP_ROWS，GL_PACK_SKIP_IMAGES，GL_PACK_ALIGNMENT description#>\n @param param#> 指定包装或者解包选项的整数值 description#>\n @return void\n */\nglPixelStorei(GLenum pname, GLint param);\n```\n\n`glPixelStorei`的`GL_PACK_xxxx`参数对纹理图像上传没有任何影响。打包选项由`glReadPixels`使用。`glPixelStorei`设置的打包和解包选项是全局状态，不由纹理对象存储，也不与之关联。在实践中，很少使用`GL_UNPACK_ALIGNMENT`之外的选项指定纹理。为了完整起见，下表提供了像素存储选项的完整列表。\n\n像素存储选项 | 初始值 | 描述\n- | - | -\nGL_UNPACK_ALIGNMENT GL_PACK_ALIGNMENT | 4 | 指定图像中各行的对齐方式。默认情况下，图像始于4字节边界。将该值设置为1意味着图像紧密打包，各行到齐到字节边界\nGL_UNPACK_ROW_LENGTH GL_PACK_ROW_LENGTH | 0 | 如果该值非0，则表示每个图像行中的像素数量。如果该值为0，则行的长度为图像的宽度（也就是紧密打包）\nGL_UNPACK_IMAGE_HEIGHT GL_PACK_IMAGE_HEIGHT | 0 | 如果该值非0，则表示作为3D纹理一部分的图形的每个列中像素的数量。这个选项可以用于在3D纹理的每个切片之间填充列。如果该值为0，则图像中的列数等于高度（也就是紧密打包）\nGL_UNPACK_SKIP_PIXELS GL_PACK_SKIP_PIXELS | 0 | 如果该值非0，则表示行开始处跳过的像素数量\nGL_UNPACK_SKIP_ROWS GL_PACK_SKIP_ROWS | 0 | 如果该值非0，则表示图像开始时跳过的行数\nGL_UNPACK_SKIP_IMAGES GL_PACK_SKIP_IMAGES | 0 | 如果该值非0，则表示3D纹理中跳过的图像数\n\n代码的最后一部分使用`glTexParameteri`将缩小和放大过滤模式设置为`GL_NEAREST`。这段代码是必需的，因为我们还没有为纹理加载完整的mip贴图链；因此，必须选择非mip贴图缩小过滤器。用于缩小和放大模式的其他选项是`GL_LINEAR`，提供双线性非mip贴图过滤。\n\n## 纹理过滤和mip贴图\n\n到目前为止，我们对2D纹理的介绍仅限于单个2D图像。尽管这使得我们能够解释纹理的概念，但是OpenGL ES中纹理的指定和使用还有一些其他的方法。这种复杂性与使用单个纹理贴图时发生的视觉伪像和性能问题有关。正如我们到目前为止所描述的那样，纹理坐标用于生成一个2D索引，以从纹理贴图中读取。当缩小和放大过滤器设置为`GL_NEAREST`时，就会发生这样的情况：一个纹素将在提供的纹理坐标位置上读取。这称作点采样或者最近采样。\n但是，最近采样可能产生严重的视觉伪像，这是因为三角形在屏幕空间中变得较小，在不同像素间的插值中，纹理坐标有很大的跳跃。结果是，从一个大的纹理贴图中去的少量样本，造成锯齿伪像，而且可能造成巨大性能损失。OpenGL ES中解决这类伪像的方案被称作mip贴图（mipmapping）。mip贴图的思路是构建一个图像链--mip贴图链。mip贴图链始于原来指定的图像，后续的每个图像在每个维度上是前一个图像的一半，一直持续到最后达到链底部的1x1纹理。mip贴图级别可以编程生成，一个mip级别中的每个像素通常根据上一级别中相同位置的4个像素的平均值计算（盒式过滤）。\n[GenMipMap2D](https://github.com/danginsburg/opengles3-book/blob/master/Chapter_9/MipMap2D/MipMap2D.c)函数提供了生成mip贴图链的代码。这个函数以一个RGB8图形作为输入，在前面的图像上执行盒式过滤，生成下一个mip贴图级别。mip贴图链用`glTexImage2D`加载。\n加载mip贴图链之后，便可以设置过滤模式，以使用mip贴图。结果是我们实现了屏幕像素和纹理像素间的更好比率，从而减少了锯齿伪像。图像的锯齿也减少了，这是因为mip贴图链中的每个图像连续进行过滤，使得高频元素随着贴图链的下移越来越少。\n\n``` objc\nglTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, pixels);\nint level = 1;\nGLubyte *prevImage = &pixels[0];\nGLubyte *newImage;\nwhile (width > 1 && height > 1) {\n    int newWidth, newHeight;\n    \n    // Generate the next mipmap level\n    GenMipMap2D(prevImage, &newImage, width, height, &newWidth, &newHeight);\n    \n    // Load the mipmap level\n    glTexImage2D(GL_TEXTURE_2D, level, GL_RGB, newWidth, newHeight, 0, GL_RGB, GL_UNSIGNED_BYTE, newImage);\n    \n    // Free the previous image\n    free(prevImage);\n    \n    // Set the previous image for the next iteration\n    prevImage = newImage;\n    level += 1;\n    \n    // Half the width and height\n    width = newWidth;\n    height = newHeight;\n}\nfree(newImage);\n```\n\n纹理渲染时发生两种过滤：缩小和放大。缩小发生在屏幕上投影的多边形小于纹理尺寸的时候。放大发生在屏幕上投影的多边形大于纹理尺寸的时候。过滤器类型的确定由硬件自动处理，但是API提供了对每种情况下使用的过滤类型的控制。对于放大，mip贴图不起作用，因为我们总是从最大的可用级别采样。对于缩小，可以使用不同的采样模式。所用模式的选择基于你需要实现的显示质量水平以及为了纹理过滤损失多少性能。\n过滤模式（和许多其他纹理选项）用`glTexParameter[i|f][v]`指定。接下来描述纹理过滤模式。\n\n``` objc\nglTexParameteri(GLenum target, GLenum pname, GLint param)\nglTexParameteriv(GLenum target, GLenum pname, const GLint *params);\nglTexParameterf(GLenum target, GLenum pname, GLfloat param);\nglTexParameterfv(GLenum target, GLenum pname, const GLfloat *params);\n```\n\n`pname`为`GL_TEXTURE_MAG_FILTER`放大过滤器时，`param`可能是`GL_NEAREST`或`GL_LINEAR`。在`GL_NEAREST`放大过滤中，将从最靠近纹理坐标的纹理中取得单点样本。在`GL_LINEAR`放大过滤中，将从纹理坐标附近的纹理中取得一个双线性样本（4个样本的平均值）。\n`pname`为`GL_TEXTURE_MIN_FILTER`缩小过滤器时，`param`可以设置为如下值的任意一个：\n- `GL_NEAREST` -- 从最靠近纹理坐标的纹理中获得一个单点样本。\n- `GL_LINEAR` -- 从最靠近纹理坐标的纹理中获得一个双线性样本。\n- `GL_NEAREST_MIPMAP_NEAREST` -- 从所选的最近的mip级别中去的单点样本。\n- `GL_NEAREST_MIPMAP_LINEAR` -- 从两个最近的mip级别中获得样本，并在这些样本之间插值。\n- `GL_LINEAR_MIPMAP_NEAREST` -- 从所选的最近mip级别中获得双线性样本。\n- `GL_LINEAR_MIPMAP_LINEAR` -- 从两个最近的mip级别中获得双线性样本，然后在它们之间插值。这种模式通常被称作三线性过滤，产生所有模式中最佳的质量。\n\n> 在纹理缩小模式中，只要`GL_NEAREST`和`GL_LINEAR`不需要为纹理指定完整的mip贴图链。其他所有模式都要求纹理存在完整的mip贴图链。\n\n选择的纹理过滤模式对性能有一定的影响。如果发生缩小且担心性能，那么使用mip贴图过滤模式通常是大部分硬件上的最佳选择。如果没有mip贴图，则纹理缓存利用率可能非常低，因为读取发生在贴图的少数位置。然而，你选择的过滤模式较高，在硬件中的性能代价就越大。例如，在大部分硬件上，进行双线性过滤的代价低于三线性过滤。我们应该选择一种可以提供所要的质量但是不会对性能有过分负面影响的模式。在某些硬件上，你可能轻松地获得高质量的过滤，特别是在纹理过滤带来的开销不是我们的瓶颈时。这需要在应用程序和计划运行应用程序的硬件上进行调整。\n\n### 无缝立方图过滤\n\n关于过滤，OpenGL ES 3.0中有一个新变化，与立方图的过滤有关。在OpenGL ES 2.0中，当线性过滤核心落到立方图边缘时，过滤将只发生在立方图的一个面上。这将在立方图各面之间的边上造成伪像。在OpenGL ES 3.0中，立方图过滤现在是无缝的--如果过滤核心跨越立方图不止一个面，核心将会从其覆盖的每个面中获得样本。无缝过滤在立方图各面的边缘形成了更平滑的过滤。在OpenGL ES 3.0中，不需要做任何操作就可以启用无缝立方图过滤，所有线性过滤核心将自动使用它。\n\n## 自动mip贴图生成\n\n前一节讲述了生成mip贴图的一种途径，但是OpenGL ES 3.0还提供了用`glGenerateMipmap`自动生成mip贴图的机制。\n\n``` objc\n/**\n 自动生成mip贴图\n\n @param target#> 为之生成mip贴图的纹理目标；可以是GL_TEXTURE_2D、GL_TEXTURE_3D、GL_TEXTURE_2D_ARRAY或GL_TEXTURE_CUBE_MAP description#>\n @return void\n */\nglGenerateMipmap(GLenum target);\n\n```\n\n在绑定的纹理对象上调用`glGenerateMipmap`时，这个函数将从0级图像的内容生成整个mip贴图链。对于2D纹理，0级纹理内容将持续地被过滤并用于每个后续级别。对于立方图，立方体的每一面都由各面的0级生成。当然，要将这个函数用于立方图，必须为立方体的每个面指定0级，每个面的内部格式、宽度和高度都必须匹配。对于2D纹理数组，数组的每个切片将进行与2D纹理一样的过滤。最后，对于3D纹理，将通过过滤各个切片生成全体的mip贴图。\nOpenGL ES 3.0不强制用于生成mip贴图的特定过滤算法（但是规范中推荐盒式过滤，各种实现可以自由地选择他们使用的算法）。如果需要特定的过滤方法，就必须自己生成mip贴图。\n在开始使用帧缓冲区对象渲染纹理时，自动化mip贴图生成变得特别重要。当渲染到一个纹理时，我们不希望将纹理的内容读回CPU来生成mip贴图，相反，可以使用`glGenerateMipmap`和图形硬件，然后在不需要将数据读回CPU的情况下生成mip贴图。\n\n## 纹理坐标包装\n\n纹理包装模式用于指定纹理坐标超出[0.0, 1.0]范围时所发生的行为，用`glTexParameter[i|f][v]`设置。这些模式可以为s、t、r坐标单独设置。`GL_TEXTURE_WRAP_S`模式定义s坐标超出[0.0, 1.0]范围时发生的行为，`GL_TEXTURE_WRAP_T`设置t坐标的行为，`GL_TEXTURE_WRAP_R`设置r坐标的行为（r坐标包装仅用于3D纹理和2D纹理数组）。在OpenGL ES中有三个包装模式可供选择，如下表：\n\n纹理包装模式 | 描述\n- | -\nGL_REPEAT | 重复纹理\nGL_CLAMP_TO_EDGE | 限定读取纹理的边缘\nGL_MIRRORED_REPEAT | 重复纹理和镜像\n\n注意，纹理包装模式也影响过滤行为。例如，当纹理坐标在纹理的边缘时，线性过滤核心可能跨越纹理的边缘。在这种情况下，包装模式将决定对于核心在纹理边缘之外的部分要读取哪些纹素。在不希望出现任何形式的重复时，应该使用`GL_CLAMP_TO_DEGE`。\n\n## 纹理调配\n\n纹理调配（Swizzle）控制输入的R、RG、RGB或RGBA纹理中的颜色分量在着色器中读取时如何映射到分量。例如，应用程序可能希望一个`GL_RED`纹理映射为(0, 0, 0, R)或者(R, R, R, 1)而不是默认的(R, 0, 0, 1)。每个R、G、B、A值映射到的纹理分量都可以用`glTexParameter[i|f][v]`设置的纹理调配单独控制。需要控制的分量用`GL_TEXTURE_SWIZZLE_R`、`GL_TEXTURE_SWIZZLE_G`、`GL_TEXTURE_SWIZZLE_B`或`GL_TEXTURE_SWIZZLE_A`设置。作为该分量纹理值来源的可能是分别从R、G、B、A分量读取的`GL_RED`、`GL_GREEN`、`GL_BLUE`或`GL_ALPHA`。此外，应用程序可以分别用`GL_ZERO`或`GL_ONE`将该值设置为常数0或者1。\n\n## 纹理细节级别\n\n在某些应用中，在所有纹理mip贴图级别可用之前就能够开始显示场景是很实用的。例如，通过数据连接下载纹理图像的GPS应用可以从最低级别的mip贴图开始，在更高级别可用时再显示它们。在OpenGL ES 3.0中，可以通过使用`glTexParameter[i|f][v]`的多个参数实现。`GL_TEXTURE_BASE_LEVEL`设置用于纹理的最大mip贴图级别。默认情况下下，该值为0，但是如果mip贴图级别还不可用，则可以设置为更高的值。同样，`GL_TEXTURE_MAX_LEVEL`设置使用的最小mip贴图级别。默认情况下，它的值为1000（超过了任何纹理可能具备的最大级别），但是可以将其设置为较小的值，以控制用于纹理的最小mip级别。\n为了选择要用于渲染的mip贴图级别，OpenGL ES自动计算一个细节级别（LOD）值。这个浮点值确定从哪一个mip贴图级别过滤（在三线性过滤中，控制每个mip贴图使用的多少）。应用程序还可以用`GL_TEXTURE_MIN_LOD`和`GL_TEXTURE_MAX_LOD`控制最小和最大的LOD值。可以从基本和最大mip贴图级别单独控制LOD限制的一个原因是在新的mip贴图级别可用时提供平滑过渡。仅仅设置纹理的基本和最大级别可能在新mip贴图级别可用时造成间歇伪像，而插入LOD可以使这一过渡看起来更平滑。\n\n## 深度纹理对比（百分比渐进过滤）\n\n最后两个纹理参数是`GL_TEXTURE_COMPARE_FUNC`和`GL_TEXTURE_COMPARE_MODE`。引入这些纹理参数是为了提供百分比渐进过滤（PCF）功能。在执行被称作阴影贴图的阴影技术时，片段着色器需要比较一个片段的当前深度值和深度纹理中的深度值，以确定片段在阴影之内还是之外。为了实现平滑的阴影边缘效果，对深度纹理进行双线性过滤是很有用的。但是，在过滤深度值时，我们希望过滤在采样深度值并与当前深度（或参考值）比较之后发生。如果过滤在比较之前发生，我们将平均计算深度纹理中的值，这不能提供正确的结果。PCF提供了正确的过滤，将采样的每个深度值与参考深度比较，然后将这些比较的结果（0或者1）一起进行平均。\n`GL_TEXTURE_COMPARE_MODE`默认为`GL_NONE`，但是当它被设置为`GL_COMPARE_REF_TO_TEXTURE`时，(s, t, r)纹理坐标中的r坐标将与深度纹理的值进行比较。然后，比较的结果将成为阴影纹理读取的结果（可能是9或者1，如果启用纹理过滤，则为这些值的平均）。比较函数用`GL_TEXTURE_COMPARE_FUNC`设置，可以设置为`GL_LEQUAL`、`GL_GEQUAL`、`GL_LESS`、`GL_GREATER`、`GL_EQUAL`、`GL_NOTEQUAL`、`GL_ALWAYS`或者`GL_NEVER`。\n\n## 纹理格式\n\nOpenGL ES 3.0为纹理提供了广泛的数据格式，格式的数量比OpenGL ES 2.0有了很大的增加。\n2D纹理可以以确定大小或者确定大小的内部格式用`glTexImage2D`上传。如果纹理用未确定大小的格式指定，则OpenGL ES实现可以自由选择纹理数据存储的内部表现形式。如果纹理用确定大小的格式指定，则OpenGL ES实现将选择至少与指定的位数相同的格式。\n\n`glTexImage2D`的有效的未确定大小内部格式组合：\n\n内部格式 | 格式 | 类型 | 输入数据\n- | - | - | -\nGL_RGB | GL_RGB | GL_UNSIGNED_BYTE | 8/8/8 RGB 24- 位\nGL_RGB | GL_RGB | GL_UNSIGNED_SHORT_5_6_5 | 5/6/5 RGB 16- 位\nGL_RGBA | GL_RGBA | GL_UNSIGNED_BYTE | 8/8/8/8 RGBA 32- 位\nGL_RGBA | GL_RGBA | GL_UNSIGNED_SHORT_4_4_4_4 | 4/4/4/4 RGBA 16- 位\nGL_RGBA | GL_RGBA | GL_UNSIGNED_SHORT_5_5_5_1 | 5/5/5/1 RGBA 16- 位\nGL_LUMINANCE_ALPHA | GL_LUMINANCE_ALPHA | GL_UNSIGNED_BYTE | 8/8 LA 16- 位\nGL_LUMINANCE | GL_LUMINANCE | GL_UNSIGNED_BYTE | 8L 8- 位\nGL_ALPHA | GL_ALPHA | GL_UNSIGNED_BYTE | 8A 8- 位\n\n如果应用程序希望更多地控制数据的内部存储方式，那么它可以使用确定大小的内部格式。\n\n### 规范化纹理格式\n\n我们所说的”规范化“指的是从片段着色器中读取纹理时，结果将处于[0.0, 1.0]范围内（或者在*_SNORM格式中的[-1.0, 1.0]范围）。例如，用`GL_UNSIGNED_BYTE`数据指定的`GL_R8`图像将取得每个8位的无符号字节值(范围为[0, 255])，并在片段着色器读取时映射到[0.0, 1.0]。用`GL_BYTE`数据指定的`GL_R8_SNORM`图像将取得每个8位的有符号字节值（范围为[-128, 127]）并在读取时映射到[-1.0, 1.0]。\n\n![glTexImage2D的规范化确定大小内部格式组合](/img/article/20190810/4.png)\n\n### 浮点纹理格式\n\nOpenGL ES 3.0也引入浮点纹理格式。大部分浮点格式由16位半浮点数据或者32位浮点数据支持。与规范化纹理格式（R、RG、RGB、RGBA）一样，浮点纹理格式可能有1~4个分量。OpenGL ES 3.0不强制浮点格式用作渲染目标，只强制16位半浮点数据可以过滤。\n\n![glTexImage2D的有效确定大小浮点内部格式组合](/img/article/20190810/5.png)\n\n### 整数纹理格式\n\n整数纹理格式允许纹理范围在片段着色器中以整数形式读取。也就是说，与片段着色器中读取时数据从整数表示转换为规范化浮点值的规范化纹理格式相反，整数纹理中的值在片段着色器读取时仍然为整数。\n整数纹理格式不可过滤，但是R、RG和RGBA变种可以用作帧缓冲区对象中渲染的颜色附着（color attachment）。使用整数纹理作为颜色附着的时候，忽略Alpha混合状态（整数渲染目标不可能进行混合）。用于从整数纹理读取并输出到整数渲染目标的片段着色器应该使用对应该格式的有符号或者无符号整数类型。\n\n![glTexImage2D的有效确定大小内部整数格式组合](/img/article/20190810/6.png)\n![glTexImage2D的有效确定大小内部整数格式组合](/img/article/20190810/7.png)\n\n### 共享指数纹理格式\n\n共享指数纹理为不需要浮点纹理使用的那么多深度位数的大范围RGB纹理提供了一种存储方式。共享指数纹理通常用于高动态范围（HDR）图像，这种图像不需要半浮点或者全浮点数据。OpenGL ES 3.0中的共享指数纹理格式是`GL_RGB9_E5`。在这种格式中，3个RGB分量共享一个5位的指数。5位的指数隐含地由数值15调整。RGB的每个9位的数值存储无符号位的尾数（因此必然为正）。\n\n![共享指数纹理转换](/img/article/20190810/8.png)\n\n### sRGB纹理格式\n\nOpenGL ES 3.0中引入的另一个纹理格式是sRGB纹理。sRGB是一个非线性颜色空间，大约遵循一个幂函数。大部分图像实际上都存储为sRGB颜色空间，这种非线性解释了人类能够在不同的亮度级别上更好地区分颜色这一事实。\n如果用于纹理的图像是以sRGB颜色空间创作的，但是没有使用sRGB纹理读取，那么所有发生在着色器中的照明计算都会在非线性颜色空间中进行。也就是说，标准创作软件包创建的纹理保存为sRGB，从着色器中读取时仍然保持为sRGB。于是照明计算发生在非线性sRGB空间中。许多应用程序都犯了这个错误，这是不正确的，会造成明显不同（不准确）的输出图像。\n为了正确地处理sRGB图像，应用程序应该使用一个sRGB纹理格式，这种格式在着色器中读取时将从sRGB转换为线性颜色空间。然后，着色器中的所有计算都将在线性颜色空间中完成。最后，通过渲染到一个sRGB渲染目标，图像将会自动地转换回sRGB。可以使用着色器命令`pow(value, 2.0)`进行近似的sRGB->线性转换，然后用`(value, 1/2.2)`进行近似的线性->sRGB转换。然后，尽可能使用sRGB纹理是最好的做法，因为这样减少了着色器指令数量，并且提供更准确的sRGB转换。\n\n内部格式 | 格式 | 类型 | 输出数据 | R | F\n- | - | - | - | - | -\nGL_SRGB8 | GL_RGB | GL_UNSIGNED_BYTE | 8/8/8 SRGB | | X\nGL_SRGB8_ALPHA8 | GL_RGBA | GL_UNSIGNED_BYTE | 8/8/8/8 RGBA | X | X\n\n### 深度纹理格式\n\nOpenGL ES 3.0中的最后一种纹理格式类型是深度纹理。深度纹理允许应用程序从帧缓冲区对象的深度附着中读取深度值（和可选的模板值）。这在各种高级渲染算法中很有用，包括阴影贴图。下表展示了OpenGL ES 3.0中有效的深度纹理格式：\n\n内部格式 | 格式 | 类型\n- | - | -\nGL_DEPTH_COMPONENT16 | GL_DEPTH_COMPONENT | GL_UNSIGNED_SHORT\nGL_DEPTH_COMPONENT16 | GL_DEPTH_COMPONENT | GL_UNSIGNED_INTp\nGL_DEPTH_COMPONENT24 | GL_DEPTH_COMPONENT | GL_UNSIGNED_INT\nGL_DEPTH_COMPONENT43F | GL_DEPTH_COMPONENT | GL_FLOAT\nGL_DEPTH24_STENCIL8 | GL_DEPTH_STENCIL | GL_UNSIGNED_INT_24_8\nGL_DEPTH32F_STENCIL8 | GL_DEPTH_STENCIL | GL_FLOAT_32_UNSIGNED_INT_24_8_REV\n\n## 在着色器中使用纹理\n\n下面代码简要演示在着色器中完成2D纹理的基本过程：\n\n``` objc\n// Vertex shader\n# version 300 es\nlayout(location = 0) in vec4 a_position;\nlayout(location = 1) in vec2 a_texCoord;\nout vec2 v_texCoord;\nvoid main()\n{\n    gl_Position = a_position;\n    v_texCoord = a_texCoord;\n}\n```\n\n``` objc\n// Fragment shader\n# version 300 es\nprecision mediump float;\nin vec2 v_texCoord;\nlayout(location = 0) out vec4 outColor;\nuniform sampler2D s_texture;\nvoid main()\n{\n    outColor = texture(s_texture, v_texCoord);\n}\n```\n\n顶点着色器以一个二分量纹理坐标作为顶点输入，并将其作为输出传递给片段着色器。片段着色器消费该纹理坐标，并将其用于纹理读取。片段着色器声明一个类型为`sampler2D`的统一变量`s_texture`。采样器是用于从纹理贴图中读取的特殊统一变量。采样器统一变量将加载一个指定纹理绑定的纹理单元的数值；例如，用数值0指定采样器表示从单元`GL_TEXTURE0`读取，指定数值1表示从`GL_TEXTURE1`读取，一次类推。在OpenGL ES 3.0 API中，纹理用`glActiveTexture`函数绑定到纹理单元。\n\n``` objc\n/**\n 绑定纹理单元\n\n @param texture#> 需要激活的纹理单元：GL_TEXTURE0, 1, 2 description#>\n @return void\n */\nglActiveTexture(GLenum texture);\n```\n\n`glActiveTexture`函数设置当前纹理单元，以便后续的`glBindTexture`调用将纹理绑定到当前活动单元。在OpenGL ES实现上可用于片段着色器的纹理单元数量可以用`GL_MAX_TEXTURE_IMAGE_UNITS`参数的`glGetintegerv`查询。可用于顶点着色器的纹理单元数量使用带`GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS`参数的`glGetintegerv`查询。\n\n当使用`glBindTexture`绑定为并使用`glUniformli`加载纹理后，可以看到片段着色器中使用内建函数`texture`从纹理贴图出读取。`texture`内建函数形式如下：\n\n``` objc\n/**\n 绑定2D纹理单元\n\n @param sampler#> 绑定到纹理单元的采样器，指定纹理为读取来源 description#>\n @param coord#> 用于从纹理贴图中读取的2D纹理坐标 description#>\n @param bias#> 可选参数，提供用于纹理读取的mip贴图偏置。这允许着色器明确地偏置用于mip忒土选择的LOD计算值 description#>\n @return vec4 纹理\n */\ntexture(sampler2D sampler, vec2 coord[, float bias]);\n```\n\n`texture`函数返回一个代表从纹理贴图中读取颜色的`vec4`。纹理数据映射到这个颜色通道的方式取决于纹理的基本格式。下表展示了纹理格式映射到`vec4`颜色的方式，[纹理调配](/article/2019/opengl-es-texture-0810/#纹理调配)确定这些分量中的值如何映射到着色器中的分量。\n\n基本格式 | 纹素数据描述\n- | -\nGL_RED | (R, 0.0 0.0, 1.0)\nGL_RG | (R, G, 0.0, 1.0)\nGL_RGB | (R, G, B, 1.0)\nGL_RGBA | (R, G, B, A)\nGL_LUMINANCE | (L, L, L, 1.0)\nGL_LUMINANCE_ALPHA | (L, L, L, A)\nGL_ALPHA | (0.0, 0.0, 0.0, A)\n\n下面看具体示例：\n\n``` objc\n- (void)setupVertices {\n    \n    GLfloat vertices[] = {\n        -1.0, -1.0, 0,\n        0, 0,\n        -1.0, 1.0, 0,\n        0, 1,\n        1.0, -1.0, 0,\n        1, 0,\n        1.0, 1.0, 0,\n        1, 1\n    };\n    \n    // 生成纹理\n    GLuint texture = [self createTextureWithImage:[UIImage imageNamed:@\"9\"]];\n    \n    GLuint program = [self createProgram];\n    glUseProgram(program);\n    glViewport(0, 0, [self getViewportWidth], [self getViewportHeight]);\n    \n    glClear(GL_COLOR_BUFFER_BIT);\n    glClearColor(0.0, 0.0, 0.0, 1.0);\n    \n    // 加载纹理\n    glActiveTexture(GL_TEXTURE0);\n    int textureLocation = glGetUniformLocation(program, \"s_texture\");\n    glBindTexture(GL_TEXTURE_2D, texture);\n    glUniform1i(textureLocation, 0);\n    \n    GLuint vbo;\n    glGenBuffers(1, &vbo);\n    glBindBuffer(GL_ARRAY_BUFFER, vbo);\n    glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);\n    \n    glEnableVertexAttribArray(0);\n    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, sizeof(GLfloat)*5, 0);\n    glEnableVertexAttribArray(1);\n    glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, sizeof(GLfloat)*5, (GLvoid *)(sizeof(GLfloat)*3));\n    \n    glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);\n    \n    [self.context presentRenderbuffer:GL_RENDERBUFFER];\n}\n\n\n- (GLuint)createTextureWithImage:(UIImage *)image {\n    // 将 UIImage 转换为 CGImageRef\n    CGImageRef cgImageRef = [image CGImage];\n    GLuint width = (GLuint)CGImageGetWidth(cgImageRef);\n    GLuint height = (GLuint)CGImageGetHeight(cgImageRef);\n    CGRect rect = CGRectMake(0, 0, width, height);\n    \n    // 绘制图片\n    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();\n    // 获取图片字节数 宽x高x4（RGBA）\n    void *imageData = malloc(width * height * 4);\n    /**\n     创建上下文\n\n     @param data#> 指向要渲染的绘制图像的内存地址 description#>\n     @param width#> 图像宽度，单位为像素 description#>\n     @param height#> 图像高度，单位为像素 description#>\n     @param bitsPerComponent#> 内存中像素的每个组件的位数，比如32位RGBA，就设置为8 description#>\n     @param bytesPerRow#> 每一行内存所占的bit数 description#>\n     @param space#> 使用的颜色空间 description#>\n     @param bitmapInfo#> bitmap信息 description#>\n     @return 返回上下文\n     */\n    CGContextRef context = CGBitmapContextCreate(imageData, width, height, 8, width * 4, colorSpace, kCGImageAlphaPremultipliedLast | kCGBitmapByteOrder32Big);\n    // 图片正向-否则绘制出来的图片是颠倒的\n    CGContextTranslateCTM(context, 0, height);\n    CGContextScaleCTM(context, 1.0f, -1.0f);\n    CGColorSpaceRelease(colorSpace);\n    CGContextClearRect(context, rect);\n    CGContextDrawImage(context, rect, cgImageRef);\n    \n    // 生成纹理\n    GLuint textureID;\n    glGenTextures(1, &textureID);\n    glBindTexture(GL_TEXTURE_2D, textureID);\n    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, imageData); // 将图片数据写入纹理缓存\n    \n    // 设置如何把纹素映射成像素\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n    \n    // 解绑\n    glBindTexture(GL_TEXTURE_2D, 0);\n    \n    // 释放内存\n    CGContextRelease(context);\n    free(imageData);\n    \n    return textureID;\n}\n```\n\n## 使用立方图纹理的示例\n\n立方图纹理的使用非常类似于2D纹理。通过对立方图的各面（`GL_TEXTURE_CUBE_MAP_POSITIVE_(X|Y|Z)`，`GL_TEXTURE_CUBE_NEGATIVE_(X|Y|Z)`）调用`glTexImage2D`加载每个面的像素数据。\n\n``` objc\n// Vertex shader\n#version 300 es\nlayout(location = 0) in vec4 a_position;\nlayout(location = 1) in vec3 a_normal;\nout vec3 v_normal;\nvoid mian()\n{\n    gl_Position = a_position;\n    v_normal = a_normal;\n}\n```\n\n``` objc\n// Fragment shader\n#version 300 es\nprecision mediump float;\nin vec3 v_normal;\nlayout(location = 0) out vec4 outColor;\nuniform samplerCube s_texture;\nvoid main()\n{\n    outColor = texture(s_texture, v_normal);\n}\n```\n\n顶点着色器取得一个位置和法线作为顶点输入。发现保存在球面的每个顶点上，用作纹理坐标，并传递给片段着色器。然后，片段着色器使用内建函数`texture`，以法线作为纹理坐标从立方图中读取。立方图所用的`texture`内建函数采用如下形式：\n\n``` objc\n/**\n 绑定立方图纹理单元\n\n @param sampler#> 绑定到纹理单元的采样器，指定纹理为读取来源 description#>\n @param coord#> 用于从纹理贴图中读取的3D纹理坐标 description#>\n @param bias#> 可选参数，提供用于纹理读取的mip贴图偏置。这允许着色器明确地偏置用于mip忒土选择的LOD计算值 description#>\n @return vec4 纹理\n */\ntexture(samplerCube sampler, vec3 coord[, float bias]);\n```\n\n读取立方图的函数与2D纹理非常类似。仅有的区别是，纹理坐标有3个分量而不是2个分量，采样器类型必须为`sampleCube`。用于绑定立方图纹理和加载采样器的方法与之前2D纹理加载一样。\n\n## 加载3D纹理和2D纹理数组\n\n除了2D纹理和立方图，OpenGL ES 3.0还包含了3D纹理和2D纹理数组。加载3D纹理和2D纹理数组的函数是`glTexImage3D`，它与`glTexImage2D`很相似。\n\n``` objc\n/**\n 加载3D纹理或者2D纹理数组\n\n @param target#> 指定纹理目标，应该为GL_TEXTURE_3D或GL_TEXTURE_2D_ARRAY description#>\n @param level#> 指定加载的mip级别。0表示基本级别，更大的数值表示各个后续的mip贴图级别 description#>\n @param internalformat#> 纹理存储的内部格式 description#>\n @param width#> 以像素表示的图像宽度 description#>\n @param height#> 以像素表示的图像高度 description#>\n @param depth#> 3D纹理的切片深度 description#>\n @param border#> 这个参数在OpenGL ES中被忽略，应该为0 description#>\n @param format#> 输入纹理数据的格式 description#>\n @param type#> 输入像素数据的类型 description#>\n @param pixels#> 包含图像的实际像素数据。这些数据必须包含（width*height*depth）个像素，每个像素根据格式和类型规格有相应数量的字节。图像数据应该按照2D纹理切片的顺序存储 description#>\n @return void\n */\nglTexImage3D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels);\n\n```\n\n一旦用`glTexImage3D`加载了3D纹理或者2D纹理数组，就可以用`texture`内建函数在着色器中读取该纹理：\n\n``` objc\n/**\n 绑定3D纹理单元\n\n @param sampler#> 绑定到纹理单元的采样器，指定纹理为读取来源 description#>\n @param coord#> 用于从纹理贴图中读取的3D纹理坐标 description#>\n @param bias#> 可选参数，提供用于纹理读取的mip贴图偏置。这允许着色器明确地偏置用于mip忒土选择的LOD计算值 description#>\n @return vec4 纹理\n */\ntexture(sampler3D sampler, vec3 coord[, float bias]);\n\n/**\n 绑定2D纹理数组单元\n\n @param sampler#> 绑定到纹理单元的采样器，指定纹理为读取来源 description#>\n @param coord#> 用于从纹理贴图中读取的3D纹理坐标 description#>\n @param bias#> 可选参数，提供用于纹理读取的mip贴图偏置。这允许着色器明确地偏置用于mip忒土选择的LOD计算值 description#>\n @return vec4 纹理\n */\ntexture(sampler2DArray sampler, vec3 coord[, float bias]);\n```\n\n> 注意，r坐标是一个浮点值。对于3D纹理，根据过滤模式设置，纹理读取可能跨越体的两个切片。\n\n# 压缩纹理\n\n上述所说的纹理加载都是未压缩的纹理图像数据，OpenGL ES 3.0还支持压缩纹理图像数据的加载。纹理压缩有几个理由，首先，压缩纹理可以减少纹理在设备上的内存占用；其次（不那么明显），压缩纹理节约了着色器中读取纹理时消耗的内存带宽；最后，压缩纹理减少必须存储的图像数据，从而减少了应用程序的下载大小。\n在OpenGL ES 2.0中，核心规范不定义任何压缩的纹理图像格式。也就是说，OpenGL ES 2.0核心简单地定义一个机制，可以加载压缩的纹理图像数据，但是没有定义任何压缩格式。因此，各供应商提供了特定于硬件的纹理压缩扩展。这样，OpenGL ES 2.0应用程序开发者必须在不同平台和硬件上支持不同的纹理压缩格式。\nOpenGL ES 3.0引入所有供应商必须支持的标准纹理压缩格式，从而改善了这种情况。爱立信纹理压缩（Ericsson Texture Compression，ETC2和EAC）以无版税标准的形式提供给Khronos，它被作为OpenGL ES 3.0的标准纹理压缩格式。EAC有一些压缩1通道和2通道数据的变种，ETC2也有压缩3通道和4通道数据的变种。用于加载2D纹理和立方图压缩图像数据的函数是`glCompressedTexImage2D`，用于2D纹理数组的对应函数为`glCompressedTexImage3D`。\n\n> 注意，ETC2/EAC不支持3D纹理（只支持2D纹理和2D纹理数组），但是`glCompressedTexImage3D`可以用于加载供应商专用的3D纹理压缩格式。\n\n``` objc\n/**\n 加载2D纹理和立方图压缩图像数据\n\n @param target#> 指定纹理目标，应该为GL_TEXTURE_2D或者GL_TEXTURE_CUBE_MAP_* description#>\n @param level#> 指定要加载的mip级别 description#>\n @param internalformat#> 纹理存储的内部格式 description#>\n @param width#> 以像素数表示的图像宽度 description#>\n @param height#> 以像素数表示的图像高度 description#>\n @param border#> 这个参数在OpenGL ES中被忽略，应该为0 description#>\n @param imageSize#> 以字节数表示的图像大小 description#>\n @param data#> 包含图像的实际压缩像素数据，必须能够容纳imageSize个字节 description#>\n @return void\n */\nglCompressedTexImage2D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *data);\n\n/**\n 加载2D纹理和立方图压缩图像数据\n\n @param target#> 指定纹理目标，应该为GL_TEXTURE_2D或者GL_TEXTURE_CUBE_MAP_* description#>\n @param level#> 指定要加载的mip级别 description#>\n @param internalformat#> 纹理存储的内部格式。OpenGL ES 3.0中的标准压缩纹理格式在下表中描述 description#>\n @param width#> 以像素数表示的图像宽度 description#>\n @param height#> 以像素数表示的图像高度 description#>\n @param border#> 这个参数在OpenGL ES中被忽略，应该为0 description#>\n @param imageSize#> 以字节数表示的图像大小 description#>\n @param data#> 包含图像的实际压缩像素数据，必须能够容纳imageSize个字节 description#>\n @return void\n */\nglCompressedTexImage3D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *data);\n\n/**\n 加载2D纹理数组或专用3D纹理压缩图像数据\n\n @param target#> 指定纹理目标，应该为GL_TEXTURE_3D或者GL_TEXTURE_2D_ARRAY description#>\n @param level#> 指定要加载的mip级别 description#>\n @param internalformat#> 纹理存储的内部格式。OpenGL ES 3.0中的标准压缩纹理格式在下表中描述 description#>\n @param width#> 以像素数表示的图像宽度 description#>\n @param height#> 以像素数表示的图像高度 description#>\n @param depth#> 以像素数表示的图像深度（或者2D纹理数组的切片数量） description#>\n @param border#> 这个参数在OpenGL ES中被忽略，应该为0 description#>\n @param imageSize#> 以字节数表示的图像大小 description#>\n @param data#> 包含图像的实际压缩像素数据，必须能够容纳imageSize个字节 description#>\n @return void\n */\nglCompressedTexImage3D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *data);\n```\n\nOpenGL ES 3.0支持的标准ETC压缩纹理格式在下表中列出。所有ETC格式将压缩的图像数据存储在4x4的块中。表中列出了每种ETC格式中每个像素的位数。单个ETC图像的大小可以由每像素位数（bpp）比率算出：`sizeInBytes = max(width, 4) * max(height, 4) * bpp / 8`。\n\n内部格式 | 大小（每像素位数）| 描述\n- | - | -\nGL_COMPRESSED_R11_EAC | 4 | 单通道无符号压缩GL_RED格式\nGL_COMPRESSED_SIGNED_R11_EAC | 4 | 单通道有符号压缩GL_RED格式\nGL_COMPRESSED_RG11_EAC | 8 | 双通道无符号压缩GL_RG格式\nGL_COMPRESSED_SIGNED_RG11_EAC | 8 | 双通道有符号压缩GL_RG格式\nGL_COMPRESSED_RGB8_ETC2 | 4 | 三通道无符号压缩GL_RGB格式\nGL_COMPRESSED_SRGB8_ETC2 | 4 | sRGB颜色空间中的三通道无符号压缩GL_RGB格式\nGL_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 | 4 | 四通道无符号压缩GL_RGBA格式，1位alpha\nGL_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 | 4 | sRGB颜色空间中四通道无符号压缩GL_RGBA格式，1位alpha\nGL_COMPRESSED_RGBA8_ETC2_EAC | 8 | 四通道无符号压缩GL_RGBA格式\nGL_COMPRESSED_SRGBA8_ETC2_EAC | 8 | sRGB颜色空间中四通道无符号压缩GL_RGBA格式\n\n一旦加载压缩纹理，它就可以和无压缩纹理一样用于纹理处理。大部分开发人员不会编写自己的压缩程序，具体可使用的压缩工具，自行选择。\n\n注意，所有OpenGL ES 3.0实现都支持如上表中列出的格式。此外，有些实现可能支持表中未列出的供应商专用压缩格式。如果我们试图在不支持它们的OpenGL ES 3.0实现上使用纹理压缩格式，将会产生一个`GL_INVALID_ENUM`错误。检查OpenGL ES 3.0实现导出使用的任何供应商专用纹理压缩格式的扩展字符串很重要。如果该实现没有导出这样的扩展字符串，那就只能退而求其次使用无压缩的纹理格式。\n除了检查扩展字符串之外，还可以用另外一种方法确定实现所支持的纹理压缩格式。也就是说，可以用`glGetIntegerv`查询`GL_NUM_COMPRESSED_TEXTURE_FORMATS`来确定所支持的压缩图像格式数量。然后，可以用`glGetIntegerv`查询`GL_COMPRESSED_TEXTURE_FORMATS`，该调用返回一个`GLenum`值的数组。数组中的每个`GLenum`值将是实现支持的一种压缩纹理格式。\n\n# 纹理子图像规范\n\n用`glTexImage2D`上传纹理图像之后，可以更新图像的各个部分。如果你只希望更新图像的一个子区域，这种能力就很试用。\n\n``` objc\n/**\n 更新2D纹理图像的子区域\n\n @param target#> 指定纹理目标，可以是GL_TEXTURE_2D或者GL_TEXTURE_CUBE_MAP_* description#>\n @param level#> 指定更新的mip级别 description#>\n @param xoffset#> 开始更新的纹素x索引 description#>\n @param yoffset#> 开始更新的纹素y索引 description#>\n @param width#> 更新的图像子区域宽度 description#>\n @param height#> 更新的图像子区域高度 description#>\n @param format#> 输入纹理数据格式 description#>\n @param type#> 输入像素数据的类型 description#>\n @param pixels#> 包含图像子区域的实际像素数据 description#>\n @return void\n */\nglTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels);\n```\n\n这个函数将更新(xoffset, yoffset)到(xoffset+width-1, yoffset+height-1)范围内的纹素。注意，要使用这个函数，纹理必须完全指定。子图像的范围必须在之前指定的纹理图像界限之内。`pixels`数组中的数据必须按照`glPixelStorei`的`GL_UNPACK_ALIGNMENT`指定的方式对齐。\n\n还有一个用于更新压缩的2D纹理图像子区域的函数：\n\n``` objc\n/**\n 更新压缩的2D纹理图像的子区域\n\n @param target#> 指定纹理目标，可以是GL_TEXTURE_2D或者GL_TEXTURE_CUBE_MAP_* description#>\n @param level#> 指定更新的mip级别 description#>\n @param xoffset#> 开始更新的纹素x索引 description#>\n @param yoffset#> 开始更新的纹素y索引 description#>\n @param width#> 更新的图像子区域宽度 description#>\n @param height#> 更新的图像子区域高度 description#>\n @param format#> 所用的压缩纹理格式，必须与图像原来指定的格式相同 description#>\n @param imageSize#> 以字节数表示的图像大小 description#>\n @param data#> 包含图像子区域的实际像素数据 description#>\n @return void\n */\nglCompressedTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *data);\n```\n\n此外，与2D纹理一样，可以用`glTexSubImage3D`更新现有3D纹理和2D纹理数组的子区域：\n\n``` objc\n/**\n 更新3D纹理图像的子区域\n\n @param target#> 指定目标纹理，可以是GL_TEXTURE_3D或GL_TEXTURE_2D_ARRAY description#>\n @param level#> 指定更新的mip级别 description#>\n @param xoffset#> 开始更新的纹素x索引 description#>\n @param yoffset#> 开始更新的纹素y索引 description#>\n @param zoffset#> 开始更新的纹素z索引 description#>\n @param width#> 更新的图像子区域宽度 description#>\n @param height#> 更新的图像子区域高度 description#>\n @param depth#> 更新的图像子区域深度 description#>\n @param format#> 输入纹理数据的格式 description#>\n @param type#> 输入像素数据的类型 description#>\n @param pixels#> 包含像素数据的类型 description#>\n @return void\n */\nglTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels);\n```\n\n`glTexSubImage3D`的表现与`glTexSubImage2D`类似，唯一的不同是子区域包含一个`zoffset`和`depth`，用于指定深度切片中要更新的子区域。对于压缩的2D纹理数组，也可以用`glCompressedTexSubImage3D`更新纹理的一个子区域。对于3D纹理，这个函数只能用于供应商专用的3D压缩纹理格式，因为ETC2/EAC只支持2D纹理和2D纹理数组。\n\n``` objc\n/**\n 更新压缩的3D纹理图像的子区域\n\n @param target#> 指定纹理目标，可能是GL_TEXTURE_3D或者GL_TEXTURE_2D_ARRAY description#>\n @param level#> 指定更新的mip级别 description#>\n @param xoffset#> 开始更新的纹素x索引 description#>\n @param yoffset#> 开始更新的纹素y索引 description#>\n @param zoffset#> 开始更新的纹素z索引 description#>\n @param width#> 更新的图像子区域宽度 description#>\n @param height#> 更新的图像子区域高度 description#>\n @param depth#> 更新的图像子区域深度 description#>\n @param format#> 使用的压缩纹理格式，必须与原来指定的图像格式相同 description#>\n @param imageSize#> 以字节数表示的图像大小 description#>\n @param data#> 包含图像子区域的实际像素数据 description#>\n @return void\n */\nglCompressedTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *data);\n```\n\n# 从颜色缓冲区复制纹理数据\n\nOpenGL ES 3.0中支持的另一个纹理功能是从颜色缓冲区复制数据到一个纹理。如果我们希望使用渲染的结果作为纹理中的图像，这一功能就很实用。后面的帧缓冲区对象提供了渲染-纹理转换的快速方法，这种方法比复制图像数据更快。但是，如果性能不是关注点，那么从颜色缓冲区复制图像数据就是一种实用的功能。\n\n作为复制图像数据来源的颜色缓冲区可以用`glReadBuffer`函数设置。如果应用程序渲染到一个双缓冲区EGL可显示表面，则`glReadBuffer`必须设置为`GL_BACK`（后台缓冲区--默认状态）。OpenGL ES 3.0只支持双缓冲区EGL可显示表面。因此，所有在显示器上绘图的OpenGL ES 3.0应用程序都有一个既用于前台缓冲区又用于后台缓冲区的颜色缓冲区。这个缓冲区当前是前台还是后台缓冲区，由对`eglSwapBuffers`的最后一次调用决定。当从可显示EGL表面的颜色缓冲区中复制图像数据时，总是会复制后台缓冲区的内容。如果渲染到一个EGL pbuffer，则复制将发生在pbuffer表面。最后，如果渲染到一个帧缓冲区对象，则所复制的帧缓冲区对象的颜色附着通过调用带`GL_COLOR_ATTACHMENTi`参数的`glReadBuffer`函数设置：\n\n``` objc\n/**\n 读取颜色缓冲区\n\n @param mode#> 指定读取的颜色缓冲区。这将为未来的glReadPixels、glCopyTexImage2D、glCopyTexSubImage2D和glCopyTexSubImage3D调用设置源颜色缓冲区。该值可能为GL_BACK、GL_COLOR_ATTACHMENTi或GL_NONE description#>\n @return void\n */\nglReadBuffer(GLenum mode);\n```\n\n从颜色缓冲区复制数据到纹理的函数是`glCopyTexImage2D`、`glCopyTexSubImage2D`和`glCopyTexSubImage3D`。\n\n``` objc\n/**\n 从颜色缓冲区复制数据到2D纹理\n\n @param target#> 指定纹理目标，可能为GL_TEXTURE_CUBE_MAP_2D或者GL_TEXTURE_CUBE_MAP_* description#>\n @param level#> 指定加载的mip级别 description#>\n @param internalformat#> 图像的内部格式 description#>\n @param x#> 读取的帧缓冲区矩形左下角的x窗口坐标 description#>\n @param y#> 读取的帧缓冲区矩形左下角的y窗口坐标 description#>\n @param width#> 读取区域的宽度，以像素数表示 description#>\n @param height#> 读取区域的高度，以像素表示 description#>\n @param border#> OpenGL ES 3.0不支持边框，必须为0 description#>\n @return void\n */\nglCopyTexImage2D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);\n```\n\n调用上述函数导致纹理图像从区域(x, y)到(x+width-1, y+height-1)的颜色缓冲区内的像素加载。纹理图像的宽度和高度等于颜色缓冲区中复制区域的大小。我们应该用这些信息填充纹理的全部内容。\n此外，可以用`glCopyTexSubImage2D`更新已经指定的图像的子区域：\n\n``` objc\n/**\n 从颜色缓冲区复制数据更新已经指定的2D纹理的子区域\n\n @param target#> 指定纹理目标，可能为GL_TEXTURE_2D或者GL_TEXTURE_CUBE_MAP_* description#>\n @param level#> 指定更新的mip级别 description#>\n @param xoffset#> 开始更新的纹素x索引 description#>\n @param yoffset#> 开始更新的纹素y索引 description#>\n @param x#> 读取的帧缓冲区矩形左下角的x窗口坐标 description#>\n @param y#> 读取的帧缓冲区矩形左下角的y窗口坐标 description#>\n @param width#> 读取区域的宽度，以像素数表示 description#>\n @param height#> 读取区域的高度，以像素数据表示 description#>\n @return void\n */\nglCopyTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);\n```\n\n上述函数将用颜色缓冲区中从(x, y)到(x+width-1, y+height-1)区域的像素更新图像中从(xoffset, yoffset)到(xoffset+width-1, yoffset+height-1)的子区域。\n最后，也可以用`glCopyTexSubImage3D`将颜色缓冲区的内容复制到之前指定的3D纹理或者2D纹理数组的一个切片中：\n\n``` objc\n/**\n 从颜色缓冲区复制数据更新已经指定的3D纹理或2D纹理数组的子区域\n\n @param target#> 指定纹理目标，可能为GL_TEXTURE_3D或者GL_TEXTURE_2D_ARRAY description#>\n @param level#> 指定加载的mip级别 description#>\n @param xoffset#> 开始更新的纹素x索引 description#>\n @param yoffset#> 开始更新的纹素y索引 description#>\n @param zoffset#> 开始更新的纹素z索引 description#>\n @param x#> 读取的帧缓冲区矩形左下角的x窗口坐标 description#>\n @param y#> 读取的帧缓冲区矩形左下角的y窗口坐标 description#>\n @param width#> 读取区域的宽度，以像素数表示 description#>\n @param height#> 读取区域的高度，以像素数表示 description#>\n @return void\n */\nglCopyTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);\n```\n\n对于上述函数要记住一点，即纹理图像格式的分量不能多于颜色缓冲区。换句话说，复制颜色缓冲区的数据时，可以转换为分量较少的格式，但是不能转换为分量较多的格式。\n\n# 采样器对象\n\n之前介绍了用`glTexParameter[i|f][v]`设置纹理参数（如过滤模式、纹理坐标包装模式和LOD设置）的方法。使用`glTexParameter[i|f][v]`的问题是它可能造成大量不必要的API开销。应用程序经常在大量纹理上使用相同的设置，在这种情况下，用`glTexParameter[i|f][v]`为每个纹理对象设置采样器状态可能造成大量额外开销。为了缓解这一问题，OpenGL ES 3.0引入采样器对象，将采样器状态和纹理状态分离。简言之，所有可用`glTexParameter[i|f][v]`进行的设置都可以对采样器对象进行，可以在一次函数调用中与纹理单元绑定使用。采样器对象可以用于许多纹理，从而降低API开销。\n\n用于生成采样器对象的函数是：\n\n``` objc\n/**\n 生成采样器对象\n\n @param count#> 指定生成的采样器对象数量 description#>\n @param samplers#> 一个无符号整数数组，将容纳n个采样器对象ID description#>\n @return void\n */\nglGenSamplers(GLsizei count, GLuint *samplers);\n```\n\n采样器对象在应用程序不再需要它们时也需要删除：\n\n``` objc\n/**\n 删除采样器对象\n\n @param count#> 指定要删除的采样器对象 description#>\n @param samplers#> 一个无符号整数数组，容纳要删除的n个采样器对象ID description#>\n @return void\n */\nglDeleteSamplers(GLsizei count, const GLuint *samplers);\n```\n\n当生成采样器对象ID之后，应用程序必须绑定采样器对象以使用其状态。采样器对象绑定到纹理单元，这种绑定取代了用`glTexParameter[i|f][v]`进行的所有纹理对象状态设置：\n\n``` objc\n/**\n 采样器对象绑定到纹理单元\n\n @param unit#> 指定采样器对象绑定到的纹理单元 description#>\n @param sampler#> 所要绑定的采样器对象的句柄 description#>\n @return void\n */\nglBindSampler(GLuint unit, GLuint sampler);\n```\n\n如果传递给`glBindSampler`的`sampler`为0（默认采样器），则使用为纹理对象设置的状态。采样器对象状态可以用`glSampler[f|i][v]`设置。可以用`glSamplerParameter[f|i][v]`设置的参数与用`glTexParameter[i|f][v]`设置的相同，唯一的区别是状态被设置到采样器对象，而非纹理对象：\n\n``` objc\nglSamplerParameteri(GLuint sampler, GLenum pname, GLint param);\nglSamplerParameteriv(GLuint sampler, GLenum pname, const GLint *param);\nglSamplerParameterf(GLuint sampler, GLenum pname, GLfloat param);\nglSamplerParameterfv(GLuint sampler, GLenum pname, const GLfloat *param);\n```\n\n# 不可变纹理\n\nOpenGL ES 3.0中引入的另一种有助于改进应用程序性能的功能是不可变纹理。正如前面所介绍的，应用程序使用`glTexImage2D`和`glTexImage3D`等函数独立地指定纹理的每个mip贴图级别。这对OpenGL ES驱动程序造成的问题是驱动程序在绘图之前无法确定纹理是否已经完全指定。也就是说，它必须检查每个mip贴图级别或者子图像的格式是否相符、每个级别的大小是否正确以及是否有足够的内存。这种绘图时检查可能代价很高，而使用不可变纹理可以避免这种情形。\n\n不可变纹理的思路很简单：应用程序在加载数据之前指定纹理的格式和大小。这样做之后，纹理格式变成不可改变的，OpenGL ES驱动程序可以预先进行所有一致性和内存检查。一旦纹理不可变，它的格式和大小就不会再变化。但是，应用程序仍然可以通过使用`glTexSubImage2D`、`glTexSubImage3D`、`glGenerateMipMap`或者渲染到纹理加载图像数据。\n为了创建不可变纹理，应用程序将使用`glBindTexture`绑定纹理，然后用`glTexStorage2D`或`glTexStorage3D`分配不可变存储：\n\n``` objc\n/**\n 创建不可变纹理\n\n @param target#> 指定纹理目标，可能是GL_TEXTURE_2D、GL_TEXTURE_CUBE_MAP_*或者GL_TEXTURE_3D、GL_TEXTURE_2D_ARRAY description#>\n @param levels#> 指定mip贴图级别数量 description#>\n @param internalformat#> 确定大小的纹理存储内部格式 description#>\n @param width#> 基本图形宽度，以像素数表示 description#>\n @param height#> 基本图像高度，以像素数表示 description#>\n @return void\n */\nglTexStorage2D/3D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);\n```\n\n一旦创建了不可变纹理，在纹理对象上调用`glTexImage*`、`glCompressedTexImage*`、`glCopyTexImage*`或`glTexStorage*`就会无效。这样做将生成`GL_INVALID_OPERATION`错误。要用图像数据填充不可变纹理，应用程序需要使用`glTexSubImage2D`、`glTexSubImage3D`、`glGenerateMipMap`或者渲染到纹理图像（通过将其作为帧缓冲区对象附着使用来实现）。\n使用`glTexStorage*`时，OpenGL ES内部通过将`GL_TEXTURE_IMMUTABLE_FORMAT`设置为`GL_TRUE`，将`GL_TEXTURE_IMMUTABLE_LEVELS`设置为传递给`glTexStorage*`的数字，将纹理对象标记为不可变。应用程序可以使用`glGetTexParameter[i|f][v]`查询这些值，但是它无法直接设置这些值。必须使用`glTexStorage*`函数设置不可变纹理参数。\n\n# 像素解包缓冲区对象\n\n缓冲区对象可以在服务器端（或者GPU）内存中存储数据，而不是在客户端（或者主机）内存。使用缓冲区对象的好处是减少了从CPU到GPU的数据传送，因而能够改进性能（并降低内存占用率）。OpenGL ES 3.0还引入了像素解包缓冲区对象，这种对象与`GL_PIXEL_UNPACK_BUFFER`目标绑定指定。像素解包缓冲区对象允许纹理数据规格保存在服务器端内存。结果是，像素解包操作`glTexImage*`、`glTexSubImage*`、`glCompressedTexImage*`和`glCompressedTexSubImage*`可以直接来自缓冲区对象。如果像素解包缓冲区对象在这类调用期间绑定，则数据指针是像素解包缓冲区中的一个偏移量，而不是指向客户端内存的指针，这与使用`glVertexAttribPointer`的VBO很相似。\n像素解包缓冲区对象可以用于将纹理数据流传输到GPU。应用程序可以分配一个像素解包缓冲区，然后为更新映射缓冲区区域。当进行加载数据到OpenGL的调用（例如`glTexSubImage*`）时，这些函数可能立即返回。因为数据已经存在于GPU（或者可以在稍后复制，但是立即复制不需要像客户端数据那样进行）。我们建议在纹理上传操作的性能/内存占用对应用程序很重要的情况下使用像素解包缓冲区对象。\n\n# 总结\n\n这篇文章主要介绍了OpenGL ES 3.0中使用纹理的方法。","source":"_posts/2019/opengl-es-texture-0810.md","raw":"---\ntitle: \"OpenGL ES学习--纹理\"\ncatalog: true\ntoc_nav_num: true\ndate: 2019-08-10 16:38:20\nsubtitle: \"About OpenGL ES\"\nheader-img: \"/img/article_header/article_header.png\"\nbusuanzi: true\ntags:\n- iOS\n\n---\n\n> 之前我们已经介绍了顶点着色器，管线的下一步是片段着色器，这是大部分OpenGL ES 3.0视觉魔法发生的地方。片段着色器的核心方面是对表面应用纹理。\n\n# 纹理基础\n\n3D图形渲染中最基本的操作之一是对一个表面应用纹理。纹理可以表现只从网格的几何形状中无法得到的附加细节。OpenGL ES 3.0中的纹理有多种形式：2D纹理、2D纹理数组、3D纹理和立方图纹理。\n纹理通常使用纹理坐标应用到一个表面，纹理坐标可以视为纹理数组数据中的索引。\n\n## 2D纹理\n\n2D纹理是OpenGL ES中最基本和常用的纹理形式，是一个图形数据的二维数组。一个纹理的单独数据元素称作”纹素“（Texel，”texture pixels“（纹理像素）的简写）。OpenGL ES中的纹理图像数据可以用许多不同的基本格式表现。纹理数据可用的基本格式如下表：\n\n基本格式 | 纹素数据描述\n- | -\nGL_RED | (红)\nGL_RG | (红，绿)\nGL_RGB | (红，绿，蓝)\nGL_RGBA | (红，绿，蓝，Alpha)\nGL_LUMINANCE | (亮度)\nGL_LUMINANCE_ALPHA | (亮度，Alpha)\nGL_ALPHA | (Alpha)\nGL_DEPTH_COMPONENT | (深度)\nGL_DEPTH_STENCIL | (深度，模板)\nGL_RED_INTEGER | (整数红)\nGL_RG_INTEGER | (整数红，整数绿)\nGL_RGB_INTEGER | (整数红，整数绿，整数蓝)\nGL_RGBA_INTERGER | (整数红，整数绿，整数蓝，整数Alpha)\n\n图像中的每个纹素根据基本格式和数据类型指定。用2D纹理渲染时，纹理坐标用作纹理图形中的索引。一般来说，在3D内容创作程序中将制作一个网格，每个顶点都有一个纹理坐标。2D纹理的纹理坐标用一对2D坐标(s, t)指定，有时也称作(u, v)坐标。这些坐标代表用于查找一个纹理贴图的规范化坐标。\n\n![2D纹理坐标](/img/article/20190810/1.png)\n\n纹理图像的左下角由`st`坐标(0.0, 0.0)指定，右上角由`st`坐标(1.0, 1.0)指定。在[0.0, 1.0]区间之外的坐标是允许的，在该区间之外的纹理读取行为由纹理包装模式定义。\n\n## 立方图纹理\n\n除了2D纹理之外，OpenGL ES 3.0还支持立方图纹理。从最基本的特征讲，立方图就是一个由6个单独2D纹理面组成的纹理。立方图的每个面代表立方体六面中的一个。虽然立方图在3D渲染中有多重高级的使用方式，但是最常用的是所谓的环境贴图特效。对这种特效，环境在物体上的倒影通过使用一个表示环境的立方图渲染。通常，生成环境贴图所用的立方图通过在场景中央防止一个摄像机，从6个轴的方向(+X, -X, +Y, -Y, +Z, -Z)捕捉场景图形并将结果保存在立方体的每个面来生成。\n立方图纹素的读取通过使用一个3D向量(s, t, r)作为纹理坐标，在立方图中查找。纹理坐标(s, t, r)代表着3D向量的(x, y, z)分量。这个3D向量首先用于选择立方图中需要读取的一个面，然后该坐标投影到2D坐标(s, t)，然后从该面上读取。我们可以通过从一个立方体内部的原点绘制一个3D向量来直观地了解这一过程。这个向量与立方体相交的点就是从立方图读取的纹素。\n\n![立方图的3D纹理坐标](/img/article/20190810/2.png)\n\n立方图各个面的指定方法与2D纹理的相同。每个面必须为正方形（宽度和高度必须相等），每个面的宽度和高度都一样。用于纹理坐标的3D向量和2D纹理的不同，通常不直接逐顶点地保存在网格上。相反，立方图通常使用法向量作为计算立方图纹理坐标的基础来读取。一般来说，法向量和一个来自眼睛的向量一起使用，计算出一个反射向量，然后用这个向量在立方图中查找。\n\n## 3D纹理\n\nOpenGL ES 3.0中的另一类纹理是3D纹理（或者体纹理）。3D纹理可以看做2D纹理多个切片的一个数组，它用一个3元(s, t, r)坐标访问，这与立方体很相似。对于3D纹理，r坐标选择3D纹理中需要采样的切片，(s, t)坐标用于读取每个切片中的2D贴图。下图展示了一个3D纹理，其中每个切片由一个单独的2D纹理组成。3D纹理中的每个mip贴图级别包含上一个级别的纹理中的半数切片。\n\n![3D纹理](/img/article/20190810/3.png)\n\n## 2D纹理数组\n\nOpenGL ES 3.0中最后一种纹理是2D纹理数组。2D纹理数组与3D纹理很相似，但是用途不同。例如，2D纹理数组尝尝用于存储2D图像的一个动画。数组的每个切片表示纹理动画的一帧。2D纹理数组和3D纹理之间的差别很细微，但是很重要。对于3D纹理，过滤发生在切片之间，而从2D纹理数组中读取只从一个单独的切片采样。mip贴图也不一样。2D纹理数组中的每个mip贴图级别包含与以上级别相同的切片数量。每个2D切片的mip贴图完全独立于其他切片（这与3D纹理的情况不同，3D纹理的每个mip贴图级别只有以上级别切片数量的一半）。\n\n为了在2D纹理数组中定位，需使用与3D纹理一样的纹理坐标(s, t, r)，r坐标选择2D纹理数组中要使用的切片，(s, t)坐标用于选择切片，选择的方法与2D纹理完全一样。\n\n## 纹理对象和纹理的加载\n\n纹理应用的第一步是创建一个纹理对象。纹理对象是一个容器对象，保存渲染所需的纹理数据，例如图像数据、过滤模式和包装模式。在OpenGL ES中，纹理对象用一个无符号整数表示，该整数是纹理对象的一个句柄。用于生成纹理对象的函数是`glGenTextures`：\n\n``` objc\n/**\n 生成纹理\n\n @param n#> 指定要生成的纹理对象数量 description#>\n @param textures#> 一个保存n个纹理对象ID的无符号整数数组 description#>\n @return void\n */\nglGenTextures(GLsizei n, GLuint *textures);\n```\n\n在创建的时候，`glGenTextures`生成的纹理对象是一个空的容器，用于加载纹理数据和参数。纹理对象在应用程序不在需要它们的时候也必须删除。这一步骤通常在应用程序关闭或者游戏级别改变时完成，可以使用`glDeleteTextures`实现：\n\n``` objc\n/**\n 删除纹理\n\n @param n#> 指定要删除的纹理对象数量 description#>\n @param textures#> 一个保存要删除的n个纹理对象ID的无符号整数数组 description#>\n @return void\n */\nglDeleteTextures(GLsizei n, const GLuint *textures);\n```\n\n一旦用`glGenTextures`生成了纹理对象ID，应用程序就必须绑定纹理对象进行操作。绑定纹理对象之后，后续的操作(如`glTexImage2D`和`glTexParameter`)将影响绑定的纹理对象。用于绑定纹理对象的函数是`glBindTexture`：\n\n``` objc\n/**\n 绑定纹理对象\n\n @param target#> 将纹理对象绑定到GL_TEXTURE_2D、GL_TEXTURE_3D、GL_TEXTURE_2D_ARRAY或者GL_TEXTURE_CUBE_MAP description#>\n @param texture#> 要绑定的纹理对象句柄 description#>\n @return void\n */\nglBindTexture(GLenum target, GLuint texture);\n```\n\n一旦纹理绑定到一个特定的纹理目标，纹理对象在删除之前就一直绑定到它的目标。生成纹理对象并绑定它之后，使用纹理的下一个步骤是真正地加载图像数据。用于加载2D和立方图纹理的基本函数是`glTexImage2D`。此外，在OpenGL ES 3.0中可以使用多种替代方法指定2D纹理，包括不可变纹理(`glTexStorage2D`)和`glTexSubImage2D`的结合。我们首先从最基本的方法开始--使用`glTexImage2D`--并在后面描述不可变纹理。为了获得最佳性能，建议使用不可变纹理。\n\n``` objc\n/**\n 加载2D和立方图纹理\n\n @param target#> 指定目标纹理，可以为GL_TEXTURE_2D、GL_TEXTURE_CUBE_MAP_POSITIVE_(X, Y, Z)、GL_TEXTURE_CUBE_MAP_NEGATIVE_(X, Y, Z) description#>\n @param level#> 指定要加载的mip级别，第一个级别为0，后续的mip贴图级别递增 description#>\n @param internalformat#> 纹理存储的内部格式；可以是未确定大小的基本内部格式，后者是确定大小的内部格式。未确定大小的内部格式可以为GL_RGBA，GL_RGB，GL_LUMINANCE_ALPHA，GL_LUMINANCE，GL_ALPHA。确定大小的内部格式有GL_RGB，GL_DEPTH_COMPONENT16等 description#>\n @param width#> 图像的像素宽度 description#>\n @param height#> 图像的像素高度 description#>\n @param border#> 这个参数在OpenGL ES中被忽略，保留它是为了与桌面的OpenGL接口兼容；应该为0 description#>\n @param format#> 输入的纹理数据格式，可以为GL_RED(_INTEGER)，GL_RG(_INTEGER)，GL_RGB(_INTERGER)，GL_RGBA(_INTEGER)，GL_DEPTH_COMPONENT，GL_DEPTH_STENCIL，GL_LUMINANCE_ALPHA，GL_ALPHA description#>\n @param type#> 输入像素数据的类型 description#>\n @param pixels#> 包含图像的实际像素数据。数据必须包含（width*height*高度）个像素，每个像素根据格式和类型规范有相应的字节数。像素行必须对其到用`glPixelStorei`设置的GL_UNPACK_ALIGHMENT description#>\n @return void\n */\nglTexImage2D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels);\n```\n\n下面举个例子，演示了生成纹理对象、绑定该对象然后加载由无符号字节表示的RGB图像数据组成的 2x2 2D纹理：\n\n``` objc\nGLuint textureId;\nGLubyte pixels[] = {\n    255, 0, 0,\n    0, 255, 0,\n    0, 0, 255,\n    255, 255, 0\n};\n\n// User tightly packed data\nglPixelStorei(GL_UNPACK_ALIGNMENT, 1);\n\n// Generate a texture object\nglGenTextures(1, &textureId);\n\n// Bind the texture object\nglBindTexture(GL_TEXTURE_2D, textureId);\n\n// Load the texture\nglTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, 2, 2, 0, GL_RGB, GL_UNSIGNED_BYTE, pixels);\n\n// Set the filtering mode\nglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);\nglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);\n```\n\n在上述代码的第一部分，`pixels`数组用简单的2x2纹理数据初始化。这些数据由无符号字节RGB三元组组成，范围为[0, 255]。当着色器中从一个8位无符号字节纹理分量读取数据时，该值从[0, 255]区间被映射到浮点区间[0.0, 1.0]。一般来说，应用程序不会以这种简单的方式创建纹理数据，而从一个图像文件中加载数据。\n在调用`glTexImage2D`之前，应用程序调用`glPixelStorei`设置解包对齐。通过`glTexImage2D`上传纹理数据时，像素行被认定为对齐到`GL_UNPACK_ALIGNMENT`设置的值。默认情况下，该值为4，意味着像素行被认定为从4字节的边界开始。\n这个应用程序将解包对齐设置为1，意味着每个像素行从字节边界开始（换言之，数据被紧密打包）。\n\n``` objc\n/**\n 设置包装或者解包对齐\n\n @param pname#> 指定设置的像素存储类型，下面的选项影响调用glTexImage2D、glTexImage3D、glTexSubImage2D和glTexSubImage3D时数据从内存中解包的方式：GL_UNPACK_ROW_LENGTH，GL_UNPACK_IMAGE_HEIGHT，GL_UNPACK_SKIP_PIXELS，GL_UNPACK_SKIP_ROWS，GL_UNPACK_SKIP_IMAGES，GL_UNPACK_ALIGNMENT；下面的选项影响调用glReadPixels时数据打包到内存中的方式：GL_PACK_ROW_LENGTH，GL_PACK_IMAGE_HEIGHT，GL_PACK_SKIP_PIXELS，GL_PACK_SKIP_ROWS，GL_PACK_SKIP_IMAGES，GL_PACK_ALIGNMENT description#>\n @param param#> 指定包装或者解包选项的整数值 description#>\n @return void\n */\nglPixelStorei(GLenum pname, GLint param);\n```\n\n`glPixelStorei`的`GL_PACK_xxxx`参数对纹理图像上传没有任何影响。打包选项由`glReadPixels`使用。`glPixelStorei`设置的打包和解包选项是全局状态，不由纹理对象存储，也不与之关联。在实践中，很少使用`GL_UNPACK_ALIGNMENT`之外的选项指定纹理。为了完整起见，下表提供了像素存储选项的完整列表。\n\n像素存储选项 | 初始值 | 描述\n- | - | -\nGL_UNPACK_ALIGNMENT GL_PACK_ALIGNMENT | 4 | 指定图像中各行的对齐方式。默认情况下，图像始于4字节边界。将该值设置为1意味着图像紧密打包，各行到齐到字节边界\nGL_UNPACK_ROW_LENGTH GL_PACK_ROW_LENGTH | 0 | 如果该值非0，则表示每个图像行中的像素数量。如果该值为0，则行的长度为图像的宽度（也就是紧密打包）\nGL_UNPACK_IMAGE_HEIGHT GL_PACK_IMAGE_HEIGHT | 0 | 如果该值非0，则表示作为3D纹理一部分的图形的每个列中像素的数量。这个选项可以用于在3D纹理的每个切片之间填充列。如果该值为0，则图像中的列数等于高度（也就是紧密打包）\nGL_UNPACK_SKIP_PIXELS GL_PACK_SKIP_PIXELS | 0 | 如果该值非0，则表示行开始处跳过的像素数量\nGL_UNPACK_SKIP_ROWS GL_PACK_SKIP_ROWS | 0 | 如果该值非0，则表示图像开始时跳过的行数\nGL_UNPACK_SKIP_IMAGES GL_PACK_SKIP_IMAGES | 0 | 如果该值非0，则表示3D纹理中跳过的图像数\n\n代码的最后一部分使用`glTexParameteri`将缩小和放大过滤模式设置为`GL_NEAREST`。这段代码是必需的，因为我们还没有为纹理加载完整的mip贴图链；因此，必须选择非mip贴图缩小过滤器。用于缩小和放大模式的其他选项是`GL_LINEAR`，提供双线性非mip贴图过滤。\n\n## 纹理过滤和mip贴图\n\n到目前为止，我们对2D纹理的介绍仅限于单个2D图像。尽管这使得我们能够解释纹理的概念，但是OpenGL ES中纹理的指定和使用还有一些其他的方法。这种复杂性与使用单个纹理贴图时发生的视觉伪像和性能问题有关。正如我们到目前为止所描述的那样，纹理坐标用于生成一个2D索引，以从纹理贴图中读取。当缩小和放大过滤器设置为`GL_NEAREST`时，就会发生这样的情况：一个纹素将在提供的纹理坐标位置上读取。这称作点采样或者最近采样。\n但是，最近采样可能产生严重的视觉伪像，这是因为三角形在屏幕空间中变得较小，在不同像素间的插值中，纹理坐标有很大的跳跃。结果是，从一个大的纹理贴图中去的少量样本，造成锯齿伪像，而且可能造成巨大性能损失。OpenGL ES中解决这类伪像的方案被称作mip贴图（mipmapping）。mip贴图的思路是构建一个图像链--mip贴图链。mip贴图链始于原来指定的图像，后续的每个图像在每个维度上是前一个图像的一半，一直持续到最后达到链底部的1x1纹理。mip贴图级别可以编程生成，一个mip级别中的每个像素通常根据上一级别中相同位置的4个像素的平均值计算（盒式过滤）。\n[GenMipMap2D](https://github.com/danginsburg/opengles3-book/blob/master/Chapter_9/MipMap2D/MipMap2D.c)函数提供了生成mip贴图链的代码。这个函数以一个RGB8图形作为输入，在前面的图像上执行盒式过滤，生成下一个mip贴图级别。mip贴图链用`glTexImage2D`加载。\n加载mip贴图链之后，便可以设置过滤模式，以使用mip贴图。结果是我们实现了屏幕像素和纹理像素间的更好比率，从而减少了锯齿伪像。图像的锯齿也减少了，这是因为mip贴图链中的每个图像连续进行过滤，使得高频元素随着贴图链的下移越来越少。\n\n``` objc\nglTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, pixels);\nint level = 1;\nGLubyte *prevImage = &pixels[0];\nGLubyte *newImage;\nwhile (width > 1 && height > 1) {\n    int newWidth, newHeight;\n    \n    // Generate the next mipmap level\n    GenMipMap2D(prevImage, &newImage, width, height, &newWidth, &newHeight);\n    \n    // Load the mipmap level\n    glTexImage2D(GL_TEXTURE_2D, level, GL_RGB, newWidth, newHeight, 0, GL_RGB, GL_UNSIGNED_BYTE, newImage);\n    \n    // Free the previous image\n    free(prevImage);\n    \n    // Set the previous image for the next iteration\n    prevImage = newImage;\n    level += 1;\n    \n    // Half the width and height\n    width = newWidth;\n    height = newHeight;\n}\nfree(newImage);\n```\n\n纹理渲染时发生两种过滤：缩小和放大。缩小发生在屏幕上投影的多边形小于纹理尺寸的时候。放大发生在屏幕上投影的多边形大于纹理尺寸的时候。过滤器类型的确定由硬件自动处理，但是API提供了对每种情况下使用的过滤类型的控制。对于放大，mip贴图不起作用，因为我们总是从最大的可用级别采样。对于缩小，可以使用不同的采样模式。所用模式的选择基于你需要实现的显示质量水平以及为了纹理过滤损失多少性能。\n过滤模式（和许多其他纹理选项）用`glTexParameter[i|f][v]`指定。接下来描述纹理过滤模式。\n\n``` objc\nglTexParameteri(GLenum target, GLenum pname, GLint param)\nglTexParameteriv(GLenum target, GLenum pname, const GLint *params);\nglTexParameterf(GLenum target, GLenum pname, GLfloat param);\nglTexParameterfv(GLenum target, GLenum pname, const GLfloat *params);\n```\n\n`pname`为`GL_TEXTURE_MAG_FILTER`放大过滤器时，`param`可能是`GL_NEAREST`或`GL_LINEAR`。在`GL_NEAREST`放大过滤中，将从最靠近纹理坐标的纹理中取得单点样本。在`GL_LINEAR`放大过滤中，将从纹理坐标附近的纹理中取得一个双线性样本（4个样本的平均值）。\n`pname`为`GL_TEXTURE_MIN_FILTER`缩小过滤器时，`param`可以设置为如下值的任意一个：\n- `GL_NEAREST` -- 从最靠近纹理坐标的纹理中获得一个单点样本。\n- `GL_LINEAR` -- 从最靠近纹理坐标的纹理中获得一个双线性样本。\n- `GL_NEAREST_MIPMAP_NEAREST` -- 从所选的最近的mip级别中去的单点样本。\n- `GL_NEAREST_MIPMAP_LINEAR` -- 从两个最近的mip级别中获得样本，并在这些样本之间插值。\n- `GL_LINEAR_MIPMAP_NEAREST` -- 从所选的最近mip级别中获得双线性样本。\n- `GL_LINEAR_MIPMAP_LINEAR` -- 从两个最近的mip级别中获得双线性样本，然后在它们之间插值。这种模式通常被称作三线性过滤，产生所有模式中最佳的质量。\n\n> 在纹理缩小模式中，只要`GL_NEAREST`和`GL_LINEAR`不需要为纹理指定完整的mip贴图链。其他所有模式都要求纹理存在完整的mip贴图链。\n\n选择的纹理过滤模式对性能有一定的影响。如果发生缩小且担心性能，那么使用mip贴图过滤模式通常是大部分硬件上的最佳选择。如果没有mip贴图，则纹理缓存利用率可能非常低，因为读取发生在贴图的少数位置。然而，你选择的过滤模式较高，在硬件中的性能代价就越大。例如，在大部分硬件上，进行双线性过滤的代价低于三线性过滤。我们应该选择一种可以提供所要的质量但是不会对性能有过分负面影响的模式。在某些硬件上，你可能轻松地获得高质量的过滤，特别是在纹理过滤带来的开销不是我们的瓶颈时。这需要在应用程序和计划运行应用程序的硬件上进行调整。\n\n### 无缝立方图过滤\n\n关于过滤，OpenGL ES 3.0中有一个新变化，与立方图的过滤有关。在OpenGL ES 2.0中，当线性过滤核心落到立方图边缘时，过滤将只发生在立方图的一个面上。这将在立方图各面之间的边上造成伪像。在OpenGL ES 3.0中，立方图过滤现在是无缝的--如果过滤核心跨越立方图不止一个面，核心将会从其覆盖的每个面中获得样本。无缝过滤在立方图各面的边缘形成了更平滑的过滤。在OpenGL ES 3.0中，不需要做任何操作就可以启用无缝立方图过滤，所有线性过滤核心将自动使用它。\n\n## 自动mip贴图生成\n\n前一节讲述了生成mip贴图的一种途径，但是OpenGL ES 3.0还提供了用`glGenerateMipmap`自动生成mip贴图的机制。\n\n``` objc\n/**\n 自动生成mip贴图\n\n @param target#> 为之生成mip贴图的纹理目标；可以是GL_TEXTURE_2D、GL_TEXTURE_3D、GL_TEXTURE_2D_ARRAY或GL_TEXTURE_CUBE_MAP description#>\n @return void\n */\nglGenerateMipmap(GLenum target);\n\n```\n\n在绑定的纹理对象上调用`glGenerateMipmap`时，这个函数将从0级图像的内容生成整个mip贴图链。对于2D纹理，0级纹理内容将持续地被过滤并用于每个后续级别。对于立方图，立方体的每一面都由各面的0级生成。当然，要将这个函数用于立方图，必须为立方体的每个面指定0级，每个面的内部格式、宽度和高度都必须匹配。对于2D纹理数组，数组的每个切片将进行与2D纹理一样的过滤。最后，对于3D纹理，将通过过滤各个切片生成全体的mip贴图。\nOpenGL ES 3.0不强制用于生成mip贴图的特定过滤算法（但是规范中推荐盒式过滤，各种实现可以自由地选择他们使用的算法）。如果需要特定的过滤方法，就必须自己生成mip贴图。\n在开始使用帧缓冲区对象渲染纹理时，自动化mip贴图生成变得特别重要。当渲染到一个纹理时，我们不希望将纹理的内容读回CPU来生成mip贴图，相反，可以使用`glGenerateMipmap`和图形硬件，然后在不需要将数据读回CPU的情况下生成mip贴图。\n\n## 纹理坐标包装\n\n纹理包装模式用于指定纹理坐标超出[0.0, 1.0]范围时所发生的行为，用`glTexParameter[i|f][v]`设置。这些模式可以为s、t、r坐标单独设置。`GL_TEXTURE_WRAP_S`模式定义s坐标超出[0.0, 1.0]范围时发生的行为，`GL_TEXTURE_WRAP_T`设置t坐标的行为，`GL_TEXTURE_WRAP_R`设置r坐标的行为（r坐标包装仅用于3D纹理和2D纹理数组）。在OpenGL ES中有三个包装模式可供选择，如下表：\n\n纹理包装模式 | 描述\n- | -\nGL_REPEAT | 重复纹理\nGL_CLAMP_TO_EDGE | 限定读取纹理的边缘\nGL_MIRRORED_REPEAT | 重复纹理和镜像\n\n注意，纹理包装模式也影响过滤行为。例如，当纹理坐标在纹理的边缘时，线性过滤核心可能跨越纹理的边缘。在这种情况下，包装模式将决定对于核心在纹理边缘之外的部分要读取哪些纹素。在不希望出现任何形式的重复时，应该使用`GL_CLAMP_TO_DEGE`。\n\n## 纹理调配\n\n纹理调配（Swizzle）控制输入的R、RG、RGB或RGBA纹理中的颜色分量在着色器中读取时如何映射到分量。例如，应用程序可能希望一个`GL_RED`纹理映射为(0, 0, 0, R)或者(R, R, R, 1)而不是默认的(R, 0, 0, 1)。每个R、G、B、A值映射到的纹理分量都可以用`glTexParameter[i|f][v]`设置的纹理调配单独控制。需要控制的分量用`GL_TEXTURE_SWIZZLE_R`、`GL_TEXTURE_SWIZZLE_G`、`GL_TEXTURE_SWIZZLE_B`或`GL_TEXTURE_SWIZZLE_A`设置。作为该分量纹理值来源的可能是分别从R、G、B、A分量读取的`GL_RED`、`GL_GREEN`、`GL_BLUE`或`GL_ALPHA`。此外，应用程序可以分别用`GL_ZERO`或`GL_ONE`将该值设置为常数0或者1。\n\n## 纹理细节级别\n\n在某些应用中，在所有纹理mip贴图级别可用之前就能够开始显示场景是很实用的。例如，通过数据连接下载纹理图像的GPS应用可以从最低级别的mip贴图开始，在更高级别可用时再显示它们。在OpenGL ES 3.0中，可以通过使用`glTexParameter[i|f][v]`的多个参数实现。`GL_TEXTURE_BASE_LEVEL`设置用于纹理的最大mip贴图级别。默认情况下下，该值为0，但是如果mip贴图级别还不可用，则可以设置为更高的值。同样，`GL_TEXTURE_MAX_LEVEL`设置使用的最小mip贴图级别。默认情况下，它的值为1000（超过了任何纹理可能具备的最大级别），但是可以将其设置为较小的值，以控制用于纹理的最小mip级别。\n为了选择要用于渲染的mip贴图级别，OpenGL ES自动计算一个细节级别（LOD）值。这个浮点值确定从哪一个mip贴图级别过滤（在三线性过滤中，控制每个mip贴图使用的多少）。应用程序还可以用`GL_TEXTURE_MIN_LOD`和`GL_TEXTURE_MAX_LOD`控制最小和最大的LOD值。可以从基本和最大mip贴图级别单独控制LOD限制的一个原因是在新的mip贴图级别可用时提供平滑过渡。仅仅设置纹理的基本和最大级别可能在新mip贴图级别可用时造成间歇伪像，而插入LOD可以使这一过渡看起来更平滑。\n\n## 深度纹理对比（百分比渐进过滤）\n\n最后两个纹理参数是`GL_TEXTURE_COMPARE_FUNC`和`GL_TEXTURE_COMPARE_MODE`。引入这些纹理参数是为了提供百分比渐进过滤（PCF）功能。在执行被称作阴影贴图的阴影技术时，片段着色器需要比较一个片段的当前深度值和深度纹理中的深度值，以确定片段在阴影之内还是之外。为了实现平滑的阴影边缘效果，对深度纹理进行双线性过滤是很有用的。但是，在过滤深度值时，我们希望过滤在采样深度值并与当前深度（或参考值）比较之后发生。如果过滤在比较之前发生，我们将平均计算深度纹理中的值，这不能提供正确的结果。PCF提供了正确的过滤，将采样的每个深度值与参考深度比较，然后将这些比较的结果（0或者1）一起进行平均。\n`GL_TEXTURE_COMPARE_MODE`默认为`GL_NONE`，但是当它被设置为`GL_COMPARE_REF_TO_TEXTURE`时，(s, t, r)纹理坐标中的r坐标将与深度纹理的值进行比较。然后，比较的结果将成为阴影纹理读取的结果（可能是9或者1，如果启用纹理过滤，则为这些值的平均）。比较函数用`GL_TEXTURE_COMPARE_FUNC`设置，可以设置为`GL_LEQUAL`、`GL_GEQUAL`、`GL_LESS`、`GL_GREATER`、`GL_EQUAL`、`GL_NOTEQUAL`、`GL_ALWAYS`或者`GL_NEVER`。\n\n## 纹理格式\n\nOpenGL ES 3.0为纹理提供了广泛的数据格式，格式的数量比OpenGL ES 2.0有了很大的增加。\n2D纹理可以以确定大小或者确定大小的内部格式用`glTexImage2D`上传。如果纹理用未确定大小的格式指定，则OpenGL ES实现可以自由选择纹理数据存储的内部表现形式。如果纹理用确定大小的格式指定，则OpenGL ES实现将选择至少与指定的位数相同的格式。\n\n`glTexImage2D`的有效的未确定大小内部格式组合：\n\n内部格式 | 格式 | 类型 | 输入数据\n- | - | - | -\nGL_RGB | GL_RGB | GL_UNSIGNED_BYTE | 8/8/8 RGB 24- 位\nGL_RGB | GL_RGB | GL_UNSIGNED_SHORT_5_6_5 | 5/6/5 RGB 16- 位\nGL_RGBA | GL_RGBA | GL_UNSIGNED_BYTE | 8/8/8/8 RGBA 32- 位\nGL_RGBA | GL_RGBA | GL_UNSIGNED_SHORT_4_4_4_4 | 4/4/4/4 RGBA 16- 位\nGL_RGBA | GL_RGBA | GL_UNSIGNED_SHORT_5_5_5_1 | 5/5/5/1 RGBA 16- 位\nGL_LUMINANCE_ALPHA | GL_LUMINANCE_ALPHA | GL_UNSIGNED_BYTE | 8/8 LA 16- 位\nGL_LUMINANCE | GL_LUMINANCE | GL_UNSIGNED_BYTE | 8L 8- 位\nGL_ALPHA | GL_ALPHA | GL_UNSIGNED_BYTE | 8A 8- 位\n\n如果应用程序希望更多地控制数据的内部存储方式，那么它可以使用确定大小的内部格式。\n\n### 规范化纹理格式\n\n我们所说的”规范化“指的是从片段着色器中读取纹理时，结果将处于[0.0, 1.0]范围内（或者在*_SNORM格式中的[-1.0, 1.0]范围）。例如，用`GL_UNSIGNED_BYTE`数据指定的`GL_R8`图像将取得每个8位的无符号字节值(范围为[0, 255])，并在片段着色器读取时映射到[0.0, 1.0]。用`GL_BYTE`数据指定的`GL_R8_SNORM`图像将取得每个8位的有符号字节值（范围为[-128, 127]）并在读取时映射到[-1.0, 1.0]。\n\n![glTexImage2D的规范化确定大小内部格式组合](/img/article/20190810/4.png)\n\n### 浮点纹理格式\n\nOpenGL ES 3.0也引入浮点纹理格式。大部分浮点格式由16位半浮点数据或者32位浮点数据支持。与规范化纹理格式（R、RG、RGB、RGBA）一样，浮点纹理格式可能有1~4个分量。OpenGL ES 3.0不强制浮点格式用作渲染目标，只强制16位半浮点数据可以过滤。\n\n![glTexImage2D的有效确定大小浮点内部格式组合](/img/article/20190810/5.png)\n\n### 整数纹理格式\n\n整数纹理格式允许纹理范围在片段着色器中以整数形式读取。也就是说，与片段着色器中读取时数据从整数表示转换为规范化浮点值的规范化纹理格式相反，整数纹理中的值在片段着色器读取时仍然为整数。\n整数纹理格式不可过滤，但是R、RG和RGBA变种可以用作帧缓冲区对象中渲染的颜色附着（color attachment）。使用整数纹理作为颜色附着的时候，忽略Alpha混合状态（整数渲染目标不可能进行混合）。用于从整数纹理读取并输出到整数渲染目标的片段着色器应该使用对应该格式的有符号或者无符号整数类型。\n\n![glTexImage2D的有效确定大小内部整数格式组合](/img/article/20190810/6.png)\n![glTexImage2D的有效确定大小内部整数格式组合](/img/article/20190810/7.png)\n\n### 共享指数纹理格式\n\n共享指数纹理为不需要浮点纹理使用的那么多深度位数的大范围RGB纹理提供了一种存储方式。共享指数纹理通常用于高动态范围（HDR）图像，这种图像不需要半浮点或者全浮点数据。OpenGL ES 3.0中的共享指数纹理格式是`GL_RGB9_E5`。在这种格式中，3个RGB分量共享一个5位的指数。5位的指数隐含地由数值15调整。RGB的每个9位的数值存储无符号位的尾数（因此必然为正）。\n\n![共享指数纹理转换](/img/article/20190810/8.png)\n\n### sRGB纹理格式\n\nOpenGL ES 3.0中引入的另一个纹理格式是sRGB纹理。sRGB是一个非线性颜色空间，大约遵循一个幂函数。大部分图像实际上都存储为sRGB颜色空间，这种非线性解释了人类能够在不同的亮度级别上更好地区分颜色这一事实。\n如果用于纹理的图像是以sRGB颜色空间创作的，但是没有使用sRGB纹理读取，那么所有发生在着色器中的照明计算都会在非线性颜色空间中进行。也就是说，标准创作软件包创建的纹理保存为sRGB，从着色器中读取时仍然保持为sRGB。于是照明计算发生在非线性sRGB空间中。许多应用程序都犯了这个错误，这是不正确的，会造成明显不同（不准确）的输出图像。\n为了正确地处理sRGB图像，应用程序应该使用一个sRGB纹理格式，这种格式在着色器中读取时将从sRGB转换为线性颜色空间。然后，着色器中的所有计算都将在线性颜色空间中完成。最后，通过渲染到一个sRGB渲染目标，图像将会自动地转换回sRGB。可以使用着色器命令`pow(value, 2.0)`进行近似的sRGB->线性转换，然后用`(value, 1/2.2)`进行近似的线性->sRGB转换。然后，尽可能使用sRGB纹理是最好的做法，因为这样减少了着色器指令数量，并且提供更准确的sRGB转换。\n\n内部格式 | 格式 | 类型 | 输出数据 | R | F\n- | - | - | - | - | -\nGL_SRGB8 | GL_RGB | GL_UNSIGNED_BYTE | 8/8/8 SRGB | | X\nGL_SRGB8_ALPHA8 | GL_RGBA | GL_UNSIGNED_BYTE | 8/8/8/8 RGBA | X | X\n\n### 深度纹理格式\n\nOpenGL ES 3.0中的最后一种纹理格式类型是深度纹理。深度纹理允许应用程序从帧缓冲区对象的深度附着中读取深度值（和可选的模板值）。这在各种高级渲染算法中很有用，包括阴影贴图。下表展示了OpenGL ES 3.0中有效的深度纹理格式：\n\n内部格式 | 格式 | 类型\n- | - | -\nGL_DEPTH_COMPONENT16 | GL_DEPTH_COMPONENT | GL_UNSIGNED_SHORT\nGL_DEPTH_COMPONENT16 | GL_DEPTH_COMPONENT | GL_UNSIGNED_INTp\nGL_DEPTH_COMPONENT24 | GL_DEPTH_COMPONENT | GL_UNSIGNED_INT\nGL_DEPTH_COMPONENT43F | GL_DEPTH_COMPONENT | GL_FLOAT\nGL_DEPTH24_STENCIL8 | GL_DEPTH_STENCIL | GL_UNSIGNED_INT_24_8\nGL_DEPTH32F_STENCIL8 | GL_DEPTH_STENCIL | GL_FLOAT_32_UNSIGNED_INT_24_8_REV\n\n## 在着色器中使用纹理\n\n下面代码简要演示在着色器中完成2D纹理的基本过程：\n\n``` objc\n// Vertex shader\n# version 300 es\nlayout(location = 0) in vec4 a_position;\nlayout(location = 1) in vec2 a_texCoord;\nout vec2 v_texCoord;\nvoid main()\n{\n    gl_Position = a_position;\n    v_texCoord = a_texCoord;\n}\n```\n\n``` objc\n// Fragment shader\n# version 300 es\nprecision mediump float;\nin vec2 v_texCoord;\nlayout(location = 0) out vec4 outColor;\nuniform sampler2D s_texture;\nvoid main()\n{\n    outColor = texture(s_texture, v_texCoord);\n}\n```\n\n顶点着色器以一个二分量纹理坐标作为顶点输入，并将其作为输出传递给片段着色器。片段着色器消费该纹理坐标，并将其用于纹理读取。片段着色器声明一个类型为`sampler2D`的统一变量`s_texture`。采样器是用于从纹理贴图中读取的特殊统一变量。采样器统一变量将加载一个指定纹理绑定的纹理单元的数值；例如，用数值0指定采样器表示从单元`GL_TEXTURE0`读取，指定数值1表示从`GL_TEXTURE1`读取，一次类推。在OpenGL ES 3.0 API中，纹理用`glActiveTexture`函数绑定到纹理单元。\n\n``` objc\n/**\n 绑定纹理单元\n\n @param texture#> 需要激活的纹理单元：GL_TEXTURE0, 1, 2 description#>\n @return void\n */\nglActiveTexture(GLenum texture);\n```\n\n`glActiveTexture`函数设置当前纹理单元，以便后续的`glBindTexture`调用将纹理绑定到当前活动单元。在OpenGL ES实现上可用于片段着色器的纹理单元数量可以用`GL_MAX_TEXTURE_IMAGE_UNITS`参数的`glGetintegerv`查询。可用于顶点着色器的纹理单元数量使用带`GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS`参数的`glGetintegerv`查询。\n\n当使用`glBindTexture`绑定为并使用`glUniformli`加载纹理后，可以看到片段着色器中使用内建函数`texture`从纹理贴图出读取。`texture`内建函数形式如下：\n\n``` objc\n/**\n 绑定2D纹理单元\n\n @param sampler#> 绑定到纹理单元的采样器，指定纹理为读取来源 description#>\n @param coord#> 用于从纹理贴图中读取的2D纹理坐标 description#>\n @param bias#> 可选参数，提供用于纹理读取的mip贴图偏置。这允许着色器明确地偏置用于mip忒土选择的LOD计算值 description#>\n @return vec4 纹理\n */\ntexture(sampler2D sampler, vec2 coord[, float bias]);\n```\n\n`texture`函数返回一个代表从纹理贴图中读取颜色的`vec4`。纹理数据映射到这个颜色通道的方式取决于纹理的基本格式。下表展示了纹理格式映射到`vec4`颜色的方式，[纹理调配](/article/2019/opengl-es-texture-0810/#纹理调配)确定这些分量中的值如何映射到着色器中的分量。\n\n基本格式 | 纹素数据描述\n- | -\nGL_RED | (R, 0.0 0.0, 1.0)\nGL_RG | (R, G, 0.0, 1.0)\nGL_RGB | (R, G, B, 1.0)\nGL_RGBA | (R, G, B, A)\nGL_LUMINANCE | (L, L, L, 1.0)\nGL_LUMINANCE_ALPHA | (L, L, L, A)\nGL_ALPHA | (0.0, 0.0, 0.0, A)\n\n下面看具体示例：\n\n``` objc\n- (void)setupVertices {\n    \n    GLfloat vertices[] = {\n        -1.0, -1.0, 0,\n        0, 0,\n        -1.0, 1.0, 0,\n        0, 1,\n        1.0, -1.0, 0,\n        1, 0,\n        1.0, 1.0, 0,\n        1, 1\n    };\n    \n    // 生成纹理\n    GLuint texture = [self createTextureWithImage:[UIImage imageNamed:@\"9\"]];\n    \n    GLuint program = [self createProgram];\n    glUseProgram(program);\n    glViewport(0, 0, [self getViewportWidth], [self getViewportHeight]);\n    \n    glClear(GL_COLOR_BUFFER_BIT);\n    glClearColor(0.0, 0.0, 0.0, 1.0);\n    \n    // 加载纹理\n    glActiveTexture(GL_TEXTURE0);\n    int textureLocation = glGetUniformLocation(program, \"s_texture\");\n    glBindTexture(GL_TEXTURE_2D, texture);\n    glUniform1i(textureLocation, 0);\n    \n    GLuint vbo;\n    glGenBuffers(1, &vbo);\n    glBindBuffer(GL_ARRAY_BUFFER, vbo);\n    glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);\n    \n    glEnableVertexAttribArray(0);\n    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, sizeof(GLfloat)*5, 0);\n    glEnableVertexAttribArray(1);\n    glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, sizeof(GLfloat)*5, (GLvoid *)(sizeof(GLfloat)*3));\n    \n    glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);\n    \n    [self.context presentRenderbuffer:GL_RENDERBUFFER];\n}\n\n\n- (GLuint)createTextureWithImage:(UIImage *)image {\n    // 将 UIImage 转换为 CGImageRef\n    CGImageRef cgImageRef = [image CGImage];\n    GLuint width = (GLuint)CGImageGetWidth(cgImageRef);\n    GLuint height = (GLuint)CGImageGetHeight(cgImageRef);\n    CGRect rect = CGRectMake(0, 0, width, height);\n    \n    // 绘制图片\n    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();\n    // 获取图片字节数 宽x高x4（RGBA）\n    void *imageData = malloc(width * height * 4);\n    /**\n     创建上下文\n\n     @param data#> 指向要渲染的绘制图像的内存地址 description#>\n     @param width#> 图像宽度，单位为像素 description#>\n     @param height#> 图像高度，单位为像素 description#>\n     @param bitsPerComponent#> 内存中像素的每个组件的位数，比如32位RGBA，就设置为8 description#>\n     @param bytesPerRow#> 每一行内存所占的bit数 description#>\n     @param space#> 使用的颜色空间 description#>\n     @param bitmapInfo#> bitmap信息 description#>\n     @return 返回上下文\n     */\n    CGContextRef context = CGBitmapContextCreate(imageData, width, height, 8, width * 4, colorSpace, kCGImageAlphaPremultipliedLast | kCGBitmapByteOrder32Big);\n    // 图片正向-否则绘制出来的图片是颠倒的\n    CGContextTranslateCTM(context, 0, height);\n    CGContextScaleCTM(context, 1.0f, -1.0f);\n    CGColorSpaceRelease(colorSpace);\n    CGContextClearRect(context, rect);\n    CGContextDrawImage(context, rect, cgImageRef);\n    \n    // 生成纹理\n    GLuint textureID;\n    glGenTextures(1, &textureID);\n    glBindTexture(GL_TEXTURE_2D, textureID);\n    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, imageData); // 将图片数据写入纹理缓存\n    \n    // 设置如何把纹素映射成像素\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n    \n    // 解绑\n    glBindTexture(GL_TEXTURE_2D, 0);\n    \n    // 释放内存\n    CGContextRelease(context);\n    free(imageData);\n    \n    return textureID;\n}\n```\n\n## 使用立方图纹理的示例\n\n立方图纹理的使用非常类似于2D纹理。通过对立方图的各面（`GL_TEXTURE_CUBE_MAP_POSITIVE_(X|Y|Z)`，`GL_TEXTURE_CUBE_NEGATIVE_(X|Y|Z)`）调用`glTexImage2D`加载每个面的像素数据。\n\n``` objc\n// Vertex shader\n#version 300 es\nlayout(location = 0) in vec4 a_position;\nlayout(location = 1) in vec3 a_normal;\nout vec3 v_normal;\nvoid mian()\n{\n    gl_Position = a_position;\n    v_normal = a_normal;\n}\n```\n\n``` objc\n// Fragment shader\n#version 300 es\nprecision mediump float;\nin vec3 v_normal;\nlayout(location = 0) out vec4 outColor;\nuniform samplerCube s_texture;\nvoid main()\n{\n    outColor = texture(s_texture, v_normal);\n}\n```\n\n顶点着色器取得一个位置和法线作为顶点输入。发现保存在球面的每个顶点上，用作纹理坐标，并传递给片段着色器。然后，片段着色器使用内建函数`texture`，以法线作为纹理坐标从立方图中读取。立方图所用的`texture`内建函数采用如下形式：\n\n``` objc\n/**\n 绑定立方图纹理单元\n\n @param sampler#> 绑定到纹理单元的采样器，指定纹理为读取来源 description#>\n @param coord#> 用于从纹理贴图中读取的3D纹理坐标 description#>\n @param bias#> 可选参数，提供用于纹理读取的mip贴图偏置。这允许着色器明确地偏置用于mip忒土选择的LOD计算值 description#>\n @return vec4 纹理\n */\ntexture(samplerCube sampler, vec3 coord[, float bias]);\n```\n\n读取立方图的函数与2D纹理非常类似。仅有的区别是，纹理坐标有3个分量而不是2个分量，采样器类型必须为`sampleCube`。用于绑定立方图纹理和加载采样器的方法与之前2D纹理加载一样。\n\n## 加载3D纹理和2D纹理数组\n\n除了2D纹理和立方图，OpenGL ES 3.0还包含了3D纹理和2D纹理数组。加载3D纹理和2D纹理数组的函数是`glTexImage3D`，它与`glTexImage2D`很相似。\n\n``` objc\n/**\n 加载3D纹理或者2D纹理数组\n\n @param target#> 指定纹理目标，应该为GL_TEXTURE_3D或GL_TEXTURE_2D_ARRAY description#>\n @param level#> 指定加载的mip级别。0表示基本级别，更大的数值表示各个后续的mip贴图级别 description#>\n @param internalformat#> 纹理存储的内部格式 description#>\n @param width#> 以像素表示的图像宽度 description#>\n @param height#> 以像素表示的图像高度 description#>\n @param depth#> 3D纹理的切片深度 description#>\n @param border#> 这个参数在OpenGL ES中被忽略，应该为0 description#>\n @param format#> 输入纹理数据的格式 description#>\n @param type#> 输入像素数据的类型 description#>\n @param pixels#> 包含图像的实际像素数据。这些数据必须包含（width*height*depth）个像素，每个像素根据格式和类型规格有相应数量的字节。图像数据应该按照2D纹理切片的顺序存储 description#>\n @return void\n */\nglTexImage3D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels);\n\n```\n\n一旦用`glTexImage3D`加载了3D纹理或者2D纹理数组，就可以用`texture`内建函数在着色器中读取该纹理：\n\n``` objc\n/**\n 绑定3D纹理单元\n\n @param sampler#> 绑定到纹理单元的采样器，指定纹理为读取来源 description#>\n @param coord#> 用于从纹理贴图中读取的3D纹理坐标 description#>\n @param bias#> 可选参数，提供用于纹理读取的mip贴图偏置。这允许着色器明确地偏置用于mip忒土选择的LOD计算值 description#>\n @return vec4 纹理\n */\ntexture(sampler3D sampler, vec3 coord[, float bias]);\n\n/**\n 绑定2D纹理数组单元\n\n @param sampler#> 绑定到纹理单元的采样器，指定纹理为读取来源 description#>\n @param coord#> 用于从纹理贴图中读取的3D纹理坐标 description#>\n @param bias#> 可选参数，提供用于纹理读取的mip贴图偏置。这允许着色器明确地偏置用于mip忒土选择的LOD计算值 description#>\n @return vec4 纹理\n */\ntexture(sampler2DArray sampler, vec3 coord[, float bias]);\n```\n\n> 注意，r坐标是一个浮点值。对于3D纹理，根据过滤模式设置，纹理读取可能跨越体的两个切片。\n\n# 压缩纹理\n\n上述所说的纹理加载都是未压缩的纹理图像数据，OpenGL ES 3.0还支持压缩纹理图像数据的加载。纹理压缩有几个理由，首先，压缩纹理可以减少纹理在设备上的内存占用；其次（不那么明显），压缩纹理节约了着色器中读取纹理时消耗的内存带宽；最后，压缩纹理减少必须存储的图像数据，从而减少了应用程序的下载大小。\n在OpenGL ES 2.0中，核心规范不定义任何压缩的纹理图像格式。也就是说，OpenGL ES 2.0核心简单地定义一个机制，可以加载压缩的纹理图像数据，但是没有定义任何压缩格式。因此，各供应商提供了特定于硬件的纹理压缩扩展。这样，OpenGL ES 2.0应用程序开发者必须在不同平台和硬件上支持不同的纹理压缩格式。\nOpenGL ES 3.0引入所有供应商必须支持的标准纹理压缩格式，从而改善了这种情况。爱立信纹理压缩（Ericsson Texture Compression，ETC2和EAC）以无版税标准的形式提供给Khronos，它被作为OpenGL ES 3.0的标准纹理压缩格式。EAC有一些压缩1通道和2通道数据的变种，ETC2也有压缩3通道和4通道数据的变种。用于加载2D纹理和立方图压缩图像数据的函数是`glCompressedTexImage2D`，用于2D纹理数组的对应函数为`glCompressedTexImage3D`。\n\n> 注意，ETC2/EAC不支持3D纹理（只支持2D纹理和2D纹理数组），但是`glCompressedTexImage3D`可以用于加载供应商专用的3D纹理压缩格式。\n\n``` objc\n/**\n 加载2D纹理和立方图压缩图像数据\n\n @param target#> 指定纹理目标，应该为GL_TEXTURE_2D或者GL_TEXTURE_CUBE_MAP_* description#>\n @param level#> 指定要加载的mip级别 description#>\n @param internalformat#> 纹理存储的内部格式 description#>\n @param width#> 以像素数表示的图像宽度 description#>\n @param height#> 以像素数表示的图像高度 description#>\n @param border#> 这个参数在OpenGL ES中被忽略，应该为0 description#>\n @param imageSize#> 以字节数表示的图像大小 description#>\n @param data#> 包含图像的实际压缩像素数据，必须能够容纳imageSize个字节 description#>\n @return void\n */\nglCompressedTexImage2D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *data);\n\n/**\n 加载2D纹理和立方图压缩图像数据\n\n @param target#> 指定纹理目标，应该为GL_TEXTURE_2D或者GL_TEXTURE_CUBE_MAP_* description#>\n @param level#> 指定要加载的mip级别 description#>\n @param internalformat#> 纹理存储的内部格式。OpenGL ES 3.0中的标准压缩纹理格式在下表中描述 description#>\n @param width#> 以像素数表示的图像宽度 description#>\n @param height#> 以像素数表示的图像高度 description#>\n @param border#> 这个参数在OpenGL ES中被忽略，应该为0 description#>\n @param imageSize#> 以字节数表示的图像大小 description#>\n @param data#> 包含图像的实际压缩像素数据，必须能够容纳imageSize个字节 description#>\n @return void\n */\nglCompressedTexImage3D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *data);\n\n/**\n 加载2D纹理数组或专用3D纹理压缩图像数据\n\n @param target#> 指定纹理目标，应该为GL_TEXTURE_3D或者GL_TEXTURE_2D_ARRAY description#>\n @param level#> 指定要加载的mip级别 description#>\n @param internalformat#> 纹理存储的内部格式。OpenGL ES 3.0中的标准压缩纹理格式在下表中描述 description#>\n @param width#> 以像素数表示的图像宽度 description#>\n @param height#> 以像素数表示的图像高度 description#>\n @param depth#> 以像素数表示的图像深度（或者2D纹理数组的切片数量） description#>\n @param border#> 这个参数在OpenGL ES中被忽略，应该为0 description#>\n @param imageSize#> 以字节数表示的图像大小 description#>\n @param data#> 包含图像的实际压缩像素数据，必须能够容纳imageSize个字节 description#>\n @return void\n */\nglCompressedTexImage3D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *data);\n```\n\nOpenGL ES 3.0支持的标准ETC压缩纹理格式在下表中列出。所有ETC格式将压缩的图像数据存储在4x4的块中。表中列出了每种ETC格式中每个像素的位数。单个ETC图像的大小可以由每像素位数（bpp）比率算出：`sizeInBytes = max(width, 4) * max(height, 4) * bpp / 8`。\n\n内部格式 | 大小（每像素位数）| 描述\n- | - | -\nGL_COMPRESSED_R11_EAC | 4 | 单通道无符号压缩GL_RED格式\nGL_COMPRESSED_SIGNED_R11_EAC | 4 | 单通道有符号压缩GL_RED格式\nGL_COMPRESSED_RG11_EAC | 8 | 双通道无符号压缩GL_RG格式\nGL_COMPRESSED_SIGNED_RG11_EAC | 8 | 双通道有符号压缩GL_RG格式\nGL_COMPRESSED_RGB8_ETC2 | 4 | 三通道无符号压缩GL_RGB格式\nGL_COMPRESSED_SRGB8_ETC2 | 4 | sRGB颜色空间中的三通道无符号压缩GL_RGB格式\nGL_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 | 4 | 四通道无符号压缩GL_RGBA格式，1位alpha\nGL_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 | 4 | sRGB颜色空间中四通道无符号压缩GL_RGBA格式，1位alpha\nGL_COMPRESSED_RGBA8_ETC2_EAC | 8 | 四通道无符号压缩GL_RGBA格式\nGL_COMPRESSED_SRGBA8_ETC2_EAC | 8 | sRGB颜色空间中四通道无符号压缩GL_RGBA格式\n\n一旦加载压缩纹理，它就可以和无压缩纹理一样用于纹理处理。大部分开发人员不会编写自己的压缩程序，具体可使用的压缩工具，自行选择。\n\n注意，所有OpenGL ES 3.0实现都支持如上表中列出的格式。此外，有些实现可能支持表中未列出的供应商专用压缩格式。如果我们试图在不支持它们的OpenGL ES 3.0实现上使用纹理压缩格式，将会产生一个`GL_INVALID_ENUM`错误。检查OpenGL ES 3.0实现导出使用的任何供应商专用纹理压缩格式的扩展字符串很重要。如果该实现没有导出这样的扩展字符串，那就只能退而求其次使用无压缩的纹理格式。\n除了检查扩展字符串之外，还可以用另外一种方法确定实现所支持的纹理压缩格式。也就是说，可以用`glGetIntegerv`查询`GL_NUM_COMPRESSED_TEXTURE_FORMATS`来确定所支持的压缩图像格式数量。然后，可以用`glGetIntegerv`查询`GL_COMPRESSED_TEXTURE_FORMATS`，该调用返回一个`GLenum`值的数组。数组中的每个`GLenum`值将是实现支持的一种压缩纹理格式。\n\n# 纹理子图像规范\n\n用`glTexImage2D`上传纹理图像之后，可以更新图像的各个部分。如果你只希望更新图像的一个子区域，这种能力就很试用。\n\n``` objc\n/**\n 更新2D纹理图像的子区域\n\n @param target#> 指定纹理目标，可以是GL_TEXTURE_2D或者GL_TEXTURE_CUBE_MAP_* description#>\n @param level#> 指定更新的mip级别 description#>\n @param xoffset#> 开始更新的纹素x索引 description#>\n @param yoffset#> 开始更新的纹素y索引 description#>\n @param width#> 更新的图像子区域宽度 description#>\n @param height#> 更新的图像子区域高度 description#>\n @param format#> 输入纹理数据格式 description#>\n @param type#> 输入像素数据的类型 description#>\n @param pixels#> 包含图像子区域的实际像素数据 description#>\n @return void\n */\nglTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels);\n```\n\n这个函数将更新(xoffset, yoffset)到(xoffset+width-1, yoffset+height-1)范围内的纹素。注意，要使用这个函数，纹理必须完全指定。子图像的范围必须在之前指定的纹理图像界限之内。`pixels`数组中的数据必须按照`glPixelStorei`的`GL_UNPACK_ALIGNMENT`指定的方式对齐。\n\n还有一个用于更新压缩的2D纹理图像子区域的函数：\n\n``` objc\n/**\n 更新压缩的2D纹理图像的子区域\n\n @param target#> 指定纹理目标，可以是GL_TEXTURE_2D或者GL_TEXTURE_CUBE_MAP_* description#>\n @param level#> 指定更新的mip级别 description#>\n @param xoffset#> 开始更新的纹素x索引 description#>\n @param yoffset#> 开始更新的纹素y索引 description#>\n @param width#> 更新的图像子区域宽度 description#>\n @param height#> 更新的图像子区域高度 description#>\n @param format#> 所用的压缩纹理格式，必须与图像原来指定的格式相同 description#>\n @param imageSize#> 以字节数表示的图像大小 description#>\n @param data#> 包含图像子区域的实际像素数据 description#>\n @return void\n */\nglCompressedTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *data);\n```\n\n此外，与2D纹理一样，可以用`glTexSubImage3D`更新现有3D纹理和2D纹理数组的子区域：\n\n``` objc\n/**\n 更新3D纹理图像的子区域\n\n @param target#> 指定目标纹理，可以是GL_TEXTURE_3D或GL_TEXTURE_2D_ARRAY description#>\n @param level#> 指定更新的mip级别 description#>\n @param xoffset#> 开始更新的纹素x索引 description#>\n @param yoffset#> 开始更新的纹素y索引 description#>\n @param zoffset#> 开始更新的纹素z索引 description#>\n @param width#> 更新的图像子区域宽度 description#>\n @param height#> 更新的图像子区域高度 description#>\n @param depth#> 更新的图像子区域深度 description#>\n @param format#> 输入纹理数据的格式 description#>\n @param type#> 输入像素数据的类型 description#>\n @param pixels#> 包含像素数据的类型 description#>\n @return void\n */\nglTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels);\n```\n\n`glTexSubImage3D`的表现与`glTexSubImage2D`类似，唯一的不同是子区域包含一个`zoffset`和`depth`，用于指定深度切片中要更新的子区域。对于压缩的2D纹理数组，也可以用`glCompressedTexSubImage3D`更新纹理的一个子区域。对于3D纹理，这个函数只能用于供应商专用的3D压缩纹理格式，因为ETC2/EAC只支持2D纹理和2D纹理数组。\n\n``` objc\n/**\n 更新压缩的3D纹理图像的子区域\n\n @param target#> 指定纹理目标，可能是GL_TEXTURE_3D或者GL_TEXTURE_2D_ARRAY description#>\n @param level#> 指定更新的mip级别 description#>\n @param xoffset#> 开始更新的纹素x索引 description#>\n @param yoffset#> 开始更新的纹素y索引 description#>\n @param zoffset#> 开始更新的纹素z索引 description#>\n @param width#> 更新的图像子区域宽度 description#>\n @param height#> 更新的图像子区域高度 description#>\n @param depth#> 更新的图像子区域深度 description#>\n @param format#> 使用的压缩纹理格式，必须与原来指定的图像格式相同 description#>\n @param imageSize#> 以字节数表示的图像大小 description#>\n @param data#> 包含图像子区域的实际像素数据 description#>\n @return void\n */\nglCompressedTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *data);\n```\n\n# 从颜色缓冲区复制纹理数据\n\nOpenGL ES 3.0中支持的另一个纹理功能是从颜色缓冲区复制数据到一个纹理。如果我们希望使用渲染的结果作为纹理中的图像，这一功能就很实用。后面的帧缓冲区对象提供了渲染-纹理转换的快速方法，这种方法比复制图像数据更快。但是，如果性能不是关注点，那么从颜色缓冲区复制图像数据就是一种实用的功能。\n\n作为复制图像数据来源的颜色缓冲区可以用`glReadBuffer`函数设置。如果应用程序渲染到一个双缓冲区EGL可显示表面，则`glReadBuffer`必须设置为`GL_BACK`（后台缓冲区--默认状态）。OpenGL ES 3.0只支持双缓冲区EGL可显示表面。因此，所有在显示器上绘图的OpenGL ES 3.0应用程序都有一个既用于前台缓冲区又用于后台缓冲区的颜色缓冲区。这个缓冲区当前是前台还是后台缓冲区，由对`eglSwapBuffers`的最后一次调用决定。当从可显示EGL表面的颜色缓冲区中复制图像数据时，总是会复制后台缓冲区的内容。如果渲染到一个EGL pbuffer，则复制将发生在pbuffer表面。最后，如果渲染到一个帧缓冲区对象，则所复制的帧缓冲区对象的颜色附着通过调用带`GL_COLOR_ATTACHMENTi`参数的`glReadBuffer`函数设置：\n\n``` objc\n/**\n 读取颜色缓冲区\n\n @param mode#> 指定读取的颜色缓冲区。这将为未来的glReadPixels、glCopyTexImage2D、glCopyTexSubImage2D和glCopyTexSubImage3D调用设置源颜色缓冲区。该值可能为GL_BACK、GL_COLOR_ATTACHMENTi或GL_NONE description#>\n @return void\n */\nglReadBuffer(GLenum mode);\n```\n\n从颜色缓冲区复制数据到纹理的函数是`glCopyTexImage2D`、`glCopyTexSubImage2D`和`glCopyTexSubImage3D`。\n\n``` objc\n/**\n 从颜色缓冲区复制数据到2D纹理\n\n @param target#> 指定纹理目标，可能为GL_TEXTURE_CUBE_MAP_2D或者GL_TEXTURE_CUBE_MAP_* description#>\n @param level#> 指定加载的mip级别 description#>\n @param internalformat#> 图像的内部格式 description#>\n @param x#> 读取的帧缓冲区矩形左下角的x窗口坐标 description#>\n @param y#> 读取的帧缓冲区矩形左下角的y窗口坐标 description#>\n @param width#> 读取区域的宽度，以像素数表示 description#>\n @param height#> 读取区域的高度，以像素表示 description#>\n @param border#> OpenGL ES 3.0不支持边框，必须为0 description#>\n @return void\n */\nglCopyTexImage2D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);\n```\n\n调用上述函数导致纹理图像从区域(x, y)到(x+width-1, y+height-1)的颜色缓冲区内的像素加载。纹理图像的宽度和高度等于颜色缓冲区中复制区域的大小。我们应该用这些信息填充纹理的全部内容。\n此外，可以用`glCopyTexSubImage2D`更新已经指定的图像的子区域：\n\n``` objc\n/**\n 从颜色缓冲区复制数据更新已经指定的2D纹理的子区域\n\n @param target#> 指定纹理目标，可能为GL_TEXTURE_2D或者GL_TEXTURE_CUBE_MAP_* description#>\n @param level#> 指定更新的mip级别 description#>\n @param xoffset#> 开始更新的纹素x索引 description#>\n @param yoffset#> 开始更新的纹素y索引 description#>\n @param x#> 读取的帧缓冲区矩形左下角的x窗口坐标 description#>\n @param y#> 读取的帧缓冲区矩形左下角的y窗口坐标 description#>\n @param width#> 读取区域的宽度，以像素数表示 description#>\n @param height#> 读取区域的高度，以像素数据表示 description#>\n @return void\n */\nglCopyTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);\n```\n\n上述函数将用颜色缓冲区中从(x, y)到(x+width-1, y+height-1)区域的像素更新图像中从(xoffset, yoffset)到(xoffset+width-1, yoffset+height-1)的子区域。\n最后，也可以用`glCopyTexSubImage3D`将颜色缓冲区的内容复制到之前指定的3D纹理或者2D纹理数组的一个切片中：\n\n``` objc\n/**\n 从颜色缓冲区复制数据更新已经指定的3D纹理或2D纹理数组的子区域\n\n @param target#> 指定纹理目标，可能为GL_TEXTURE_3D或者GL_TEXTURE_2D_ARRAY description#>\n @param level#> 指定加载的mip级别 description#>\n @param xoffset#> 开始更新的纹素x索引 description#>\n @param yoffset#> 开始更新的纹素y索引 description#>\n @param zoffset#> 开始更新的纹素z索引 description#>\n @param x#> 读取的帧缓冲区矩形左下角的x窗口坐标 description#>\n @param y#> 读取的帧缓冲区矩形左下角的y窗口坐标 description#>\n @param width#> 读取区域的宽度，以像素数表示 description#>\n @param height#> 读取区域的高度，以像素数表示 description#>\n @return void\n */\nglCopyTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);\n```\n\n对于上述函数要记住一点，即纹理图像格式的分量不能多于颜色缓冲区。换句话说，复制颜色缓冲区的数据时，可以转换为分量较少的格式，但是不能转换为分量较多的格式。\n\n# 采样器对象\n\n之前介绍了用`glTexParameter[i|f][v]`设置纹理参数（如过滤模式、纹理坐标包装模式和LOD设置）的方法。使用`glTexParameter[i|f][v]`的问题是它可能造成大量不必要的API开销。应用程序经常在大量纹理上使用相同的设置，在这种情况下，用`glTexParameter[i|f][v]`为每个纹理对象设置采样器状态可能造成大量额外开销。为了缓解这一问题，OpenGL ES 3.0引入采样器对象，将采样器状态和纹理状态分离。简言之，所有可用`glTexParameter[i|f][v]`进行的设置都可以对采样器对象进行，可以在一次函数调用中与纹理单元绑定使用。采样器对象可以用于许多纹理，从而降低API开销。\n\n用于生成采样器对象的函数是：\n\n``` objc\n/**\n 生成采样器对象\n\n @param count#> 指定生成的采样器对象数量 description#>\n @param samplers#> 一个无符号整数数组，将容纳n个采样器对象ID description#>\n @return void\n */\nglGenSamplers(GLsizei count, GLuint *samplers);\n```\n\n采样器对象在应用程序不再需要它们时也需要删除：\n\n``` objc\n/**\n 删除采样器对象\n\n @param count#> 指定要删除的采样器对象 description#>\n @param samplers#> 一个无符号整数数组，容纳要删除的n个采样器对象ID description#>\n @return void\n */\nglDeleteSamplers(GLsizei count, const GLuint *samplers);\n```\n\n当生成采样器对象ID之后，应用程序必须绑定采样器对象以使用其状态。采样器对象绑定到纹理单元，这种绑定取代了用`glTexParameter[i|f][v]`进行的所有纹理对象状态设置：\n\n``` objc\n/**\n 采样器对象绑定到纹理单元\n\n @param unit#> 指定采样器对象绑定到的纹理单元 description#>\n @param sampler#> 所要绑定的采样器对象的句柄 description#>\n @return void\n */\nglBindSampler(GLuint unit, GLuint sampler);\n```\n\n如果传递给`glBindSampler`的`sampler`为0（默认采样器），则使用为纹理对象设置的状态。采样器对象状态可以用`glSampler[f|i][v]`设置。可以用`glSamplerParameter[f|i][v]`设置的参数与用`glTexParameter[i|f][v]`设置的相同，唯一的区别是状态被设置到采样器对象，而非纹理对象：\n\n``` objc\nglSamplerParameteri(GLuint sampler, GLenum pname, GLint param);\nglSamplerParameteriv(GLuint sampler, GLenum pname, const GLint *param);\nglSamplerParameterf(GLuint sampler, GLenum pname, GLfloat param);\nglSamplerParameterfv(GLuint sampler, GLenum pname, const GLfloat *param);\n```\n\n# 不可变纹理\n\nOpenGL ES 3.0中引入的另一种有助于改进应用程序性能的功能是不可变纹理。正如前面所介绍的，应用程序使用`glTexImage2D`和`glTexImage3D`等函数独立地指定纹理的每个mip贴图级别。这对OpenGL ES驱动程序造成的问题是驱动程序在绘图之前无法确定纹理是否已经完全指定。也就是说，它必须检查每个mip贴图级别或者子图像的格式是否相符、每个级别的大小是否正确以及是否有足够的内存。这种绘图时检查可能代价很高，而使用不可变纹理可以避免这种情形。\n\n不可变纹理的思路很简单：应用程序在加载数据之前指定纹理的格式和大小。这样做之后，纹理格式变成不可改变的，OpenGL ES驱动程序可以预先进行所有一致性和内存检查。一旦纹理不可变，它的格式和大小就不会再变化。但是，应用程序仍然可以通过使用`glTexSubImage2D`、`glTexSubImage3D`、`glGenerateMipMap`或者渲染到纹理加载图像数据。\n为了创建不可变纹理，应用程序将使用`glBindTexture`绑定纹理，然后用`glTexStorage2D`或`glTexStorage3D`分配不可变存储：\n\n``` objc\n/**\n 创建不可变纹理\n\n @param target#> 指定纹理目标，可能是GL_TEXTURE_2D、GL_TEXTURE_CUBE_MAP_*或者GL_TEXTURE_3D、GL_TEXTURE_2D_ARRAY description#>\n @param levels#> 指定mip贴图级别数量 description#>\n @param internalformat#> 确定大小的纹理存储内部格式 description#>\n @param width#> 基本图形宽度，以像素数表示 description#>\n @param height#> 基本图像高度，以像素数表示 description#>\n @return void\n */\nglTexStorage2D/3D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);\n```\n\n一旦创建了不可变纹理，在纹理对象上调用`glTexImage*`、`glCompressedTexImage*`、`glCopyTexImage*`或`glTexStorage*`就会无效。这样做将生成`GL_INVALID_OPERATION`错误。要用图像数据填充不可变纹理，应用程序需要使用`glTexSubImage2D`、`glTexSubImage3D`、`glGenerateMipMap`或者渲染到纹理图像（通过将其作为帧缓冲区对象附着使用来实现）。\n使用`glTexStorage*`时，OpenGL ES内部通过将`GL_TEXTURE_IMMUTABLE_FORMAT`设置为`GL_TRUE`，将`GL_TEXTURE_IMMUTABLE_LEVELS`设置为传递给`glTexStorage*`的数字，将纹理对象标记为不可变。应用程序可以使用`glGetTexParameter[i|f][v]`查询这些值，但是它无法直接设置这些值。必须使用`glTexStorage*`函数设置不可变纹理参数。\n\n# 像素解包缓冲区对象\n\n缓冲区对象可以在服务器端（或者GPU）内存中存储数据，而不是在客户端（或者主机）内存。使用缓冲区对象的好处是减少了从CPU到GPU的数据传送，因而能够改进性能（并降低内存占用率）。OpenGL ES 3.0还引入了像素解包缓冲区对象，这种对象与`GL_PIXEL_UNPACK_BUFFER`目标绑定指定。像素解包缓冲区对象允许纹理数据规格保存在服务器端内存。结果是，像素解包操作`glTexImage*`、`glTexSubImage*`、`glCompressedTexImage*`和`glCompressedTexSubImage*`可以直接来自缓冲区对象。如果像素解包缓冲区对象在这类调用期间绑定，则数据指针是像素解包缓冲区中的一个偏移量，而不是指向客户端内存的指针，这与使用`glVertexAttribPointer`的VBO很相似。\n像素解包缓冲区对象可以用于将纹理数据流传输到GPU。应用程序可以分配一个像素解包缓冲区，然后为更新映射缓冲区区域。当进行加载数据到OpenGL的调用（例如`glTexSubImage*`）时，这些函数可能立即返回。因为数据已经存在于GPU（或者可以在稍后复制，但是立即复制不需要像客户端数据那样进行）。我们建议在纹理上传操作的性能/内存占用对应用程序很重要的情况下使用像素解包缓冲区对象。\n\n# 总结\n\n这篇文章主要介绍了OpenGL ES 3.0中使用纹理的方法。","slug":"2019/opengl-es-texture-0810","published":1,"updated":"2022-01-10T09:04:52.808Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cky8gmc4w001zd1qhqp76qtlk","content":"<blockquote>\n<p>之前我们已经介绍了顶点着色器，管线的下一步是片段着色器，这是大部分OpenGL ES 3.0视觉魔法发生的地方。片段着色器的核心方面是对表面应用纹理。</p>\n</blockquote>\n<h1 id=\"纹理基础\">纹理基础</h1>\n<p>3D图形渲染中最基本的操作之一是对一个表面应用纹理。纹理可以表现只从网格的几何形状中无法得到的附加细节。OpenGL ES 3.0中的纹理有多种形式：2D纹理、2D纹理数组、3D纹理和立方图纹理。<br>\n纹理通常使用纹理坐标应用到一个表面，纹理坐标可以视为纹理数组数据中的索引。</p>\n<h2 id=\"2d纹理\">2D纹理</h2>\n<p>2D纹理是OpenGL ES中最基本和常用的纹理形式，是一个图形数据的二维数组。一个纹理的单独数据元素称作”纹素“（Texel，”texture pixels“（纹理像素）的简写）。OpenGL ES中的纹理图像数据可以用许多不同的基本格式表现。纹理数据可用的基本格式如下表：</p>\n<table>\n<thead>\n<tr>\n<th>基本格式</th>\n<th>纹素数据描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>GL_RED</td>\n<td>(红)</td>\n</tr>\n<tr>\n<td>GL_RG</td>\n<td>(红，绿)</td>\n</tr>\n<tr>\n<td>GL_RGB</td>\n<td>(红，绿，蓝)</td>\n</tr>\n<tr>\n<td>GL_RGBA</td>\n<td>(红，绿，蓝，Alpha)</td>\n</tr>\n<tr>\n<td>GL_LUMINANCE</td>\n<td>(亮度)</td>\n</tr>\n<tr>\n<td>GL_LUMINANCE_ALPHA</td>\n<td>(亮度，Alpha)</td>\n</tr>\n<tr>\n<td>GL_ALPHA</td>\n<td>(Alpha)</td>\n</tr>\n<tr>\n<td>GL_DEPTH_COMPONENT</td>\n<td>(深度)</td>\n</tr>\n<tr>\n<td>GL_DEPTH_STENCIL</td>\n<td>(深度，模板)</td>\n</tr>\n<tr>\n<td>GL_RED_INTEGER</td>\n<td>(整数红)</td>\n</tr>\n<tr>\n<td>GL_RG_INTEGER</td>\n<td>(整数红，整数绿)</td>\n</tr>\n<tr>\n<td>GL_RGB_INTEGER</td>\n<td>(整数红，整数绿，整数蓝)</td>\n</tr>\n<tr>\n<td>GL_RGBA_INTERGER</td>\n<td>(整数红，整数绿，整数蓝，整数Alpha)</td>\n</tr>\n</tbody>\n</table>\n<p>图像中的每个纹素根据基本格式和数据类型指定。用2D纹理渲染时，纹理坐标用作纹理图形中的索引。一般来说，在3D内容创作程序中将制作一个网格，每个顶点都有一个纹理坐标。2D纹理的纹理坐标用一对2D坐标(s, t)指定，有时也称作(u, v)坐标。这些坐标代表用于查找一个纹理贴图的规范化坐标。</p>\n<p><img src=\"/img/article/20190810/1.png\" alt=\"2D纹理坐标\"></p>\n<p>纹理图像的左下角由<code>st</code>坐标(0.0, 0.0)指定，右上角由<code>st</code>坐标(1.0, 1.0)指定。在[0.0, 1.0]区间之外的坐标是允许的，在该区间之外的纹理读取行为由纹理包装模式定义。</p>\n<h2 id=\"立方图纹理\">立方图纹理</h2>\n<p>除了2D纹理之外，OpenGL ES 3.0还支持立方图纹理。从最基本的特征讲，立方图就是一个由6个单独2D纹理面组成的纹理。立方图的每个面代表立方体六面中的一个。虽然立方图在3D渲染中有多重高级的使用方式，但是最常用的是所谓的环境贴图特效。对这种特效，环境在物体上的倒影通过使用一个表示环境的立方图渲染。通常，生成环境贴图所用的立方图通过在场景中央防止一个摄像机，从6个轴的方向(+X, -X, +Y, -Y, +Z, -Z)捕捉场景图形并将结果保存在立方体的每个面来生成。<br>\n立方图纹素的读取通过使用一个3D向量(s, t, r)作为纹理坐标，在立方图中查找。纹理坐标(s, t, r)代表着3D向量的(x, y, z)分量。这个3D向量首先用于选择立方图中需要读取的一个面，然后该坐标投影到2D坐标(s, t)，然后从该面上读取。我们可以通过从一个立方体内部的原点绘制一个3D向量来直观地了解这一过程。这个向量与立方体相交的点就是从立方图读取的纹素。</p>\n<p><img src=\"/img/article/20190810/2.png\" alt=\"立方图的3D纹理坐标\"></p>\n<p>立方图各个面的指定方法与2D纹理的相同。每个面必须为正方形（宽度和高度必须相等），每个面的宽度和高度都一样。用于纹理坐标的3D向量和2D纹理的不同，通常不直接逐顶点地保存在网格上。相反，立方图通常使用法向量作为计算立方图纹理坐标的基础来读取。一般来说，法向量和一个来自眼睛的向量一起使用，计算出一个反射向量，然后用这个向量在立方图中查找。</p>\n<h2 id=\"3d纹理\">3D纹理</h2>\n<p>OpenGL ES 3.0中的另一类纹理是3D纹理（或者体纹理）。3D纹理可以看做2D纹理多个切片的一个数组，它用一个3元(s, t, r)坐标访问，这与立方体很相似。对于3D纹理，r坐标选择3D纹理中需要采样的切片，(s, t)坐标用于读取每个切片中的2D贴图。下图展示了一个3D纹理，其中每个切片由一个单独的2D纹理组成。3D纹理中的每个mip贴图级别包含上一个级别的纹理中的半数切片。</p>\n<p><img src=\"/img/article/20190810/3.png\" alt=\"3D纹理\"></p>\n<h2 id=\"2d纹理数组\">2D纹理数组</h2>\n<p>OpenGL ES 3.0中最后一种纹理是2D纹理数组。2D纹理数组与3D纹理很相似，但是用途不同。例如，2D纹理数组尝尝用于存储2D图像的一个动画。数组的每个切片表示纹理动画的一帧。2D纹理数组和3D纹理之间的差别很细微，但是很重要。对于3D纹理，过滤发生在切片之间，而从2D纹理数组中读取只从一个单独的切片采样。mip贴图也不一样。2D纹理数组中的每个mip贴图级别包含与以上级别相同的切片数量。每个2D切片的mip贴图完全独立于其他切片（这与3D纹理的情况不同，3D纹理的每个mip贴图级别只有以上级别切片数量的一半）。</p>\n<p>为了在2D纹理数组中定位，需使用与3D纹理一样的纹理坐标(s, t, r)，r坐标选择2D纹理数组中要使用的切片，(s, t)坐标用于选择切片，选择的方法与2D纹理完全一样。</p>\n<h2 id=\"纹理对象和纹理的加载\">纹理对象和纹理的加载</h2>\n<p>纹理应用的第一步是创建一个纹理对象。纹理对象是一个容器对象，保存渲染所需的纹理数据，例如图像数据、过滤模式和包装模式。在OpenGL ES中，纹理对象用一个无符号整数表示，该整数是纹理对象的一个句柄。用于生成纹理对象的函数是<code>glGenTextures</code>：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 生成纹理</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param n#&gt; 指定要生成的纹理对象数量 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param textures#&gt; 一个保存n个纹理对象ID的无符号整数数组 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glGenTextures(GLsizei n, GLuint *textures);</span><br></pre></td></tr></table></figure>\n<p>在创建的时候，<code>glGenTextures</code>生成的纹理对象是一个空的容器，用于加载纹理数据和参数。纹理对象在应用程序不在需要它们的时候也必须删除。这一步骤通常在应用程序关闭或者游戏级别改变时完成，可以使用<code>glDeleteTextures</code>实现：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 删除纹理</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param n#&gt; 指定要删除的纹理对象数量 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param textures#&gt; 一个保存要删除的n个纹理对象ID的无符号整数数组 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glDeleteTextures(GLsizei n, <span class=\"keyword\">const</span> GLuint *textures);</span><br></pre></td></tr></table></figure>\n<p>一旦用<code>glGenTextures</code>生成了纹理对象ID，应用程序就必须绑定纹理对象进行操作。绑定纹理对象之后，后续的操作(如<code>glTexImage2D</code>和<code>glTexParameter</code>)将影响绑定的纹理对象。用于绑定纹理对象的函数是<code>glBindTexture</code>：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 绑定纹理对象</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param target#&gt; 将纹理对象绑定到GL_TEXTURE_2D、GL_TEXTURE_3D、GL_TEXTURE_2D_ARRAY或者GL_TEXTURE_CUBE_MAP description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param texture#&gt; 要绑定的纹理对象句柄 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glBindTexture(GLenum target, GLuint texture);</span><br></pre></td></tr></table></figure>\n<p>一旦纹理绑定到一个特定的纹理目标，纹理对象在删除之前就一直绑定到它的目标。生成纹理对象并绑定它之后，使用纹理的下一个步骤是真正地加载图像数据。用于加载2D和立方图纹理的基本函数是<code>glTexImage2D</code>。此外，在OpenGL ES 3.0中可以使用多种替代方法指定2D纹理，包括不可变纹理(<code>glTexStorage2D</code>)和<code>glTexSubImage2D</code>的结合。我们首先从最基本的方法开始–使用<code>glTexImage2D</code>–并在后面描述不可变纹理。为了获得最佳性能，建议使用不可变纹理。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 加载2D和立方图纹理</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param target#&gt; 指定目标纹理，可以为GL_TEXTURE_2D、GL_TEXTURE_CUBE_MAP_POSITIVE_(X, Y, Z)、GL_TEXTURE_CUBE_MAP_NEGATIVE_(X, Y, Z) description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param level#&gt; 指定要加载的mip级别，第一个级别为0，后续的mip贴图级别递增 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param internalformat#&gt; 纹理存储的内部格式；可以是未确定大小的基本内部格式，后者是确定大小的内部格式。未确定大小的内部格式可以为GL_RGBA，GL_RGB，GL_LUMINANCE_ALPHA，GL_LUMINANCE，GL_ALPHA。确定大小的内部格式有GL_RGB，GL_DEPTH_COMPONENT16等 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param width#&gt; 图像的像素宽度 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param height#&gt; 图像的像素高度 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param border#&gt; 这个参数在OpenGL ES中被忽略，保留它是为了与桌面的OpenGL接口兼容；应该为0 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param format#&gt; 输入的纹理数据格式，可以为GL_RED(_INTEGER)，GL_RG(_INTEGER)，GL_RGB(_INTERGER)，GL_RGBA(_INTEGER)，GL_DEPTH_COMPONENT，GL_DEPTH_STENCIL，GL_LUMINANCE_ALPHA，GL_ALPHA description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param type#&gt; 输入像素数据的类型 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param pixels#&gt; 包含图像的实际像素数据。数据必须包含（width*height*高度）个像素，每个像素根据格式和类型规范有相应的字节数。像素行必须对其到用`glPixelStorei`设置的GL_UNPACK_ALIGHMENT description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glTexImage2D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, <span class=\"keyword\">const</span> GLvoid *pixels);</span><br></pre></td></tr></table></figure>\n<p>下面举个例子，演示了生成纹理对象、绑定该对象然后加载由无符号字节表示的RGB图像数据组成的 2x2 2D纹理：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GLuint textureId;</span><br><span class=\"line\">GLubyte pixels[] = &#123;</span><br><span class=\"line\">    <span class=\"number\">255</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>,</span><br><span class=\"line\">    <span class=\"number\">0</span>, <span class=\"number\">255</span>, <span class=\"number\">0</span>,</span><br><span class=\"line\">    <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">255</span>,</span><br><span class=\"line\">    <span class=\"number\">255</span>, <span class=\"number\">255</span>, <span class=\"number\">0</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// User tightly packed data</span></span><br><span class=\"line\">glPixelStorei(GL_UNPACK_ALIGNMENT, <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Generate a texture object</span></span><br><span class=\"line\">glGenTextures(<span class=\"number\">1</span>, &amp;textureId);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Bind the texture object</span></span><br><span class=\"line\">glBindTexture(GL_TEXTURE_2D, textureId);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Load the texture</span></span><br><span class=\"line\">glTexImage2D(GL_TEXTURE_2D, <span class=\"number\">0</span>, GL_RGB, <span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">0</span>, GL_RGB, GL_UNSIGNED_BYTE, pixels);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Set the filtering mode</span></span><br><span class=\"line\">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);</span><br><span class=\"line\">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);</span><br></pre></td></tr></table></figure>\n<p>在上述代码的第一部分，<code>pixels</code>数组用简单的2x2纹理数据初始化。这些数据由无符号字节RGB三元组组成，范围为[0, 255]。当着色器中从一个8位无符号字节纹理分量读取数据时，该值从[0, 255]区间被映射到浮点区间[0.0, 1.0]。一般来说，应用程序不会以这种简单的方式创建纹理数据，而从一个图像文件中加载数据。<br>\n在调用<code>glTexImage2D</code>之前，应用程序调用<code>glPixelStorei</code>设置解包对齐。通过<code>glTexImage2D</code>上传纹理数据时，像素行被认定为对齐到<code>GL_UNPACK_ALIGNMENT</code>设置的值。默认情况下，该值为4，意味着像素行被认定为从4字节的边界开始。<br>\n这个应用程序将解包对齐设置为1，意味着每个像素行从字节边界开始（换言之，数据被紧密打包）。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 设置包装或者解包对齐</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param pname#&gt; 指定设置的像素存储类型，下面的选项影响调用glTexImage2D、glTexImage3D、glTexSubImage2D和glTexSubImage3D时数据从内存中解包的方式：GL_UNPACK_ROW_LENGTH，GL_UNPACK_IMAGE_HEIGHT，GL_UNPACK_SKIP_PIXELS，GL_UNPACK_SKIP_ROWS，GL_UNPACK_SKIP_IMAGES，GL_UNPACK_ALIGNMENT；下面的选项影响调用glReadPixels时数据打包到内存中的方式：GL_PACK_ROW_LENGTH，GL_PACK_IMAGE_HEIGHT，GL_PACK_SKIP_PIXELS，GL_PACK_SKIP_ROWS，GL_PACK_SKIP_IMAGES，GL_PACK_ALIGNMENT description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param param#&gt; 指定包装或者解包选项的整数值 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glPixelStorei(GLenum pname, GLint param);</span><br></pre></td></tr></table></figure>\n<p><code>glPixelStorei</code>的<code>GL_PACK_xxxx</code>参数对纹理图像上传没有任何影响。打包选项由<code>glReadPixels</code>使用。<code>glPixelStorei</code>设置的打包和解包选项是全局状态，不由纹理对象存储，也不与之关联。在实践中，很少使用<code>GL_UNPACK_ALIGNMENT</code>之外的选项指定纹理。为了完整起见，下表提供了像素存储选项的完整列表。</p>\n<table>\n<thead>\n<tr>\n<th>像素存储选项</th>\n<th>初始值</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>GL_UNPACK_ALIGNMENT GL_PACK_ALIGNMENT</td>\n<td>4</td>\n<td>指定图像中各行的对齐方式。默认情况下，图像始于4字节边界。将该值设置为1意味着图像紧密打包，各行到齐到字节边界</td>\n</tr>\n<tr>\n<td>GL_UNPACK_ROW_LENGTH GL_PACK_ROW_LENGTH</td>\n<td>0</td>\n<td>如果该值非0，则表示每个图像行中的像素数量。如果该值为0，则行的长度为图像的宽度（也就是紧密打包）</td>\n</tr>\n<tr>\n<td>GL_UNPACK_IMAGE_HEIGHT GL_PACK_IMAGE_HEIGHT</td>\n<td>0</td>\n<td>如果该值非0，则表示作为3D纹理一部分的图形的每个列中像素的数量。这个选项可以用于在3D纹理的每个切片之间填充列。如果该值为0，则图像中的列数等于高度（也就是紧密打包）</td>\n</tr>\n<tr>\n<td>GL_UNPACK_SKIP_PIXELS GL_PACK_SKIP_PIXELS</td>\n<td>0</td>\n<td>如果该值非0，则表示行开始处跳过的像素数量</td>\n</tr>\n<tr>\n<td>GL_UNPACK_SKIP_ROWS GL_PACK_SKIP_ROWS</td>\n<td>0</td>\n<td>如果该值非0，则表示图像开始时跳过的行数</td>\n</tr>\n<tr>\n<td>GL_UNPACK_SKIP_IMAGES GL_PACK_SKIP_IMAGES</td>\n<td>0</td>\n<td>如果该值非0，则表示3D纹理中跳过的图像数</td>\n</tr>\n</tbody>\n</table>\n<p>代码的最后一部分使用<code>glTexParameteri</code>将缩小和放大过滤模式设置为<code>GL_NEAREST</code>。这段代码是必需的，因为我们还没有为纹理加载完整的mip贴图链；因此，必须选择非mip贴图缩小过滤器。用于缩小和放大模式的其他选项是<code>GL_LINEAR</code>，提供双线性非mip贴图过滤。</p>\n<h2 id=\"纹理过滤和mip贴图\">纹理过滤和mip贴图</h2>\n<p>到目前为止，我们对2D纹理的介绍仅限于单个2D图像。尽管这使得我们能够解释纹理的概念，但是OpenGL ES中纹理的指定和使用还有一些其他的方法。这种复杂性与使用单个纹理贴图时发生的视觉伪像和性能问题有关。正如我们到目前为止所描述的那样，纹理坐标用于生成一个2D索引，以从纹理贴图中读取。当缩小和放大过滤器设置为<code>GL_NEAREST</code>时，就会发生这样的情况：一个纹素将在提供的纹理坐标位置上读取。这称作点采样或者最近采样。<br>\n但是，最近采样可能产生严重的视觉伪像，这是因为三角形在屏幕空间中变得较小，在不同像素间的插值中，纹理坐标有很大的跳跃。结果是，从一个大的纹理贴图中去的少量样本，造成锯齿伪像，而且可能造成巨大性能损失。OpenGL ES中解决这类伪像的方案被称作mip贴图（mipmapping）。mip贴图的思路是构建一个图像链–mip贴图链。mip贴图链始于原来指定的图像，后续的每个图像在每个维度上是前一个图像的一半，一直持续到最后达到链底部的1x1纹理。mip贴图级别可以编程生成，一个mip级别中的每个像素通常根据上一级别中相同位置的4个像素的平均值计算（盒式过滤）。<br>\n<a href=\"https://github.com/danginsburg/opengles3-book/blob/master/Chapter_9/MipMap2D/MipMap2D.c\" target=\"_blank\" rel=\"noopener\">GenMipMap2D</a>函数提供了生成mip贴图链的代码。这个函数以一个RGB8图形作为输入，在前面的图像上执行盒式过滤，生成下一个mip贴图级别。mip贴图链用<code>glTexImage2D</code>加载。<br>\n加载mip贴图链之后，便可以设置过滤模式，以使用mip贴图。结果是我们实现了屏幕像素和纹理像素间的更好比率，从而减少了锯齿伪像。图像的锯齿也减少了，这是因为mip贴图链中的每个图像连续进行过滤，使得高频元素随着贴图链的下移越来越少。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">glTexImage2D(GL_TEXTURE_2D, <span class=\"number\">0</span>, GL_RGB, width, height, <span class=\"number\">0</span>, GL_RGB, GL_UNSIGNED_BYTE, pixels);</span><br><span class=\"line\"><span class=\"keyword\">int</span> level = <span class=\"number\">1</span>;</span><br><span class=\"line\">GLubyte *prevImage = &amp;pixels[<span class=\"number\">0</span>];</span><br><span class=\"line\">GLubyte *newImage;</span><br><span class=\"line\"><span class=\"keyword\">while</span> (width &gt; <span class=\"number\">1</span> &amp;&amp; height &gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> newWidth, newHeight;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// Generate the next mipmap level</span></span><br><span class=\"line\">    GenMipMap2D(prevImage, &amp;newImage, width, height, &amp;newWidth, &amp;newHeight);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// Load the mipmap level</span></span><br><span class=\"line\">    glTexImage2D(GL_TEXTURE_2D, level, GL_RGB, newWidth, newHeight, <span class=\"number\">0</span>, GL_RGB, GL_UNSIGNED_BYTE, newImage);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// Free the previous image</span></span><br><span class=\"line\">    free(prevImage);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// Set the previous image for the next iteration</span></span><br><span class=\"line\">    prevImage = newImage;</span><br><span class=\"line\">    level += <span class=\"number\">1</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// Half the width and height</span></span><br><span class=\"line\">    width = newWidth;</span><br><span class=\"line\">    height = newHeight;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">free(newImage);</span><br></pre></td></tr></table></figure>\n<p>纹理渲染时发生两种过滤：缩小和放大。缩小发生在屏幕上投影的多边形小于纹理尺寸的时候。放大发生在屏幕上投影的多边形大于纹理尺寸的时候。过滤器类型的确定由硬件自动处理，但是API提供了对每种情况下使用的过滤类型的控制。对于放大，mip贴图不起作用，因为我们总是从最大的可用级别采样。对于缩小，可以使用不同的采样模式。所用模式的选择基于你需要实现的显示质量水平以及为了纹理过滤损失多少性能。<br>\n过滤模式（和许多其他纹理选项）用<code>glTexParameter[i|f][v]</code>指定。接下来描述纹理过滤模式。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">glTexParameteri(GLenum target, GLenum pname, GLint param)</span><br><span class=\"line\">glTexParameteriv(GLenum target, GLenum pname, <span class=\"keyword\">const</span> GLint *params);</span><br><span class=\"line\">glTexParameterf(GLenum target, GLenum pname, GLfloat param);</span><br><span class=\"line\">glTexParameterfv(GLenum target, GLenum pname, <span class=\"keyword\">const</span> GLfloat *params);</span><br></pre></td></tr></table></figure>\n<p><code>pname</code>为<code>GL_TEXTURE_MAG_FILTER</code>放大过滤器时，<code>param</code>可能是<code>GL_NEAREST</code>或<code>GL_LINEAR</code>。在<code>GL_NEAREST</code>放大过滤中，将从最靠近纹理坐标的纹理中取得单点样本。在<code>GL_LINEAR</code>放大过滤中，将从纹理坐标附近的纹理中取得一个双线性样本（4个样本的平均值）。<br>\n<code>pname</code>为<code>GL_TEXTURE_MIN_FILTER</code>缩小过滤器时，<code>param</code>可以设置为如下值的任意一个：</p>\n<ul>\n<li><code>GL_NEAREST</code> – 从最靠近纹理坐标的纹理中获得一个单点样本。</li>\n<li><code>GL_LINEAR</code> – 从最靠近纹理坐标的纹理中获得一个双线性样本。</li>\n<li><code>GL_NEAREST_MIPMAP_NEAREST</code> – 从所选的最近的mip级别中去的单点样本。</li>\n<li><code>GL_NEAREST_MIPMAP_LINEAR</code> – 从两个最近的mip级别中获得样本，并在这些样本之间插值。</li>\n<li><code>GL_LINEAR_MIPMAP_NEAREST</code> – 从所选的最近mip级别中获得双线性样本。</li>\n<li><code>GL_LINEAR_MIPMAP_LINEAR</code> – 从两个最近的mip级别中获得双线性样本，然后在它们之间插值。这种模式通常被称作三线性过滤，产生所有模式中最佳的质量。</li>\n</ul>\n<blockquote>\n<p>在纹理缩小模式中，只要<code>GL_NEAREST</code>和<code>GL_LINEAR</code>不需要为纹理指定完整的mip贴图链。其他所有模式都要求纹理存在完整的mip贴图链。</p>\n</blockquote>\n<p>选择的纹理过滤模式对性能有一定的影响。如果发生缩小且担心性能，那么使用mip贴图过滤模式通常是大部分硬件上的最佳选择。如果没有mip贴图，则纹理缓存利用率可能非常低，因为读取发生在贴图的少数位置。然而，你选择的过滤模式较高，在硬件中的性能代价就越大。例如，在大部分硬件上，进行双线性过滤的代价低于三线性过滤。我们应该选择一种可以提供所要的质量但是不会对性能有过分负面影响的模式。在某些硬件上，你可能轻松地获得高质量的过滤，特别是在纹理过滤带来的开销不是我们的瓶颈时。这需要在应用程序和计划运行应用程序的硬件上进行调整。</p>\n<h3 id=\"无缝立方图过滤\">无缝立方图过滤</h3>\n<p>关于过滤，OpenGL ES 3.0中有一个新变化，与立方图的过滤有关。在OpenGL ES 2.0中，当线性过滤核心落到立方图边缘时，过滤将只发生在立方图的一个面上。这将在立方图各面之间的边上造成伪像。在OpenGL ES 3.0中，立方图过滤现在是无缝的–如果过滤核心跨越立方图不止一个面，核心将会从其覆盖的每个面中获得样本。无缝过滤在立方图各面的边缘形成了更平滑的过滤。在OpenGL ES 3.0中，不需要做任何操作就可以启用无缝立方图过滤，所有线性过滤核心将自动使用它。</p>\n<h2 id=\"自动mip贴图生成\">自动mip贴图生成</h2>\n<p>前一节讲述了生成mip贴图的一种途径，但是OpenGL ES 3.0还提供了用<code>glGenerateMipmap</code>自动生成mip贴图的机制。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 自动生成mip贴图</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param target#&gt; 为之生成mip贴图的纹理目标；可以是GL_TEXTURE_2D、GL_TEXTURE_3D、GL_TEXTURE_2D_ARRAY或GL_TEXTURE_CUBE_MAP description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glGenerateMipmap(GLenum target);</span><br></pre></td></tr></table></figure>\n<p>在绑定的纹理对象上调用<code>glGenerateMipmap</code>时，这个函数将从0级图像的内容生成整个mip贴图链。对于2D纹理，0级纹理内容将持续地被过滤并用于每个后续级别。对于立方图，立方体的每一面都由各面的0级生成。当然，要将这个函数用于立方图，必须为立方体的每个面指定0级，每个面的内部格式、宽度和高度都必须匹配。对于2D纹理数组，数组的每个切片将进行与2D纹理一样的过滤。最后，对于3D纹理，将通过过滤各个切片生成全体的mip贴图。<br>\nOpenGL ES 3.0不强制用于生成mip贴图的特定过滤算法（但是规范中推荐盒式过滤，各种实现可以自由地选择他们使用的算法）。如果需要特定的过滤方法，就必须自己生成mip贴图。<br>\n在开始使用帧缓冲区对象渲染纹理时，自动化mip贴图生成变得特别重要。当渲染到一个纹理时，我们不希望将纹理的内容读回CPU来生成mip贴图，相反，可以使用<code>glGenerateMipmap</code>和图形硬件，然后在不需要将数据读回CPU的情况下生成mip贴图。</p>\n<h2 id=\"纹理坐标包装\">纹理坐标包装</h2>\n<p>纹理包装模式用于指定纹理坐标超出[0.0, 1.0]范围时所发生的行为，用<code>glTexParameter[i|f][v]</code>设置。这些模式可以为s、t、r坐标单独设置。<code>GL_TEXTURE_WRAP_S</code>模式定义s坐标超出[0.0, 1.0]范围时发生的行为，<code>GL_TEXTURE_WRAP_T</code>设置t坐标的行为，<code>GL_TEXTURE_WRAP_R</code>设置r坐标的行为（r坐标包装仅用于3D纹理和2D纹理数组）。在OpenGL ES中有三个包装模式可供选择，如下表：</p>\n<table>\n<thead>\n<tr>\n<th>纹理包装模式</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>GL_REPEAT</td>\n<td>重复纹理</td>\n</tr>\n<tr>\n<td>GL_CLAMP_TO_EDGE</td>\n<td>限定读取纹理的边缘</td>\n</tr>\n<tr>\n<td>GL_MIRRORED_REPEAT</td>\n<td>重复纹理和镜像</td>\n</tr>\n</tbody>\n</table>\n<p>注意，纹理包装模式也影响过滤行为。例如，当纹理坐标在纹理的边缘时，线性过滤核心可能跨越纹理的边缘。在这种情况下，包装模式将决定对于核心在纹理边缘之外的部分要读取哪些纹素。在不希望出现任何形式的重复时，应该使用<code>GL_CLAMP_TO_DEGE</code>。</p>\n<h2 id=\"纹理调配\">纹理调配</h2>\n<p>纹理调配（Swizzle）控制输入的R、RG、RGB或RGBA纹理中的颜色分量在着色器中读取时如何映射到分量。例如，应用程序可能希望一个<code>GL_RED</code>纹理映射为(0, 0, 0, R)或者(R, R, R, 1)而不是默认的(R, 0, 0, 1)。每个R、G、B、A值映射到的纹理分量都可以用<code>glTexParameter[i|f][v]</code>设置的纹理调配单独控制。需要控制的分量用<code>GL_TEXTURE_SWIZZLE_R</code>、<code>GL_TEXTURE_SWIZZLE_G</code>、<code>GL_TEXTURE_SWIZZLE_B</code>或<code>GL_TEXTURE_SWIZZLE_A</code>设置。作为该分量纹理值来源的可能是分别从R、G、B、A分量读取的<code>GL_RED</code>、<code>GL_GREEN</code>、<code>GL_BLUE</code>或<code>GL_ALPHA</code>。此外，应用程序可以分别用<code>GL_ZERO</code>或<code>GL_ONE</code>将该值设置为常数0或者1。</p>\n<h2 id=\"纹理细节级别\">纹理细节级别</h2>\n<p>在某些应用中，在所有纹理mip贴图级别可用之前就能够开始显示场景是很实用的。例如，通过数据连接下载纹理图像的GPS应用可以从最低级别的mip贴图开始，在更高级别可用时再显示它们。在OpenGL ES 3.0中，可以通过使用<code>glTexParameter[i|f][v]</code>的多个参数实现。<code>GL_TEXTURE_BASE_LEVEL</code>设置用于纹理的最大mip贴图级别。默认情况下下，该值为0，但是如果mip贴图级别还不可用，则可以设置为更高的值。同样，<code>GL_TEXTURE_MAX_LEVEL</code>设置使用的最小mip贴图级别。默认情况下，它的值为1000（超过了任何纹理可能具备的最大级别），但是可以将其设置为较小的值，以控制用于纹理的最小mip级别。<br>\n为了选择要用于渲染的mip贴图级别，OpenGL ES自动计算一个细节级别（LOD）值。这个浮点值确定从哪一个mip贴图级别过滤（在三线性过滤中，控制每个mip贴图使用的多少）。应用程序还可以用<code>GL_TEXTURE_MIN_LOD</code>和<code>GL_TEXTURE_MAX_LOD</code>控制最小和最大的LOD值。可以从基本和最大mip贴图级别单独控制LOD限制的一个原因是在新的mip贴图级别可用时提供平滑过渡。仅仅设置纹理的基本和最大级别可能在新mip贴图级别可用时造成间歇伪像，而插入LOD可以使这一过渡看起来更平滑。</p>\n<h2 id=\"深度纹理对比百分比渐进过滤\">深度纹理对比（百分比渐进过滤）</h2>\n<p>最后两个纹理参数是<code>GL_TEXTURE_COMPARE_FUNC</code>和<code>GL_TEXTURE_COMPARE_MODE</code>。引入这些纹理参数是为了提供百分比渐进过滤（PCF）功能。在执行被称作阴影贴图的阴影技术时，片段着色器需要比较一个片段的当前深度值和深度纹理中的深度值，以确定片段在阴影之内还是之外。为了实现平滑的阴影边缘效果，对深度纹理进行双线性过滤是很有用的。但是，在过滤深度值时，我们希望过滤在采样深度值并与当前深度（或参考值）比较之后发生。如果过滤在比较之前发生，我们将平均计算深度纹理中的值，这不能提供正确的结果。PCF提供了正确的过滤，将采样的每个深度值与参考深度比较，然后将这些比较的结果（0或者1）一起进行平均。<br>\n<code>GL_TEXTURE_COMPARE_MODE</code>默认为<code>GL_NONE</code>，但是当它被设置为<code>GL_COMPARE_REF_TO_TEXTURE</code>时，(s, t, r)纹理坐标中的r坐标将与深度纹理的值进行比较。然后，比较的结果将成为阴影纹理读取的结果（可能是9或者1，如果启用纹理过滤，则为这些值的平均）。比较函数用<code>GL_TEXTURE_COMPARE_FUNC</code>设置，可以设置为<code>GL_LEQUAL</code>、<code>GL_GEQUAL</code>、<code>GL_LESS</code>、<code>GL_GREATER</code>、<code>GL_EQUAL</code>、<code>GL_NOTEQUAL</code>、<code>GL_ALWAYS</code>或者<code>GL_NEVER</code>。</p>\n<h2 id=\"纹理格式\">纹理格式</h2>\n<p>OpenGL ES 3.0为纹理提供了广泛的数据格式，格式的数量比OpenGL ES 2.0有了很大的增加。<br>\n2D纹理可以以确定大小或者确定大小的内部格式用<code>glTexImage2D</code>上传。如果纹理用未确定大小的格式指定，则OpenGL ES实现可以自由选择纹理数据存储的内部表现形式。如果纹理用确定大小的格式指定，则OpenGL ES实现将选择至少与指定的位数相同的格式。</p>\n<p><code>glTexImage2D</code>的有效的未确定大小内部格式组合：</p>\n<table>\n<thead>\n<tr>\n<th>内部格式</th>\n<th>格式</th>\n<th>类型</th>\n<th>输入数据</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>GL_RGB</td>\n<td>GL_RGB</td>\n<td>GL_UNSIGNED_BYTE</td>\n<td>8/8/8 RGB 24- 位</td>\n</tr>\n<tr>\n<td>GL_RGB</td>\n<td>GL_RGB</td>\n<td>GL_UNSIGNED_SHORT_5_6_5</td>\n<td>5/6/5 RGB 16- 位</td>\n</tr>\n<tr>\n<td>GL_RGBA</td>\n<td>GL_RGBA</td>\n<td>GL_UNSIGNED_BYTE</td>\n<td>8/8/8/8 RGBA 32- 位</td>\n</tr>\n<tr>\n<td>GL_RGBA</td>\n<td>GL_RGBA</td>\n<td>GL_UNSIGNED_SHORT_4_4_4_4</td>\n<td>4/4/4/4 RGBA 16- 位</td>\n</tr>\n<tr>\n<td>GL_RGBA</td>\n<td>GL_RGBA</td>\n<td>GL_UNSIGNED_SHORT_5_5_5_1</td>\n<td>5/5/5/1 RGBA 16- 位</td>\n</tr>\n<tr>\n<td>GL_LUMINANCE_ALPHA</td>\n<td>GL_LUMINANCE_ALPHA</td>\n<td>GL_UNSIGNED_BYTE</td>\n<td>8/8 LA 16- 位</td>\n</tr>\n<tr>\n<td>GL_LUMINANCE</td>\n<td>GL_LUMINANCE</td>\n<td>GL_UNSIGNED_BYTE</td>\n<td>8L 8- 位</td>\n</tr>\n<tr>\n<td>GL_ALPHA</td>\n<td>GL_ALPHA</td>\n<td>GL_UNSIGNED_BYTE</td>\n<td>8A 8- 位</td>\n</tr>\n</tbody>\n</table>\n<p>如果应用程序希望更多地控制数据的内部存储方式，那么它可以使用确定大小的内部格式。</p>\n<h3 id=\"规范化纹理格式\">规范化纹理格式</h3>\n<p>我们所说的”规范化“指的是从片段着色器中读取纹理时，结果将处于[0.0, 1.0]范围内（或者在*_SNORM格式中的[-1.0, 1.0]范围）。例如，用<code>GL_UNSIGNED_BYTE</code>数据指定的<code>GL_R8</code>图像将取得每个8位的无符号字节值(范围为[0, 255])，并在片段着色器读取时映射到[0.0, 1.0]。用<code>GL_BYTE</code>数据指定的<code>GL_R8_SNORM</code>图像将取得每个8位的有符号字节值（范围为[-128, 127]）并在读取时映射到[-1.0, 1.0]。</p>\n<p><img src=\"/img/article/20190810/4.png\" alt=\"glTexImage2D的规范化确定大小内部格式组合\"></p>\n<h3 id=\"浮点纹理格式\">浮点纹理格式</h3>\n<p>OpenGL ES 3.0也引入浮点纹理格式。大部分浮点格式由16位半浮点数据或者32位浮点数据支持。与规范化纹理格式（R、RG、RGB、RGBA）一样，浮点纹理格式可能有1~4个分量。OpenGL ES 3.0不强制浮点格式用作渲染目标，只强制16位半浮点数据可以过滤。</p>\n<p><img src=\"/img/article/20190810/5.png\" alt=\"glTexImage2D的有效确定大小浮点内部格式组合\"></p>\n<h3 id=\"整数纹理格式\">整数纹理格式</h3>\n<p>整数纹理格式允许纹理范围在片段着色器中以整数形式读取。也就是说，与片段着色器中读取时数据从整数表示转换为规范化浮点值的规范化纹理格式相反，整数纹理中的值在片段着色器读取时仍然为整数。<br>\n整数纹理格式不可过滤，但是R、RG和RGBA变种可以用作帧缓冲区对象中渲染的颜色附着（color attachment）。使用整数纹理作为颜色附着的时候，忽略Alpha混合状态（整数渲染目标不可能进行混合）。用于从整数纹理读取并输出到整数渲染目标的片段着色器应该使用对应该格式的有符号或者无符号整数类型。</p>\n<p><img src=\"/img/article/20190810/6.png\" alt=\"glTexImage2D的有效确定大小内部整数格式组合\"><br>\n<img src=\"/img/article/20190810/7.png\" alt=\"glTexImage2D的有效确定大小内部整数格式组合\"></p>\n<h3 id=\"共享指数纹理格式\">共享指数纹理格式</h3>\n<p>共享指数纹理为不需要浮点纹理使用的那么多深度位数的大范围RGB纹理提供了一种存储方式。共享指数纹理通常用于高动态范围（HDR）图像，这种图像不需要半浮点或者全浮点数据。OpenGL ES 3.0中的共享指数纹理格式是<code>GL_RGB9_E5</code>。在这种格式中，3个RGB分量共享一个5位的指数。5位的指数隐含地由数值15调整。RGB的每个9位的数值存储无符号位的尾数（因此必然为正）。</p>\n<p><img src=\"/img/article/20190810/8.png\" alt=\"共享指数纹理转换\"></p>\n<h3 id=\"srgb纹理格式\">sRGB纹理格式</h3>\n<p>OpenGL ES 3.0中引入的另一个纹理格式是sRGB纹理。sRGB是一个非线性颜色空间，大约遵循一个幂函数。大部分图像实际上都存储为sRGB颜色空间，这种非线性解释了人类能够在不同的亮度级别上更好地区分颜色这一事实。<br>\n如果用于纹理的图像是以sRGB颜色空间创作的，但是没有使用sRGB纹理读取，那么所有发生在着色器中的照明计算都会在非线性颜色空间中进行。也就是说，标准创作软件包创建的纹理保存为sRGB，从着色器中读取时仍然保持为sRGB。于是照明计算发生在非线性sRGB空间中。许多应用程序都犯了这个错误，这是不正确的，会造成明显不同（不准确）的输出图像。<br>\n为了正确地处理sRGB图像，应用程序应该使用一个sRGB纹理格式，这种格式在着色器中读取时将从sRGB转换为线性颜色空间。然后，着色器中的所有计算都将在线性颜色空间中完成。最后，通过渲染到一个sRGB渲染目标，图像将会自动地转换回sRGB。可以使用着色器命令<code>pow(value, 2.0)</code>进行近似的sRGB-&gt;线性转换，然后用<code>(value, 1/2.2)</code>进行近似的线性-&gt;sRGB转换。然后，尽可能使用sRGB纹理是最好的做法，因为这样减少了着色器指令数量，并且提供更准确的sRGB转换。</p>\n<table>\n<thead>\n<tr>\n<th>内部格式</th>\n<th>格式</th>\n<th>类型</th>\n<th>输出数据</th>\n<th>R</th>\n<th>F</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>GL_SRGB8</td>\n<td>GL_RGB</td>\n<td>GL_UNSIGNED_BYTE</td>\n<td>8/8/8 SRGB</td>\n<td></td>\n<td>X</td>\n</tr>\n<tr>\n<td>GL_SRGB8_ALPHA8</td>\n<td>GL_RGBA</td>\n<td>GL_UNSIGNED_BYTE</td>\n<td>8/8/8/8 RGBA</td>\n<td>X</td>\n<td>X</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"深度纹理格式\">深度纹理格式</h3>\n<p>OpenGL ES 3.0中的最后一种纹理格式类型是深度纹理。深度纹理允许应用程序从帧缓冲区对象的深度附着中读取深度值（和可选的模板值）。这在各种高级渲染算法中很有用，包括阴影贴图。下表展示了OpenGL ES 3.0中有效的深度纹理格式：</p>\n<table>\n<thead>\n<tr>\n<th>内部格式</th>\n<th>格式</th>\n<th>类型</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>GL_DEPTH_COMPONENT16</td>\n<td>GL_DEPTH_COMPONENT</td>\n<td>GL_UNSIGNED_SHORT</td>\n</tr>\n<tr>\n<td>GL_DEPTH_COMPONENT16</td>\n<td>GL_DEPTH_COMPONENT</td>\n<td>GL_UNSIGNED_INTp</td>\n</tr>\n<tr>\n<td>GL_DEPTH_COMPONENT24</td>\n<td>GL_DEPTH_COMPONENT</td>\n<td>GL_UNSIGNED_INT</td>\n</tr>\n<tr>\n<td>GL_DEPTH_COMPONENT43F</td>\n<td>GL_DEPTH_COMPONENT</td>\n<td>GL_FLOAT</td>\n</tr>\n<tr>\n<td>GL_DEPTH24_STENCIL8</td>\n<td>GL_DEPTH_STENCIL</td>\n<td>GL_UNSIGNED_INT_24_8</td>\n</tr>\n<tr>\n<td>GL_DEPTH32F_STENCIL8</td>\n<td>GL_DEPTH_STENCIL</td>\n<td>GL_FLOAT_32_UNSIGNED_INT_24_8_REV</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"在着色器中使用纹理\">在着色器中使用纹理</h2>\n<p>下面代码简要演示在着色器中完成2D纹理的基本过程：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Vertex shader</span></span><br><span class=\"line\"><span class=\"meta\"># version 300 es</span></span><br><span class=\"line\">layout(location = <span class=\"number\">0</span>) <span class=\"keyword\">in</span> vec4 a_position;</span><br><span class=\"line\">layout(location = <span class=\"number\">1</span>) <span class=\"keyword\">in</span> vec2 a_texCoord;</span><br><span class=\"line\"><span class=\"keyword\">out</span> vec2 v_texCoord;</span><br><span class=\"line\"><span class=\"keyword\">void</span> main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    gl_Position = a_position;</span><br><span class=\"line\">    v_texCoord = a_texCoord;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Fragment shader</span></span><br><span class=\"line\"><span class=\"meta\"># version 300 es</span></span><br><span class=\"line\">precision mediump <span class=\"keyword\">float</span>;</span><br><span class=\"line\"><span class=\"keyword\">in</span> vec2 v_texCoord;</span><br><span class=\"line\">layout(location = <span class=\"number\">0</span>) <span class=\"keyword\">out</span> vec4 outColor;</span><br><span class=\"line\">uniform sampler2D s_texture;</span><br><span class=\"line\"><span class=\"keyword\">void</span> main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    outColor = texture(s_texture, v_texCoord);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>顶点着色器以一个二分量纹理坐标作为顶点输入，并将其作为输出传递给片段着色器。片段着色器消费该纹理坐标，并将其用于纹理读取。片段着色器声明一个类型为<code>sampler2D</code>的统一变量<code>s_texture</code>。采样器是用于从纹理贴图中读取的特殊统一变量。采样器统一变量将加载一个指定纹理绑定的纹理单元的数值；例如，用数值0指定采样器表示从单元<code>GL_TEXTURE0</code>读取，指定数值1表示从<code>GL_TEXTURE1</code>读取，一次类推。在OpenGL ES 3.0 API中，纹理用<code>glActiveTexture</code>函数绑定到纹理单元。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 绑定纹理单元</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param texture#&gt; 需要激活的纹理单元：GL_TEXTURE0, 1, 2 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glActiveTexture(GLenum texture);</span><br></pre></td></tr></table></figure>\n<p><code>glActiveTexture</code>函数设置当前纹理单元，以便后续的<code>glBindTexture</code>调用将纹理绑定到当前活动单元。在OpenGL ES实现上可用于片段着色器的纹理单元数量可以用<code>GL_MAX_TEXTURE_IMAGE_UNITS</code>参数的<code>glGetintegerv</code>查询。可用于顶点着色器的纹理单元数量使用带<code>GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS</code>参数的<code>glGetintegerv</code>查询。</p>\n<p>当使用<code>glBindTexture</code>绑定为并使用<code>glUniformli</code>加载纹理后，可以看到片段着色器中使用内建函数<code>texture</code>从纹理贴图出读取。<code>texture</code>内建函数形式如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 绑定2D纹理单元</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param sampler#&gt; 绑定到纹理单元的采样器，指定纹理为读取来源 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param coord#&gt; 用于从纹理贴图中读取的2D纹理坐标 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param bias#&gt; 可选参数，提供用于纹理读取的mip贴图偏置。这允许着色器明确地偏置用于mip忒土选择的LOD计算值 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return vec4 纹理</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">texture(sampler2D sampler, vec2 coord[, <span class=\"keyword\">float</span> bias]);</span><br></pre></td></tr></table></figure>\n<p><code>texture</code>函数返回一个代表从纹理贴图中读取颜色的<code>vec4</code>。纹理数据映射到这个颜色通道的方式取决于纹理的基本格式。下表展示了纹理格式映射到<code>vec4</code>颜色的方式，<a href=\"/article/2019/opengl-es-texture-0810/#%E7%BA%B9%E7%90%86%E8%B0%83%E9%85%8D\">纹理调配</a>确定这些分量中的值如何映射到着色器中的分量。</p>\n<table>\n<thead>\n<tr>\n<th>基本格式</th>\n<th>纹素数据描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>GL_RED</td>\n<td>(R, 0.0 0.0, 1.0)</td>\n</tr>\n<tr>\n<td>GL_RG</td>\n<td>(R, G, 0.0, 1.0)</td>\n</tr>\n<tr>\n<td>GL_RGB</td>\n<td>(R, G, B, 1.0)</td>\n</tr>\n<tr>\n<td>GL_RGBA</td>\n<td>(R, G, B, A)</td>\n</tr>\n<tr>\n<td>GL_LUMINANCE</td>\n<td>(L, L, L, 1.0)</td>\n</tr>\n<tr>\n<td>GL_LUMINANCE_ALPHA</td>\n<td>(L, L, L, A)</td>\n</tr>\n<tr>\n<td>GL_ALPHA</td>\n<td>(0.0, 0.0, 0.0, A)</td>\n</tr>\n</tbody>\n</table>\n<p>下面看具体示例：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)setupVertices &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    GLfloat vertices[] = &#123;</span><br><span class=\"line\">        <span class=\"number\">-1.0</span>, <span class=\"number\">-1.0</span>, <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"number\">0</span>, <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"number\">-1.0</span>, <span class=\"number\">1.0</span>, <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"number\">0</span>, <span class=\"number\">1</span>,</span><br><span class=\"line\">        <span class=\"number\">1.0</span>, <span class=\"number\">-1.0</span>, <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"number\">1</span>, <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"number\">1.0</span>, <span class=\"number\">1.0</span>, <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"number\">1</span>, <span class=\"number\">1</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 生成纹理</span></span><br><span class=\"line\">    GLuint texture = [<span class=\"keyword\">self</span> createTextureWithImage:[<span class=\"built_in\">UIImage</span> imageNamed:<span class=\"string\">@\"9\"</span>]];</span><br><span class=\"line\">    </span><br><span class=\"line\">    GLuint program = [<span class=\"keyword\">self</span> createProgram];</span><br><span class=\"line\">    glUseProgram(program);</span><br><span class=\"line\">    glViewport(<span class=\"number\">0</span>, <span class=\"number\">0</span>, [<span class=\"keyword\">self</span> getViewportWidth], [<span class=\"keyword\">self</span> getViewportHeight]);</span><br><span class=\"line\">    </span><br><span class=\"line\">    glClear(GL_COLOR_BUFFER_BIT);</span><br><span class=\"line\">    glClearColor(<span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 加载纹理</span></span><br><span class=\"line\">    glActiveTexture(GL_TEXTURE0);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> textureLocation = glGetUniformLocation(program, <span class=\"string\">\"s_texture\"</span>);</span><br><span class=\"line\">    glBindTexture(GL_TEXTURE_2D, texture);</span><br><span class=\"line\">    glUniform1i(textureLocation, <span class=\"number\">0</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    GLuint vbo;</span><br><span class=\"line\">    glGenBuffers(<span class=\"number\">1</span>, &amp;vbo);</span><br><span class=\"line\">    glBindBuffer(GL_ARRAY_BUFFER, vbo);</span><br><span class=\"line\">    glBufferData(GL_ARRAY_BUFFER, <span class=\"keyword\">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class=\"line\">    </span><br><span class=\"line\">    glEnableVertexAttribArray(<span class=\"number\">0</span>);</span><br><span class=\"line\">    glVertexAttribPointer(<span class=\"number\">0</span>, <span class=\"number\">3</span>, GL_FLOAT, GL_FALSE, <span class=\"keyword\">sizeof</span>(GLfloat)*<span class=\"number\">5</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    glEnableVertexAttribArray(<span class=\"number\">1</span>);</span><br><span class=\"line\">    glVertexAttribPointer(<span class=\"number\">1</span>, <span class=\"number\">2</span>, GL_FLOAT, GL_FALSE, <span class=\"keyword\">sizeof</span>(GLfloat)*<span class=\"number\">5</span>, (GLvoid *)(<span class=\"keyword\">sizeof</span>(GLfloat)*<span class=\"number\">3</span>));</span><br><span class=\"line\">    </span><br><span class=\"line\">    glDrawArrays(GL_TRIANGLE_STRIP, <span class=\"number\">0</span>, <span class=\"number\">4</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.context presentRenderbuffer:GL_RENDERBUFFER];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">- (GLuint)createTextureWithImage:(<span class=\"built_in\">UIImage</span> *)image &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 将 UIImage 转换为 CGImageRef</span></span><br><span class=\"line\">    <span class=\"built_in\">CGImageRef</span> cgImageRef = [image <span class=\"built_in\">CGImage</span>];</span><br><span class=\"line\">    GLuint width = (GLuint)<span class=\"built_in\">CGImageGetWidth</span>(cgImageRef);</span><br><span class=\"line\">    GLuint height = (GLuint)<span class=\"built_in\">CGImageGetHeight</span>(cgImageRef);</span><br><span class=\"line\">    <span class=\"built_in\">CGRect</span> rect = <span class=\"built_in\">CGRectMake</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, width, height);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 绘制图片</span></span><br><span class=\"line\">    <span class=\"built_in\">CGColorSpaceRef</span> colorSpace = <span class=\"built_in\">CGColorSpaceCreateDeviceRGB</span>();</span><br><span class=\"line\">    <span class=\"comment\">// 获取图片字节数 宽x高x4（RGBA）</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *imageData = malloc(width * height * <span class=\"number\">4</span>);</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     创建上下文</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">     @param data#&gt; 指向要渲染的绘制图像的内存地址 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     @param width#&gt; 图像宽度，单位为像素 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     @param height#&gt; 图像高度，单位为像素 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     @param bitsPerComponent#&gt; 内存中像素的每个组件的位数，比如32位RGBA，就设置为8 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     @param bytesPerRow#&gt; 每一行内存所占的bit数 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     @param space#&gt; 使用的颜色空间 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     @param bitmapInfo#&gt; bitmap信息 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     @return 返回上下文</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"built_in\">CGContextRef</span> context = <span class=\"built_in\">CGBitmapContextCreate</span>(imageData, width, height, <span class=\"number\">8</span>, width * <span class=\"number\">4</span>, colorSpace, kCGImageAlphaPremultipliedLast | kCGBitmapByteOrder32Big);</span><br><span class=\"line\">    <span class=\"comment\">// 图片正向-否则绘制出来的图片是颠倒的</span></span><br><span class=\"line\">    <span class=\"built_in\">CGContextTranslateCTM</span>(context, <span class=\"number\">0</span>, height);</span><br><span class=\"line\">    <span class=\"built_in\">CGContextScaleCTM</span>(context, <span class=\"number\">1.0</span>f, <span class=\"number\">-1.0</span>f);</span><br><span class=\"line\">    <span class=\"built_in\">CGColorSpaceRelease</span>(colorSpace);</span><br><span class=\"line\">    <span class=\"built_in\">CGContextClearRect</span>(context, rect);</span><br><span class=\"line\">    <span class=\"built_in\">CGContextDrawImage</span>(context, rect, cgImageRef);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 生成纹理</span></span><br><span class=\"line\">    GLuint textureID;</span><br><span class=\"line\">    glGenTextures(<span class=\"number\">1</span>, &amp;textureID);</span><br><span class=\"line\">    glBindTexture(GL_TEXTURE_2D, textureID);</span><br><span class=\"line\">    glTexImage2D(GL_TEXTURE_2D, <span class=\"number\">0</span>, GL_RGBA, width, height, <span class=\"number\">0</span>, GL_RGBA, GL_UNSIGNED_BYTE, imageData); <span class=\"comment\">// 将图片数据写入纹理缓存</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 设置如何把纹素映射成像素</span></span><br><span class=\"line\">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);</span><br><span class=\"line\">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);</span><br><span class=\"line\">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class=\"line\">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 解绑</span></span><br><span class=\"line\">    glBindTexture(GL_TEXTURE_2D, <span class=\"number\">0</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 释放内存</span></span><br><span class=\"line\">    <span class=\"built_in\">CGContextRelease</span>(context);</span><br><span class=\"line\">    free(imageData);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> textureID;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"使用立方图纹理的示例\">使用立方图纹理的示例</h2>\n<p>立方图纹理的使用非常类似于2D纹理。通过对立方图的各面（<code>GL_TEXTURE_CUBE_MAP_POSITIVE_(X|Y|Z)</code>，<code>GL_TEXTURE_CUBE_NEGATIVE_(X|Y|Z)</code>）调用<code>glTexImage2D</code>加载每个面的像素数据。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Vertex shader</span></span><br><span class=\"line\"><span class=\"meta\">#version 300 es</span></span><br><span class=\"line\">layout(location = <span class=\"number\">0</span>) <span class=\"keyword\">in</span> vec4 a_position;</span><br><span class=\"line\">layout(location = <span class=\"number\">1</span>) <span class=\"keyword\">in</span> vec3 a_normal;</span><br><span class=\"line\"><span class=\"keyword\">out</span> vec3 v_normal;</span><br><span class=\"line\"><span class=\"keyword\">void</span> mian()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    gl_Position = a_position;</span><br><span class=\"line\">    v_normal = a_normal;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Fragment shader</span></span><br><span class=\"line\"><span class=\"meta\">#version 300 es</span></span><br><span class=\"line\">precision mediump <span class=\"keyword\">float</span>;</span><br><span class=\"line\"><span class=\"keyword\">in</span> vec3 v_normal;</span><br><span class=\"line\">layout(location = <span class=\"number\">0</span>) <span class=\"keyword\">out</span> vec4 outColor;</span><br><span class=\"line\">uniform samplerCube s_texture;</span><br><span class=\"line\"><span class=\"keyword\">void</span> main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    outColor = texture(s_texture, v_normal);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>顶点着色器取得一个位置和法线作为顶点输入。发现保存在球面的每个顶点上，用作纹理坐标，并传递给片段着色器。然后，片段着色器使用内建函数<code>texture</code>，以法线作为纹理坐标从立方图中读取。立方图所用的<code>texture</code>内建函数采用如下形式：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 绑定立方图纹理单元</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param sampler#&gt; 绑定到纹理单元的采样器，指定纹理为读取来源 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param coord#&gt; 用于从纹理贴图中读取的3D纹理坐标 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param bias#&gt; 可选参数，提供用于纹理读取的mip贴图偏置。这允许着色器明确地偏置用于mip忒土选择的LOD计算值 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return vec4 纹理</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">texture(samplerCube sampler, vec3 coord[, <span class=\"keyword\">float</span> bias]);</span><br></pre></td></tr></table></figure>\n<p>读取立方图的函数与2D纹理非常类似。仅有的区别是，纹理坐标有3个分量而不是2个分量，采样器类型必须为<code>sampleCube</code>。用于绑定立方图纹理和加载采样器的方法与之前2D纹理加载一样。</p>\n<h2 id=\"加载3d纹理和2d纹理数组\">加载3D纹理和2D纹理数组</h2>\n<p>除了2D纹理和立方图，OpenGL ES 3.0还包含了3D纹理和2D纹理数组。加载3D纹理和2D纹理数组的函数是<code>glTexImage3D</code>，它与<code>glTexImage2D</code>很相似。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 加载3D纹理或者2D纹理数组</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param target#&gt; 指定纹理目标，应该为GL_TEXTURE_3D或GL_TEXTURE_2D_ARRAY description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param level#&gt; 指定加载的mip级别。0表示基本级别，更大的数值表示各个后续的mip贴图级别 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param internalformat#&gt; 纹理存储的内部格式 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param width#&gt; 以像素表示的图像宽度 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param height#&gt; 以像素表示的图像高度 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param depth#&gt; 3D纹理的切片深度 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param border#&gt; 这个参数在OpenGL ES中被忽略，应该为0 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param format#&gt; 输入纹理数据的格式 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param type#&gt; 输入像素数据的类型 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param pixels#&gt; 包含图像的实际像素数据。这些数据必须包含（width*height*depth）个像素，每个像素根据格式和类型规格有相应数量的字节。图像数据应该按照2D纹理切片的顺序存储 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glTexImage3D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, <span class=\"keyword\">const</span> GLvoid *pixels);</span><br></pre></td></tr></table></figure>\n<p>一旦用<code>glTexImage3D</code>加载了3D纹理或者2D纹理数组，就可以用<code>texture</code>内建函数在着色器中读取该纹理：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 绑定3D纹理单元</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param sampler#&gt; 绑定到纹理单元的采样器，指定纹理为读取来源 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param coord#&gt; 用于从纹理贴图中读取的3D纹理坐标 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param bias#&gt; 可选参数，提供用于纹理读取的mip贴图偏置。这允许着色器明确地偏置用于mip忒土选择的LOD计算值 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return vec4 纹理</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">texture(sampler3D sampler, vec3 coord[, <span class=\"keyword\">float</span> bias]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 绑定2D纹理数组单元</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param sampler#&gt; 绑定到纹理单元的采样器，指定纹理为读取来源 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param coord#&gt; 用于从纹理贴图中读取的3D纹理坐标 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param bias#&gt; 可选参数，提供用于纹理读取的mip贴图偏置。这允许着色器明确地偏置用于mip忒土选择的LOD计算值 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return vec4 纹理</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">texture(sampler2DArray sampler, vec3 coord[, <span class=\"keyword\">float</span> bias]);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>注意，r坐标是一个浮点值。对于3D纹理，根据过滤模式设置，纹理读取可能跨越体的两个切片。</p>\n</blockquote>\n<h1 id=\"压缩纹理\">压缩纹理</h1>\n<p>上述所说的纹理加载都是未压缩的纹理图像数据，OpenGL ES 3.0还支持压缩纹理图像数据的加载。纹理压缩有几个理由，首先，压缩纹理可以减少纹理在设备上的内存占用；其次（不那么明显），压缩纹理节约了着色器中读取纹理时消耗的内存带宽；最后，压缩纹理减少必须存储的图像数据，从而减少了应用程序的下载大小。<br>\n在OpenGL ES 2.0中，核心规范不定义任何压缩的纹理图像格式。也就是说，OpenGL ES 2.0核心简单地定义一个机制，可以加载压缩的纹理图像数据，但是没有定义任何压缩格式。因此，各供应商提供了特定于硬件的纹理压缩扩展。这样，OpenGL ES 2.0应用程序开发者必须在不同平台和硬件上支持不同的纹理压缩格式。<br>\nOpenGL ES 3.0引入所有供应商必须支持的标准纹理压缩格式，从而改善了这种情况。爱立信纹理压缩（Ericsson Texture Compression，ETC2和EAC）以无版税标准的形式提供给Khronos，它被作为OpenGL ES 3.0的标准纹理压缩格式。EAC有一些压缩1通道和2通道数据的变种，ETC2也有压缩3通道和4通道数据的变种。用于加载2D纹理和立方图压缩图像数据的函数是<code>glCompressedTexImage2D</code>，用于2D纹理数组的对应函数为<code>glCompressedTexImage3D</code>。</p>\n<blockquote>\n<p>注意，ETC2/EAC不支持3D纹理（只支持2D纹理和2D纹理数组），但是<code>glCompressedTexImage3D</code>可以用于加载供应商专用的3D纹理压缩格式。</p>\n</blockquote>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 加载2D纹理和立方图压缩图像数据</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param target#&gt; 指定纹理目标，应该为GL_TEXTURE_2D或者GL_TEXTURE_CUBE_MAP_* description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param level#&gt; 指定要加载的mip级别 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param internalformat#&gt; 纹理存储的内部格式 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param width#&gt; 以像素数表示的图像宽度 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param height#&gt; 以像素数表示的图像高度 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param border#&gt; 这个参数在OpenGL ES中被忽略，应该为0 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param imageSize#&gt; 以字节数表示的图像大小 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param data#&gt; 包含图像的实际压缩像素数据，必须能够容纳imageSize个字节 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glCompressedTexImage2D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, <span class=\"keyword\">const</span> GLvoid *data);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 加载2D纹理和立方图压缩图像数据</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param target#&gt; 指定纹理目标，应该为GL_TEXTURE_2D或者GL_TEXTURE_CUBE_MAP_* description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param level#&gt; 指定要加载的mip级别 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param internalformat#&gt; 纹理存储的内部格式。OpenGL ES 3.0中的标准压缩纹理格式在下表中描述 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param width#&gt; 以像素数表示的图像宽度 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param height#&gt; 以像素数表示的图像高度 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param border#&gt; 这个参数在OpenGL ES中被忽略，应该为0 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param imageSize#&gt; 以字节数表示的图像大小 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param data#&gt; 包含图像的实际压缩像素数据，必须能够容纳imageSize个字节 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glCompressedTexImage3D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, <span class=\"keyword\">const</span> GLvoid *data);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 加载2D纹理数组或专用3D纹理压缩图像数据</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param target#&gt; 指定纹理目标，应该为GL_TEXTURE_3D或者GL_TEXTURE_2D_ARRAY description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param level#&gt; 指定要加载的mip级别 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param internalformat#&gt; 纹理存储的内部格式。OpenGL ES 3.0中的标准压缩纹理格式在下表中描述 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param width#&gt; 以像素数表示的图像宽度 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param height#&gt; 以像素数表示的图像高度 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param depth#&gt; 以像素数表示的图像深度（或者2D纹理数组的切片数量） description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param border#&gt; 这个参数在OpenGL ES中被忽略，应该为0 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param imageSize#&gt; 以字节数表示的图像大小 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param data#&gt; 包含图像的实际压缩像素数据，必须能够容纳imageSize个字节 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glCompressedTexImage3D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, <span class=\"keyword\">const</span> GLvoid *data);</span><br></pre></td></tr></table></figure>\n<p>OpenGL ES 3.0支持的标准ETC压缩纹理格式在下表中列出。所有ETC格式将压缩的图像数据存储在4x4的块中。表中列出了每种ETC格式中每个像素的位数。单个ETC图像的大小可以由每像素位数（bpp）比率算出：<code>sizeInBytes = max(width, 4) * max(height, 4) * bpp / 8</code>。</p>\n<table>\n<thead>\n<tr>\n<th>内部格式</th>\n<th>大小（每像素位数）</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>GL_COMPRESSED_R11_EAC</td>\n<td>4</td>\n<td>单通道无符号压缩GL_RED格式</td>\n</tr>\n<tr>\n<td>GL_COMPRESSED_SIGNED_R11_EAC</td>\n<td>4</td>\n<td>单通道有符号压缩GL_RED格式</td>\n</tr>\n<tr>\n<td>GL_COMPRESSED_RG11_EAC</td>\n<td>8</td>\n<td>双通道无符号压缩GL_RG格式</td>\n</tr>\n<tr>\n<td>GL_COMPRESSED_SIGNED_RG11_EAC</td>\n<td>8</td>\n<td>双通道有符号压缩GL_RG格式</td>\n</tr>\n<tr>\n<td>GL_COMPRESSED_RGB8_ETC2</td>\n<td>4</td>\n<td>三通道无符号压缩GL_RGB格式</td>\n</tr>\n<tr>\n<td>GL_COMPRESSED_SRGB8_ETC2</td>\n<td>4</td>\n<td>sRGB颜色空间中的三通道无符号压缩GL_RGB格式</td>\n</tr>\n<tr>\n<td>GL_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2</td>\n<td>4</td>\n<td>四通道无符号压缩GL_RGBA格式，1位alpha</td>\n</tr>\n<tr>\n<td>GL_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2</td>\n<td>4</td>\n<td>sRGB颜色空间中四通道无符号压缩GL_RGBA格式，1位alpha</td>\n</tr>\n<tr>\n<td>GL_COMPRESSED_RGBA8_ETC2_EAC</td>\n<td>8</td>\n<td>四通道无符号压缩GL_RGBA格式</td>\n</tr>\n<tr>\n<td>GL_COMPRESSED_SRGBA8_ETC2_EAC</td>\n<td>8</td>\n<td>sRGB颜色空间中四通道无符号压缩GL_RGBA格式</td>\n</tr>\n</tbody>\n</table>\n<p>一旦加载压缩纹理，它就可以和无压缩纹理一样用于纹理处理。大部分开发人员不会编写自己的压缩程序，具体可使用的压缩工具，自行选择。</p>\n<p>注意，所有OpenGL ES 3.0实现都支持如上表中列出的格式。此外，有些实现可能支持表中未列出的供应商专用压缩格式。如果我们试图在不支持它们的OpenGL ES 3.0实现上使用纹理压缩格式，将会产生一个<code>GL_INVALID_ENUM</code>错误。检查OpenGL ES 3.0实现导出使用的任何供应商专用纹理压缩格式的扩展字符串很重要。如果该实现没有导出这样的扩展字符串，那就只能退而求其次使用无压缩的纹理格式。<br>\n除了检查扩展字符串之外，还可以用另外一种方法确定实现所支持的纹理压缩格式。也就是说，可以用<code>glGetIntegerv</code>查询<code>GL_NUM_COMPRESSED_TEXTURE_FORMATS</code>来确定所支持的压缩图像格式数量。然后，可以用<code>glGetIntegerv</code>查询<code>GL_COMPRESSED_TEXTURE_FORMATS</code>，该调用返回一个<code>GLenum</code>值的数组。数组中的每个<code>GLenum</code>值将是实现支持的一种压缩纹理格式。</p>\n<h1 id=\"纹理子图像规范\">纹理子图像规范</h1>\n<p>用<code>glTexImage2D</code>上传纹理图像之后，可以更新图像的各个部分。如果你只希望更新图像的一个子区域，这种能力就很试用。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 更新2D纹理图像的子区域</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param target#&gt; 指定纹理目标，可以是GL_TEXTURE_2D或者GL_TEXTURE_CUBE_MAP_* description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param level#&gt; 指定更新的mip级别 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param xoffset#&gt; 开始更新的纹素x索引 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param yoffset#&gt; 开始更新的纹素y索引 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param width#&gt; 更新的图像子区域宽度 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param height#&gt; 更新的图像子区域高度 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param format#&gt; 输入纹理数据格式 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param type#&gt; 输入像素数据的类型 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param pixels#&gt; 包含图像子区域的实际像素数据 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, <span class=\"keyword\">const</span> GLvoid *pixels);</span><br></pre></td></tr></table></figure>\n<p>这个函数将更新(xoffset, yoffset)到(xoffset+width-1, yoffset+height-1)范围内的纹素。注意，要使用这个函数，纹理必须完全指定。子图像的范围必须在之前指定的纹理图像界限之内。<code>pixels</code>数组中的数据必须按照<code>glPixelStorei</code>的<code>GL_UNPACK_ALIGNMENT</code>指定的方式对齐。</p>\n<p>还有一个用于更新压缩的2D纹理图像子区域的函数：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 更新压缩的2D纹理图像的子区域</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param target#&gt; 指定纹理目标，可以是GL_TEXTURE_2D或者GL_TEXTURE_CUBE_MAP_* description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param level#&gt; 指定更新的mip级别 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param xoffset#&gt; 开始更新的纹素x索引 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param yoffset#&gt; 开始更新的纹素y索引 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param width#&gt; 更新的图像子区域宽度 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param height#&gt; 更新的图像子区域高度 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param format#&gt; 所用的压缩纹理格式，必须与图像原来指定的格式相同 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param imageSize#&gt; 以字节数表示的图像大小 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param data#&gt; 包含图像子区域的实际像素数据 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glCompressedTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, <span class=\"keyword\">const</span> GLvoid *data);</span><br></pre></td></tr></table></figure>\n<p>此外，与2D纹理一样，可以用<code>glTexSubImage3D</code>更新现有3D纹理和2D纹理数组的子区域：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 更新3D纹理图像的子区域</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param target#&gt; 指定目标纹理，可以是GL_TEXTURE_3D或GL_TEXTURE_2D_ARRAY description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param level#&gt; 指定更新的mip级别 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param xoffset#&gt; 开始更新的纹素x索引 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param yoffset#&gt; 开始更新的纹素y索引 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param zoffset#&gt; 开始更新的纹素z索引 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param width#&gt; 更新的图像子区域宽度 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param height#&gt; 更新的图像子区域高度 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param depth#&gt; 更新的图像子区域深度 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param format#&gt; 输入纹理数据的格式 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param type#&gt; 输入像素数据的类型 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param pixels#&gt; 包含像素数据的类型 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, <span class=\"keyword\">const</span> GLvoid *pixels);</span><br></pre></td></tr></table></figure>\n<p><code>glTexSubImage3D</code>的表现与<code>glTexSubImage2D</code>类似，唯一的不同是子区域包含一个<code>zoffset</code>和<code>depth</code>，用于指定深度切片中要更新的子区域。对于压缩的2D纹理数组，也可以用<code>glCompressedTexSubImage3D</code>更新纹理的一个子区域。对于3D纹理，这个函数只能用于供应商专用的3D压缩纹理格式，因为ETC2/EAC只支持2D纹理和2D纹理数组。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 更新压缩的3D纹理图像的子区域</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param target#&gt; 指定纹理目标，可能是GL_TEXTURE_3D或者GL_TEXTURE_2D_ARRAY description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param level#&gt; 指定更新的mip级别 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param xoffset#&gt; 开始更新的纹素x索引 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param yoffset#&gt; 开始更新的纹素y索引 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param zoffset#&gt; 开始更新的纹素z索引 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param width#&gt; 更新的图像子区域宽度 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param height#&gt; 更新的图像子区域高度 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param depth#&gt; 更新的图像子区域深度 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param format#&gt; 使用的压缩纹理格式，必须与原来指定的图像格式相同 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param imageSize#&gt; 以字节数表示的图像大小 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param data#&gt; 包含图像子区域的实际像素数据 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glCompressedTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, <span class=\"keyword\">const</span> GLvoid *data);</span><br></pre></td></tr></table></figure>\n<h1 id=\"从颜色缓冲区复制纹理数据\">从颜色缓冲区复制纹理数据</h1>\n<p>OpenGL ES 3.0中支持的另一个纹理功能是从颜色缓冲区复制数据到一个纹理。如果我们希望使用渲染的结果作为纹理中的图像，这一功能就很实用。后面的帧缓冲区对象提供了渲染-纹理转换的快速方法，这种方法比复制图像数据更快。但是，如果性能不是关注点，那么从颜色缓冲区复制图像数据就是一种实用的功能。</p>\n<p>作为复制图像数据来源的颜色缓冲区可以用<code>glReadBuffer</code>函数设置。如果应用程序渲染到一个双缓冲区EGL可显示表面，则<code>glReadBuffer</code>必须设置为<code>GL_BACK</code>（后台缓冲区–默认状态）。OpenGL ES 3.0只支持双缓冲区EGL可显示表面。因此，所有在显示器上绘图的OpenGL ES 3.0应用程序都有一个既用于前台缓冲区又用于后台缓冲区的颜色缓冲区。这个缓冲区当前是前台还是后台缓冲区，由对<code>eglSwapBuffers</code>的最后一次调用决定。当从可显示EGL表面的颜色缓冲区中复制图像数据时，总是会复制后台缓冲区的内容。如果渲染到一个EGL pbuffer，则复制将发生在pbuffer表面。最后，如果渲染到一个帧缓冲区对象，则所复制的帧缓冲区对象的颜色附着通过调用带<code>GL_COLOR_ATTACHMENTi</code>参数的<code>glReadBuffer</code>函数设置：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 读取颜色缓冲区</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param mode#&gt; 指定读取的颜色缓冲区。这将为未来的glReadPixels、glCopyTexImage2D、glCopyTexSubImage2D和glCopyTexSubImage3D调用设置源颜色缓冲区。该值可能为GL_BACK、GL_COLOR_ATTACHMENTi或GL_NONE description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glReadBuffer(GLenum mode);</span><br></pre></td></tr></table></figure>\n<p>从颜色缓冲区复制数据到纹理的函数是<code>glCopyTexImage2D</code>、<code>glCopyTexSubImage2D</code>和<code>glCopyTexSubImage3D</code>。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 从颜色缓冲区复制数据到2D纹理</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param target#&gt; 指定纹理目标，可能为GL_TEXTURE_CUBE_MAP_2D或者GL_TEXTURE_CUBE_MAP_* description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param level#&gt; 指定加载的mip级别 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param internalformat#&gt; 图像的内部格式 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param x#&gt; 读取的帧缓冲区矩形左下角的x窗口坐标 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param y#&gt; 读取的帧缓冲区矩形左下角的y窗口坐标 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param width#&gt; 读取区域的宽度，以像素数表示 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param height#&gt; 读取区域的高度，以像素表示 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param border#&gt; OpenGL ES 3.0不支持边框，必须为0 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glCopyTexImage2D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);</span><br></pre></td></tr></table></figure>\n<p>调用上述函数导致纹理图像从区域(x, y)到(x+width-1, y+height-1)的颜色缓冲区内的像素加载。纹理图像的宽度和高度等于颜色缓冲区中复制区域的大小。我们应该用这些信息填充纹理的全部内容。<br>\n此外，可以用<code>glCopyTexSubImage2D</code>更新已经指定的图像的子区域：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 从颜色缓冲区复制数据更新已经指定的2D纹理的子区域</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param target#&gt; 指定纹理目标，可能为GL_TEXTURE_2D或者GL_TEXTURE_CUBE_MAP_* description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param level#&gt; 指定更新的mip级别 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param xoffset#&gt; 开始更新的纹素x索引 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param yoffset#&gt; 开始更新的纹素y索引 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param x#&gt; 读取的帧缓冲区矩形左下角的x窗口坐标 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param y#&gt; 读取的帧缓冲区矩形左下角的y窗口坐标 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param width#&gt; 读取区域的宽度，以像素数表示 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param height#&gt; 读取区域的高度，以像素数据表示 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glCopyTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);</span><br></pre></td></tr></table></figure>\n<p>上述函数将用颜色缓冲区中从(x, y)到(x+width-1, y+height-1)区域的像素更新图像中从(xoffset, yoffset)到(xoffset+width-1, yoffset+height-1)的子区域。<br>\n最后，也可以用<code>glCopyTexSubImage3D</code>将颜色缓冲区的内容复制到之前指定的3D纹理或者2D纹理数组的一个切片中：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 从颜色缓冲区复制数据更新已经指定的3D纹理或2D纹理数组的子区域</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param target#&gt; 指定纹理目标，可能为GL_TEXTURE_3D或者GL_TEXTURE_2D_ARRAY description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param level#&gt; 指定加载的mip级别 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param xoffset#&gt; 开始更新的纹素x索引 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param yoffset#&gt; 开始更新的纹素y索引 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param zoffset#&gt; 开始更新的纹素z索引 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param x#&gt; 读取的帧缓冲区矩形左下角的x窗口坐标 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param y#&gt; 读取的帧缓冲区矩形左下角的y窗口坐标 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param width#&gt; 读取区域的宽度，以像素数表示 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param height#&gt; 读取区域的高度，以像素数表示 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glCopyTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);</span><br></pre></td></tr></table></figure>\n<p>对于上述函数要记住一点，即纹理图像格式的分量不能多于颜色缓冲区。换句话说，复制颜色缓冲区的数据时，可以转换为分量较少的格式，但是不能转换为分量较多的格式。</p>\n<h1 id=\"采样器对象\">采样器对象</h1>\n<p>之前介绍了用<code>glTexParameter[i|f][v]</code>设置纹理参数（如过滤模式、纹理坐标包装模式和LOD设置）的方法。使用<code>glTexParameter[i|f][v]</code>的问题是它可能造成大量不必要的API开销。应用程序经常在大量纹理上使用相同的设置，在这种情况下，用<code>glTexParameter[i|f][v]</code>为每个纹理对象设置采样器状态可能造成大量额外开销。为了缓解这一问题，OpenGL ES 3.0引入采样器对象，将采样器状态和纹理状态分离。简言之，所有可用<code>glTexParameter[i|f][v]</code>进行的设置都可以对采样器对象进行，可以在一次函数调用中与纹理单元绑定使用。采样器对象可以用于许多纹理，从而降低API开销。</p>\n<p>用于生成采样器对象的函数是：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 生成采样器对象</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param count#&gt; 指定生成的采样器对象数量 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param samplers#&gt; 一个无符号整数数组，将容纳n个采样器对象ID description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glGenSamplers(GLsizei count, GLuint *samplers);</span><br></pre></td></tr></table></figure>\n<p>采样器对象在应用程序不再需要它们时也需要删除：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 删除采样器对象</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param count#&gt; 指定要删除的采样器对象 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param samplers#&gt; 一个无符号整数数组，容纳要删除的n个采样器对象ID description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glDeleteSamplers(GLsizei count, <span class=\"keyword\">const</span> GLuint *samplers);</span><br></pre></td></tr></table></figure>\n<p>当生成采样器对象ID之后，应用程序必须绑定采样器对象以使用其状态。采样器对象绑定到纹理单元，这种绑定取代了用<code>glTexParameter[i|f][v]</code>进行的所有纹理对象状态设置：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 采样器对象绑定到纹理单元</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param unit#&gt; 指定采样器对象绑定到的纹理单元 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param sampler#&gt; 所要绑定的采样器对象的句柄 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glBindSampler(GLuint unit, GLuint sampler);</span><br></pre></td></tr></table></figure>\n<p>如果传递给<code>glBindSampler</code>的<code>sampler</code>为0（默认采样器），则使用为纹理对象设置的状态。采样器对象状态可以用<code>glSampler[f|i][v]</code>设置。可以用<code>glSamplerParameter[f|i][v]</code>设置的参数与用<code>glTexParameter[i|f][v]</code>设置的相同，唯一的区别是状态被设置到采样器对象，而非纹理对象：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">glSamplerParameteri(GLuint sampler, GLenum pname, GLint param);</span><br><span class=\"line\">glSamplerParameteriv(GLuint sampler, GLenum pname, <span class=\"keyword\">const</span> GLint *param);</span><br><span class=\"line\">glSamplerParameterf(GLuint sampler, GLenum pname, GLfloat param);</span><br><span class=\"line\">glSamplerParameterfv(GLuint sampler, GLenum pname, <span class=\"keyword\">const</span> GLfloat *param);</span><br></pre></td></tr></table></figure>\n<h1 id=\"不可变纹理\">不可变纹理</h1>\n<p>OpenGL ES 3.0中引入的另一种有助于改进应用程序性能的功能是不可变纹理。正如前面所介绍的，应用程序使用<code>glTexImage2D</code>和<code>glTexImage3D</code>等函数独立地指定纹理的每个mip贴图级别。这对OpenGL ES驱动程序造成的问题是驱动程序在绘图之前无法确定纹理是否已经完全指定。也就是说，它必须检查每个mip贴图级别或者子图像的格式是否相符、每个级别的大小是否正确以及是否有足够的内存。这种绘图时检查可能代价很高，而使用不可变纹理可以避免这种情形。</p>\n<p>不可变纹理的思路很简单：应用程序在加载数据之前指定纹理的格式和大小。这样做之后，纹理格式变成不可改变的，OpenGL ES驱动程序可以预先进行所有一致性和内存检查。一旦纹理不可变，它的格式和大小就不会再变化。但是，应用程序仍然可以通过使用<code>glTexSubImage2D</code>、<code>glTexSubImage3D</code>、<code>glGenerateMipMap</code>或者渲染到纹理加载图像数据。<br>\n为了创建不可变纹理，应用程序将使用<code>glBindTexture</code>绑定纹理，然后用<code>glTexStorage2D</code>或<code>glTexStorage3D</code>分配不可变存储：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 创建不可变纹理</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param target#&gt; 指定纹理目标，可能是GL_TEXTURE_2D、GL_TEXTURE_CUBE_MAP_*或者GL_TEXTURE_3D、GL_TEXTURE_2D_ARRAY description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param levels#&gt; 指定mip贴图级别数量 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param internalformat#&gt; 确定大小的纹理存储内部格式 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param width#&gt; 基本图形宽度，以像素数表示 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param height#&gt; 基本图像高度，以像素数表示 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glTexStorage2D/<span class=\"number\">3</span>D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);</span><br></pre></td></tr></table></figure>\n<p>一旦创建了不可变纹理，在纹理对象上调用<code>glTexImage*</code>、<code>glCompressedTexImage*</code>、<code>glCopyTexImage*</code>或<code>glTexStorage*</code>就会无效。这样做将生成<code>GL_INVALID_OPERATION</code>错误。要用图像数据填充不可变纹理，应用程序需要使用<code>glTexSubImage2D</code>、<code>glTexSubImage3D</code>、<code>glGenerateMipMap</code>或者渲染到纹理图像（通过将其作为帧缓冲区对象附着使用来实现）。<br>\n使用<code>glTexStorage*</code>时，OpenGL ES内部通过将<code>GL_TEXTURE_IMMUTABLE_FORMAT</code>设置为<code>GL_TRUE</code>，将<code>GL_TEXTURE_IMMUTABLE_LEVELS</code>设置为传递给<code>glTexStorage*</code>的数字，将纹理对象标记为不可变。应用程序可以使用<code>glGetTexParameter[i|f][v]</code>查询这些值，但是它无法直接设置这些值。必须使用<code>glTexStorage*</code>函数设置不可变纹理参数。</p>\n<h1 id=\"像素解包缓冲区对象\">像素解包缓冲区对象</h1>\n<p>缓冲区对象可以在服务器端（或者GPU）内存中存储数据，而不是在客户端（或者主机）内存。使用缓冲区对象的好处是减少了从CPU到GPU的数据传送，因而能够改进性能（并降低内存占用率）。OpenGL ES 3.0还引入了像素解包缓冲区对象，这种对象与<code>GL_PIXEL_UNPACK_BUFFER</code>目标绑定指定。像素解包缓冲区对象允许纹理数据规格保存在服务器端内存。结果是，像素解包操作<code>glTexImage*</code>、<code>glTexSubImage*</code>、<code>glCompressedTexImage*</code>和<code>glCompressedTexSubImage*</code>可以直接来自缓冲区对象。如果像素解包缓冲区对象在这类调用期间绑定，则数据指针是像素解包缓冲区中的一个偏移量，而不是指向客户端内存的指针，这与使用<code>glVertexAttribPointer</code>的VBO很相似。<br>\n像素解包缓冲区对象可以用于将纹理数据流传输到GPU。应用程序可以分配一个像素解包缓冲区，然后为更新映射缓冲区区域。当进行加载数据到OpenGL的调用（例如<code>glTexSubImage*</code>）时，这些函数可能立即返回。因为数据已经存在于GPU（或者可以在稍后复制，但是立即复制不需要像客户端数据那样进行）。我们建议在纹理上传操作的性能/内存占用对应用程序很重要的情况下使用像素解包缓冲区对象。</p>\n<h1 id=\"总结\">总结</h1>\n<p>这篇文章主要介绍了OpenGL ES 3.0中使用纹理的方法。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>之前我们已经介绍了顶点着色器，管线的下一步是片段着色器，这是大部分OpenGL ES 3.0视觉魔法发生的地方。片段着色器的核心方面是对表面应用纹理。</p>\n</blockquote>\n<h1>纹理基础</h1>\n<p>3D图形渲染中最基本的操作之一是对一个表面应用纹理。纹理可以表现只从网格的几何形状中无法得到的附加细节。OpenGL ES 3.0中的纹理有多种形式：2D纹理、2D纹理数组、3D纹理和立方图纹理。<br>\n纹理通常使用纹理坐标应用到一个表面，纹理坐标可以视为纹理数组数据中的索引。</p>\n<h2>2D纹理</h2>\n<p>2D纹理是OpenGL ES中最基本和常用的纹理形式，是一个图形数据的二维数组。一个纹理的单独数据元素称作”纹素“（Texel，”texture pixels“（纹理像素）的简写）。OpenGL ES中的纹理图像数据可以用许多不同的基本格式表现。纹理数据可用的基本格式如下表：</p>\n<table>\n<thead>\n<tr>\n<th>基本格式</th>\n<th>纹素数据描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>GL_RED</td>\n<td>(红)</td>\n</tr>\n<tr>\n<td>GL_RG</td>\n<td>(红，绿)</td>\n</tr>\n<tr>\n<td>GL_RGB</td>\n<td>(红，绿，蓝)</td>\n</tr>\n<tr>\n<td>GL_RGBA</td>\n<td>(红，绿，蓝，Alpha)</td>\n</tr>\n<tr>\n<td>GL_LUMINANCE</td>\n<td>(亮度)</td>\n</tr>\n<tr>\n<td>GL_LUMINANCE_ALPHA</td>\n<td>(亮度，Alpha)</td>\n</tr>\n<tr>\n<td>GL_ALPHA</td>\n<td>(Alpha)</td>\n</tr>\n<tr>\n<td>GL_DEPTH_COMPONENT</td>\n<td>(深度)</td>\n</tr>\n<tr>\n<td>GL_DEPTH_STENCIL</td>\n<td>(深度，模板)</td>\n</tr>\n<tr>\n<td>GL_RED_INTEGER</td>\n<td>(整数红)</td>\n</tr>\n<tr>\n<td>GL_RG_INTEGER</td>\n<td>(整数红，整数绿)</td>\n</tr>\n<tr>\n<td>GL_RGB_INTEGER</td>\n<td>(整数红，整数绿，整数蓝)</td>\n</tr>\n<tr>\n<td>GL_RGBA_INTERGER</td>\n<td>(整数红，整数绿，整数蓝，整数Alpha)</td>\n</tr>\n</tbody>\n</table>\n<p>图像中的每个纹素根据基本格式和数据类型指定。用2D纹理渲染时，纹理坐标用作纹理图形中的索引。一般来说，在3D内容创作程序中将制作一个网格，每个顶点都有一个纹理坐标。2D纹理的纹理坐标用一对2D坐标(s, t)指定，有时也称作(u, v)坐标。这些坐标代表用于查找一个纹理贴图的规范化坐标。</p>\n<p><img src=\"/img/article/20190810/1.png\" alt=\"2D纹理坐标\"></p>\n<p>纹理图像的左下角由<code>st</code>坐标(0.0, 0.0)指定，右上角由<code>st</code>坐标(1.0, 1.0)指定。在[0.0, 1.0]区间之外的坐标是允许的，在该区间之外的纹理读取行为由纹理包装模式定义。</p>\n<h2>立方图纹理</h2>\n<p>除了2D纹理之外，OpenGL ES 3.0还支持立方图纹理。从最基本的特征讲，立方图就是一个由6个单独2D纹理面组成的纹理。立方图的每个面代表立方体六面中的一个。虽然立方图在3D渲染中有多重高级的使用方式，但是最常用的是所谓的环境贴图特效。对这种特效，环境在物体上的倒影通过使用一个表示环境的立方图渲染。通常，生成环境贴图所用的立方图通过在场景中央防止一个摄像机，从6个轴的方向(+X, -X, +Y, -Y, +Z, -Z)捕捉场景图形并将结果保存在立方体的每个面来生成。<br>\n立方图纹素的读取通过使用一个3D向量(s, t, r)作为纹理坐标，在立方图中查找。纹理坐标(s, t, r)代表着3D向量的(x, y, z)分量。这个3D向量首先用于选择立方图中需要读取的一个面，然后该坐标投影到2D坐标(s, t)，然后从该面上读取。我们可以通过从一个立方体内部的原点绘制一个3D向量来直观地了解这一过程。这个向量与立方体相交的点就是从立方图读取的纹素。</p>\n<p><img src=\"/img/article/20190810/2.png\" alt=\"立方图的3D纹理坐标\"></p>\n<p>立方图各个面的指定方法与2D纹理的相同。每个面必须为正方形（宽度和高度必须相等），每个面的宽度和高度都一样。用于纹理坐标的3D向量和2D纹理的不同，通常不直接逐顶点地保存在网格上。相反，立方图通常使用法向量作为计算立方图纹理坐标的基础来读取。一般来说，法向量和一个来自眼睛的向量一起使用，计算出一个反射向量，然后用这个向量在立方图中查找。</p>\n<h2>3D纹理</h2>\n<p>OpenGL ES 3.0中的另一类纹理是3D纹理（或者体纹理）。3D纹理可以看做2D纹理多个切片的一个数组，它用一个3元(s, t, r)坐标访问，这与立方体很相似。对于3D纹理，r坐标选择3D纹理中需要采样的切片，(s, t)坐标用于读取每个切片中的2D贴图。下图展示了一个3D纹理，其中每个切片由一个单独的2D纹理组成。3D纹理中的每个mip贴图级别包含上一个级别的纹理中的半数切片。</p>\n<p><img src=\"/img/article/20190810/3.png\" alt=\"3D纹理\"></p>\n<h2>2D纹理数组</h2>\n<p>OpenGL ES 3.0中最后一种纹理是2D纹理数组。2D纹理数组与3D纹理很相似，但是用途不同。例如，2D纹理数组尝尝用于存储2D图像的一个动画。数组的每个切片表示纹理动画的一帧。2D纹理数组和3D纹理之间的差别很细微，但是很重要。对于3D纹理，过滤发生在切片之间，而从2D纹理数组中读取只从一个单独的切片采样。mip贴图也不一样。2D纹理数组中的每个mip贴图级别包含与以上级别相同的切片数量。每个2D切片的mip贴图完全独立于其他切片（这与3D纹理的情况不同，3D纹理的每个mip贴图级别只有以上级别切片数量的一半）。</p>\n<p>为了在2D纹理数组中定位，需使用与3D纹理一样的纹理坐标(s, t, r)，r坐标选择2D纹理数组中要使用的切片，(s, t)坐标用于选择切片，选择的方法与2D纹理完全一样。</p>\n<h2>纹理对象和纹理的加载</h2>\n<p>纹理应用的第一步是创建一个纹理对象。纹理对象是一个容器对象，保存渲染所需的纹理数据，例如图像数据、过滤模式和包装模式。在OpenGL ES中，纹理对象用一个无符号整数表示，该整数是纹理对象的一个句柄。用于生成纹理对象的函数是<code>glGenTextures</code>：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 生成纹理</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param n#&gt; 指定要生成的纹理对象数量 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param textures#&gt; 一个保存n个纹理对象ID的无符号整数数组 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glGenTextures(GLsizei n, GLuint *textures);</span><br></pre></td></tr></table></figure>\n<p>在创建的时候，<code>glGenTextures</code>生成的纹理对象是一个空的容器，用于加载纹理数据和参数。纹理对象在应用程序不在需要它们的时候也必须删除。这一步骤通常在应用程序关闭或者游戏级别改变时完成，可以使用<code>glDeleteTextures</code>实现：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 删除纹理</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param n#&gt; 指定要删除的纹理对象数量 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param textures#&gt; 一个保存要删除的n个纹理对象ID的无符号整数数组 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glDeleteTextures(GLsizei n, <span class=\"keyword\">const</span> GLuint *textures);</span><br></pre></td></tr></table></figure>\n<p>一旦用<code>glGenTextures</code>生成了纹理对象ID，应用程序就必须绑定纹理对象进行操作。绑定纹理对象之后，后续的操作(如<code>glTexImage2D</code>和<code>glTexParameter</code>)将影响绑定的纹理对象。用于绑定纹理对象的函数是<code>glBindTexture</code>：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 绑定纹理对象</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param target#&gt; 将纹理对象绑定到GL_TEXTURE_2D、GL_TEXTURE_3D、GL_TEXTURE_2D_ARRAY或者GL_TEXTURE_CUBE_MAP description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param texture#&gt; 要绑定的纹理对象句柄 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glBindTexture(GLenum target, GLuint texture);</span><br></pre></td></tr></table></figure>\n<p>一旦纹理绑定到一个特定的纹理目标，纹理对象在删除之前就一直绑定到它的目标。生成纹理对象并绑定它之后，使用纹理的下一个步骤是真正地加载图像数据。用于加载2D和立方图纹理的基本函数是<code>glTexImage2D</code>。此外，在OpenGL ES 3.0中可以使用多种替代方法指定2D纹理，包括不可变纹理(<code>glTexStorage2D</code>)和<code>glTexSubImage2D</code>的结合。我们首先从最基本的方法开始–使用<code>glTexImage2D</code>–并在后面描述不可变纹理。为了获得最佳性能，建议使用不可变纹理。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 加载2D和立方图纹理</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param target#&gt; 指定目标纹理，可以为GL_TEXTURE_2D、GL_TEXTURE_CUBE_MAP_POSITIVE_(X, Y, Z)、GL_TEXTURE_CUBE_MAP_NEGATIVE_(X, Y, Z) description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param level#&gt; 指定要加载的mip级别，第一个级别为0，后续的mip贴图级别递增 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param internalformat#&gt; 纹理存储的内部格式；可以是未确定大小的基本内部格式，后者是确定大小的内部格式。未确定大小的内部格式可以为GL_RGBA，GL_RGB，GL_LUMINANCE_ALPHA，GL_LUMINANCE，GL_ALPHA。确定大小的内部格式有GL_RGB，GL_DEPTH_COMPONENT16等 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param width#&gt; 图像的像素宽度 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param height#&gt; 图像的像素高度 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param border#&gt; 这个参数在OpenGL ES中被忽略，保留它是为了与桌面的OpenGL接口兼容；应该为0 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param format#&gt; 输入的纹理数据格式，可以为GL_RED(_INTEGER)，GL_RG(_INTEGER)，GL_RGB(_INTERGER)，GL_RGBA(_INTEGER)，GL_DEPTH_COMPONENT，GL_DEPTH_STENCIL，GL_LUMINANCE_ALPHA，GL_ALPHA description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param type#&gt; 输入像素数据的类型 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param pixels#&gt; 包含图像的实际像素数据。数据必须包含（width*height*高度）个像素，每个像素根据格式和类型规范有相应的字节数。像素行必须对其到用`glPixelStorei`设置的GL_UNPACK_ALIGHMENT description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glTexImage2D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, <span class=\"keyword\">const</span> GLvoid *pixels);</span><br></pre></td></tr></table></figure>\n<p>下面举个例子，演示了生成纹理对象、绑定该对象然后加载由无符号字节表示的RGB图像数据组成的 2x2 2D纹理：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GLuint textureId;</span><br><span class=\"line\">GLubyte pixels[] = &#123;</span><br><span class=\"line\">    <span class=\"number\">255</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>,</span><br><span class=\"line\">    <span class=\"number\">0</span>, <span class=\"number\">255</span>, <span class=\"number\">0</span>,</span><br><span class=\"line\">    <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">255</span>,</span><br><span class=\"line\">    <span class=\"number\">255</span>, <span class=\"number\">255</span>, <span class=\"number\">0</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// User tightly packed data</span></span><br><span class=\"line\">glPixelStorei(GL_UNPACK_ALIGNMENT, <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Generate a texture object</span></span><br><span class=\"line\">glGenTextures(<span class=\"number\">1</span>, &amp;textureId);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Bind the texture object</span></span><br><span class=\"line\">glBindTexture(GL_TEXTURE_2D, textureId);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Load the texture</span></span><br><span class=\"line\">glTexImage2D(GL_TEXTURE_2D, <span class=\"number\">0</span>, GL_RGB, <span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">0</span>, GL_RGB, GL_UNSIGNED_BYTE, pixels);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Set the filtering mode</span></span><br><span class=\"line\">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);</span><br><span class=\"line\">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);</span><br></pre></td></tr></table></figure>\n<p>在上述代码的第一部分，<code>pixels</code>数组用简单的2x2纹理数据初始化。这些数据由无符号字节RGB三元组组成，范围为[0, 255]。当着色器中从一个8位无符号字节纹理分量读取数据时，该值从[0, 255]区间被映射到浮点区间[0.0, 1.0]。一般来说，应用程序不会以这种简单的方式创建纹理数据，而从一个图像文件中加载数据。<br>\n在调用<code>glTexImage2D</code>之前，应用程序调用<code>glPixelStorei</code>设置解包对齐。通过<code>glTexImage2D</code>上传纹理数据时，像素行被认定为对齐到<code>GL_UNPACK_ALIGNMENT</code>设置的值。默认情况下，该值为4，意味着像素行被认定为从4字节的边界开始。<br>\n这个应用程序将解包对齐设置为1，意味着每个像素行从字节边界开始（换言之，数据被紧密打包）。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 设置包装或者解包对齐</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param pname#&gt; 指定设置的像素存储类型，下面的选项影响调用glTexImage2D、glTexImage3D、glTexSubImage2D和glTexSubImage3D时数据从内存中解包的方式：GL_UNPACK_ROW_LENGTH，GL_UNPACK_IMAGE_HEIGHT，GL_UNPACK_SKIP_PIXELS，GL_UNPACK_SKIP_ROWS，GL_UNPACK_SKIP_IMAGES，GL_UNPACK_ALIGNMENT；下面的选项影响调用glReadPixels时数据打包到内存中的方式：GL_PACK_ROW_LENGTH，GL_PACK_IMAGE_HEIGHT，GL_PACK_SKIP_PIXELS，GL_PACK_SKIP_ROWS，GL_PACK_SKIP_IMAGES，GL_PACK_ALIGNMENT description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param param#&gt; 指定包装或者解包选项的整数值 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glPixelStorei(GLenum pname, GLint param);</span><br></pre></td></tr></table></figure>\n<p><code>glPixelStorei</code>的<code>GL_PACK_xxxx</code>参数对纹理图像上传没有任何影响。打包选项由<code>glReadPixels</code>使用。<code>glPixelStorei</code>设置的打包和解包选项是全局状态，不由纹理对象存储，也不与之关联。在实践中，很少使用<code>GL_UNPACK_ALIGNMENT</code>之外的选项指定纹理。为了完整起见，下表提供了像素存储选项的完整列表。</p>\n<table>\n<thead>\n<tr>\n<th>像素存储选项</th>\n<th>初始值</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>GL_UNPACK_ALIGNMENT GL_PACK_ALIGNMENT</td>\n<td>4</td>\n<td>指定图像中各行的对齐方式。默认情况下，图像始于4字节边界。将该值设置为1意味着图像紧密打包，各行到齐到字节边界</td>\n</tr>\n<tr>\n<td>GL_UNPACK_ROW_LENGTH GL_PACK_ROW_LENGTH</td>\n<td>0</td>\n<td>如果该值非0，则表示每个图像行中的像素数量。如果该值为0，则行的长度为图像的宽度（也就是紧密打包）</td>\n</tr>\n<tr>\n<td>GL_UNPACK_IMAGE_HEIGHT GL_PACK_IMAGE_HEIGHT</td>\n<td>0</td>\n<td>如果该值非0，则表示作为3D纹理一部分的图形的每个列中像素的数量。这个选项可以用于在3D纹理的每个切片之间填充列。如果该值为0，则图像中的列数等于高度（也就是紧密打包）</td>\n</tr>\n<tr>\n<td>GL_UNPACK_SKIP_PIXELS GL_PACK_SKIP_PIXELS</td>\n<td>0</td>\n<td>如果该值非0，则表示行开始处跳过的像素数量</td>\n</tr>\n<tr>\n<td>GL_UNPACK_SKIP_ROWS GL_PACK_SKIP_ROWS</td>\n<td>0</td>\n<td>如果该值非0，则表示图像开始时跳过的行数</td>\n</tr>\n<tr>\n<td>GL_UNPACK_SKIP_IMAGES GL_PACK_SKIP_IMAGES</td>\n<td>0</td>\n<td>如果该值非0，则表示3D纹理中跳过的图像数</td>\n</tr>\n</tbody>\n</table>\n<p>代码的最后一部分使用<code>glTexParameteri</code>将缩小和放大过滤模式设置为<code>GL_NEAREST</code>。这段代码是必需的，因为我们还没有为纹理加载完整的mip贴图链；因此，必须选择非mip贴图缩小过滤器。用于缩小和放大模式的其他选项是<code>GL_LINEAR</code>，提供双线性非mip贴图过滤。</p>\n<h2>纹理过滤和mip贴图</h2>\n<p>到目前为止，我们对2D纹理的介绍仅限于单个2D图像。尽管这使得我们能够解释纹理的概念，但是OpenGL ES中纹理的指定和使用还有一些其他的方法。这种复杂性与使用单个纹理贴图时发生的视觉伪像和性能问题有关。正如我们到目前为止所描述的那样，纹理坐标用于生成一个2D索引，以从纹理贴图中读取。当缩小和放大过滤器设置为<code>GL_NEAREST</code>时，就会发生这样的情况：一个纹素将在提供的纹理坐标位置上读取。这称作点采样或者最近采样。<br>\n但是，最近采样可能产生严重的视觉伪像，这是因为三角形在屏幕空间中变得较小，在不同像素间的插值中，纹理坐标有很大的跳跃。结果是，从一个大的纹理贴图中去的少量样本，造成锯齿伪像，而且可能造成巨大性能损失。OpenGL ES中解决这类伪像的方案被称作mip贴图（mipmapping）。mip贴图的思路是构建一个图像链–mip贴图链。mip贴图链始于原来指定的图像，后续的每个图像在每个维度上是前一个图像的一半，一直持续到最后达到链底部的1x1纹理。mip贴图级别可以编程生成，一个mip级别中的每个像素通常根据上一级别中相同位置的4个像素的平均值计算（盒式过滤）。<br>\n<a href=\"https://github.com/danginsburg/opengles3-book/blob/master/Chapter_9/MipMap2D/MipMap2D.c\" target=\"_blank\" rel=\"noopener\">GenMipMap2D</a>函数提供了生成mip贴图链的代码。这个函数以一个RGB8图形作为输入，在前面的图像上执行盒式过滤，生成下一个mip贴图级别。mip贴图链用<code>glTexImage2D</code>加载。<br>\n加载mip贴图链之后，便可以设置过滤模式，以使用mip贴图。结果是我们实现了屏幕像素和纹理像素间的更好比率，从而减少了锯齿伪像。图像的锯齿也减少了，这是因为mip贴图链中的每个图像连续进行过滤，使得高频元素随着贴图链的下移越来越少。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">glTexImage2D(GL_TEXTURE_2D, <span class=\"number\">0</span>, GL_RGB, width, height, <span class=\"number\">0</span>, GL_RGB, GL_UNSIGNED_BYTE, pixels);</span><br><span class=\"line\"><span class=\"keyword\">int</span> level = <span class=\"number\">1</span>;</span><br><span class=\"line\">GLubyte *prevImage = &amp;pixels[<span class=\"number\">0</span>];</span><br><span class=\"line\">GLubyte *newImage;</span><br><span class=\"line\"><span class=\"keyword\">while</span> (width &gt; <span class=\"number\">1</span> &amp;&amp; height &gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> newWidth, newHeight;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// Generate the next mipmap level</span></span><br><span class=\"line\">    GenMipMap2D(prevImage, &amp;newImage, width, height, &amp;newWidth, &amp;newHeight);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// Load the mipmap level</span></span><br><span class=\"line\">    glTexImage2D(GL_TEXTURE_2D, level, GL_RGB, newWidth, newHeight, <span class=\"number\">0</span>, GL_RGB, GL_UNSIGNED_BYTE, newImage);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// Free the previous image</span></span><br><span class=\"line\">    free(prevImage);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// Set the previous image for the next iteration</span></span><br><span class=\"line\">    prevImage = newImage;</span><br><span class=\"line\">    level += <span class=\"number\">1</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// Half the width and height</span></span><br><span class=\"line\">    width = newWidth;</span><br><span class=\"line\">    height = newHeight;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">free(newImage);</span><br></pre></td></tr></table></figure>\n<p>纹理渲染时发生两种过滤：缩小和放大。缩小发生在屏幕上投影的多边形小于纹理尺寸的时候。放大发生在屏幕上投影的多边形大于纹理尺寸的时候。过滤器类型的确定由硬件自动处理，但是API提供了对每种情况下使用的过滤类型的控制。对于放大，mip贴图不起作用，因为我们总是从最大的可用级别采样。对于缩小，可以使用不同的采样模式。所用模式的选择基于你需要实现的显示质量水平以及为了纹理过滤损失多少性能。<br>\n过滤模式（和许多其他纹理选项）用<code>glTexParameter[i|f][v]</code>指定。接下来描述纹理过滤模式。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">glTexParameteri(GLenum target, GLenum pname, GLint param)</span><br><span class=\"line\">glTexParameteriv(GLenum target, GLenum pname, <span class=\"keyword\">const</span> GLint *params);</span><br><span class=\"line\">glTexParameterf(GLenum target, GLenum pname, GLfloat param);</span><br><span class=\"line\">glTexParameterfv(GLenum target, GLenum pname, <span class=\"keyword\">const</span> GLfloat *params);</span><br></pre></td></tr></table></figure>\n<p><code>pname</code>为<code>GL_TEXTURE_MAG_FILTER</code>放大过滤器时，<code>param</code>可能是<code>GL_NEAREST</code>或<code>GL_LINEAR</code>。在<code>GL_NEAREST</code>放大过滤中，将从最靠近纹理坐标的纹理中取得单点样本。在<code>GL_LINEAR</code>放大过滤中，将从纹理坐标附近的纹理中取得一个双线性样本（4个样本的平均值）。<br>\n<code>pname</code>为<code>GL_TEXTURE_MIN_FILTER</code>缩小过滤器时，<code>param</code>可以设置为如下值的任意一个：</p>\n<ul>\n<li><code>GL_NEAREST</code> – 从最靠近纹理坐标的纹理中获得一个单点样本。</li>\n<li><code>GL_LINEAR</code> – 从最靠近纹理坐标的纹理中获得一个双线性样本。</li>\n<li><code>GL_NEAREST_MIPMAP_NEAREST</code> – 从所选的最近的mip级别中去的单点样本。</li>\n<li><code>GL_NEAREST_MIPMAP_LINEAR</code> – 从两个最近的mip级别中获得样本，并在这些样本之间插值。</li>\n<li><code>GL_LINEAR_MIPMAP_NEAREST</code> – 从所选的最近mip级别中获得双线性样本。</li>\n<li><code>GL_LINEAR_MIPMAP_LINEAR</code> – 从两个最近的mip级别中获得双线性样本，然后在它们之间插值。这种模式通常被称作三线性过滤，产生所有模式中最佳的质量。</li>\n</ul>\n<blockquote>\n<p>在纹理缩小模式中，只要<code>GL_NEAREST</code>和<code>GL_LINEAR</code>不需要为纹理指定完整的mip贴图链。其他所有模式都要求纹理存在完整的mip贴图链。</p>\n</blockquote>\n<p>选择的纹理过滤模式对性能有一定的影响。如果发生缩小且担心性能，那么使用mip贴图过滤模式通常是大部分硬件上的最佳选择。如果没有mip贴图，则纹理缓存利用率可能非常低，因为读取发生在贴图的少数位置。然而，你选择的过滤模式较高，在硬件中的性能代价就越大。例如，在大部分硬件上，进行双线性过滤的代价低于三线性过滤。我们应该选择一种可以提供所要的质量但是不会对性能有过分负面影响的模式。在某些硬件上，你可能轻松地获得高质量的过滤，特别是在纹理过滤带来的开销不是我们的瓶颈时。这需要在应用程序和计划运行应用程序的硬件上进行调整。</p>\n<h3>无缝立方图过滤</h3>\n<p>关于过滤，OpenGL ES 3.0中有一个新变化，与立方图的过滤有关。在OpenGL ES 2.0中，当线性过滤核心落到立方图边缘时，过滤将只发生在立方图的一个面上。这将在立方图各面之间的边上造成伪像。在OpenGL ES 3.0中，立方图过滤现在是无缝的–如果过滤核心跨越立方图不止一个面，核心将会从其覆盖的每个面中获得样本。无缝过滤在立方图各面的边缘形成了更平滑的过滤。在OpenGL ES 3.0中，不需要做任何操作就可以启用无缝立方图过滤，所有线性过滤核心将自动使用它。</p>\n<h2>自动mip贴图生成</h2>\n<p>前一节讲述了生成mip贴图的一种途径，但是OpenGL ES 3.0还提供了用<code>glGenerateMipmap</code>自动生成mip贴图的机制。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 自动生成mip贴图</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param target#&gt; 为之生成mip贴图的纹理目标；可以是GL_TEXTURE_2D、GL_TEXTURE_3D、GL_TEXTURE_2D_ARRAY或GL_TEXTURE_CUBE_MAP description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glGenerateMipmap(GLenum target);</span><br></pre></td></tr></table></figure>\n<p>在绑定的纹理对象上调用<code>glGenerateMipmap</code>时，这个函数将从0级图像的内容生成整个mip贴图链。对于2D纹理，0级纹理内容将持续地被过滤并用于每个后续级别。对于立方图，立方体的每一面都由各面的0级生成。当然，要将这个函数用于立方图，必须为立方体的每个面指定0级，每个面的内部格式、宽度和高度都必须匹配。对于2D纹理数组，数组的每个切片将进行与2D纹理一样的过滤。最后，对于3D纹理，将通过过滤各个切片生成全体的mip贴图。<br>\nOpenGL ES 3.0不强制用于生成mip贴图的特定过滤算法（但是规范中推荐盒式过滤，各种实现可以自由地选择他们使用的算法）。如果需要特定的过滤方法，就必须自己生成mip贴图。<br>\n在开始使用帧缓冲区对象渲染纹理时，自动化mip贴图生成变得特别重要。当渲染到一个纹理时，我们不希望将纹理的内容读回CPU来生成mip贴图，相反，可以使用<code>glGenerateMipmap</code>和图形硬件，然后在不需要将数据读回CPU的情况下生成mip贴图。</p>\n<h2>纹理坐标包装</h2>\n<p>纹理包装模式用于指定纹理坐标超出[0.0, 1.0]范围时所发生的行为，用<code>glTexParameter[i|f][v]</code>设置。这些模式可以为s、t、r坐标单独设置。<code>GL_TEXTURE_WRAP_S</code>模式定义s坐标超出[0.0, 1.0]范围时发生的行为，<code>GL_TEXTURE_WRAP_T</code>设置t坐标的行为，<code>GL_TEXTURE_WRAP_R</code>设置r坐标的行为（r坐标包装仅用于3D纹理和2D纹理数组）。在OpenGL ES中有三个包装模式可供选择，如下表：</p>\n<table>\n<thead>\n<tr>\n<th>纹理包装模式</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>GL_REPEAT</td>\n<td>重复纹理</td>\n</tr>\n<tr>\n<td>GL_CLAMP_TO_EDGE</td>\n<td>限定读取纹理的边缘</td>\n</tr>\n<tr>\n<td>GL_MIRRORED_REPEAT</td>\n<td>重复纹理和镜像</td>\n</tr>\n</tbody>\n</table>\n<p>注意，纹理包装模式也影响过滤行为。例如，当纹理坐标在纹理的边缘时，线性过滤核心可能跨越纹理的边缘。在这种情况下，包装模式将决定对于核心在纹理边缘之外的部分要读取哪些纹素。在不希望出现任何形式的重复时，应该使用<code>GL_CLAMP_TO_DEGE</code>。</p>\n<h2>纹理调配</h2>\n<p>纹理调配（Swizzle）控制输入的R、RG、RGB或RGBA纹理中的颜色分量在着色器中读取时如何映射到分量。例如，应用程序可能希望一个<code>GL_RED</code>纹理映射为(0, 0, 0, R)或者(R, R, R, 1)而不是默认的(R, 0, 0, 1)。每个R、G、B、A值映射到的纹理分量都可以用<code>glTexParameter[i|f][v]</code>设置的纹理调配单独控制。需要控制的分量用<code>GL_TEXTURE_SWIZZLE_R</code>、<code>GL_TEXTURE_SWIZZLE_G</code>、<code>GL_TEXTURE_SWIZZLE_B</code>或<code>GL_TEXTURE_SWIZZLE_A</code>设置。作为该分量纹理值来源的可能是分别从R、G、B、A分量读取的<code>GL_RED</code>、<code>GL_GREEN</code>、<code>GL_BLUE</code>或<code>GL_ALPHA</code>。此外，应用程序可以分别用<code>GL_ZERO</code>或<code>GL_ONE</code>将该值设置为常数0或者1。</p>\n<h2>纹理细节级别</h2>\n<p>在某些应用中，在所有纹理mip贴图级别可用之前就能够开始显示场景是很实用的。例如，通过数据连接下载纹理图像的GPS应用可以从最低级别的mip贴图开始，在更高级别可用时再显示它们。在OpenGL ES 3.0中，可以通过使用<code>glTexParameter[i|f][v]</code>的多个参数实现。<code>GL_TEXTURE_BASE_LEVEL</code>设置用于纹理的最大mip贴图级别。默认情况下下，该值为0，但是如果mip贴图级别还不可用，则可以设置为更高的值。同样，<code>GL_TEXTURE_MAX_LEVEL</code>设置使用的最小mip贴图级别。默认情况下，它的值为1000（超过了任何纹理可能具备的最大级别），但是可以将其设置为较小的值，以控制用于纹理的最小mip级别。<br>\n为了选择要用于渲染的mip贴图级别，OpenGL ES自动计算一个细节级别（LOD）值。这个浮点值确定从哪一个mip贴图级别过滤（在三线性过滤中，控制每个mip贴图使用的多少）。应用程序还可以用<code>GL_TEXTURE_MIN_LOD</code>和<code>GL_TEXTURE_MAX_LOD</code>控制最小和最大的LOD值。可以从基本和最大mip贴图级别单独控制LOD限制的一个原因是在新的mip贴图级别可用时提供平滑过渡。仅仅设置纹理的基本和最大级别可能在新mip贴图级别可用时造成间歇伪像，而插入LOD可以使这一过渡看起来更平滑。</p>\n<h2>深度纹理对比（百分比渐进过滤）</h2>\n<p>最后两个纹理参数是<code>GL_TEXTURE_COMPARE_FUNC</code>和<code>GL_TEXTURE_COMPARE_MODE</code>。引入这些纹理参数是为了提供百分比渐进过滤（PCF）功能。在执行被称作阴影贴图的阴影技术时，片段着色器需要比较一个片段的当前深度值和深度纹理中的深度值，以确定片段在阴影之内还是之外。为了实现平滑的阴影边缘效果，对深度纹理进行双线性过滤是很有用的。但是，在过滤深度值时，我们希望过滤在采样深度值并与当前深度（或参考值）比较之后发生。如果过滤在比较之前发生，我们将平均计算深度纹理中的值，这不能提供正确的结果。PCF提供了正确的过滤，将采样的每个深度值与参考深度比较，然后将这些比较的结果（0或者1）一起进行平均。<br>\n<code>GL_TEXTURE_COMPARE_MODE</code>默认为<code>GL_NONE</code>，但是当它被设置为<code>GL_COMPARE_REF_TO_TEXTURE</code>时，(s, t, r)纹理坐标中的r坐标将与深度纹理的值进行比较。然后，比较的结果将成为阴影纹理读取的结果（可能是9或者1，如果启用纹理过滤，则为这些值的平均）。比较函数用<code>GL_TEXTURE_COMPARE_FUNC</code>设置，可以设置为<code>GL_LEQUAL</code>、<code>GL_GEQUAL</code>、<code>GL_LESS</code>、<code>GL_GREATER</code>、<code>GL_EQUAL</code>、<code>GL_NOTEQUAL</code>、<code>GL_ALWAYS</code>或者<code>GL_NEVER</code>。</p>\n<h2>纹理格式</h2>\n<p>OpenGL ES 3.0为纹理提供了广泛的数据格式，格式的数量比OpenGL ES 2.0有了很大的增加。<br>\n2D纹理可以以确定大小或者确定大小的内部格式用<code>glTexImage2D</code>上传。如果纹理用未确定大小的格式指定，则OpenGL ES实现可以自由选择纹理数据存储的内部表现形式。如果纹理用确定大小的格式指定，则OpenGL ES实现将选择至少与指定的位数相同的格式。</p>\n<p><code>glTexImage2D</code>的有效的未确定大小内部格式组合：</p>\n<table>\n<thead>\n<tr>\n<th>内部格式</th>\n<th>格式</th>\n<th>类型</th>\n<th>输入数据</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>GL_RGB</td>\n<td>GL_RGB</td>\n<td>GL_UNSIGNED_BYTE</td>\n<td>8/8/8 RGB 24- 位</td>\n</tr>\n<tr>\n<td>GL_RGB</td>\n<td>GL_RGB</td>\n<td>GL_UNSIGNED_SHORT_5_6_5</td>\n<td>5/6/5 RGB 16- 位</td>\n</tr>\n<tr>\n<td>GL_RGBA</td>\n<td>GL_RGBA</td>\n<td>GL_UNSIGNED_BYTE</td>\n<td>8/8/8/8 RGBA 32- 位</td>\n</tr>\n<tr>\n<td>GL_RGBA</td>\n<td>GL_RGBA</td>\n<td>GL_UNSIGNED_SHORT_4_4_4_4</td>\n<td>4/4/4/4 RGBA 16- 位</td>\n</tr>\n<tr>\n<td>GL_RGBA</td>\n<td>GL_RGBA</td>\n<td>GL_UNSIGNED_SHORT_5_5_5_1</td>\n<td>5/5/5/1 RGBA 16- 位</td>\n</tr>\n<tr>\n<td>GL_LUMINANCE_ALPHA</td>\n<td>GL_LUMINANCE_ALPHA</td>\n<td>GL_UNSIGNED_BYTE</td>\n<td>8/8 LA 16- 位</td>\n</tr>\n<tr>\n<td>GL_LUMINANCE</td>\n<td>GL_LUMINANCE</td>\n<td>GL_UNSIGNED_BYTE</td>\n<td>8L 8- 位</td>\n</tr>\n<tr>\n<td>GL_ALPHA</td>\n<td>GL_ALPHA</td>\n<td>GL_UNSIGNED_BYTE</td>\n<td>8A 8- 位</td>\n</tr>\n</tbody>\n</table>\n<p>如果应用程序希望更多地控制数据的内部存储方式，那么它可以使用确定大小的内部格式。</p>\n<h3>规范化纹理格式</h3>\n<p>我们所说的”规范化“指的是从片段着色器中读取纹理时，结果将处于[0.0, 1.0]范围内（或者在*_SNORM格式中的[-1.0, 1.0]范围）。例如，用<code>GL_UNSIGNED_BYTE</code>数据指定的<code>GL_R8</code>图像将取得每个8位的无符号字节值(范围为[0, 255])，并在片段着色器读取时映射到[0.0, 1.0]。用<code>GL_BYTE</code>数据指定的<code>GL_R8_SNORM</code>图像将取得每个8位的有符号字节值（范围为[-128, 127]）并在读取时映射到[-1.0, 1.0]。</p>\n<p><img src=\"/img/article/20190810/4.png\" alt=\"glTexImage2D的规范化确定大小内部格式组合\"></p>\n<h3>浮点纹理格式</h3>\n<p>OpenGL ES 3.0也引入浮点纹理格式。大部分浮点格式由16位半浮点数据或者32位浮点数据支持。与规范化纹理格式（R、RG、RGB、RGBA）一样，浮点纹理格式可能有1~4个分量。OpenGL ES 3.0不强制浮点格式用作渲染目标，只强制16位半浮点数据可以过滤。</p>\n<p><img src=\"/img/article/20190810/5.png\" alt=\"glTexImage2D的有效确定大小浮点内部格式组合\"></p>\n<h3>整数纹理格式</h3>\n<p>整数纹理格式允许纹理范围在片段着色器中以整数形式读取。也就是说，与片段着色器中读取时数据从整数表示转换为规范化浮点值的规范化纹理格式相反，整数纹理中的值在片段着色器读取时仍然为整数。<br>\n整数纹理格式不可过滤，但是R、RG和RGBA变种可以用作帧缓冲区对象中渲染的颜色附着（color attachment）。使用整数纹理作为颜色附着的时候，忽略Alpha混合状态（整数渲染目标不可能进行混合）。用于从整数纹理读取并输出到整数渲染目标的片段着色器应该使用对应该格式的有符号或者无符号整数类型。</p>\n<p><img src=\"/img/article/20190810/6.png\" alt=\"glTexImage2D的有效确定大小内部整数格式组合\"><br>\n<img src=\"/img/article/20190810/7.png\" alt=\"glTexImage2D的有效确定大小内部整数格式组合\"></p>\n<h3>共享指数纹理格式</h3>\n<p>共享指数纹理为不需要浮点纹理使用的那么多深度位数的大范围RGB纹理提供了一种存储方式。共享指数纹理通常用于高动态范围（HDR）图像，这种图像不需要半浮点或者全浮点数据。OpenGL ES 3.0中的共享指数纹理格式是<code>GL_RGB9_E5</code>。在这种格式中，3个RGB分量共享一个5位的指数。5位的指数隐含地由数值15调整。RGB的每个9位的数值存储无符号位的尾数（因此必然为正）。</p>\n<p><img src=\"/img/article/20190810/8.png\" alt=\"共享指数纹理转换\"></p>\n<h3>sRGB纹理格式</h3>\n<p>OpenGL ES 3.0中引入的另一个纹理格式是sRGB纹理。sRGB是一个非线性颜色空间，大约遵循一个幂函数。大部分图像实际上都存储为sRGB颜色空间，这种非线性解释了人类能够在不同的亮度级别上更好地区分颜色这一事实。<br>\n如果用于纹理的图像是以sRGB颜色空间创作的，但是没有使用sRGB纹理读取，那么所有发生在着色器中的照明计算都会在非线性颜色空间中进行。也就是说，标准创作软件包创建的纹理保存为sRGB，从着色器中读取时仍然保持为sRGB。于是照明计算发生在非线性sRGB空间中。许多应用程序都犯了这个错误，这是不正确的，会造成明显不同（不准确）的输出图像。<br>\n为了正确地处理sRGB图像，应用程序应该使用一个sRGB纹理格式，这种格式在着色器中读取时将从sRGB转换为线性颜色空间。然后，着色器中的所有计算都将在线性颜色空间中完成。最后，通过渲染到一个sRGB渲染目标，图像将会自动地转换回sRGB。可以使用着色器命令<code>pow(value, 2.0)</code>进行近似的sRGB-&gt;线性转换，然后用<code>(value, 1/2.2)</code>进行近似的线性-&gt;sRGB转换。然后，尽可能使用sRGB纹理是最好的做法，因为这样减少了着色器指令数量，并且提供更准确的sRGB转换。</p>\n<table>\n<thead>\n<tr>\n<th>内部格式</th>\n<th>格式</th>\n<th>类型</th>\n<th>输出数据</th>\n<th>R</th>\n<th>F</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>GL_SRGB8</td>\n<td>GL_RGB</td>\n<td>GL_UNSIGNED_BYTE</td>\n<td>8/8/8 SRGB</td>\n<td></td>\n<td>X</td>\n</tr>\n<tr>\n<td>GL_SRGB8_ALPHA8</td>\n<td>GL_RGBA</td>\n<td>GL_UNSIGNED_BYTE</td>\n<td>8/8/8/8 RGBA</td>\n<td>X</td>\n<td>X</td>\n</tr>\n</tbody>\n</table>\n<h3>深度纹理格式</h3>\n<p>OpenGL ES 3.0中的最后一种纹理格式类型是深度纹理。深度纹理允许应用程序从帧缓冲区对象的深度附着中读取深度值（和可选的模板值）。这在各种高级渲染算法中很有用，包括阴影贴图。下表展示了OpenGL ES 3.0中有效的深度纹理格式：</p>\n<table>\n<thead>\n<tr>\n<th>内部格式</th>\n<th>格式</th>\n<th>类型</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>GL_DEPTH_COMPONENT16</td>\n<td>GL_DEPTH_COMPONENT</td>\n<td>GL_UNSIGNED_SHORT</td>\n</tr>\n<tr>\n<td>GL_DEPTH_COMPONENT16</td>\n<td>GL_DEPTH_COMPONENT</td>\n<td>GL_UNSIGNED_INTp</td>\n</tr>\n<tr>\n<td>GL_DEPTH_COMPONENT24</td>\n<td>GL_DEPTH_COMPONENT</td>\n<td>GL_UNSIGNED_INT</td>\n</tr>\n<tr>\n<td>GL_DEPTH_COMPONENT43F</td>\n<td>GL_DEPTH_COMPONENT</td>\n<td>GL_FLOAT</td>\n</tr>\n<tr>\n<td>GL_DEPTH24_STENCIL8</td>\n<td>GL_DEPTH_STENCIL</td>\n<td>GL_UNSIGNED_INT_24_8</td>\n</tr>\n<tr>\n<td>GL_DEPTH32F_STENCIL8</td>\n<td>GL_DEPTH_STENCIL</td>\n<td>GL_FLOAT_32_UNSIGNED_INT_24_8_REV</td>\n</tr>\n</tbody>\n</table>\n<h2>在着色器中使用纹理</h2>\n<p>下面代码简要演示在着色器中完成2D纹理的基本过程：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Vertex shader</span></span><br><span class=\"line\"><span class=\"meta\"># version 300 es</span></span><br><span class=\"line\">layout(location = <span class=\"number\">0</span>) <span class=\"keyword\">in</span> vec4 a_position;</span><br><span class=\"line\">layout(location = <span class=\"number\">1</span>) <span class=\"keyword\">in</span> vec2 a_texCoord;</span><br><span class=\"line\"><span class=\"keyword\">out</span> vec2 v_texCoord;</span><br><span class=\"line\"><span class=\"keyword\">void</span> main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    gl_Position = a_position;</span><br><span class=\"line\">    v_texCoord = a_texCoord;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Fragment shader</span></span><br><span class=\"line\"><span class=\"meta\"># version 300 es</span></span><br><span class=\"line\">precision mediump <span class=\"keyword\">float</span>;</span><br><span class=\"line\"><span class=\"keyword\">in</span> vec2 v_texCoord;</span><br><span class=\"line\">layout(location = <span class=\"number\">0</span>) <span class=\"keyword\">out</span> vec4 outColor;</span><br><span class=\"line\">uniform sampler2D s_texture;</span><br><span class=\"line\"><span class=\"keyword\">void</span> main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    outColor = texture(s_texture, v_texCoord);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>顶点着色器以一个二分量纹理坐标作为顶点输入，并将其作为输出传递给片段着色器。片段着色器消费该纹理坐标，并将其用于纹理读取。片段着色器声明一个类型为<code>sampler2D</code>的统一变量<code>s_texture</code>。采样器是用于从纹理贴图中读取的特殊统一变量。采样器统一变量将加载一个指定纹理绑定的纹理单元的数值；例如，用数值0指定采样器表示从单元<code>GL_TEXTURE0</code>读取，指定数值1表示从<code>GL_TEXTURE1</code>读取，一次类推。在OpenGL ES 3.0 API中，纹理用<code>glActiveTexture</code>函数绑定到纹理单元。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 绑定纹理单元</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param texture#&gt; 需要激活的纹理单元：GL_TEXTURE0, 1, 2 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glActiveTexture(GLenum texture);</span><br></pre></td></tr></table></figure>\n<p><code>glActiveTexture</code>函数设置当前纹理单元，以便后续的<code>glBindTexture</code>调用将纹理绑定到当前活动单元。在OpenGL ES实现上可用于片段着色器的纹理单元数量可以用<code>GL_MAX_TEXTURE_IMAGE_UNITS</code>参数的<code>glGetintegerv</code>查询。可用于顶点着色器的纹理单元数量使用带<code>GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS</code>参数的<code>glGetintegerv</code>查询。</p>\n<p>当使用<code>glBindTexture</code>绑定为并使用<code>glUniformli</code>加载纹理后，可以看到片段着色器中使用内建函数<code>texture</code>从纹理贴图出读取。<code>texture</code>内建函数形式如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 绑定2D纹理单元</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param sampler#&gt; 绑定到纹理单元的采样器，指定纹理为读取来源 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param coord#&gt; 用于从纹理贴图中读取的2D纹理坐标 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param bias#&gt; 可选参数，提供用于纹理读取的mip贴图偏置。这允许着色器明确地偏置用于mip忒土选择的LOD计算值 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return vec4 纹理</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">texture(sampler2D sampler, vec2 coord[, <span class=\"keyword\">float</span> bias]);</span><br></pre></td></tr></table></figure>\n<p><code>texture</code>函数返回一个代表从纹理贴图中读取颜色的<code>vec4</code>。纹理数据映射到这个颜色通道的方式取决于纹理的基本格式。下表展示了纹理格式映射到<code>vec4</code>颜色的方式，<a href=\"/article/2019/opengl-es-texture-0810/#%E7%BA%B9%E7%90%86%E8%B0%83%E9%85%8D\">纹理调配</a>确定这些分量中的值如何映射到着色器中的分量。</p>\n<table>\n<thead>\n<tr>\n<th>基本格式</th>\n<th>纹素数据描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>GL_RED</td>\n<td>(R, 0.0 0.0, 1.0)</td>\n</tr>\n<tr>\n<td>GL_RG</td>\n<td>(R, G, 0.0, 1.0)</td>\n</tr>\n<tr>\n<td>GL_RGB</td>\n<td>(R, G, B, 1.0)</td>\n</tr>\n<tr>\n<td>GL_RGBA</td>\n<td>(R, G, B, A)</td>\n</tr>\n<tr>\n<td>GL_LUMINANCE</td>\n<td>(L, L, L, 1.0)</td>\n</tr>\n<tr>\n<td>GL_LUMINANCE_ALPHA</td>\n<td>(L, L, L, A)</td>\n</tr>\n<tr>\n<td>GL_ALPHA</td>\n<td>(0.0, 0.0, 0.0, A)</td>\n</tr>\n</tbody>\n</table>\n<p>下面看具体示例：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)setupVertices &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    GLfloat vertices[] = &#123;</span><br><span class=\"line\">        <span class=\"number\">-1.0</span>, <span class=\"number\">-1.0</span>, <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"number\">0</span>, <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"number\">-1.0</span>, <span class=\"number\">1.0</span>, <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"number\">0</span>, <span class=\"number\">1</span>,</span><br><span class=\"line\">        <span class=\"number\">1.0</span>, <span class=\"number\">-1.0</span>, <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"number\">1</span>, <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"number\">1.0</span>, <span class=\"number\">1.0</span>, <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"number\">1</span>, <span class=\"number\">1</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 生成纹理</span></span><br><span class=\"line\">    GLuint texture = [<span class=\"keyword\">self</span> createTextureWithImage:[<span class=\"built_in\">UIImage</span> imageNamed:<span class=\"string\">@\"9\"</span>]];</span><br><span class=\"line\">    </span><br><span class=\"line\">    GLuint program = [<span class=\"keyword\">self</span> createProgram];</span><br><span class=\"line\">    glUseProgram(program);</span><br><span class=\"line\">    glViewport(<span class=\"number\">0</span>, <span class=\"number\">0</span>, [<span class=\"keyword\">self</span> getViewportWidth], [<span class=\"keyword\">self</span> getViewportHeight]);</span><br><span class=\"line\">    </span><br><span class=\"line\">    glClear(GL_COLOR_BUFFER_BIT);</span><br><span class=\"line\">    glClearColor(<span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 加载纹理</span></span><br><span class=\"line\">    glActiveTexture(GL_TEXTURE0);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> textureLocation = glGetUniformLocation(program, <span class=\"string\">\"s_texture\"</span>);</span><br><span class=\"line\">    glBindTexture(GL_TEXTURE_2D, texture);</span><br><span class=\"line\">    glUniform1i(textureLocation, <span class=\"number\">0</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    GLuint vbo;</span><br><span class=\"line\">    glGenBuffers(<span class=\"number\">1</span>, &amp;vbo);</span><br><span class=\"line\">    glBindBuffer(GL_ARRAY_BUFFER, vbo);</span><br><span class=\"line\">    glBufferData(GL_ARRAY_BUFFER, <span class=\"keyword\">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class=\"line\">    </span><br><span class=\"line\">    glEnableVertexAttribArray(<span class=\"number\">0</span>);</span><br><span class=\"line\">    glVertexAttribPointer(<span class=\"number\">0</span>, <span class=\"number\">3</span>, GL_FLOAT, GL_FALSE, <span class=\"keyword\">sizeof</span>(GLfloat)*<span class=\"number\">5</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    glEnableVertexAttribArray(<span class=\"number\">1</span>);</span><br><span class=\"line\">    glVertexAttribPointer(<span class=\"number\">1</span>, <span class=\"number\">2</span>, GL_FLOAT, GL_FALSE, <span class=\"keyword\">sizeof</span>(GLfloat)*<span class=\"number\">5</span>, (GLvoid *)(<span class=\"keyword\">sizeof</span>(GLfloat)*<span class=\"number\">3</span>));</span><br><span class=\"line\">    </span><br><span class=\"line\">    glDrawArrays(GL_TRIANGLE_STRIP, <span class=\"number\">0</span>, <span class=\"number\">4</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.context presentRenderbuffer:GL_RENDERBUFFER];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">- (GLuint)createTextureWithImage:(<span class=\"built_in\">UIImage</span> *)image &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 将 UIImage 转换为 CGImageRef</span></span><br><span class=\"line\">    <span class=\"built_in\">CGImageRef</span> cgImageRef = [image <span class=\"built_in\">CGImage</span>];</span><br><span class=\"line\">    GLuint width = (GLuint)<span class=\"built_in\">CGImageGetWidth</span>(cgImageRef);</span><br><span class=\"line\">    GLuint height = (GLuint)<span class=\"built_in\">CGImageGetHeight</span>(cgImageRef);</span><br><span class=\"line\">    <span class=\"built_in\">CGRect</span> rect = <span class=\"built_in\">CGRectMake</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, width, height);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 绘制图片</span></span><br><span class=\"line\">    <span class=\"built_in\">CGColorSpaceRef</span> colorSpace = <span class=\"built_in\">CGColorSpaceCreateDeviceRGB</span>();</span><br><span class=\"line\">    <span class=\"comment\">// 获取图片字节数 宽x高x4（RGBA）</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *imageData = malloc(width * height * <span class=\"number\">4</span>);</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     创建上下文</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">     @param data#&gt; 指向要渲染的绘制图像的内存地址 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     @param width#&gt; 图像宽度，单位为像素 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     @param height#&gt; 图像高度，单位为像素 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     @param bitsPerComponent#&gt; 内存中像素的每个组件的位数，比如32位RGBA，就设置为8 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     @param bytesPerRow#&gt; 每一行内存所占的bit数 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     @param space#&gt; 使用的颜色空间 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     @param bitmapInfo#&gt; bitmap信息 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     @return 返回上下文</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"built_in\">CGContextRef</span> context = <span class=\"built_in\">CGBitmapContextCreate</span>(imageData, width, height, <span class=\"number\">8</span>, width * <span class=\"number\">4</span>, colorSpace, kCGImageAlphaPremultipliedLast | kCGBitmapByteOrder32Big);</span><br><span class=\"line\">    <span class=\"comment\">// 图片正向-否则绘制出来的图片是颠倒的</span></span><br><span class=\"line\">    <span class=\"built_in\">CGContextTranslateCTM</span>(context, <span class=\"number\">0</span>, height);</span><br><span class=\"line\">    <span class=\"built_in\">CGContextScaleCTM</span>(context, <span class=\"number\">1.0</span>f, <span class=\"number\">-1.0</span>f);</span><br><span class=\"line\">    <span class=\"built_in\">CGColorSpaceRelease</span>(colorSpace);</span><br><span class=\"line\">    <span class=\"built_in\">CGContextClearRect</span>(context, rect);</span><br><span class=\"line\">    <span class=\"built_in\">CGContextDrawImage</span>(context, rect, cgImageRef);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 生成纹理</span></span><br><span class=\"line\">    GLuint textureID;</span><br><span class=\"line\">    glGenTextures(<span class=\"number\">1</span>, &amp;textureID);</span><br><span class=\"line\">    glBindTexture(GL_TEXTURE_2D, textureID);</span><br><span class=\"line\">    glTexImage2D(GL_TEXTURE_2D, <span class=\"number\">0</span>, GL_RGBA, width, height, <span class=\"number\">0</span>, GL_RGBA, GL_UNSIGNED_BYTE, imageData); <span class=\"comment\">// 将图片数据写入纹理缓存</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 设置如何把纹素映射成像素</span></span><br><span class=\"line\">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);</span><br><span class=\"line\">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);</span><br><span class=\"line\">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class=\"line\">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 解绑</span></span><br><span class=\"line\">    glBindTexture(GL_TEXTURE_2D, <span class=\"number\">0</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 释放内存</span></span><br><span class=\"line\">    <span class=\"built_in\">CGContextRelease</span>(context);</span><br><span class=\"line\">    free(imageData);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> textureID;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2>使用立方图纹理的示例</h2>\n<p>立方图纹理的使用非常类似于2D纹理。通过对立方图的各面（<code>GL_TEXTURE_CUBE_MAP_POSITIVE_(X|Y|Z)</code>，<code>GL_TEXTURE_CUBE_NEGATIVE_(X|Y|Z)</code>）调用<code>glTexImage2D</code>加载每个面的像素数据。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Vertex shader</span></span><br><span class=\"line\"><span class=\"meta\">#version 300 es</span></span><br><span class=\"line\">layout(location = <span class=\"number\">0</span>) <span class=\"keyword\">in</span> vec4 a_position;</span><br><span class=\"line\">layout(location = <span class=\"number\">1</span>) <span class=\"keyword\">in</span> vec3 a_normal;</span><br><span class=\"line\"><span class=\"keyword\">out</span> vec3 v_normal;</span><br><span class=\"line\"><span class=\"keyword\">void</span> mian()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    gl_Position = a_position;</span><br><span class=\"line\">    v_normal = a_normal;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Fragment shader</span></span><br><span class=\"line\"><span class=\"meta\">#version 300 es</span></span><br><span class=\"line\">precision mediump <span class=\"keyword\">float</span>;</span><br><span class=\"line\"><span class=\"keyword\">in</span> vec3 v_normal;</span><br><span class=\"line\">layout(location = <span class=\"number\">0</span>) <span class=\"keyword\">out</span> vec4 outColor;</span><br><span class=\"line\">uniform samplerCube s_texture;</span><br><span class=\"line\"><span class=\"keyword\">void</span> main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    outColor = texture(s_texture, v_normal);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>顶点着色器取得一个位置和法线作为顶点输入。发现保存在球面的每个顶点上，用作纹理坐标，并传递给片段着色器。然后，片段着色器使用内建函数<code>texture</code>，以法线作为纹理坐标从立方图中读取。立方图所用的<code>texture</code>内建函数采用如下形式：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 绑定立方图纹理单元</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param sampler#&gt; 绑定到纹理单元的采样器，指定纹理为读取来源 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param coord#&gt; 用于从纹理贴图中读取的3D纹理坐标 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param bias#&gt; 可选参数，提供用于纹理读取的mip贴图偏置。这允许着色器明确地偏置用于mip忒土选择的LOD计算值 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return vec4 纹理</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">texture(samplerCube sampler, vec3 coord[, <span class=\"keyword\">float</span> bias]);</span><br></pre></td></tr></table></figure>\n<p>读取立方图的函数与2D纹理非常类似。仅有的区别是，纹理坐标有3个分量而不是2个分量，采样器类型必须为<code>sampleCube</code>。用于绑定立方图纹理和加载采样器的方法与之前2D纹理加载一样。</p>\n<h2>加载3D纹理和2D纹理数组</h2>\n<p>除了2D纹理和立方图，OpenGL ES 3.0还包含了3D纹理和2D纹理数组。加载3D纹理和2D纹理数组的函数是<code>glTexImage3D</code>，它与<code>glTexImage2D</code>很相似。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 加载3D纹理或者2D纹理数组</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param target#&gt; 指定纹理目标，应该为GL_TEXTURE_3D或GL_TEXTURE_2D_ARRAY description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param level#&gt; 指定加载的mip级别。0表示基本级别，更大的数值表示各个后续的mip贴图级别 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param internalformat#&gt; 纹理存储的内部格式 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param width#&gt; 以像素表示的图像宽度 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param height#&gt; 以像素表示的图像高度 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param depth#&gt; 3D纹理的切片深度 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param border#&gt; 这个参数在OpenGL ES中被忽略，应该为0 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param format#&gt; 输入纹理数据的格式 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param type#&gt; 输入像素数据的类型 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param pixels#&gt; 包含图像的实际像素数据。这些数据必须包含（width*height*depth）个像素，每个像素根据格式和类型规格有相应数量的字节。图像数据应该按照2D纹理切片的顺序存储 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glTexImage3D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, <span class=\"keyword\">const</span> GLvoid *pixels);</span><br></pre></td></tr></table></figure>\n<p>一旦用<code>glTexImage3D</code>加载了3D纹理或者2D纹理数组，就可以用<code>texture</code>内建函数在着色器中读取该纹理：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 绑定3D纹理单元</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param sampler#&gt; 绑定到纹理单元的采样器，指定纹理为读取来源 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param coord#&gt; 用于从纹理贴图中读取的3D纹理坐标 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param bias#&gt; 可选参数，提供用于纹理读取的mip贴图偏置。这允许着色器明确地偏置用于mip忒土选择的LOD计算值 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return vec4 纹理</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">texture(sampler3D sampler, vec3 coord[, <span class=\"keyword\">float</span> bias]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 绑定2D纹理数组单元</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param sampler#&gt; 绑定到纹理单元的采样器，指定纹理为读取来源 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param coord#&gt; 用于从纹理贴图中读取的3D纹理坐标 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param bias#&gt; 可选参数，提供用于纹理读取的mip贴图偏置。这允许着色器明确地偏置用于mip忒土选择的LOD计算值 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return vec4 纹理</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">texture(sampler2DArray sampler, vec3 coord[, <span class=\"keyword\">float</span> bias]);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>注意，r坐标是一个浮点值。对于3D纹理，根据过滤模式设置，纹理读取可能跨越体的两个切片。</p>\n</blockquote>\n<h1>压缩纹理</h1>\n<p>上述所说的纹理加载都是未压缩的纹理图像数据，OpenGL ES 3.0还支持压缩纹理图像数据的加载。纹理压缩有几个理由，首先，压缩纹理可以减少纹理在设备上的内存占用；其次（不那么明显），压缩纹理节约了着色器中读取纹理时消耗的内存带宽；最后，压缩纹理减少必须存储的图像数据，从而减少了应用程序的下载大小。<br>\n在OpenGL ES 2.0中，核心规范不定义任何压缩的纹理图像格式。也就是说，OpenGL ES 2.0核心简单地定义一个机制，可以加载压缩的纹理图像数据，但是没有定义任何压缩格式。因此，各供应商提供了特定于硬件的纹理压缩扩展。这样，OpenGL ES 2.0应用程序开发者必须在不同平台和硬件上支持不同的纹理压缩格式。<br>\nOpenGL ES 3.0引入所有供应商必须支持的标准纹理压缩格式，从而改善了这种情况。爱立信纹理压缩（Ericsson Texture Compression，ETC2和EAC）以无版税标准的形式提供给Khronos，它被作为OpenGL ES 3.0的标准纹理压缩格式。EAC有一些压缩1通道和2通道数据的变种，ETC2也有压缩3通道和4通道数据的变种。用于加载2D纹理和立方图压缩图像数据的函数是<code>glCompressedTexImage2D</code>，用于2D纹理数组的对应函数为<code>glCompressedTexImage3D</code>。</p>\n<blockquote>\n<p>注意，ETC2/EAC不支持3D纹理（只支持2D纹理和2D纹理数组），但是<code>glCompressedTexImage3D</code>可以用于加载供应商专用的3D纹理压缩格式。</p>\n</blockquote>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 加载2D纹理和立方图压缩图像数据</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param target#&gt; 指定纹理目标，应该为GL_TEXTURE_2D或者GL_TEXTURE_CUBE_MAP_* description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param level#&gt; 指定要加载的mip级别 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param internalformat#&gt; 纹理存储的内部格式 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param width#&gt; 以像素数表示的图像宽度 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param height#&gt; 以像素数表示的图像高度 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param border#&gt; 这个参数在OpenGL ES中被忽略，应该为0 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param imageSize#&gt; 以字节数表示的图像大小 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param data#&gt; 包含图像的实际压缩像素数据，必须能够容纳imageSize个字节 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glCompressedTexImage2D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, <span class=\"keyword\">const</span> GLvoid *data);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 加载2D纹理和立方图压缩图像数据</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param target#&gt; 指定纹理目标，应该为GL_TEXTURE_2D或者GL_TEXTURE_CUBE_MAP_* description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param level#&gt; 指定要加载的mip级别 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param internalformat#&gt; 纹理存储的内部格式。OpenGL ES 3.0中的标准压缩纹理格式在下表中描述 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param width#&gt; 以像素数表示的图像宽度 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param height#&gt; 以像素数表示的图像高度 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param border#&gt; 这个参数在OpenGL ES中被忽略，应该为0 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param imageSize#&gt; 以字节数表示的图像大小 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param data#&gt; 包含图像的实际压缩像素数据，必须能够容纳imageSize个字节 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glCompressedTexImage3D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, <span class=\"keyword\">const</span> GLvoid *data);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 加载2D纹理数组或专用3D纹理压缩图像数据</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param target#&gt; 指定纹理目标，应该为GL_TEXTURE_3D或者GL_TEXTURE_2D_ARRAY description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param level#&gt; 指定要加载的mip级别 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param internalformat#&gt; 纹理存储的内部格式。OpenGL ES 3.0中的标准压缩纹理格式在下表中描述 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param width#&gt; 以像素数表示的图像宽度 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param height#&gt; 以像素数表示的图像高度 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param depth#&gt; 以像素数表示的图像深度（或者2D纹理数组的切片数量） description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param border#&gt; 这个参数在OpenGL ES中被忽略，应该为0 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param imageSize#&gt; 以字节数表示的图像大小 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param data#&gt; 包含图像的实际压缩像素数据，必须能够容纳imageSize个字节 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glCompressedTexImage3D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, <span class=\"keyword\">const</span> GLvoid *data);</span><br></pre></td></tr></table></figure>\n<p>OpenGL ES 3.0支持的标准ETC压缩纹理格式在下表中列出。所有ETC格式将压缩的图像数据存储在4x4的块中。表中列出了每种ETC格式中每个像素的位数。单个ETC图像的大小可以由每像素位数（bpp）比率算出：<code>sizeInBytes = max(width, 4) * max(height, 4) * bpp / 8</code>。</p>\n<table>\n<thead>\n<tr>\n<th>内部格式</th>\n<th>大小（每像素位数）</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>GL_COMPRESSED_R11_EAC</td>\n<td>4</td>\n<td>单通道无符号压缩GL_RED格式</td>\n</tr>\n<tr>\n<td>GL_COMPRESSED_SIGNED_R11_EAC</td>\n<td>4</td>\n<td>单通道有符号压缩GL_RED格式</td>\n</tr>\n<tr>\n<td>GL_COMPRESSED_RG11_EAC</td>\n<td>8</td>\n<td>双通道无符号压缩GL_RG格式</td>\n</tr>\n<tr>\n<td>GL_COMPRESSED_SIGNED_RG11_EAC</td>\n<td>8</td>\n<td>双通道有符号压缩GL_RG格式</td>\n</tr>\n<tr>\n<td>GL_COMPRESSED_RGB8_ETC2</td>\n<td>4</td>\n<td>三通道无符号压缩GL_RGB格式</td>\n</tr>\n<tr>\n<td>GL_COMPRESSED_SRGB8_ETC2</td>\n<td>4</td>\n<td>sRGB颜色空间中的三通道无符号压缩GL_RGB格式</td>\n</tr>\n<tr>\n<td>GL_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2</td>\n<td>4</td>\n<td>四通道无符号压缩GL_RGBA格式，1位alpha</td>\n</tr>\n<tr>\n<td>GL_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2</td>\n<td>4</td>\n<td>sRGB颜色空间中四通道无符号压缩GL_RGBA格式，1位alpha</td>\n</tr>\n<tr>\n<td>GL_COMPRESSED_RGBA8_ETC2_EAC</td>\n<td>8</td>\n<td>四通道无符号压缩GL_RGBA格式</td>\n</tr>\n<tr>\n<td>GL_COMPRESSED_SRGBA8_ETC2_EAC</td>\n<td>8</td>\n<td>sRGB颜色空间中四通道无符号压缩GL_RGBA格式</td>\n</tr>\n</tbody>\n</table>\n<p>一旦加载压缩纹理，它就可以和无压缩纹理一样用于纹理处理。大部分开发人员不会编写自己的压缩程序，具体可使用的压缩工具，自行选择。</p>\n<p>注意，所有OpenGL ES 3.0实现都支持如上表中列出的格式。此外，有些实现可能支持表中未列出的供应商专用压缩格式。如果我们试图在不支持它们的OpenGL ES 3.0实现上使用纹理压缩格式，将会产生一个<code>GL_INVALID_ENUM</code>错误。检查OpenGL ES 3.0实现导出使用的任何供应商专用纹理压缩格式的扩展字符串很重要。如果该实现没有导出这样的扩展字符串，那就只能退而求其次使用无压缩的纹理格式。<br>\n除了检查扩展字符串之外，还可以用另外一种方法确定实现所支持的纹理压缩格式。也就是说，可以用<code>glGetIntegerv</code>查询<code>GL_NUM_COMPRESSED_TEXTURE_FORMATS</code>来确定所支持的压缩图像格式数量。然后，可以用<code>glGetIntegerv</code>查询<code>GL_COMPRESSED_TEXTURE_FORMATS</code>，该调用返回一个<code>GLenum</code>值的数组。数组中的每个<code>GLenum</code>值将是实现支持的一种压缩纹理格式。</p>\n<h1>纹理子图像规范</h1>\n<p>用<code>glTexImage2D</code>上传纹理图像之后，可以更新图像的各个部分。如果你只希望更新图像的一个子区域，这种能力就很试用。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 更新2D纹理图像的子区域</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param target#&gt; 指定纹理目标，可以是GL_TEXTURE_2D或者GL_TEXTURE_CUBE_MAP_* description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param level#&gt; 指定更新的mip级别 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param xoffset#&gt; 开始更新的纹素x索引 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param yoffset#&gt; 开始更新的纹素y索引 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param width#&gt; 更新的图像子区域宽度 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param height#&gt; 更新的图像子区域高度 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param format#&gt; 输入纹理数据格式 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param type#&gt; 输入像素数据的类型 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param pixels#&gt; 包含图像子区域的实际像素数据 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, <span class=\"keyword\">const</span> GLvoid *pixels);</span><br></pre></td></tr></table></figure>\n<p>这个函数将更新(xoffset, yoffset)到(xoffset+width-1, yoffset+height-1)范围内的纹素。注意，要使用这个函数，纹理必须完全指定。子图像的范围必须在之前指定的纹理图像界限之内。<code>pixels</code>数组中的数据必须按照<code>glPixelStorei</code>的<code>GL_UNPACK_ALIGNMENT</code>指定的方式对齐。</p>\n<p>还有一个用于更新压缩的2D纹理图像子区域的函数：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 更新压缩的2D纹理图像的子区域</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param target#&gt; 指定纹理目标，可以是GL_TEXTURE_2D或者GL_TEXTURE_CUBE_MAP_* description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param level#&gt; 指定更新的mip级别 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param xoffset#&gt; 开始更新的纹素x索引 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param yoffset#&gt; 开始更新的纹素y索引 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param width#&gt; 更新的图像子区域宽度 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param height#&gt; 更新的图像子区域高度 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param format#&gt; 所用的压缩纹理格式，必须与图像原来指定的格式相同 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param imageSize#&gt; 以字节数表示的图像大小 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param data#&gt; 包含图像子区域的实际像素数据 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glCompressedTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, <span class=\"keyword\">const</span> GLvoid *data);</span><br></pre></td></tr></table></figure>\n<p>此外，与2D纹理一样，可以用<code>glTexSubImage3D</code>更新现有3D纹理和2D纹理数组的子区域：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 更新3D纹理图像的子区域</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param target#&gt; 指定目标纹理，可以是GL_TEXTURE_3D或GL_TEXTURE_2D_ARRAY description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param level#&gt; 指定更新的mip级别 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param xoffset#&gt; 开始更新的纹素x索引 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param yoffset#&gt; 开始更新的纹素y索引 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param zoffset#&gt; 开始更新的纹素z索引 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param width#&gt; 更新的图像子区域宽度 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param height#&gt; 更新的图像子区域高度 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param depth#&gt; 更新的图像子区域深度 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param format#&gt; 输入纹理数据的格式 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param type#&gt; 输入像素数据的类型 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param pixels#&gt; 包含像素数据的类型 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, <span class=\"keyword\">const</span> GLvoid *pixels);</span><br></pre></td></tr></table></figure>\n<p><code>glTexSubImage3D</code>的表现与<code>glTexSubImage2D</code>类似，唯一的不同是子区域包含一个<code>zoffset</code>和<code>depth</code>，用于指定深度切片中要更新的子区域。对于压缩的2D纹理数组，也可以用<code>glCompressedTexSubImage3D</code>更新纹理的一个子区域。对于3D纹理，这个函数只能用于供应商专用的3D压缩纹理格式，因为ETC2/EAC只支持2D纹理和2D纹理数组。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 更新压缩的3D纹理图像的子区域</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param target#&gt; 指定纹理目标，可能是GL_TEXTURE_3D或者GL_TEXTURE_2D_ARRAY description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param level#&gt; 指定更新的mip级别 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param xoffset#&gt; 开始更新的纹素x索引 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param yoffset#&gt; 开始更新的纹素y索引 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param zoffset#&gt; 开始更新的纹素z索引 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param width#&gt; 更新的图像子区域宽度 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param height#&gt; 更新的图像子区域高度 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param depth#&gt; 更新的图像子区域深度 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param format#&gt; 使用的压缩纹理格式，必须与原来指定的图像格式相同 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param imageSize#&gt; 以字节数表示的图像大小 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param data#&gt; 包含图像子区域的实际像素数据 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glCompressedTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, <span class=\"keyword\">const</span> GLvoid *data);</span><br></pre></td></tr></table></figure>\n<h1>从颜色缓冲区复制纹理数据</h1>\n<p>OpenGL ES 3.0中支持的另一个纹理功能是从颜色缓冲区复制数据到一个纹理。如果我们希望使用渲染的结果作为纹理中的图像，这一功能就很实用。后面的帧缓冲区对象提供了渲染-纹理转换的快速方法，这种方法比复制图像数据更快。但是，如果性能不是关注点，那么从颜色缓冲区复制图像数据就是一种实用的功能。</p>\n<p>作为复制图像数据来源的颜色缓冲区可以用<code>glReadBuffer</code>函数设置。如果应用程序渲染到一个双缓冲区EGL可显示表面，则<code>glReadBuffer</code>必须设置为<code>GL_BACK</code>（后台缓冲区–默认状态）。OpenGL ES 3.0只支持双缓冲区EGL可显示表面。因此，所有在显示器上绘图的OpenGL ES 3.0应用程序都有一个既用于前台缓冲区又用于后台缓冲区的颜色缓冲区。这个缓冲区当前是前台还是后台缓冲区，由对<code>eglSwapBuffers</code>的最后一次调用决定。当从可显示EGL表面的颜色缓冲区中复制图像数据时，总是会复制后台缓冲区的内容。如果渲染到一个EGL pbuffer，则复制将发生在pbuffer表面。最后，如果渲染到一个帧缓冲区对象，则所复制的帧缓冲区对象的颜色附着通过调用带<code>GL_COLOR_ATTACHMENTi</code>参数的<code>glReadBuffer</code>函数设置：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 读取颜色缓冲区</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param mode#&gt; 指定读取的颜色缓冲区。这将为未来的glReadPixels、glCopyTexImage2D、glCopyTexSubImage2D和glCopyTexSubImage3D调用设置源颜色缓冲区。该值可能为GL_BACK、GL_COLOR_ATTACHMENTi或GL_NONE description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glReadBuffer(GLenum mode);</span><br></pre></td></tr></table></figure>\n<p>从颜色缓冲区复制数据到纹理的函数是<code>glCopyTexImage2D</code>、<code>glCopyTexSubImage2D</code>和<code>glCopyTexSubImage3D</code>。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 从颜色缓冲区复制数据到2D纹理</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param target#&gt; 指定纹理目标，可能为GL_TEXTURE_CUBE_MAP_2D或者GL_TEXTURE_CUBE_MAP_* description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param level#&gt; 指定加载的mip级别 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param internalformat#&gt; 图像的内部格式 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param x#&gt; 读取的帧缓冲区矩形左下角的x窗口坐标 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param y#&gt; 读取的帧缓冲区矩形左下角的y窗口坐标 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param width#&gt; 读取区域的宽度，以像素数表示 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param height#&gt; 读取区域的高度，以像素表示 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param border#&gt; OpenGL ES 3.0不支持边框，必须为0 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glCopyTexImage2D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);</span><br></pre></td></tr></table></figure>\n<p>调用上述函数导致纹理图像从区域(x, y)到(x+width-1, y+height-1)的颜色缓冲区内的像素加载。纹理图像的宽度和高度等于颜色缓冲区中复制区域的大小。我们应该用这些信息填充纹理的全部内容。<br>\n此外，可以用<code>glCopyTexSubImage2D</code>更新已经指定的图像的子区域：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 从颜色缓冲区复制数据更新已经指定的2D纹理的子区域</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param target#&gt; 指定纹理目标，可能为GL_TEXTURE_2D或者GL_TEXTURE_CUBE_MAP_* description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param level#&gt; 指定更新的mip级别 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param xoffset#&gt; 开始更新的纹素x索引 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param yoffset#&gt; 开始更新的纹素y索引 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param x#&gt; 读取的帧缓冲区矩形左下角的x窗口坐标 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param y#&gt; 读取的帧缓冲区矩形左下角的y窗口坐标 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param width#&gt; 读取区域的宽度，以像素数表示 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param height#&gt; 读取区域的高度，以像素数据表示 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glCopyTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);</span><br></pre></td></tr></table></figure>\n<p>上述函数将用颜色缓冲区中从(x, y)到(x+width-1, y+height-1)区域的像素更新图像中从(xoffset, yoffset)到(xoffset+width-1, yoffset+height-1)的子区域。<br>\n最后，也可以用<code>glCopyTexSubImage3D</code>将颜色缓冲区的内容复制到之前指定的3D纹理或者2D纹理数组的一个切片中：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 从颜色缓冲区复制数据更新已经指定的3D纹理或2D纹理数组的子区域</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param target#&gt; 指定纹理目标，可能为GL_TEXTURE_3D或者GL_TEXTURE_2D_ARRAY description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param level#&gt; 指定加载的mip级别 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param xoffset#&gt; 开始更新的纹素x索引 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param yoffset#&gt; 开始更新的纹素y索引 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param zoffset#&gt; 开始更新的纹素z索引 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param x#&gt; 读取的帧缓冲区矩形左下角的x窗口坐标 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param y#&gt; 读取的帧缓冲区矩形左下角的y窗口坐标 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param width#&gt; 读取区域的宽度，以像素数表示 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param height#&gt; 读取区域的高度，以像素数表示 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glCopyTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);</span><br></pre></td></tr></table></figure>\n<p>对于上述函数要记住一点，即纹理图像格式的分量不能多于颜色缓冲区。换句话说，复制颜色缓冲区的数据时，可以转换为分量较少的格式，但是不能转换为分量较多的格式。</p>\n<h1>采样器对象</h1>\n<p>之前介绍了用<code>glTexParameter[i|f][v]</code>设置纹理参数（如过滤模式、纹理坐标包装模式和LOD设置）的方法。使用<code>glTexParameter[i|f][v]</code>的问题是它可能造成大量不必要的API开销。应用程序经常在大量纹理上使用相同的设置，在这种情况下，用<code>glTexParameter[i|f][v]</code>为每个纹理对象设置采样器状态可能造成大量额外开销。为了缓解这一问题，OpenGL ES 3.0引入采样器对象，将采样器状态和纹理状态分离。简言之，所有可用<code>glTexParameter[i|f][v]</code>进行的设置都可以对采样器对象进行，可以在一次函数调用中与纹理单元绑定使用。采样器对象可以用于许多纹理，从而降低API开销。</p>\n<p>用于生成采样器对象的函数是：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 生成采样器对象</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param count#&gt; 指定生成的采样器对象数量 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param samplers#&gt; 一个无符号整数数组，将容纳n个采样器对象ID description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glGenSamplers(GLsizei count, GLuint *samplers);</span><br></pre></td></tr></table></figure>\n<p>采样器对象在应用程序不再需要它们时也需要删除：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 删除采样器对象</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param count#&gt; 指定要删除的采样器对象 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param samplers#&gt; 一个无符号整数数组，容纳要删除的n个采样器对象ID description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glDeleteSamplers(GLsizei count, <span class=\"keyword\">const</span> GLuint *samplers);</span><br></pre></td></tr></table></figure>\n<p>当生成采样器对象ID之后，应用程序必须绑定采样器对象以使用其状态。采样器对象绑定到纹理单元，这种绑定取代了用<code>glTexParameter[i|f][v]</code>进行的所有纹理对象状态设置：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 采样器对象绑定到纹理单元</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param unit#&gt; 指定采样器对象绑定到的纹理单元 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param sampler#&gt; 所要绑定的采样器对象的句柄 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glBindSampler(GLuint unit, GLuint sampler);</span><br></pre></td></tr></table></figure>\n<p>如果传递给<code>glBindSampler</code>的<code>sampler</code>为0（默认采样器），则使用为纹理对象设置的状态。采样器对象状态可以用<code>glSampler[f|i][v]</code>设置。可以用<code>glSamplerParameter[f|i][v]</code>设置的参数与用<code>glTexParameter[i|f][v]</code>设置的相同，唯一的区别是状态被设置到采样器对象，而非纹理对象：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">glSamplerParameteri(GLuint sampler, GLenum pname, GLint param);</span><br><span class=\"line\">glSamplerParameteriv(GLuint sampler, GLenum pname, <span class=\"keyword\">const</span> GLint *param);</span><br><span class=\"line\">glSamplerParameterf(GLuint sampler, GLenum pname, GLfloat param);</span><br><span class=\"line\">glSamplerParameterfv(GLuint sampler, GLenum pname, <span class=\"keyword\">const</span> GLfloat *param);</span><br></pre></td></tr></table></figure>\n<h1>不可变纹理</h1>\n<p>OpenGL ES 3.0中引入的另一种有助于改进应用程序性能的功能是不可变纹理。正如前面所介绍的，应用程序使用<code>glTexImage2D</code>和<code>glTexImage3D</code>等函数独立地指定纹理的每个mip贴图级别。这对OpenGL ES驱动程序造成的问题是驱动程序在绘图之前无法确定纹理是否已经完全指定。也就是说，它必须检查每个mip贴图级别或者子图像的格式是否相符、每个级别的大小是否正确以及是否有足够的内存。这种绘图时检查可能代价很高，而使用不可变纹理可以避免这种情形。</p>\n<p>不可变纹理的思路很简单：应用程序在加载数据之前指定纹理的格式和大小。这样做之后，纹理格式变成不可改变的，OpenGL ES驱动程序可以预先进行所有一致性和内存检查。一旦纹理不可变，它的格式和大小就不会再变化。但是，应用程序仍然可以通过使用<code>glTexSubImage2D</code>、<code>glTexSubImage3D</code>、<code>glGenerateMipMap</code>或者渲染到纹理加载图像数据。<br>\n为了创建不可变纹理，应用程序将使用<code>glBindTexture</code>绑定纹理，然后用<code>glTexStorage2D</code>或<code>glTexStorage3D</code>分配不可变存储：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 创建不可变纹理</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param target#&gt; 指定纹理目标，可能是GL_TEXTURE_2D、GL_TEXTURE_CUBE_MAP_*或者GL_TEXTURE_3D、GL_TEXTURE_2D_ARRAY description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param levels#&gt; 指定mip贴图级别数量 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param internalformat#&gt; 确定大小的纹理存储内部格式 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param width#&gt; 基本图形宽度，以像素数表示 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @param height#&gt; 基本图像高度，以像素数表示 description#&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> @return void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">glTexStorage2D/<span class=\"number\">3</span>D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);</span><br></pre></td></tr></table></figure>\n<p>一旦创建了不可变纹理，在纹理对象上调用<code>glTexImage*</code>、<code>glCompressedTexImage*</code>、<code>glCopyTexImage*</code>或<code>glTexStorage*</code>就会无效。这样做将生成<code>GL_INVALID_OPERATION</code>错误。要用图像数据填充不可变纹理，应用程序需要使用<code>glTexSubImage2D</code>、<code>glTexSubImage3D</code>、<code>glGenerateMipMap</code>或者渲染到纹理图像（通过将其作为帧缓冲区对象附着使用来实现）。<br>\n使用<code>glTexStorage*</code>时，OpenGL ES内部通过将<code>GL_TEXTURE_IMMUTABLE_FORMAT</code>设置为<code>GL_TRUE</code>，将<code>GL_TEXTURE_IMMUTABLE_LEVELS</code>设置为传递给<code>glTexStorage*</code>的数字，将纹理对象标记为不可变。应用程序可以使用<code>glGetTexParameter[i|f][v]</code>查询这些值，但是它无法直接设置这些值。必须使用<code>glTexStorage*</code>函数设置不可变纹理参数。</p>\n<h1>像素解包缓冲区对象</h1>\n<p>缓冲区对象可以在服务器端（或者GPU）内存中存储数据，而不是在客户端（或者主机）内存。使用缓冲区对象的好处是减少了从CPU到GPU的数据传送，因而能够改进性能（并降低内存占用率）。OpenGL ES 3.0还引入了像素解包缓冲区对象，这种对象与<code>GL_PIXEL_UNPACK_BUFFER</code>目标绑定指定。像素解包缓冲区对象允许纹理数据规格保存在服务器端内存。结果是，像素解包操作<code>glTexImage*</code>、<code>glTexSubImage*</code>、<code>glCompressedTexImage*</code>和<code>glCompressedTexSubImage*</code>可以直接来自缓冲区对象。如果像素解包缓冲区对象在这类调用期间绑定，则数据指针是像素解包缓冲区中的一个偏移量，而不是指向客户端内存的指针，这与使用<code>glVertexAttribPointer</code>的VBO很相似。<br>\n像素解包缓冲区对象可以用于将纹理数据流传输到GPU。应用程序可以分配一个像素解包缓冲区，然后为更新映射缓冲区区域。当进行加载数据到OpenGL的调用（例如<code>glTexSubImage*</code>）时，这些函数可能立即返回。因为数据已经存在于GPU（或者可以在稍后复制，但是立即复制不需要像客户端数据那样进行）。我们建议在纹理上传操作的性能/内存占用对应用程序很重要的情况下使用像素解包缓冲区对象。</p>\n<h1>总结</h1>\n<p>这篇文章主要介绍了OpenGL ES 3.0中使用纹理的方法。</p>\n"},{"title":"Bitmap - 位的映射","catalog":true,"toc_nav_num":true,"date":"2022-01-10T11:00:08.000Z","subtitle":"A mapping from some domain (for example, a range of integers) to bits","header-img":"/img/article_header/article_header.png","busuanzi":true,"_content":"\n# 前言\n\n`BitMap`从字面的意思，很多人认为是位图，其实更准确的来说，是位的映射。下面我们分别从位映射算法和绘图中的绘图这两块内容来介绍`Bitmap`。\n\n# Bitmap 算法\n\n`Bitmap`的基本思想就是用一个`bit`位来标记某个元素对应的`Value`，而`Key`即是该元素。由于采用`bit`为单位来存储数据，所以在存储空间方面，可以大大节约空间。\n\n假设有这样一个需求：在20亿个随机整数中找出某个数是否存在，那么：\n- 如果每个数字用`UInt32`存储，占用的空间为`2_000_000_000 * 4 / 1024 / 1024 / 1024 ≈ 7.25G`\n- 如果按位存储，20亿个数字就是20亿位，占用空间为`2_000_000_000 / 8 / 1024 / 1024 / 1024 ≈ 0.23G`\n所以我们可以看出，按位存储在数据存储中所占有的优势。\n\n## 数据存储\n\n那么我们如果表示一个数呢？\n既然我们是按位存储，那么每一位就代表当前位置的数据是否存在，可以用0或者1表示，正好符合二进制。\n那么，我们就可以通过二进制表示数字，比如`{1, 3, 5, 7}`：\n\n<font color=red>1</font> | 0 | <font color=red>1</font> | 0 | <font color=red>1</font> | 0 | <font color=red>1</font> | 0\n:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:\n<font color=red>7</font> | 6 | <font color=red>5</font> | 4 | <font color=red>3</font> | 2 | <font color=red>1</font> | 0\n\n计算机内存分配的最小单位是字节，也就是8位，所以很容易表示小于8的数，那么对于`{10, 11, 14}`的数，可以在另一个8位上表示：\n\n<font color=red>1</font> | 0 | <font color=red>1</font> | 0 | <font color=red>1</font> | 0 | <font color=red>1</font> | 0\n:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:\n<font color=red>7</font> | 6 | <font color=red>5</font> | 4 | <font color=red>3</font> | 2 | <font color=red>1</font> | 0\n\n0 | <font color=red>1</font> | 0 | 0 | <font color=red>1</font> | <font color=red>1</font> | 0 | 0\n:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:\n15 | <font color=red>14</font> | 13 | 12 | <font color=red>11</font> | <font color=red>10</font> | 9 | 8\n\n一个`Int32`占32位，那么一个`Int32`可以存储32个数字，那么对于需要存储数字的最大值`N`，可以得到需要申请一个`let tmp: [Int32]`数组长度为`(1 + N / 32)`即可存储：\n```swift\ntmp[0]：可以表示0~31\ntmp[1]：可以表示31~63\ntmp[2]：可以表示64~95\n。。。\n```\n\n## 添加\n\n那我们如何将一个数字`P`放进去呢？\n我们就可以通过位运算`|或`，对于是存储在哪一个`Int32`，可以通过`P / 32`计算出。所以在`{1, 3, 5, 7}`中插入数字`6`：\n``` swift\n0x10101010 | (1 << 6) = 0x10101010 | 0x01000000 = 0x11101010\n// 转换为十进制：\n170 | 64 = 234\n```\n所以可以总结为：\n```swift\ntmp[P/8] |= 1 << (P % 8)\n```\n\n## 删除\n\n那么我们删除一个数字`Q`呢？\n我们可以通过位运算`&与`，与上同理找到对于存储的位置，然后对应删除数字`6`：\n```swift\n0x11101010 & ~(1 << 6) = 0x11101010 & 0x10111111 = 0x10101010\n// 转换为十进制\n234 & ~64 = 170\n```\n所以可以总结为：\n```swift\ntmp[Q/8] &= ~(1 << (Q % 8))\n```\n\n## 查找\n\n查找数字`R`就更简单了，可以通过位运算`&与`，判断`tmp[R/8] & (1 << (R % 8))`的结果值，如果为`1`则存在，`0`则不存在。\n\n## 用途\n\n那么这种`Bitmap`有什么用呢？\n可以进行大量数据的快速排序、查找和去重等等，那么我们就抓到了他的关键点，对于大量数据的存储和查找，这就可以引入到我们位图的概念。\n\n# Bitmap 位图\n\n## 概念\n\n**位图**，又称**栅格图(Raster Graphics)**或**点阵图**，是使用像素阵列(Pixel-array/Dot-matrix点阵)来表示的图像。\n\n位图的像素都分配有特定的位置和颜色值，每个像素的颜色信息由RGB组合或者灰度值表示。\n\n根据位深度,可将位图分为1、4、8、16、24及32位图像等。每个像素使用的信息位数越多，可用的颜色就越多，颜色表现就越逼真，相应的数据量越大。例如，位深度为 1 的像素位图只有两个可能的值（黑色和白色），所以又称为二值位图。位深度为 8 的图像有 2^8（即 256）个可能的值。位深度为 8 的灰度模式图像有 256 个可能的灰色值。\n\nRGB图像由三个颜色通道组成。8 位/通道的 RGB 图像中的每个通道有 256 个可能的值，这意味着该图像有 1600 万个以上可能的颜色值。有时将带有 8 位/通道 (bpc) 的 RGB 图像称作 24 位图像（8 位 x 3 通道 = 24 位数据/像素）。通常将使用24位RGB组合数据位表示的的位图称为真彩色位图。\n\n## iOS中的Bitmap\n\n在iOS中，`Bitmap`的数据由`CGImageRef`封装。如果要使用`Bitmap`对图片进行各种处理，就需要先创建位图上下文：\n```swift\nfunc createContext(_ image: CGImage) -> CGContext? {\n    let w = Int(image.width)\n    let h = Int(image.height)\n    let bitsPerComponent = 8\n    let bytesPerRow = w * 4\n    let space = CGColorSpaceCreateDeviceRGB()\n    let bitmapInfo = CGImageAlphaInfo.premultipliedLast.rawValue | CGBitmapInfo.byteOrder32Big.rawValue\n    let data = UnsafeMutablePointer<UInt32>.allocate(capacity: w * h)\n    let context = CGContext(data: data,\n                            width: w,\n                            height: h,\n                            bitsPerComponent: bitsPerComponent,\n                            bytesPerRow: bytesPerRow,\n                            space: space,\n                            bitmapInfo: bitmapInfo)\n    return context\n}\n```\n\n参数说明注释：\n```swift\nextension CGContext {\n    /// - Parameters:\n    ///   - data: 用于存放位图的点阵数组指针，当生成上下文并调用上下文的`draw`方法将指定图片或层级绘制到上下文后，data指针就会存储该图片的位图像素信息；我们可以对data里面的数据进行操作，通过创建`CGDataProvider`实例并调用`CGImage`的初始化方法重新生成图片\n    ///   - width: 位图宽\n    ///   - height: 位图高\n    ///   - bitsPerComponent: 每个颜色组件或alpha组件占用的`bite`值，对于32位图像值为8\n    ///   - bytesPerRow: 位图每一行占的字节数，对于32位图像一个像素有4`byte`(rgba)，值为w * 4\n    ///   - space: 颜色空间，RGBA -> CGColorSpaceCreateDeviceRGB(), CMYK -> CGColorSpaceCreateDeviceCMYK(), 灰度 -> CGColorSpaceCreateDeviceGray()\n    ///   - bitmapInfo: 一个常量，通常多枚举做或运算，描述位图上下文所对应的基本信息，具体见`CGBitmapInfo`和`CGImageAlphaInfo`描述\n    @available(iOS 2.0, *)\n    public /*not inherited*/ init?(data: UnsafeMutableRawPointer?, width: Int, height: Int, bitsPerComponent: Int, bytesPerRow: Int, space: CGColorSpace, bitmapInfo: UInt32)\n}\n```\n\n### CGBitmapInfo 和 CGImageAlphaInfo\n\n``` swift\npublic struct CGBitmapInfo : OptionSet {\n    public init(rawValue: UInt32)\n    public static var alphaInfoMask: CGBitmapInfo { get }\n    public static var floatInfoMask: CGBitmapInfo { get }\n    public static var floatComponents: CGBitmapInfo { get }    \n    public static var byteOrderMask: CGBitmapInfo { get }\n    public static var byteOrder16Little: CGBitmapInfo { get } // 16位小端模式\n    public static var byteOrder32Little: CGBitmapInfo { get } // 32位小端模式\n    public static var byteOrder16Big: CGBitmapInfo { get } // 16位大端模式\n    public static var byteOrder32Big: CGBitmapInfo { get } // 32位大端模式\n}\n\npublic enum CGImageAlphaInfo : UInt32 {\n    case none = 0 /* For example, RGB. */\n    case premultipliedLast = 1 /* For example, premultiplied RGBA */\n    case premultipliedFirst = 2 /* For example, premultiplied ARGB */\n    case last = 3 /* For example, non-premultiplied RGBA */\n    case first = 4 /* For example, non-premultiplied ARGB */\n    case noneSkipLast = 5 /* For example, RBGX. */\n    case noneSkipFirst = 6 /* For example, XRGB. */\n    case alphaOnly = 7 /* No color data, alpha data only */\n}\n```\n\n上面就是对于`CGBitmapInfo`和`CGImageAlphaInfo`的定义。\n\n我们先关注`CGImageAlphaInfo`，像素构成类型：\n- `last`和`first`分别代表`alpha`的分量在前置位还是后置位，在数据读取时是按照`RGBA`还是`ARGB`来读取的。\n- `premultiplied`代表预乘透明，比如对应`RGBA`为(0.5, 0.5, 0.5, 0.5)的色值，在预乘之后变为(0.25, 0.25, 0.25, 0.5)；所以带有`premultiplied`时，说明在图片解码压缩的时候，就将`alpha`通道的值分别乘到了颜色分量上，我们知道`alpha`就会影响颜色的透明度，我们如果在压缩的时候就将这步做完了，那么渲染的时候就不必再处理`alpha`通道了，这样在显示位图的时候直接显示就行了，这样就提高了性能。\n- `noneSkip`就代表了虽然有`alpha`分量，但是忽略`alpha`的值，相当于透明度不起作用；这样的话，我们可以获取到图片的`RGB`原始值。\n\n然后我们看一下`CGBitmapInfo`，像素存储格式：\n- `byteOrder16Big`和`byteOrder32Big`分别代表16和32位的大端模式\n   - 大端模式(Big-Endian)：高位字节排放在内存的低地址端，低位字节排放在内存的高地址段\n   - `0x12 | 0x34 | 0x56 | 0x78`（低到高）\n   - 对于`RGBA`在内存中的存放则是为`R | G | B | A`\n- `byteOrder16Little`和`byteOrder32Little`分别代表16和32位的小端模式\n   - 小端模式(Little-Endian)：低位字节排放在内存的低地址端，高位字节排放在内存的高地址段\n   - `0x78 | 0x56 | 0x34 | 0x12`（低到高）\n   - 对于`RGBA`在内存中的存放则是为`A | B | G | R`\n\n## 代码实践\n\n### 获取图片中点击位置的颜色\n\n- 获取`ImageView`控件的`bounds`作为像素范围大小\n- 通过`CGPoint`参数计算出该点对应与像素索引位置的像素数据\n- 逐个字节解析出rgb颜色分量和alpha分量值最后生成UIColor最为结果返回\n```swift\nextension UIImageView {\n    /// 工具坐标点获取颜色\n    func color(for point: CGPoint) -> UIColor? {\n        guard let pixels = pixels,\n              let index = indexForPixel(point)\n        else { return nil }\n        return color(for: pixels[index])\n    }\n\n    /// 解析像素点颜色\n    func color(for pixel: UInt32) -> UIColor {\n        let a = CGFloat(pixel & 0xff) / 255.0\n        let r = CGFloat((pixel >> 8) & 0xff) / 255.0\n        let g = CGFloat((pixel >> 16) & 0xff) / 255.0\n        let b = CGFloat((pixel >> 24) & 0xff) / 255.0\n        return UIColor(red: r, green: g, blue: b, alpha: a)\n    }\n    \n    /// 获取对应像素点索引\n    func indexForPixel(_ point: CGPoint) -> Int? {\n        guard bounds.contains(point) else { return nil }\n        return Int(bounds.width) * Int(point.y) + Int(point.x)\n    }\n    \n    /// 获取图片像素数据\n    var pixels: [UInt32]? {\n        guard let image = image?.cgImage else { return nil }\n        let w = Int(bounds.width)\n        let h = Int(bounds.height)\n        let bitsPerComponent = 8\n        let bytesPerRow = w * 4\n        let space = CGColorSpaceCreateDeviceRGB()\n        let bitmapInfo = CGImageAlphaInfo.premultipliedFirst.rawValue | CGBitmapInfo.byteOrder32Big.rawValue\n        var data = [UInt32](repeating: 0, count: w * h)\n        let context = CGContext(data: &data, width: w, height: h, bitsPerComponent: bitsPerComponent, bytesPerRow: bytesPerRow, space: space, bitmapInfo: bitmapInfo)\n        context?.draw(image, in: bounds)\n        return data\n    }\n}\n```\n\n注意点：\n- 这边简单操作，真实过程需要判断`ImageView`的`ContentMode`模型，根据不同的模式判断图片在视图中的位置\n- 获取像素数据时机中可以做缓存，没有必要每次都去重新读取\n- 索引处理先`Int`转换后再计算，否则会有偏差\n\n### 获取图片中点击位置的颜色(另一种方法)\n\n- 生成只容纳一像素的上下文\n- 根据点击位置对上下文进行平移并绘制，然后读取对应颜色\n```swift\nextension UIImageView {\n    func color2(for point: CGPoint) -> UIColor? {\n        let w = 1\n        let h = 1\n        let bitsPerComponent = 8\n        let bytesPerRow = w * 4\n        let space = CGColorSpaceCreateDeviceRGB()\n        let bitmapInfo = CGImageAlphaInfo.premultipliedFirst.rawValue | CGBitmapInfo.byteOrder32Big.rawValue\n        var data = [UInt32](repeating: 0, count: w * h)\n        guard let context = CGContext(data: &data, width: w, height: h, bitsPerComponent: bitsPerComponent, bytesPerRow: bytesPerRow, space: space, bitmapInfo: bitmapInfo)\n        else { return nil }\n        context.translateBy(x: -point.x, y: -point.y)\n        layer.render(in: context)\n        guard let component = data.first else { return nil }\n        return color(for: component)\n    }\n}\n```\n\n### 设置图片透明度\n```swift\nextension UIImage {\n    func setAlpha(_ a: CGFloat) -> UIImage? {\n        UIGraphicsBeginImageContextWithOptions(size, false, 0)\n        defer { UIGraphicsEndImageContext() }\n        guard let cgImage = cgImage,\n              let context = UIGraphicsGetCurrentContext()\n        else { return self }\n        context.scaleBy(x: 1, y: -1)\n        context.translateBy(x: 0, y: -size.height)\n        context.setBlendMode(.multiply)\n        context.setAlpha(a)\n        context.draw(cgImage, in: .init(origin: .zero, size: size))\n        return UIGraphicsGetImageFromCurrentImageContext()\n    }\n}\n```\n\n### 获取图片格式\n\n```swift\nextension Data {\n    enum ImageFormat {\n        case unknown\n        case PNG\n        case JPEG\n        case GIF\n        \n        struct HeaderData {\n            static var PNG: [UInt8] = [0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A]\n            static var JPEG_SOI: [UInt8] = [0xFF, 0xD8]\n            static var JPEG_IF: [UInt8] = [0xFF]\n            static var GIF: [UInt8] = [0x47, 0x49, 0x46]\n        }\n    }\n    \n    var imageFormat: ImageFormat {\n        guard count > 8 else { return .unknown }\n        \n        var buffer = [UInt8](repeating: 0, count: 8)\n        copyBytes(to: &buffer, count: 8)\n        \n        if buffer == ImageFormat.HeaderData.PNG {\n            return .PNG\n            \n        } else if buffer[0] == ImageFormat.HeaderData.JPEG_SOI[0],\n                  buffer[1] == ImageFormat.HeaderData.JPEG_SOI[1],\n                  buffer[2] == ImageFormat.HeaderData.JPEG_IF[0] {\n            return .JPEG\n            \n        } else if buffer[0] == ImageFormat.HeaderData.GIF[0],\n                  buffer[1] == ImageFormat.HeaderData.GIF[1],\n                  buffer[2] == ImageFormat.HeaderData.GIF[2] {\n            return .GIF\n        }\n        \n        return .unknown\n    }\n}\n```\n\n# 总结\n\n本篇内容就是有关`Bitmap`相关的算法与位图相关的知识，也是作为一个总结归纳和知识梳理，也同时收获到了很多新的思路。\n以上。","source":"_posts/2022/bitmap-0110.md","raw":"---\ntitle: \"Bitmap - 位的映射\"\ncatalog: true\ntoc_nav_num: true\ndate: 2022-01-10 19:00:08\nsubtitle: \"A mapping from some domain (for example, a range of integers) to bits\"\nheader-img: \"/img/article_header/article_header.png\"\nbusuanzi: true\ntags:\n- iOS - Swift\n\n---\n\n# 前言\n\n`BitMap`从字面的意思，很多人认为是位图，其实更准确的来说，是位的映射。下面我们分别从位映射算法和绘图中的绘图这两块内容来介绍`Bitmap`。\n\n# Bitmap 算法\n\n`Bitmap`的基本思想就是用一个`bit`位来标记某个元素对应的`Value`，而`Key`即是该元素。由于采用`bit`为单位来存储数据，所以在存储空间方面，可以大大节约空间。\n\n假设有这样一个需求：在20亿个随机整数中找出某个数是否存在，那么：\n- 如果每个数字用`UInt32`存储，占用的空间为`2_000_000_000 * 4 / 1024 / 1024 / 1024 ≈ 7.25G`\n- 如果按位存储，20亿个数字就是20亿位，占用空间为`2_000_000_000 / 8 / 1024 / 1024 / 1024 ≈ 0.23G`\n所以我们可以看出，按位存储在数据存储中所占有的优势。\n\n## 数据存储\n\n那么我们如果表示一个数呢？\n既然我们是按位存储，那么每一位就代表当前位置的数据是否存在，可以用0或者1表示，正好符合二进制。\n那么，我们就可以通过二进制表示数字，比如`{1, 3, 5, 7}`：\n\n<font color=red>1</font> | 0 | <font color=red>1</font> | 0 | <font color=red>1</font> | 0 | <font color=red>1</font> | 0\n:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:\n<font color=red>7</font> | 6 | <font color=red>5</font> | 4 | <font color=red>3</font> | 2 | <font color=red>1</font> | 0\n\n计算机内存分配的最小单位是字节，也就是8位，所以很容易表示小于8的数，那么对于`{10, 11, 14}`的数，可以在另一个8位上表示：\n\n<font color=red>1</font> | 0 | <font color=red>1</font> | 0 | <font color=red>1</font> | 0 | <font color=red>1</font> | 0\n:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:\n<font color=red>7</font> | 6 | <font color=red>5</font> | 4 | <font color=red>3</font> | 2 | <font color=red>1</font> | 0\n\n0 | <font color=red>1</font> | 0 | 0 | <font color=red>1</font> | <font color=red>1</font> | 0 | 0\n:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:\n15 | <font color=red>14</font> | 13 | 12 | <font color=red>11</font> | <font color=red>10</font> | 9 | 8\n\n一个`Int32`占32位，那么一个`Int32`可以存储32个数字，那么对于需要存储数字的最大值`N`，可以得到需要申请一个`let tmp: [Int32]`数组长度为`(1 + N / 32)`即可存储：\n```swift\ntmp[0]：可以表示0~31\ntmp[1]：可以表示31~63\ntmp[2]：可以表示64~95\n。。。\n```\n\n## 添加\n\n那我们如何将一个数字`P`放进去呢？\n我们就可以通过位运算`|或`，对于是存储在哪一个`Int32`，可以通过`P / 32`计算出。所以在`{1, 3, 5, 7}`中插入数字`6`：\n``` swift\n0x10101010 | (1 << 6) = 0x10101010 | 0x01000000 = 0x11101010\n// 转换为十进制：\n170 | 64 = 234\n```\n所以可以总结为：\n```swift\ntmp[P/8] |= 1 << (P % 8)\n```\n\n## 删除\n\n那么我们删除一个数字`Q`呢？\n我们可以通过位运算`&与`，与上同理找到对于存储的位置，然后对应删除数字`6`：\n```swift\n0x11101010 & ~(1 << 6) = 0x11101010 & 0x10111111 = 0x10101010\n// 转换为十进制\n234 & ~64 = 170\n```\n所以可以总结为：\n```swift\ntmp[Q/8] &= ~(1 << (Q % 8))\n```\n\n## 查找\n\n查找数字`R`就更简单了，可以通过位运算`&与`，判断`tmp[R/8] & (1 << (R % 8))`的结果值，如果为`1`则存在，`0`则不存在。\n\n## 用途\n\n那么这种`Bitmap`有什么用呢？\n可以进行大量数据的快速排序、查找和去重等等，那么我们就抓到了他的关键点，对于大量数据的存储和查找，这就可以引入到我们位图的概念。\n\n# Bitmap 位图\n\n## 概念\n\n**位图**，又称**栅格图(Raster Graphics)**或**点阵图**，是使用像素阵列(Pixel-array/Dot-matrix点阵)来表示的图像。\n\n位图的像素都分配有特定的位置和颜色值，每个像素的颜色信息由RGB组合或者灰度值表示。\n\n根据位深度,可将位图分为1、4、8、16、24及32位图像等。每个像素使用的信息位数越多，可用的颜色就越多，颜色表现就越逼真，相应的数据量越大。例如，位深度为 1 的像素位图只有两个可能的值（黑色和白色），所以又称为二值位图。位深度为 8 的图像有 2^8（即 256）个可能的值。位深度为 8 的灰度模式图像有 256 个可能的灰色值。\n\nRGB图像由三个颜色通道组成。8 位/通道的 RGB 图像中的每个通道有 256 个可能的值，这意味着该图像有 1600 万个以上可能的颜色值。有时将带有 8 位/通道 (bpc) 的 RGB 图像称作 24 位图像（8 位 x 3 通道 = 24 位数据/像素）。通常将使用24位RGB组合数据位表示的的位图称为真彩色位图。\n\n## iOS中的Bitmap\n\n在iOS中，`Bitmap`的数据由`CGImageRef`封装。如果要使用`Bitmap`对图片进行各种处理，就需要先创建位图上下文：\n```swift\nfunc createContext(_ image: CGImage) -> CGContext? {\n    let w = Int(image.width)\n    let h = Int(image.height)\n    let bitsPerComponent = 8\n    let bytesPerRow = w * 4\n    let space = CGColorSpaceCreateDeviceRGB()\n    let bitmapInfo = CGImageAlphaInfo.premultipliedLast.rawValue | CGBitmapInfo.byteOrder32Big.rawValue\n    let data = UnsafeMutablePointer<UInt32>.allocate(capacity: w * h)\n    let context = CGContext(data: data,\n                            width: w,\n                            height: h,\n                            bitsPerComponent: bitsPerComponent,\n                            bytesPerRow: bytesPerRow,\n                            space: space,\n                            bitmapInfo: bitmapInfo)\n    return context\n}\n```\n\n参数说明注释：\n```swift\nextension CGContext {\n    /// - Parameters:\n    ///   - data: 用于存放位图的点阵数组指针，当生成上下文并调用上下文的`draw`方法将指定图片或层级绘制到上下文后，data指针就会存储该图片的位图像素信息；我们可以对data里面的数据进行操作，通过创建`CGDataProvider`实例并调用`CGImage`的初始化方法重新生成图片\n    ///   - width: 位图宽\n    ///   - height: 位图高\n    ///   - bitsPerComponent: 每个颜色组件或alpha组件占用的`bite`值，对于32位图像值为8\n    ///   - bytesPerRow: 位图每一行占的字节数，对于32位图像一个像素有4`byte`(rgba)，值为w * 4\n    ///   - space: 颜色空间，RGBA -> CGColorSpaceCreateDeviceRGB(), CMYK -> CGColorSpaceCreateDeviceCMYK(), 灰度 -> CGColorSpaceCreateDeviceGray()\n    ///   - bitmapInfo: 一个常量，通常多枚举做或运算，描述位图上下文所对应的基本信息，具体见`CGBitmapInfo`和`CGImageAlphaInfo`描述\n    @available(iOS 2.0, *)\n    public /*not inherited*/ init?(data: UnsafeMutableRawPointer?, width: Int, height: Int, bitsPerComponent: Int, bytesPerRow: Int, space: CGColorSpace, bitmapInfo: UInt32)\n}\n```\n\n### CGBitmapInfo 和 CGImageAlphaInfo\n\n``` swift\npublic struct CGBitmapInfo : OptionSet {\n    public init(rawValue: UInt32)\n    public static var alphaInfoMask: CGBitmapInfo { get }\n    public static var floatInfoMask: CGBitmapInfo { get }\n    public static var floatComponents: CGBitmapInfo { get }    \n    public static var byteOrderMask: CGBitmapInfo { get }\n    public static var byteOrder16Little: CGBitmapInfo { get } // 16位小端模式\n    public static var byteOrder32Little: CGBitmapInfo { get } // 32位小端模式\n    public static var byteOrder16Big: CGBitmapInfo { get } // 16位大端模式\n    public static var byteOrder32Big: CGBitmapInfo { get } // 32位大端模式\n}\n\npublic enum CGImageAlphaInfo : UInt32 {\n    case none = 0 /* For example, RGB. */\n    case premultipliedLast = 1 /* For example, premultiplied RGBA */\n    case premultipliedFirst = 2 /* For example, premultiplied ARGB */\n    case last = 3 /* For example, non-premultiplied RGBA */\n    case first = 4 /* For example, non-premultiplied ARGB */\n    case noneSkipLast = 5 /* For example, RBGX. */\n    case noneSkipFirst = 6 /* For example, XRGB. */\n    case alphaOnly = 7 /* No color data, alpha data only */\n}\n```\n\n上面就是对于`CGBitmapInfo`和`CGImageAlphaInfo`的定义。\n\n我们先关注`CGImageAlphaInfo`，像素构成类型：\n- `last`和`first`分别代表`alpha`的分量在前置位还是后置位，在数据读取时是按照`RGBA`还是`ARGB`来读取的。\n- `premultiplied`代表预乘透明，比如对应`RGBA`为(0.5, 0.5, 0.5, 0.5)的色值，在预乘之后变为(0.25, 0.25, 0.25, 0.5)；所以带有`premultiplied`时，说明在图片解码压缩的时候，就将`alpha`通道的值分别乘到了颜色分量上，我们知道`alpha`就会影响颜色的透明度，我们如果在压缩的时候就将这步做完了，那么渲染的时候就不必再处理`alpha`通道了，这样在显示位图的时候直接显示就行了，这样就提高了性能。\n- `noneSkip`就代表了虽然有`alpha`分量，但是忽略`alpha`的值，相当于透明度不起作用；这样的话，我们可以获取到图片的`RGB`原始值。\n\n然后我们看一下`CGBitmapInfo`，像素存储格式：\n- `byteOrder16Big`和`byteOrder32Big`分别代表16和32位的大端模式\n   - 大端模式(Big-Endian)：高位字节排放在内存的低地址端，低位字节排放在内存的高地址段\n   - `0x12 | 0x34 | 0x56 | 0x78`（低到高）\n   - 对于`RGBA`在内存中的存放则是为`R | G | B | A`\n- `byteOrder16Little`和`byteOrder32Little`分别代表16和32位的小端模式\n   - 小端模式(Little-Endian)：低位字节排放在内存的低地址端，高位字节排放在内存的高地址段\n   - `0x78 | 0x56 | 0x34 | 0x12`（低到高）\n   - 对于`RGBA`在内存中的存放则是为`A | B | G | R`\n\n## 代码实践\n\n### 获取图片中点击位置的颜色\n\n- 获取`ImageView`控件的`bounds`作为像素范围大小\n- 通过`CGPoint`参数计算出该点对应与像素索引位置的像素数据\n- 逐个字节解析出rgb颜色分量和alpha分量值最后生成UIColor最为结果返回\n```swift\nextension UIImageView {\n    /// 工具坐标点获取颜色\n    func color(for point: CGPoint) -> UIColor? {\n        guard let pixels = pixels,\n              let index = indexForPixel(point)\n        else { return nil }\n        return color(for: pixels[index])\n    }\n\n    /// 解析像素点颜色\n    func color(for pixel: UInt32) -> UIColor {\n        let a = CGFloat(pixel & 0xff) / 255.0\n        let r = CGFloat((pixel >> 8) & 0xff) / 255.0\n        let g = CGFloat((pixel >> 16) & 0xff) / 255.0\n        let b = CGFloat((pixel >> 24) & 0xff) / 255.0\n        return UIColor(red: r, green: g, blue: b, alpha: a)\n    }\n    \n    /// 获取对应像素点索引\n    func indexForPixel(_ point: CGPoint) -> Int? {\n        guard bounds.contains(point) else { return nil }\n        return Int(bounds.width) * Int(point.y) + Int(point.x)\n    }\n    \n    /// 获取图片像素数据\n    var pixels: [UInt32]? {\n        guard let image = image?.cgImage else { return nil }\n        let w = Int(bounds.width)\n        let h = Int(bounds.height)\n        let bitsPerComponent = 8\n        let bytesPerRow = w * 4\n        let space = CGColorSpaceCreateDeviceRGB()\n        let bitmapInfo = CGImageAlphaInfo.premultipliedFirst.rawValue | CGBitmapInfo.byteOrder32Big.rawValue\n        var data = [UInt32](repeating: 0, count: w * h)\n        let context = CGContext(data: &data, width: w, height: h, bitsPerComponent: bitsPerComponent, bytesPerRow: bytesPerRow, space: space, bitmapInfo: bitmapInfo)\n        context?.draw(image, in: bounds)\n        return data\n    }\n}\n```\n\n注意点：\n- 这边简单操作，真实过程需要判断`ImageView`的`ContentMode`模型，根据不同的模式判断图片在视图中的位置\n- 获取像素数据时机中可以做缓存，没有必要每次都去重新读取\n- 索引处理先`Int`转换后再计算，否则会有偏差\n\n### 获取图片中点击位置的颜色(另一种方法)\n\n- 生成只容纳一像素的上下文\n- 根据点击位置对上下文进行平移并绘制，然后读取对应颜色\n```swift\nextension UIImageView {\n    func color2(for point: CGPoint) -> UIColor? {\n        let w = 1\n        let h = 1\n        let bitsPerComponent = 8\n        let bytesPerRow = w * 4\n        let space = CGColorSpaceCreateDeviceRGB()\n        let bitmapInfo = CGImageAlphaInfo.premultipliedFirst.rawValue | CGBitmapInfo.byteOrder32Big.rawValue\n        var data = [UInt32](repeating: 0, count: w * h)\n        guard let context = CGContext(data: &data, width: w, height: h, bitsPerComponent: bitsPerComponent, bytesPerRow: bytesPerRow, space: space, bitmapInfo: bitmapInfo)\n        else { return nil }\n        context.translateBy(x: -point.x, y: -point.y)\n        layer.render(in: context)\n        guard let component = data.first else { return nil }\n        return color(for: component)\n    }\n}\n```\n\n### 设置图片透明度\n```swift\nextension UIImage {\n    func setAlpha(_ a: CGFloat) -> UIImage? {\n        UIGraphicsBeginImageContextWithOptions(size, false, 0)\n        defer { UIGraphicsEndImageContext() }\n        guard let cgImage = cgImage,\n              let context = UIGraphicsGetCurrentContext()\n        else { return self }\n        context.scaleBy(x: 1, y: -1)\n        context.translateBy(x: 0, y: -size.height)\n        context.setBlendMode(.multiply)\n        context.setAlpha(a)\n        context.draw(cgImage, in: .init(origin: .zero, size: size))\n        return UIGraphicsGetImageFromCurrentImageContext()\n    }\n}\n```\n\n### 获取图片格式\n\n```swift\nextension Data {\n    enum ImageFormat {\n        case unknown\n        case PNG\n        case JPEG\n        case GIF\n        \n        struct HeaderData {\n            static var PNG: [UInt8] = [0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A]\n            static var JPEG_SOI: [UInt8] = [0xFF, 0xD8]\n            static var JPEG_IF: [UInt8] = [0xFF]\n            static var GIF: [UInt8] = [0x47, 0x49, 0x46]\n        }\n    }\n    \n    var imageFormat: ImageFormat {\n        guard count > 8 else { return .unknown }\n        \n        var buffer = [UInt8](repeating: 0, count: 8)\n        copyBytes(to: &buffer, count: 8)\n        \n        if buffer == ImageFormat.HeaderData.PNG {\n            return .PNG\n            \n        } else if buffer[0] == ImageFormat.HeaderData.JPEG_SOI[0],\n                  buffer[1] == ImageFormat.HeaderData.JPEG_SOI[1],\n                  buffer[2] == ImageFormat.HeaderData.JPEG_IF[0] {\n            return .JPEG\n            \n        } else if buffer[0] == ImageFormat.HeaderData.GIF[0],\n                  buffer[1] == ImageFormat.HeaderData.GIF[1],\n                  buffer[2] == ImageFormat.HeaderData.GIF[2] {\n            return .GIF\n        }\n        \n        return .unknown\n    }\n}\n```\n\n# 总结\n\n本篇内容就是有关`Bitmap`相关的算法与位图相关的知识，也是作为一个总结归纳和知识梳理，也同时收获到了很多新的思路。\n以上。","slug":"2022/bitmap-0110","published":1,"updated":"2022-01-20T03:11:30.161Z","_id":"cky9y7xz000008fqh7eoyg0do","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"前言\">前言</h1>\n<p><code>BitMap</code>从字面的意思，很多人认为是位图，其实更准确的来说，是位的映射。下面我们分别从位映射算法和绘图中的绘图这两块内容来介绍<code>Bitmap</code>。</p>\n<h1 id=\"bitmap-算法\">Bitmap 算法</h1>\n<p><code>Bitmap</code>的基本思想就是用一个<code>bit</code>位来标记某个元素对应的<code>Value</code>，而<code>Key</code>即是该元素。由于采用<code>bit</code>为单位来存储数据，所以在存储空间方面，可以大大节约空间。</p>\n<p>假设有这样一个需求：在20亿个随机整数中找出某个数是否存在，那么：</p>\n<ul>\n<li>如果每个数字用<code>UInt32</code>存储，占用的空间为<code>2_000_000_000 * 4 / 1024 / 1024 / 1024 ≈ 7.25G</code></li>\n<li>如果按位存储，20亿个数字就是20亿位，占用空间为<code>2_000_000_000 / 8 / 1024 / 1024 / 1024 ≈ 0.23G</code><br>\n所以我们可以看出，按位存储在数据存储中所占有的优势。</li>\n</ul>\n<h2 id=\"数据存储\">数据存储</h2>\n<p>那么我们如果表示一个数呢？<br>\n既然我们是按位存储，那么每一位就代表当前位置的数据是否存在，可以用0或者1表示，正好符合二进制。<br>\n那么，我们就可以通过二进制表示数字，比如<code>{1, 3, 5, 7}</code>：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\"><font color=\"red\">1</font></th>\n<th style=\"text-align:center\">0</th>\n<th style=\"text-align:center\"><font color=\"red\">1</font></th>\n<th style=\"text-align:center\">0</th>\n<th style=\"text-align:center\"><font color=\"red\">1</font></th>\n<th style=\"text-align:center\">0</th>\n<th style=\"text-align:center\"><font color=\"red\">1</font></th>\n<th style=\"text-align:center\">0</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"><font color=\"red\">7</font></td>\n<td style=\"text-align:center\">6</td>\n<td style=\"text-align:center\"><font color=\"red\">5</font></td>\n<td style=\"text-align:center\">4</td>\n<td style=\"text-align:center\"><font color=\"red\">3</font></td>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:center\"><font color=\"red\">1</font></td>\n<td style=\"text-align:center\">0</td>\n</tr>\n</tbody>\n</table>\n<p>计算机内存分配的最小单位是字节，也就是8位，所以很容易表示小于8的数，那么对于<code>{10, 11, 14}</code>的数，可以在另一个8位上表示：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\"><font color=\"red\">1</font></th>\n<th style=\"text-align:center\">0</th>\n<th style=\"text-align:center\"><font color=\"red\">1</font></th>\n<th style=\"text-align:center\">0</th>\n<th style=\"text-align:center\"><font color=\"red\">1</font></th>\n<th style=\"text-align:center\">0</th>\n<th style=\"text-align:center\"><font color=\"red\">1</font></th>\n<th style=\"text-align:center\">0</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"><font color=\"red\">7</font></td>\n<td style=\"text-align:center\">6</td>\n<td style=\"text-align:center\"><font color=\"red\">5</font></td>\n<td style=\"text-align:center\">4</td>\n<td style=\"text-align:center\"><font color=\"red\">3</font></td>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:center\"><font color=\"red\">1</font></td>\n<td style=\"text-align:center\">0</td>\n</tr>\n</tbody>\n</table>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">0</th>\n<th style=\"text-align:center\"><font color=\"red\">1</font></th>\n<th style=\"text-align:center\">0</th>\n<th style=\"text-align:center\">0</th>\n<th style=\"text-align:center\"><font color=\"red\">1</font></th>\n<th style=\"text-align:center\"><font color=\"red\">1</font></th>\n<th style=\"text-align:center\">0</th>\n<th style=\"text-align:center\">0</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">15</td>\n<td style=\"text-align:center\"><font color=\"red\">14</font></td>\n<td style=\"text-align:center\">13</td>\n<td style=\"text-align:center\">12</td>\n<td style=\"text-align:center\"><font color=\"red\">11</font></td>\n<td style=\"text-align:center\"><font color=\"red\">10</font></td>\n<td style=\"text-align:center\">9</td>\n<td style=\"text-align:center\">8</td>\n</tr>\n</tbody>\n</table>\n<p>一个<code>Int32</code>占32位，那么一个<code>Int32</code>可以存储32个数字，那么对于需要存储数字的最大值<code>N</code>，可以得到需要申请一个<code>let tmp: [Int32]</code>数组长度为<code>(1 + N / 32)</code>即可存储：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tmp[<span class=\"number\">0</span>]：可以表示<span class=\"number\">0</span>~<span class=\"number\">31</span></span><br><span class=\"line\">tmp[<span class=\"number\">1</span>]：可以表示<span class=\"number\">31</span>~<span class=\"number\">63</span></span><br><span class=\"line\">tmp[<span class=\"number\">2</span>]：可以表示<span class=\"number\">64</span>~<span class=\"number\">95</span></span><br><span class=\"line\">。。。</span><br></pre></td></tr></table></figure>\n<h2 id=\"添加\">添加</h2>\n<p>那我们如何将一个数字<code>P</code>放进去呢？<br>\n我们就可以通过位运算<code>|或</code>，对于是存储在哪一个<code>Int32</code>，可以通过<code>P / 32</code>计算出。所以在<code>{1, 3, 5, 7}</code>中插入数字<code>6</code>：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">0x10101010</span> | (<span class=\"number\">1</span> &lt;&lt; <span class=\"number\">6</span>) = <span class=\"number\">0x10101010</span> | <span class=\"number\">0x01000000</span> = <span class=\"number\">0x11101010</span></span><br><span class=\"line\"><span class=\"comment\">// 转换为十进制：</span></span><br><span class=\"line\"><span class=\"number\">170</span> | <span class=\"number\">64</span> = <span class=\"number\">234</span></span><br></pre></td></tr></table></figure>\n<p>所以可以总结为：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tmp[<span class=\"type\">P</span>/<span class=\"number\">8</span>] |= <span class=\"number\">1</span> &lt;&lt; (<span class=\"type\">P</span> % <span class=\"number\">8</span>)</span><br></pre></td></tr></table></figure>\n<h2 id=\"删除\">删除</h2>\n<p>那么我们删除一个数字<code>Q</code>呢？<br>\n我们可以通过位运算<code>&amp;与</code>，与上同理找到对于存储的位置，然后对应删除数字<code>6</code>：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">0x11101010</span> &amp; ~(<span class=\"number\">1</span> &lt;&lt; <span class=\"number\">6</span>) = <span class=\"number\">0x11101010</span> &amp; <span class=\"number\">0x10111111</span> = <span class=\"number\">0x10101010</span></span><br><span class=\"line\"><span class=\"comment\">// 转换为十进制</span></span><br><span class=\"line\"><span class=\"number\">234</span> &amp; ~<span class=\"number\">64</span> = <span class=\"number\">170</span></span><br></pre></td></tr></table></figure>\n<p>所以可以总结为：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tmp[<span class=\"type\">Q</span>/<span class=\"number\">8</span>] &amp;= ~(<span class=\"number\">1</span> &lt;&lt; (<span class=\"type\">Q</span> % <span class=\"number\">8</span>))</span><br></pre></td></tr></table></figure>\n<h2 id=\"查找\">查找</h2>\n<p>查找数字<code>R</code>就更简单了，可以通过位运算<code>&amp;与</code>，判断<code>tmp[R/8] &amp; (1 &lt;&lt; (R % 8))</code>的结果值，如果为<code>1</code>则存在，<code>0</code>则不存在。</p>\n<h2 id=\"用途\">用途</h2>\n<p>那么这种<code>Bitmap</code>有什么用呢？<br>\n可以进行大量数据的快速排序、查找和去重等等，那么我们就抓到了他的关键点，对于大量数据的存储和查找，这就可以引入到我们位图的概念。</p>\n<h1 id=\"bitmap-位图\">Bitmap 位图</h1>\n<h2 id=\"概念\">概念</h2>\n<p><strong>位图</strong>，又称<strong>栅格图(Raster Graphics)<strong>或</strong>点阵图</strong>，是使用像素阵列(Pixel-array/Dot-matrix点阵)来表示的图像。</p>\n<p>位图的像素都分配有特定的位置和颜色值，每个像素的颜色信息由RGB组合或者灰度值表示。</p>\n<p>根据位深度,可将位图分为1、4、8、16、24及32位图像等。每个像素使用的信息位数越多，可用的颜色就越多，颜色表现就越逼真，相应的数据量越大。例如，位深度为 1 的像素位图只有两个可能的值（黑色和白色），所以又称为二值位图。位深度为 8 的图像有 2^8（即 256）个可能的值。位深度为 8 的灰度模式图像有 256 个可能的灰色值。</p>\n<p>RGB图像由三个颜色通道组成。8 位/通道的 RGB 图像中的每个通道有 256 个可能的值，这意味着该图像有 1600 万个以上可能的颜色值。有时将带有 8 位/通道 (bpc) 的 RGB 图像称作 24 位图像（8 位 x 3 通道 = 24 位数据/像素）。通常将使用24位RGB组合数据位表示的的位图称为真彩色位图。</p>\n<h2 id=\"ios中的bitmap\">iOS中的Bitmap</h2>\n<p>在iOS中，<code>Bitmap</code>的数据由<code>CGImageRef</code>封装。如果要使用<code>Bitmap</code>对图片进行各种处理，就需要先创建位图上下文：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">createContext</span><span class=\"params\">(<span class=\"number\">_</span> image: CGImage)</span></span> -&gt; <span class=\"type\">CGContext</span>? &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> w = <span class=\"type\">Int</span>(image.width)</span><br><span class=\"line\">    <span class=\"keyword\">let</span> h = <span class=\"type\">Int</span>(image.height)</span><br><span class=\"line\">    <span class=\"keyword\">let</span> bitsPerComponent = <span class=\"number\">8</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> bytesPerRow = w * <span class=\"number\">4</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> space = <span class=\"type\">CGColorSpaceCreateDeviceRGB</span>()</span><br><span class=\"line\">    <span class=\"keyword\">let</span> bitmapInfo = <span class=\"type\">CGImageAlphaInfo</span>.premultipliedLast.rawValue | <span class=\"type\">CGBitmapInfo</span>.byteOrder32Big.rawValue</span><br><span class=\"line\">    <span class=\"keyword\">let</span> data = <span class=\"type\">UnsafeMutablePointer</span>&lt;<span class=\"type\">UInt32</span>&gt;.allocate(capacity: w * h)</span><br><span class=\"line\">    <span class=\"keyword\">let</span> context = <span class=\"type\">CGContext</span>(data: data,</span><br><span class=\"line\">                            width: w,</span><br><span class=\"line\">                            height: h,</span><br><span class=\"line\">                            bitsPerComponent: bitsPerComponent,</span><br><span class=\"line\">                            bytesPerRow: bytesPerRow,</span><br><span class=\"line\">                            space: space,</span><br><span class=\"line\">                            bitmapInfo: bitmapInfo)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> context</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>参数说明注释：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">CGContext</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/// - Parameters:</span></span><br><span class=\"line\">    <span class=\"comment\">///   - data: 用于存放位图的点阵数组指针，当生成上下文并调用上下文的`draw`方法将指定图片或层级绘制到上下文后，data指针就会存储该图片的位图像素信息；我们可以对data里面的数据进行操作，通过创建`CGDataProvider`实例并调用`CGImage`的初始化方法重新生成图片</span></span><br><span class=\"line\">    <span class=\"comment\">///   - width: 位图宽</span></span><br><span class=\"line\">    <span class=\"comment\">///   - height: 位图高</span></span><br><span class=\"line\">    <span class=\"comment\">///   - bitsPerComponent: 每个颜色组件或alpha组件占用的`bite`值，对于32位图像值为8</span></span><br><span class=\"line\">    <span class=\"comment\">///   - bytesPerRow: 位图每一行占的字节数，对于32位图像一个像素有4`byte`(rgba)，值为w * 4</span></span><br><span class=\"line\">    <span class=\"comment\">///   - space: 颜色空间，RGBA -&gt; CGColorSpaceCreateDeviceRGB(), CMYK -&gt; CGColorSpaceCreateDeviceCMYK(), 灰度 -&gt; CGColorSpaceCreateDeviceGray()</span></span><br><span class=\"line\">    <span class=\"comment\">///   - bitmapInfo: 一个常量，通常多枚举做或运算，描述位图上下文所对应的基本信息，具体见`CGBitmapInfo`和`CGImageAlphaInfo`描述</span></span><br><span class=\"line\">    <span class=\"meta\">@available</span>(iOS <span class=\"number\">2.0</span>, *)</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"comment\">/*not inherited*/</span> <span class=\"keyword\">init</span>?(data: <span class=\"type\">UnsafeMutableRawPointer</span>?, width: <span class=\"type\">Int</span>, height: <span class=\"type\">Int</span>, bitsPerComponent: <span class=\"type\">Int</span>, bytesPerRow: <span class=\"type\">Int</span>, space: <span class=\"type\">CGColorSpace</span>, bitmapInfo: <span class=\"type\">UInt32</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"cgbitmapinfo-和-cgimagealphainfo\">CGBitmapInfo 和 CGImageAlphaInfo</h3>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">CGBitmapInfo</span> : <span class=\"title\">OptionSet</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">init</span>(rawValue: <span class=\"type\">UInt32</span>)</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">var</span> alphaInfoMask: <span class=\"type\">CGBitmapInfo</span> &#123; <span class=\"keyword\">get</span> &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">var</span> floatInfoMask: <span class=\"type\">CGBitmapInfo</span> &#123; <span class=\"keyword\">get</span> &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">var</span> floatComponents: <span class=\"type\">CGBitmapInfo</span> &#123; <span class=\"keyword\">get</span> &#125;    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">var</span> byteOrderMask: <span class=\"type\">CGBitmapInfo</span> &#123; <span class=\"keyword\">get</span> &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">var</span> byteOrder16Little: <span class=\"type\">CGBitmapInfo</span> &#123; <span class=\"keyword\">get</span> &#125; <span class=\"comment\">// 16位小端模式</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">var</span> byteOrder32Little: <span class=\"type\">CGBitmapInfo</span> &#123; <span class=\"keyword\">get</span> &#125; <span class=\"comment\">// 32位小端模式</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">var</span> byteOrder16Big: <span class=\"type\">CGBitmapInfo</span> &#123; <span class=\"keyword\">get</span> &#125; <span class=\"comment\">// 16位大端模式</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">var</span> byteOrder32Big: <span class=\"type\">CGBitmapInfo</span> &#123; <span class=\"keyword\">get</span> &#125; <span class=\"comment\">// 32位大端模式</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">CGImageAlphaInfo</span> : <span class=\"title\">UInt32</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"keyword\">none</span> = <span class=\"number\">0</span> <span class=\"comment\">/* For example, RGB. */</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> premultipliedLast = <span class=\"number\">1</span> <span class=\"comment\">/* For example, premultiplied RGBA */</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> premultipliedFirst = <span class=\"number\">2</span> <span class=\"comment\">/* For example, premultiplied ARGB */</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> last = <span class=\"number\">3</span> <span class=\"comment\">/* For example, non-premultiplied RGBA */</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> first = <span class=\"number\">4</span> <span class=\"comment\">/* For example, non-premultiplied ARGB */</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> noneSkipLast = <span class=\"number\">5</span> <span class=\"comment\">/* For example, RBGX. */</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> noneSkipFirst = <span class=\"number\">6</span> <span class=\"comment\">/* For example, XRGB. */</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> alphaOnly = <span class=\"number\">7</span> <span class=\"comment\">/* No color data, alpha data only */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面就是对于<code>CGBitmapInfo</code>和<code>CGImageAlphaInfo</code>的定义。</p>\n<p>我们先关注<code>CGImageAlphaInfo</code>，像素构成类型：</p>\n<ul>\n<li><code>last</code>和<code>first</code>分别代表<code>alpha</code>的分量在前置位还是后置位，在数据读取时是按照<code>RGBA</code>还是<code>ARGB</code>来读取的。</li>\n<li><code>premultiplied</code>代表预乘透明，比如对应<code>RGBA</code>为(0.5, 0.5, 0.5, 0.5)的色值，在预乘之后变为(0.25, 0.25, 0.25, 0.5)；所以带有<code>premultiplied</code>时，说明在图片解码压缩的时候，就将<code>alpha</code>通道的值分别乘到了颜色分量上，我们知道<code>alpha</code>就会影响颜色的透明度，我们如果在压缩的时候就将这步做完了，那么渲染的时候就不必再处理<code>alpha</code>通道了，这样在显示位图的时候直接显示就行了，这样就提高了性能。</li>\n<li><code>noneSkip</code>就代表了虽然有<code>alpha</code>分量，但是忽略<code>alpha</code>的值，相当于透明度不起作用；这样的话，我们可以获取到图片的<code>RGB</code>原始值。</li>\n</ul>\n<p>然后我们看一下<code>CGBitmapInfo</code>，像素存储格式：</p>\n<ul>\n<li><code>byteOrder16Big</code>和<code>byteOrder32Big</code>分别代表16和32位的大端模式\n<ul>\n<li>大端模式(Big-Endian)：高位字节排放在内存的低地址端，低位字节排放在内存的高地址段</li>\n<li><code>0x12 | 0x34 | 0x56 | 0x78</code>（低到高）</li>\n<li>对于<code>RGBA</code>在内存中的存放则是为<code>R | G | B | A</code></li>\n</ul>\n</li>\n<li><code>byteOrder16Little</code>和<code>byteOrder32Little</code>分别代表16和32位的小端模式\n<ul>\n<li>小端模式(Little-Endian)：低位字节排放在内存的低地址端，高位字节排放在内存的高地址段</li>\n<li><code>0x78 | 0x56 | 0x34 | 0x12</code>（低到高）</li>\n<li>对于<code>RGBA</code>在内存中的存放则是为<code>A | B | G | R</code></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"代码实践\">代码实践</h2>\n<h3 id=\"获取图片中点击位置的颜色\">获取图片中点击位置的颜色</h3>\n<ul>\n<li>获取<code>ImageView</code>控件的<code>bounds</code>作为像素范围大小</li>\n<li>通过<code>CGPoint</code>参数计算出该点对应与像素索引位置的像素数据</li>\n<li>逐个字节解析出rgb颜色分量和alpha分量值最后生成UIColor最为结果返回</li>\n</ul>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">UIImageView</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/// 工具坐标点获取颜色</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">color</span><span class=\"params\">(<span class=\"keyword\">for</span> point: CGPoint)</span></span> -&gt; <span class=\"type\">UIColor</span>? &#123;</span><br><span class=\"line\">        <span class=\"keyword\">guard</span> <span class=\"keyword\">let</span> pixels = pixels,</span><br><span class=\"line\">              <span class=\"keyword\">let</span> index = indexForPixel(point)</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123; <span class=\"keyword\">return</span> <span class=\"literal\">nil</span> &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> color(<span class=\"keyword\">for</span>: pixels[index])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// 解析像素点颜色</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">color</span><span class=\"params\">(<span class=\"keyword\">for</span> pixel: UInt32)</span></span> -&gt; <span class=\"type\">UIColor</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> a = <span class=\"type\">CGFloat</span>(pixel &amp; <span class=\"number\">0xff</span>) / <span class=\"number\">255.0</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> r = <span class=\"type\">CGFloat</span>((pixel &gt;&gt; <span class=\"number\">8</span>) &amp; <span class=\"number\">0xff</span>) / <span class=\"number\">255.0</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> g = <span class=\"type\">CGFloat</span>((pixel &gt;&gt; <span class=\"number\">16</span>) &amp; <span class=\"number\">0xff</span>) / <span class=\"number\">255.0</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> b = <span class=\"type\">CGFloat</span>((pixel &gt;&gt; <span class=\"number\">24</span>) &amp; <span class=\"number\">0xff</span>) / <span class=\"number\">255.0</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"type\">UIColor</span>(red: r, green: g, blue: b, alpha: a)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/// 获取对应像素点索引</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">indexForPixel</span><span class=\"params\">(<span class=\"number\">_</span> point: CGPoint)</span></span> -&gt; <span class=\"type\">Int</span>? &#123;</span><br><span class=\"line\">        <span class=\"keyword\">guard</span> bounds.<span class=\"built_in\">contains</span>(point) <span class=\"keyword\">else</span> &#123; <span class=\"keyword\">return</span> <span class=\"literal\">nil</span> &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"type\">Int</span>(bounds.width) * <span class=\"type\">Int</span>(point.y) + <span class=\"type\">Int</span>(point.x)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/// 获取图片像素数据</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> pixels: [<span class=\"type\">UInt32</span>]? &#123;</span><br><span class=\"line\">        <span class=\"keyword\">guard</span> <span class=\"keyword\">let</span> image = image?.cgImage <span class=\"keyword\">else</span> &#123; <span class=\"keyword\">return</span> <span class=\"literal\">nil</span> &#125;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> w = <span class=\"type\">Int</span>(bounds.width)</span><br><span class=\"line\">        <span class=\"keyword\">let</span> h = <span class=\"type\">Int</span>(bounds.height)</span><br><span class=\"line\">        <span class=\"keyword\">let</span> bitsPerComponent = <span class=\"number\">8</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> bytesPerRow = w * <span class=\"number\">4</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> space = <span class=\"type\">CGColorSpaceCreateDeviceRGB</span>()</span><br><span class=\"line\">        <span class=\"keyword\">let</span> bitmapInfo = <span class=\"type\">CGImageAlphaInfo</span>.premultipliedFirst.rawValue | <span class=\"type\">CGBitmapInfo</span>.byteOrder32Big.rawValue</span><br><span class=\"line\">        <span class=\"keyword\">var</span> data = [<span class=\"type\">UInt32</span>](repeating: <span class=\"number\">0</span>, <span class=\"built_in\">count</span>: w * h)</span><br><span class=\"line\">        <span class=\"keyword\">let</span> context = <span class=\"type\">CGContext</span>(data: &amp;data, width: w, height: h, bitsPerComponent: bitsPerComponent, bytesPerRow: bytesPerRow, space: space, bitmapInfo: bitmapInfo)</span><br><span class=\"line\">        context?.draw(image, <span class=\"keyword\">in</span>: bounds)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> data</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意点：</p>\n<ul>\n<li>这边简单操作，真实过程需要判断<code>ImageView</code>的<code>ContentMode</code>模型，根据不同的模式判断图片在视图中的位置</li>\n<li>获取像素数据时机中可以做缓存，没有必要每次都去重新读取</li>\n<li>索引处理先<code>Int</code>转换后再计算，否则会有偏差</li>\n</ul>\n<h3 id=\"获取图片中点击位置的颜色另一种方法\">获取图片中点击位置的颜色(另一种方法)</h3>\n<ul>\n<li>生成只容纳一像素的上下文</li>\n<li>根据点击位置对上下文进行平移并绘制，然后读取对应颜色</li>\n</ul>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">UIImageView</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">color2</span><span class=\"params\">(<span class=\"keyword\">for</span> point: CGPoint)</span></span> -&gt; <span class=\"type\">UIColor</span>? &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> w = <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> h = <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> bitsPerComponent = <span class=\"number\">8</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> bytesPerRow = w * <span class=\"number\">4</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> space = <span class=\"type\">CGColorSpaceCreateDeviceRGB</span>()</span><br><span class=\"line\">        <span class=\"keyword\">let</span> bitmapInfo = <span class=\"type\">CGImageAlphaInfo</span>.premultipliedFirst.rawValue | <span class=\"type\">CGBitmapInfo</span>.byteOrder32Big.rawValue</span><br><span class=\"line\">        <span class=\"keyword\">var</span> data = [<span class=\"type\">UInt32</span>](repeating: <span class=\"number\">0</span>, <span class=\"built_in\">count</span>: w * h)</span><br><span class=\"line\">        <span class=\"keyword\">guard</span> <span class=\"keyword\">let</span> context = <span class=\"type\">CGContext</span>(data: &amp;data, width: w, height: h, bitsPerComponent: bitsPerComponent, bytesPerRow: bytesPerRow, space: space, bitmapInfo: bitmapInfo)</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123; <span class=\"keyword\">return</span> <span class=\"literal\">nil</span> &#125;</span><br><span class=\"line\">        context.translateBy(x: -point.x, y: -point.y)</span><br><span class=\"line\">        layer.render(<span class=\"keyword\">in</span>: context)</span><br><span class=\"line\">        <span class=\"keyword\">guard</span> <span class=\"keyword\">let</span> component = data.first <span class=\"keyword\">else</span> &#123; <span class=\"keyword\">return</span> <span class=\"literal\">nil</span> &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> color(<span class=\"keyword\">for</span>: component)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"设置图片透明度\">设置图片透明度</h3>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">UIImage</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">setAlpha</span><span class=\"params\">(<span class=\"number\">_</span> a: CGFloat)</span></span> -&gt; <span class=\"type\">UIImage</span>? &#123;</span><br><span class=\"line\">        <span class=\"type\">UIGraphicsBeginImageContextWithOptions</span>(size, <span class=\"literal\">false</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">defer</span> &#123; <span class=\"type\">UIGraphicsEndImageContext</span>() &#125;</span><br><span class=\"line\">        <span class=\"keyword\">guard</span> <span class=\"keyword\">let</span> cgImage = cgImage,</span><br><span class=\"line\">              <span class=\"keyword\">let</span> context = <span class=\"type\">UIGraphicsGetCurrentContext</span>()</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123; <span class=\"keyword\">return</span> <span class=\"keyword\">self</span> &#125;</span><br><span class=\"line\">        context.scaleBy(x: <span class=\"number\">1</span>, y: -<span class=\"number\">1</span>)</span><br><span class=\"line\">        context.translateBy(x: <span class=\"number\">0</span>, y: -size.height)</span><br><span class=\"line\">        context.setBlendMode(.multiply)</span><br><span class=\"line\">        context.setAlpha(a)</span><br><span class=\"line\">        context.draw(cgImage, <span class=\"keyword\">in</span>: .<span class=\"keyword\">init</span>(origin: .zero, size: size))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"type\">UIGraphicsGetImageFromCurrentImageContext</span>()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"获取图片格式\">获取图片格式</h3>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">Data</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">ImageFormat</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> unknown</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"type\">PNG</span></span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"type\">JPEG</span></span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"type\">GIF</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">HeaderData</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">static</span> <span class=\"keyword\">var</span> <span class=\"type\">PNG</span>: [<span class=\"type\">UInt8</span>] = [<span class=\"number\">0x89</span>, <span class=\"number\">0x50</span>, <span class=\"number\">0x4E</span>, <span class=\"number\">0x47</span>, <span class=\"number\">0x0D</span>, <span class=\"number\">0x0A</span>, <span class=\"number\">0x1A</span>, <span class=\"number\">0x0A</span>]</span><br><span class=\"line\">            <span class=\"keyword\">static</span> <span class=\"keyword\">var</span> <span class=\"type\">JPEG_SOI</span>: [<span class=\"type\">UInt8</span>] = [<span class=\"number\">0xFF</span>, <span class=\"number\">0xD8</span>]</span><br><span class=\"line\">            <span class=\"keyword\">static</span> <span class=\"keyword\">var</span> <span class=\"type\">JPEG_IF</span>: [<span class=\"type\">UInt8</span>] = [<span class=\"number\">0xFF</span>]</span><br><span class=\"line\">            <span class=\"keyword\">static</span> <span class=\"keyword\">var</span> <span class=\"type\">GIF</span>: [<span class=\"type\">UInt8</span>] = [<span class=\"number\">0x47</span>, <span class=\"number\">0x49</span>, <span class=\"number\">0x46</span>]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">var</span> imageFormat: <span class=\"type\">ImageFormat</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">guard</span> <span class=\"built_in\">count</span> &gt; <span class=\"number\">8</span> <span class=\"keyword\">else</span> &#123; <span class=\"keyword\">return</span> .unknown &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">var</span> buffer = [<span class=\"type\">UInt8</span>](repeating: <span class=\"number\">0</span>, <span class=\"built_in\">count</span>: <span class=\"number\">8</span>)</span><br><span class=\"line\">        copyBytes(to: &amp;buffer, <span class=\"built_in\">count</span>: <span class=\"number\">8</span>)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> buffer == <span class=\"type\">ImageFormat</span>.<span class=\"type\">HeaderData</span>.<span class=\"type\">PNG</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> .<span class=\"type\">PNG</span></span><br><span class=\"line\">            </span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> buffer[<span class=\"number\">0</span>] == <span class=\"type\">ImageFormat</span>.<span class=\"type\">HeaderData</span>.<span class=\"type\">JPEG_SOI</span>[<span class=\"number\">0</span>],</span><br><span class=\"line\">                  buffer[<span class=\"number\">1</span>] == <span class=\"type\">ImageFormat</span>.<span class=\"type\">HeaderData</span>.<span class=\"type\">JPEG_SOI</span>[<span class=\"number\">1</span>],</span><br><span class=\"line\">                  buffer[<span class=\"number\">2</span>] == <span class=\"type\">ImageFormat</span>.<span class=\"type\">HeaderData</span>.<span class=\"type\">JPEG_IF</span>[<span class=\"number\">0</span>] &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> .<span class=\"type\">JPEG</span></span><br><span class=\"line\">            </span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> buffer[<span class=\"number\">0</span>] == <span class=\"type\">ImageFormat</span>.<span class=\"type\">HeaderData</span>.<span class=\"type\">GIF</span>[<span class=\"number\">0</span>],</span><br><span class=\"line\">                  buffer[<span class=\"number\">1</span>] == <span class=\"type\">ImageFormat</span>.<span class=\"type\">HeaderData</span>.<span class=\"type\">GIF</span>[<span class=\"number\">1</span>],</span><br><span class=\"line\">                  buffer[<span class=\"number\">2</span>] == <span class=\"type\">ImageFormat</span>.<span class=\"type\">HeaderData</span>.<span class=\"type\">GIF</span>[<span class=\"number\">2</span>] &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> .<span class=\"type\">GIF</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> .unknown</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"总结\">总结</h1>\n<p>本篇内容就是有关<code>Bitmap</code>相关的算法与位图相关的知识，也是作为一个总结归纳和知识梳理，也同时收获到了很多新的思路。<br>\n以上。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1>前言</h1>\n<p><code>BitMap</code>从字面的意思，很多人认为是位图，其实更准确的来说，是位的映射。下面我们分别从位映射算法和绘图中的绘图这两块内容来介绍<code>Bitmap</code>。</p>\n<h1>Bitmap 算法</h1>\n<p><code>Bitmap</code>的基本思想就是用一个<code>bit</code>位来标记某个元素对应的<code>Value</code>，而<code>Key</code>即是该元素。由于采用<code>bit</code>为单位来存储数据，所以在存储空间方面，可以大大节约空间。</p>\n<p>假设有这样一个需求：在20亿个随机整数中找出某个数是否存在，那么：</p>\n<ul>\n<li>如果每个数字用<code>UInt32</code>存储，占用的空间为<code>2_000_000_000 * 4 / 1024 / 1024 / 1024 ≈ 7.25G</code></li>\n<li>如果按位存储，20亿个数字就是20亿位，占用空间为<code>2_000_000_000 / 8 / 1024 / 1024 / 1024 ≈ 0.23G</code><br>\n所以我们可以看出，按位存储在数据存储中所占有的优势。</li>\n</ul>\n<h2>数据存储</h2>\n<p>那么我们如果表示一个数呢？<br>\n既然我们是按位存储，那么每一位就代表当前位置的数据是否存在，可以用0或者1表示，正好符合二进制。<br>\n那么，我们就可以通过二进制表示数字，比如<code>{1, 3, 5, 7}</code>：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\"><font color=\"red\">1</font></th>\n<th style=\"text-align:center\">0</th>\n<th style=\"text-align:center\"><font color=\"red\">1</font></th>\n<th style=\"text-align:center\">0</th>\n<th style=\"text-align:center\"><font color=\"red\">1</font></th>\n<th style=\"text-align:center\">0</th>\n<th style=\"text-align:center\"><font color=\"red\">1</font></th>\n<th style=\"text-align:center\">0</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"><font color=\"red\">7</font></td>\n<td style=\"text-align:center\">6</td>\n<td style=\"text-align:center\"><font color=\"red\">5</font></td>\n<td style=\"text-align:center\">4</td>\n<td style=\"text-align:center\"><font color=\"red\">3</font></td>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:center\"><font color=\"red\">1</font></td>\n<td style=\"text-align:center\">0</td>\n</tr>\n</tbody>\n</table>\n<p>计算机内存分配的最小单位是字节，也就是8位，所以很容易表示小于8的数，那么对于<code>{10, 11, 14}</code>的数，可以在另一个8位上表示：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\"><font color=\"red\">1</font></th>\n<th style=\"text-align:center\">0</th>\n<th style=\"text-align:center\"><font color=\"red\">1</font></th>\n<th style=\"text-align:center\">0</th>\n<th style=\"text-align:center\"><font color=\"red\">1</font></th>\n<th style=\"text-align:center\">0</th>\n<th style=\"text-align:center\"><font color=\"red\">1</font></th>\n<th style=\"text-align:center\">0</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"><font color=\"red\">7</font></td>\n<td style=\"text-align:center\">6</td>\n<td style=\"text-align:center\"><font color=\"red\">5</font></td>\n<td style=\"text-align:center\">4</td>\n<td style=\"text-align:center\"><font color=\"red\">3</font></td>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:center\"><font color=\"red\">1</font></td>\n<td style=\"text-align:center\">0</td>\n</tr>\n</tbody>\n</table>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">0</th>\n<th style=\"text-align:center\"><font color=\"red\">1</font></th>\n<th style=\"text-align:center\">0</th>\n<th style=\"text-align:center\">0</th>\n<th style=\"text-align:center\"><font color=\"red\">1</font></th>\n<th style=\"text-align:center\"><font color=\"red\">1</font></th>\n<th style=\"text-align:center\">0</th>\n<th style=\"text-align:center\">0</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">15</td>\n<td style=\"text-align:center\"><font color=\"red\">14</font></td>\n<td style=\"text-align:center\">13</td>\n<td style=\"text-align:center\">12</td>\n<td style=\"text-align:center\"><font color=\"red\">11</font></td>\n<td style=\"text-align:center\"><font color=\"red\">10</font></td>\n<td style=\"text-align:center\">9</td>\n<td style=\"text-align:center\">8</td>\n</tr>\n</tbody>\n</table>\n<p>一个<code>Int32</code>占32位，那么一个<code>Int32</code>可以存储32个数字，那么对于需要存储数字的最大值<code>N</code>，可以得到需要申请一个<code>let tmp: [Int32]</code>数组长度为<code>(1 + N / 32)</code>即可存储：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tmp[<span class=\"number\">0</span>]：可以表示<span class=\"number\">0</span>~<span class=\"number\">31</span></span><br><span class=\"line\">tmp[<span class=\"number\">1</span>]：可以表示<span class=\"number\">31</span>~<span class=\"number\">63</span></span><br><span class=\"line\">tmp[<span class=\"number\">2</span>]：可以表示<span class=\"number\">64</span>~<span class=\"number\">95</span></span><br><span class=\"line\">。。。</span><br></pre></td></tr></table></figure>\n<h2>添加</h2>\n<p>那我们如何将一个数字<code>P</code>放进去呢？<br>\n我们就可以通过位运算<code>|或</code>，对于是存储在哪一个<code>Int32</code>，可以通过<code>P / 32</code>计算出。所以在<code>{1, 3, 5, 7}</code>中插入数字<code>6</code>：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">0x10101010</span> | (<span class=\"number\">1</span> &lt;&lt; <span class=\"number\">6</span>) = <span class=\"number\">0x10101010</span> | <span class=\"number\">0x01000000</span> = <span class=\"number\">0x11101010</span></span><br><span class=\"line\"><span class=\"comment\">// 转换为十进制：</span></span><br><span class=\"line\"><span class=\"number\">170</span> | <span class=\"number\">64</span> = <span class=\"number\">234</span></span><br></pre></td></tr></table></figure>\n<p>所以可以总结为：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tmp[<span class=\"type\">P</span>/<span class=\"number\">8</span>] |= <span class=\"number\">1</span> &lt;&lt; (<span class=\"type\">P</span> % <span class=\"number\">8</span>)</span><br></pre></td></tr></table></figure>\n<h2>删除</h2>\n<p>那么我们删除一个数字<code>Q</code>呢？<br>\n我们可以通过位运算<code>&amp;与</code>，与上同理找到对于存储的位置，然后对应删除数字<code>6</code>：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">0x11101010</span> &amp; ~(<span class=\"number\">1</span> &lt;&lt; <span class=\"number\">6</span>) = <span class=\"number\">0x11101010</span> &amp; <span class=\"number\">0x10111111</span> = <span class=\"number\">0x10101010</span></span><br><span class=\"line\"><span class=\"comment\">// 转换为十进制</span></span><br><span class=\"line\"><span class=\"number\">234</span> &amp; ~<span class=\"number\">64</span> = <span class=\"number\">170</span></span><br></pre></td></tr></table></figure>\n<p>所以可以总结为：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tmp[<span class=\"type\">Q</span>/<span class=\"number\">8</span>] &amp;= ~(<span class=\"number\">1</span> &lt;&lt; (<span class=\"type\">Q</span> % <span class=\"number\">8</span>))</span><br></pre></td></tr></table></figure>\n<h2>查找</h2>\n<p>查找数字<code>R</code>就更简单了，可以通过位运算<code>&amp;与</code>，判断<code>tmp[R/8] &amp; (1 &lt;&lt; (R % 8))</code>的结果值，如果为<code>1</code>则存在，<code>0</code>则不存在。</p>\n<h2>用途</h2>\n<p>那么这种<code>Bitmap</code>有什么用呢？<br>\n可以进行大量数据的快速排序、查找和去重等等，那么我们就抓到了他的关键点，对于大量数据的存储和查找，这就可以引入到我们位图的概念。</p>\n<h1>Bitmap 位图</h1>\n<h2>概念</h2>\n<p><strong>位图</strong>，又称<strong>栅格图(Raster Graphics)<strong>或</strong>点阵图</strong>，是使用像素阵列(Pixel-array/Dot-matrix点阵)来表示的图像。</p>\n<p>位图的像素都分配有特定的位置和颜色值，每个像素的颜色信息由RGB组合或者灰度值表示。</p>\n<p>根据位深度,可将位图分为1、4、8、16、24及32位图像等。每个像素使用的信息位数越多，可用的颜色就越多，颜色表现就越逼真，相应的数据量越大。例如，位深度为 1 的像素位图只有两个可能的值（黑色和白色），所以又称为二值位图。位深度为 8 的图像有 2^8（即 256）个可能的值。位深度为 8 的灰度模式图像有 256 个可能的灰色值。</p>\n<p>RGB图像由三个颜色通道组成。8 位/通道的 RGB 图像中的每个通道有 256 个可能的值，这意味着该图像有 1600 万个以上可能的颜色值。有时将带有 8 位/通道 (bpc) 的 RGB 图像称作 24 位图像（8 位 x 3 通道 = 24 位数据/像素）。通常将使用24位RGB组合数据位表示的的位图称为真彩色位图。</p>\n<h2>iOS中的Bitmap</h2>\n<p>在iOS中，<code>Bitmap</code>的数据由<code>CGImageRef</code>封装。如果要使用<code>Bitmap</code>对图片进行各种处理，就需要先创建位图上下文：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">createContext</span><span class=\"params\">(<span class=\"number\">_</span> image: CGImage)</span></span> -&gt; <span class=\"type\">CGContext</span>? &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> w = <span class=\"type\">Int</span>(image.width)</span><br><span class=\"line\">    <span class=\"keyword\">let</span> h = <span class=\"type\">Int</span>(image.height)</span><br><span class=\"line\">    <span class=\"keyword\">let</span> bitsPerComponent = <span class=\"number\">8</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> bytesPerRow = w * <span class=\"number\">4</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> space = <span class=\"type\">CGColorSpaceCreateDeviceRGB</span>()</span><br><span class=\"line\">    <span class=\"keyword\">let</span> bitmapInfo = <span class=\"type\">CGImageAlphaInfo</span>.premultipliedLast.rawValue | <span class=\"type\">CGBitmapInfo</span>.byteOrder32Big.rawValue</span><br><span class=\"line\">    <span class=\"keyword\">let</span> data = <span class=\"type\">UnsafeMutablePointer</span>&lt;<span class=\"type\">UInt32</span>&gt;.allocate(capacity: w * h)</span><br><span class=\"line\">    <span class=\"keyword\">let</span> context = <span class=\"type\">CGContext</span>(data: data,</span><br><span class=\"line\">                            width: w,</span><br><span class=\"line\">                            height: h,</span><br><span class=\"line\">                            bitsPerComponent: bitsPerComponent,</span><br><span class=\"line\">                            bytesPerRow: bytesPerRow,</span><br><span class=\"line\">                            space: space,</span><br><span class=\"line\">                            bitmapInfo: bitmapInfo)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> context</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>参数说明注释：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">CGContext</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/// - Parameters:</span></span><br><span class=\"line\">    <span class=\"comment\">///   - data: 用于存放位图的点阵数组指针，当生成上下文并调用上下文的`draw`方法将指定图片或层级绘制到上下文后，data指针就会存储该图片的位图像素信息；我们可以对data里面的数据进行操作，通过创建`CGDataProvider`实例并调用`CGImage`的初始化方法重新生成图片</span></span><br><span class=\"line\">    <span class=\"comment\">///   - width: 位图宽</span></span><br><span class=\"line\">    <span class=\"comment\">///   - height: 位图高</span></span><br><span class=\"line\">    <span class=\"comment\">///   - bitsPerComponent: 每个颜色组件或alpha组件占用的`bite`值，对于32位图像值为8</span></span><br><span class=\"line\">    <span class=\"comment\">///   - bytesPerRow: 位图每一行占的字节数，对于32位图像一个像素有4`byte`(rgba)，值为w * 4</span></span><br><span class=\"line\">    <span class=\"comment\">///   - space: 颜色空间，RGBA -&gt; CGColorSpaceCreateDeviceRGB(), CMYK -&gt; CGColorSpaceCreateDeviceCMYK(), 灰度 -&gt; CGColorSpaceCreateDeviceGray()</span></span><br><span class=\"line\">    <span class=\"comment\">///   - bitmapInfo: 一个常量，通常多枚举做或运算，描述位图上下文所对应的基本信息，具体见`CGBitmapInfo`和`CGImageAlphaInfo`描述</span></span><br><span class=\"line\">    <span class=\"meta\">@available</span>(iOS <span class=\"number\">2.0</span>, *)</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"comment\">/*not inherited*/</span> <span class=\"keyword\">init</span>?(data: <span class=\"type\">UnsafeMutableRawPointer</span>?, width: <span class=\"type\">Int</span>, height: <span class=\"type\">Int</span>, bitsPerComponent: <span class=\"type\">Int</span>, bytesPerRow: <span class=\"type\">Int</span>, space: <span class=\"type\">CGColorSpace</span>, bitmapInfo: <span class=\"type\">UInt32</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3>CGBitmapInfo 和 CGImageAlphaInfo</h3>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">CGBitmapInfo</span> : <span class=\"title\">OptionSet</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">init</span>(rawValue: <span class=\"type\">UInt32</span>)</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">var</span> alphaInfoMask: <span class=\"type\">CGBitmapInfo</span> &#123; <span class=\"keyword\">get</span> &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">var</span> floatInfoMask: <span class=\"type\">CGBitmapInfo</span> &#123; <span class=\"keyword\">get</span> &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">var</span> floatComponents: <span class=\"type\">CGBitmapInfo</span> &#123; <span class=\"keyword\">get</span> &#125;    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">var</span> byteOrderMask: <span class=\"type\">CGBitmapInfo</span> &#123; <span class=\"keyword\">get</span> &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">var</span> byteOrder16Little: <span class=\"type\">CGBitmapInfo</span> &#123; <span class=\"keyword\">get</span> &#125; <span class=\"comment\">// 16位小端模式</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">var</span> byteOrder32Little: <span class=\"type\">CGBitmapInfo</span> &#123; <span class=\"keyword\">get</span> &#125; <span class=\"comment\">// 32位小端模式</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">var</span> byteOrder16Big: <span class=\"type\">CGBitmapInfo</span> &#123; <span class=\"keyword\">get</span> &#125; <span class=\"comment\">// 16位大端模式</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">var</span> byteOrder32Big: <span class=\"type\">CGBitmapInfo</span> &#123; <span class=\"keyword\">get</span> &#125; <span class=\"comment\">// 32位大端模式</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">CGImageAlphaInfo</span> : <span class=\"title\">UInt32</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"keyword\">none</span> = <span class=\"number\">0</span> <span class=\"comment\">/* For example, RGB. */</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> premultipliedLast = <span class=\"number\">1</span> <span class=\"comment\">/* For example, premultiplied RGBA */</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> premultipliedFirst = <span class=\"number\">2</span> <span class=\"comment\">/* For example, premultiplied ARGB */</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> last = <span class=\"number\">3</span> <span class=\"comment\">/* For example, non-premultiplied RGBA */</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> first = <span class=\"number\">4</span> <span class=\"comment\">/* For example, non-premultiplied ARGB */</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> noneSkipLast = <span class=\"number\">5</span> <span class=\"comment\">/* For example, RBGX. */</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> noneSkipFirst = <span class=\"number\">6</span> <span class=\"comment\">/* For example, XRGB. */</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> alphaOnly = <span class=\"number\">7</span> <span class=\"comment\">/* No color data, alpha data only */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面就是对于<code>CGBitmapInfo</code>和<code>CGImageAlphaInfo</code>的定义。</p>\n<p>我们先关注<code>CGImageAlphaInfo</code>，像素构成类型：</p>\n<ul>\n<li><code>last</code>和<code>first</code>分别代表<code>alpha</code>的分量在前置位还是后置位，在数据读取时是按照<code>RGBA</code>还是<code>ARGB</code>来读取的。</li>\n<li><code>premultiplied</code>代表预乘透明，比如对应<code>RGBA</code>为(0.5, 0.5, 0.5, 0.5)的色值，在预乘之后变为(0.25, 0.25, 0.25, 0.5)；所以带有<code>premultiplied</code>时，说明在图片解码压缩的时候，就将<code>alpha</code>通道的值分别乘到了颜色分量上，我们知道<code>alpha</code>就会影响颜色的透明度，我们如果在压缩的时候就将这步做完了，那么渲染的时候就不必再处理<code>alpha</code>通道了，这样在显示位图的时候直接显示就行了，这样就提高了性能。</li>\n<li><code>noneSkip</code>就代表了虽然有<code>alpha</code>分量，但是忽略<code>alpha</code>的值，相当于透明度不起作用；这样的话，我们可以获取到图片的<code>RGB</code>原始值。</li>\n</ul>\n<p>然后我们看一下<code>CGBitmapInfo</code>，像素存储格式：</p>\n<ul>\n<li><code>byteOrder16Big</code>和<code>byteOrder32Big</code>分别代表16和32位的大端模式\n<ul>\n<li>大端模式(Big-Endian)：高位字节排放在内存的低地址端，低位字节排放在内存的高地址段</li>\n<li><code>0x12 | 0x34 | 0x56 | 0x78</code>（低到高）</li>\n<li>对于<code>RGBA</code>在内存中的存放则是为<code>R | G | B | A</code></li>\n</ul>\n</li>\n<li><code>byteOrder16Little</code>和<code>byteOrder32Little</code>分别代表16和32位的小端模式\n<ul>\n<li>小端模式(Little-Endian)：低位字节排放在内存的低地址端，高位字节排放在内存的高地址段</li>\n<li><code>0x78 | 0x56 | 0x34 | 0x12</code>（低到高）</li>\n<li>对于<code>RGBA</code>在内存中的存放则是为<code>A | B | G | R</code></li>\n</ul>\n</li>\n</ul>\n<h2>代码实践</h2>\n<h3>获取图片中点击位置的颜色</h3>\n<ul>\n<li>获取<code>ImageView</code>控件的<code>bounds</code>作为像素范围大小</li>\n<li>通过<code>CGPoint</code>参数计算出该点对应与像素索引位置的像素数据</li>\n<li>逐个字节解析出rgb颜色分量和alpha分量值最后生成UIColor最为结果返回</li>\n</ul>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">UIImageView</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/// 工具坐标点获取颜色</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">color</span><span class=\"params\">(<span class=\"keyword\">for</span> point: CGPoint)</span></span> -&gt; <span class=\"type\">UIColor</span>? &#123;</span><br><span class=\"line\">        <span class=\"keyword\">guard</span> <span class=\"keyword\">let</span> pixels = pixels,</span><br><span class=\"line\">              <span class=\"keyword\">let</span> index = indexForPixel(point)</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123; <span class=\"keyword\">return</span> <span class=\"literal\">nil</span> &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> color(<span class=\"keyword\">for</span>: pixels[index])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// 解析像素点颜色</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">color</span><span class=\"params\">(<span class=\"keyword\">for</span> pixel: UInt32)</span></span> -&gt; <span class=\"type\">UIColor</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> a = <span class=\"type\">CGFloat</span>(pixel &amp; <span class=\"number\">0xff</span>) / <span class=\"number\">255.0</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> r = <span class=\"type\">CGFloat</span>((pixel &gt;&gt; <span class=\"number\">8</span>) &amp; <span class=\"number\">0xff</span>) / <span class=\"number\">255.0</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> g = <span class=\"type\">CGFloat</span>((pixel &gt;&gt; <span class=\"number\">16</span>) &amp; <span class=\"number\">0xff</span>) / <span class=\"number\">255.0</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> b = <span class=\"type\">CGFloat</span>((pixel &gt;&gt; <span class=\"number\">24</span>) &amp; <span class=\"number\">0xff</span>) / <span class=\"number\">255.0</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"type\">UIColor</span>(red: r, green: g, blue: b, alpha: a)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/// 获取对应像素点索引</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">indexForPixel</span><span class=\"params\">(<span class=\"number\">_</span> point: CGPoint)</span></span> -&gt; <span class=\"type\">Int</span>? &#123;</span><br><span class=\"line\">        <span class=\"keyword\">guard</span> bounds.<span class=\"built_in\">contains</span>(point) <span class=\"keyword\">else</span> &#123; <span class=\"keyword\">return</span> <span class=\"literal\">nil</span> &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"type\">Int</span>(bounds.width) * <span class=\"type\">Int</span>(point.y) + <span class=\"type\">Int</span>(point.x)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/// 获取图片像素数据</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> pixels: [<span class=\"type\">UInt32</span>]? &#123;</span><br><span class=\"line\">        <span class=\"keyword\">guard</span> <span class=\"keyword\">let</span> image = image?.cgImage <span class=\"keyword\">else</span> &#123; <span class=\"keyword\">return</span> <span class=\"literal\">nil</span> &#125;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> w = <span class=\"type\">Int</span>(bounds.width)</span><br><span class=\"line\">        <span class=\"keyword\">let</span> h = <span class=\"type\">Int</span>(bounds.height)</span><br><span class=\"line\">        <span class=\"keyword\">let</span> bitsPerComponent = <span class=\"number\">8</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> bytesPerRow = w * <span class=\"number\">4</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> space = <span class=\"type\">CGColorSpaceCreateDeviceRGB</span>()</span><br><span class=\"line\">        <span class=\"keyword\">let</span> bitmapInfo = <span class=\"type\">CGImageAlphaInfo</span>.premultipliedFirst.rawValue | <span class=\"type\">CGBitmapInfo</span>.byteOrder32Big.rawValue</span><br><span class=\"line\">        <span class=\"keyword\">var</span> data = [<span class=\"type\">UInt32</span>](repeating: <span class=\"number\">0</span>, <span class=\"built_in\">count</span>: w * h)</span><br><span class=\"line\">        <span class=\"keyword\">let</span> context = <span class=\"type\">CGContext</span>(data: &amp;data, width: w, height: h, bitsPerComponent: bitsPerComponent, bytesPerRow: bytesPerRow, space: space, bitmapInfo: bitmapInfo)</span><br><span class=\"line\">        context?.draw(image, <span class=\"keyword\">in</span>: bounds)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> data</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意点：</p>\n<ul>\n<li>这边简单操作，真实过程需要判断<code>ImageView</code>的<code>ContentMode</code>模型，根据不同的模式判断图片在视图中的位置</li>\n<li>获取像素数据时机中可以做缓存，没有必要每次都去重新读取</li>\n<li>索引处理先<code>Int</code>转换后再计算，否则会有偏差</li>\n</ul>\n<h3>获取图片中点击位置的颜色(另一种方法)</h3>\n<ul>\n<li>生成只容纳一像素的上下文</li>\n<li>根据点击位置对上下文进行平移并绘制，然后读取对应颜色</li>\n</ul>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">UIImageView</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">color2</span><span class=\"params\">(<span class=\"keyword\">for</span> point: CGPoint)</span></span> -&gt; <span class=\"type\">UIColor</span>? &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> w = <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> h = <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> bitsPerComponent = <span class=\"number\">8</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> bytesPerRow = w * <span class=\"number\">4</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> space = <span class=\"type\">CGColorSpaceCreateDeviceRGB</span>()</span><br><span class=\"line\">        <span class=\"keyword\">let</span> bitmapInfo = <span class=\"type\">CGImageAlphaInfo</span>.premultipliedFirst.rawValue | <span class=\"type\">CGBitmapInfo</span>.byteOrder32Big.rawValue</span><br><span class=\"line\">        <span class=\"keyword\">var</span> data = [<span class=\"type\">UInt32</span>](repeating: <span class=\"number\">0</span>, <span class=\"built_in\">count</span>: w * h)</span><br><span class=\"line\">        <span class=\"keyword\">guard</span> <span class=\"keyword\">let</span> context = <span class=\"type\">CGContext</span>(data: &amp;data, width: w, height: h, bitsPerComponent: bitsPerComponent, bytesPerRow: bytesPerRow, space: space, bitmapInfo: bitmapInfo)</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123; <span class=\"keyword\">return</span> <span class=\"literal\">nil</span> &#125;</span><br><span class=\"line\">        context.translateBy(x: -point.x, y: -point.y)</span><br><span class=\"line\">        layer.render(<span class=\"keyword\">in</span>: context)</span><br><span class=\"line\">        <span class=\"keyword\">guard</span> <span class=\"keyword\">let</span> component = data.first <span class=\"keyword\">else</span> &#123; <span class=\"keyword\">return</span> <span class=\"literal\">nil</span> &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> color(<span class=\"keyword\">for</span>: component)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3>设置图片透明度</h3>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">UIImage</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">setAlpha</span><span class=\"params\">(<span class=\"number\">_</span> a: CGFloat)</span></span> -&gt; <span class=\"type\">UIImage</span>? &#123;</span><br><span class=\"line\">        <span class=\"type\">UIGraphicsBeginImageContextWithOptions</span>(size, <span class=\"literal\">false</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">defer</span> &#123; <span class=\"type\">UIGraphicsEndImageContext</span>() &#125;</span><br><span class=\"line\">        <span class=\"keyword\">guard</span> <span class=\"keyword\">let</span> cgImage = cgImage,</span><br><span class=\"line\">              <span class=\"keyword\">let</span> context = <span class=\"type\">UIGraphicsGetCurrentContext</span>()</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123; <span class=\"keyword\">return</span> <span class=\"keyword\">self</span> &#125;</span><br><span class=\"line\">        context.scaleBy(x: <span class=\"number\">1</span>, y: -<span class=\"number\">1</span>)</span><br><span class=\"line\">        context.translateBy(x: <span class=\"number\">0</span>, y: -size.height)</span><br><span class=\"line\">        context.setBlendMode(.multiply)</span><br><span class=\"line\">        context.setAlpha(a)</span><br><span class=\"line\">        context.draw(cgImage, <span class=\"keyword\">in</span>: .<span class=\"keyword\">init</span>(origin: .zero, size: size))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"type\">UIGraphicsGetImageFromCurrentImageContext</span>()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3>获取图片格式</h3>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">Data</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">ImageFormat</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> unknown</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"type\">PNG</span></span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"type\">JPEG</span></span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"type\">GIF</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">HeaderData</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">static</span> <span class=\"keyword\">var</span> <span class=\"type\">PNG</span>: [<span class=\"type\">UInt8</span>] = [<span class=\"number\">0x89</span>, <span class=\"number\">0x50</span>, <span class=\"number\">0x4E</span>, <span class=\"number\">0x47</span>, <span class=\"number\">0x0D</span>, <span class=\"number\">0x0A</span>, <span class=\"number\">0x1A</span>, <span class=\"number\">0x0A</span>]</span><br><span class=\"line\">            <span class=\"keyword\">static</span> <span class=\"keyword\">var</span> <span class=\"type\">JPEG_SOI</span>: [<span class=\"type\">UInt8</span>] = [<span class=\"number\">0xFF</span>, <span class=\"number\">0xD8</span>]</span><br><span class=\"line\">            <span class=\"keyword\">static</span> <span class=\"keyword\">var</span> <span class=\"type\">JPEG_IF</span>: [<span class=\"type\">UInt8</span>] = [<span class=\"number\">0xFF</span>]</span><br><span class=\"line\">            <span class=\"keyword\">static</span> <span class=\"keyword\">var</span> <span class=\"type\">GIF</span>: [<span class=\"type\">UInt8</span>] = [<span class=\"number\">0x47</span>, <span class=\"number\">0x49</span>, <span class=\"number\">0x46</span>]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">var</span> imageFormat: <span class=\"type\">ImageFormat</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">guard</span> <span class=\"built_in\">count</span> &gt; <span class=\"number\">8</span> <span class=\"keyword\">else</span> &#123; <span class=\"keyword\">return</span> .unknown &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">var</span> buffer = [<span class=\"type\">UInt8</span>](repeating: <span class=\"number\">0</span>, <span class=\"built_in\">count</span>: <span class=\"number\">8</span>)</span><br><span class=\"line\">        copyBytes(to: &amp;buffer, <span class=\"built_in\">count</span>: <span class=\"number\">8</span>)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> buffer == <span class=\"type\">ImageFormat</span>.<span class=\"type\">HeaderData</span>.<span class=\"type\">PNG</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> .<span class=\"type\">PNG</span></span><br><span class=\"line\">            </span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> buffer[<span class=\"number\">0</span>] == <span class=\"type\">ImageFormat</span>.<span class=\"type\">HeaderData</span>.<span class=\"type\">JPEG_SOI</span>[<span class=\"number\">0</span>],</span><br><span class=\"line\">                  buffer[<span class=\"number\">1</span>] == <span class=\"type\">ImageFormat</span>.<span class=\"type\">HeaderData</span>.<span class=\"type\">JPEG_SOI</span>[<span class=\"number\">1</span>],</span><br><span class=\"line\">                  buffer[<span class=\"number\">2</span>] == <span class=\"type\">ImageFormat</span>.<span class=\"type\">HeaderData</span>.<span class=\"type\">JPEG_IF</span>[<span class=\"number\">0</span>] &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> .<span class=\"type\">JPEG</span></span><br><span class=\"line\">            </span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> buffer[<span class=\"number\">0</span>] == <span class=\"type\">ImageFormat</span>.<span class=\"type\">HeaderData</span>.<span class=\"type\">GIF</span>[<span class=\"number\">0</span>],</span><br><span class=\"line\">                  buffer[<span class=\"number\">1</span>] == <span class=\"type\">ImageFormat</span>.<span class=\"type\">HeaderData</span>.<span class=\"type\">GIF</span>[<span class=\"number\">1</span>],</span><br><span class=\"line\">                  buffer[<span class=\"number\">2</span>] == <span class=\"type\">ImageFormat</span>.<span class=\"type\">HeaderData</span>.<span class=\"type\">GIF</span>[<span class=\"number\">2</span>] &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> .<span class=\"type\">GIF</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> .unknown</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1>总结</h1>\n<p>本篇内容就是有关<code>Bitmap</code>相关的算法与位图相关的知识，也是作为一个总结归纳和知识梳理，也同时收获到了很多新的思路。<br>\n以上。</p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cky8gmc3s0004d1qhr74i6fsf","tag_id":"cky8gmc3w0006d1qhy244rlk2","_id":"cky8gmc42000bd1qhab408ux5"},{"post_id":"cky8gmc3v0005d1qhofwez3yc","tag_id":"cky8gmc3w0006d1qhy244rlk2","_id":"cky8gmc44000fd1qhzbpiguir"},{"post_id":"cky8gmc44000gd1qh2r2gok41","tag_id":"cky8gmc44000ed1qhmpvl96vj","_id":"cky8gmc46000jd1qhygtsloxc"},{"post_id":"cky8gmc3x0007d1qh7aoi1m03","tag_id":"cky8gmc44000ed1qhmpvl96vj","_id":"cky8gmc47000ld1qho065nq1w"},{"post_id":"cky8gmc46000kd1qh91whodvy","tag_id":"cky8gmc44000ed1qhmpvl96vj","_id":"cky8gmc48000od1qh402x0usl"},{"post_id":"cky8gmc3y0008d1qh9a9bgfjr","tag_id":"cky8gmc44000ed1qhmpvl96vj","_id":"cky8gmc49000qd1qhfgu0vof0"},{"post_id":"cky8gmc48000pd1qho9nljqad","tag_id":"cky8gmc44000ed1qhmpvl96vj","_id":"cky8gmc4a000td1qhdhghe1gg"},{"post_id":"cky8gmc400009d1qh2w2bkwv1","tag_id":"cky8gmc48000nd1qhr2y67mwa","_id":"cky8gmc4a000vd1qhifrfgm8x"},{"post_id":"cky8gmc49000rd1qh4kxsf1vl","tag_id":"cky8gmc44000ed1qhmpvl96vj","_id":"cky8gmc4b000yd1qhk0kllt2g"},{"post_id":"cky8gmc4a000ud1qhf0c1yfyb","tag_id":"cky8gmc44000ed1qhmpvl96vj","_id":"cky8gmc4c0010d1qhlk4ifpq9"},{"post_id":"cky8gmc42000cd1qh3wdjyt9f","tag_id":"cky8gmc44000ed1qhmpvl96vj","_id":"cky8gmc4d0012d1qhpn3nx0me"},{"post_id":"cky8gmc4b000wd1qh7b6osuvq","tag_id":"cky8gmc44000ed1qhmpvl96vj","_id":"cky8gmc4e0015d1qh6e2d8lzi"},{"post_id":"cky8gmc4b000zd1qha1azfdds","tag_id":"cky8gmc44000ed1qhmpvl96vj","_id":"cky8gmc4f0017d1qhdzch48wr"},{"post_id":"cky8gmc43000dd1qhnl5t58pr","tag_id":"cky8gmc4b000xd1qhr9hngbvh","_id":"cky8gmc4g001ad1qhw8fpaauj"},{"post_id":"cky8gmc4c0011d1qhnfnwfi2w","tag_id":"cky8gmc44000ed1qhmpvl96vj","_id":"cky8gmc4h001cd1qhh18lciuf"},{"post_id":"cky8gmc4d0014d1qhz8wwln6u","tag_id":"cky8gmc44000ed1qhmpvl96vj","_id":"cky8gmc4i001ed1qht5pfq8n3"},{"post_id":"cky8gmc45000hd1qherblnfh9","tag_id":"cky8gmc48000nd1qhr2y67mwa","_id":"cky8gmc4j001gd1qhcyrzzvew"},{"post_id":"cky8gmc4e0016d1qhpo15r5d1","tag_id":"cky8gmc44000ed1qhmpvl96vj","_id":"cky8gmc4k001id1qhlqkynryd"},{"post_id":"cky8gmc4f0019d1qhip9kvw15","tag_id":"cky8gmc44000ed1qhmpvl96vj","_id":"cky8gmc4l001kd1qh841rohej"},{"post_id":"cky8gmc47000md1qh97y7dmwp","tag_id":"cky8gmc48000nd1qhr2y67mwa","_id":"cky8gmc4l001md1qhkxuw0a87"},{"post_id":"cky8gmc4g001bd1qh49nugp2s","tag_id":"cky8gmc44000ed1qhmpvl96vj","_id":"cky8gmc4m001pd1qh2fra2yck"},{"post_id":"cky8gmc4i001dd1qhfct4wvy3","tag_id":"cky8gmc44000ed1qhmpvl96vj","_id":"cky8gmc4n001rd1qhp8ftzi4m"},{"post_id":"cky8gmc4i001fd1qhuudr61kn","tag_id":"cky8gmc48000nd1qhr2y67mwa","_id":"cky8gmc4n001sd1qhb1utvq8c"},{"post_id":"cky8gmc4j001hd1qh9h9su95q","tag_id":"cky8gmc3w0006d1qhy244rlk2","_id":"cky8gmc4n001td1qh30yas49r"},{"post_id":"cky8gmc4k001jd1qhkhdl41cq","tag_id":"cky8gmc44000ed1qhmpvl96vj","_id":"cky8gmc4n001ud1qhfnbff9wz"},{"post_id":"cky8gmc4l001nd1qhhifsxusk","tag_id":"cky8gmc48000nd1qhr2y67mwa","_id":"cky8gmc4n001vd1qhqgrzqt0q"},{"post_id":"cky8gmc4m001qd1qhk9oeuelv","tag_id":"cky8gmc48000nd1qhr2y67mwa","_id":"cky8gmc4n001wd1qhzbur2y3z"},{"post_id":"cky8gmc4l001ld1qhhns9qs01","tag_id":"cky8gmc4m001od1qh2nos5acb","_id":"cky8gmc4n001xd1qh0tkz0ia8"},{"post_id":"cky8gmc4v001yd1qh8ycodj4y","tag_id":"cky8gmc44000ed1qhmpvl96vj","_id":"cky8gmc4x0020d1qh30yd07q6"},{"post_id":"cky8gmc4w001zd1qhqp76qtlk","tag_id":"cky8gmc44000ed1qhmpvl96vj","_id":"cky8gmc4x0021d1qhulccvcvn"},{"post_id":"cky9y7xz000008fqh7eoyg0do","tag_id":"cky8gmc48000nd1qhr2y67mwa","_id":"cky9y7xz600018fqh10co4fpu"}],"Tag":[{"name":"iOS - Objective-C","_id":"cky8gmc3w0006d1qhy244rlk2"},{"name":"iOS","_id":"cky8gmc44000ed1qhmpvl96vj"},{"name":"iOS - Swift","_id":"cky8gmc48000nd1qhr2y67mwa"},{"name":"GitHub","_id":"cky8gmc4b000xd1qhr9hngbvh"},{"name":"Tech","_id":"cky8gmc4m001od1qh2nos5acb"}]}}